<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java_集合 | Unfall_Blog</title><meta name="keywords" content="Java"><meta name="author" content="Unfall"><meta name="copyright" content="Unfall"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么要有集合提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行添加、修改、删除操作，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为Collection和Map两种体系。 在java中，集合分为两大类  单个方式存储元素，这一类集合的超级父接口为：java.util.Coll">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_集合">
<meta property="og:url" content="https://unfall.top/2022/11/15/Java_%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Unfall_Blog">
<meta property="og:description" content="为什么要有集合提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行添加、修改、删除操作，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为Collection和Map两种体系。 在java中，集合分为两大类  单个方式存储元素，这一类集合的超级父接口为：java.util.Coll">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png">
<meta property="article:published_time" content="2022-11-15T14:11:03.000Z">
<meta property="article:modified_time" content="2023-03-05T11:25:51.242Z">
<meta property="article:author" content="Unfall">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png"><link rel="shortcut icon" href="/img/cat.png"><link rel="canonical" href="https://unfall.top/2022/11/15/Java_%E9%9B%86%E5%90%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java_集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-05 19:25:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/03/08/bcZYpd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Unfall_Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java_集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-15T14:11:03.000Z" title="发表于 2022-11-15 22:11:03">2022-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-05T11:25:51.242Z" title="更新于 2023-03-05 19:25:51">2023-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>156分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java_集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>为什么要有集合</strong><br>提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行添加、修改、删除操作，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为Collection和Map两种体系。</p>
<p><strong>在java中，集合分为两大类</strong></p>
<ul>
<li>单个方式存储元素，这一类集合的超级父接口为：java.util.Collection</li>
<li>以键值对的方式存储元素，这一类集合的超级父接口为：java.util.Map</li>
</ul>
<p><strong>集合和数组</strong></p>
<ul>
<li><p>长度区别</p>
<ul>
<li>数组固定</li>
<li>集合可变</li>
</ul>
</li>
<li><p>内容区别</p>
<ul>
<li>数组可以是基本类型，也可以是引用类型</li>
<li>集合只能是引用类型</li>
</ul>
</li>
<li><p>元素内容</p>
<ul>
<li>数组只能存储同一种类型</li>
<li>集合可以存储不同类型（其实集合一般存储的也是同一种类型）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1010726-20170621004734695-988542448.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1010726-20170621004756882-1379253225.gif" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025110431438.png" alt="image-20221025110431438"></p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025110453481.png" alt="image-20221025110453481"></p>
<h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>迭代器的介绍</p>
<p>迭代器，集合的专用遍历方式</p>
<p>Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</p>
<p>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</p>
<p>Collection集合的遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用while循环改进元素的判断和获取</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二次遍历需要重置迭代器</span></span><br><span class="line">        it = c.iterator();</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环遍历方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Object o : c)&#123;</span><br><span class="line">        System.out.println( o );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h4><p>Collection 接口有 3 种子类型集合: List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、ArrayBlockingQueue等，下面是Collection的所有方法。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025161938824.png" alt="image-20221025161938824"></p>
<p>这些方法即可以操作Set集合，也可以操作Queue和List集合,下面分别使用<code>Collection</code>集合接口的方法说明</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>向集合添加元素e，若指定集合元素改变了则返回true</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>把集合C中的元素全部添加到集合中，若指定集合元素改变返回true</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空所有集合元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断指定集合是否包含对象o</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td>判断指定集合是否包含集合c的所有元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断指定集合的元素size是否为0</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>删除集合中的元素对象o,若集合有多个o元素，则只会删除第一个元素</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c）</td>
<td>删除指定集合包含集合c的元素</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td>从指定集合中保留包含集合c的元素,其他元素则删除</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的元素个数</td>
</tr>
<tr>
<td>T[] toArray(T[] a)</td>
<td>将集合转换为T类型的数组</td>
</tr>
</tbody></table>
<p>eg</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 创建Collection接口的实现</span></span><br><span class="line">      <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 添加元素</span></span><br><span class="line">      collection.add(<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;????&quot;</span>;</span><br><span class="line">      collection.add(src);</span><br><span class="line">      System.out.println(collection);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建Collection的实现</span></span><br><span class="line">      Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      System.out.println(coll);</span><br><span class="line">      <span class="comment">// 添加一个集合数据</span></span><br><span class="line">      collection.addAll(coll);</span><br><span class="line">      <span class="comment">// 输出集合的长度</span></span><br><span class="line">      System.out.println(collection);</span><br><span class="line">      <span class="comment">// 判断是否包含</span></span><br><span class="line">      System.out.println(collection.contains(<span class="string">&quot;?&quot;</span>));</span><br><span class="line">      <span class="comment">// 移除元素</span></span><br><span class="line">      collection.remove(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      <span class="comment">// 添加对象</span></span><br><span class="line">      collection.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">5000d</span>));</span><br><span class="line">      <span class="comment">// 当认为两个对象属性一致，相等时候，需重写hashCode 和 equals方法</span></span><br><span class="line">      System.out.println(collection.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">5000d</span>)));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">      collection.add(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">      Collection&lt;String&gt; collection1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      collection1.add(<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">      collection1.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      <span class="comment">// 求两个集合的交集(只保留collection1存在的元素)</span></span><br><span class="line">      collection.retainAll(collection1);</span><br><span class="line">      System.out.println(collection);</span><br><span class="line">      <span class="comment">// 清空元素</span></span><br><span class="line">      collection.clear();</span><br><span class="line">      System.out.println(collection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ol>
<li>List集合类中元素有序（即添加顺序和取出顺序一致），且可重复</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以更具序号存取容器中的元素</li>
<li>JDK  API中List接口的实现类非常多，常用的有ArrayList、LinkedList、Vectors<ol>
<li>ArrayList：底层由数组结构实现Object[]，可以存储任何Object类型的对象，是非线程安全的</li>
<li>LinkedList：List和Deque接口的双向链表实现。实现所有可选列表操作，并允许所有元素（包括null ）。所有操作都按照双向链表的预期执行。索引到列表中的操作将从开头或结尾遍历列表，以更接近指定索引的为准。</li>
<li>Vector：底层实现是动态数组的方式存放数据，是线程安全的，Vector源码当中每个方法都被synchronized关键字进行修饰，保证了Vector的线程安全，所以效率很低，尽量少使用</li>
</ol>
</li>
</ol>
<h5 id="List的继承、实现关系"><a href="#List的继承、实现关系" class="headerlink" title="List的继承、实现关系"></a>List的继承、实现关系</h5><p>其继承了Collection接口并由AbstractList来实现，Collection又继承了Iterable接口</p>
<p>Collection：集合层次结构中的根接口。一个集合表示一组对象，称为它的元素。一些集合允许重复元素，而另一些则不允许。有些是有序的，有些是无序的。<br>Iterable：实现此接口允许对象成为“for-each 循环”语句的目标。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2022020709121614.png" alt="img"></p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        </span><br><span class="line">List&lt;Object&gt; list1= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Map&gt; list2= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Student&gt; list3= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, Object ele)</td>
<td>在index位置插入ele元素</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection eles)</td>
<td>从index位置开始将eles中的所有元素添加进来</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>获取指定index位置的元素</td>
</tr>
<tr>
<td>int indexOf(Object obj</td>
<td>返回obj在集合中首次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(Object obj)</td>
<td>返回obj在当前集合中末次出现的位置</td>
</tr>
<tr>
<td>Object remove(int index)</td>
<td>移除指定index位置的元素，并返回此元素</td>
</tr>
<tr>
<td>Object set(int index, Object ele)</td>
<td>设置指定index位置的元素为ele , 相当于是替换.</td>
</tr>
<tr>
<td>List subList(int fromIndex, int toIndex)</td>
<td>返回从fromIndex到toIndex位置的子集合</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line"><span class="comment">//        void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">//在index = 1的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        Object get(int index):获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"><span class="comment">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line"><span class="comment">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;玛丽&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list=[张三丰, 韩顺平, 贾宝玉]</span><br><span class="line">list=[张三丰, jack, tom, 韩顺平, 贾宝玉]</span><br><span class="line">jack</span><br><span class="line"><span class="number">2</span></span><br><span class="line">list=[张三丰, jack, tom, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">list=[jack, tom, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line">list=[jack, 玛丽, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line">returnlist=[jack, 玛丽]</span><br></pre></td></tr></table></figure>

<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p> ArrayList实现了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=List%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">List接口</a>它是一个可调整大小的数组可以用来存放各种形式的数据。并提供了包括CRUD在内的多种方法可以对数据进行操作但是它不是线程安全的，外ArrayList按照插入的顺序来存放数据。</p>
<h6 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//数组默认初始容量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空的数组实例以供其他需要用到空数组的地方调用 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空数组，跟前面的区别就是这个空数组是用来判断ArrayList第一添加数据的时候要扩容多少。默认的构造器情况下返回这个空数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//数据存的地方它的容量就是这个数组的长度，同时只要是使用默认构造器（DEFAULTCAPACITY_EMPTY_ELEMENTDATA ）第一次添加数据的时候容量扩容为DEFAULT_CAPACITY = 10 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//当前数组的长度</span></span><br></pre></td></tr></table></figure>

<h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20180530205624808" alt="img"></p>
<ol>
<li>第一个构造方法用来返回一个初始容量为10的数组（具体过程后面会提到）</li>
<li>第二个用来生成一个带数据的ArrayList这边不再赘述</li>
<li>第三个构造方法就是自定义初始容量。下面我将根据默认的构造方法来展开下文。</li>
</ol>
<p>可以看到默认的构造器就是用了参数DEFAULTCAPACITY_EMPTY_ELEMENTDATA返回了一个空的数组，所以这边我们可以了解到ArrayList在创建的时候如果没有指定初始容量的话就会返回一个长度为0的空数组。下面我想从ArrayList的扩容机制开始解析，因为在所有添加数据的操作上面都要需要判断当前数组容量是否足以容纳新的数据，如果不够的话就需要进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>

<h6 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h6><p>​    ArrayList扩容的核心从ensureCapacityInternal方法说起。可以看到前面介绍成员变量的提到的ArrayList有两个默认的空数组：</p>
<p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA：是用来使用默认构造方法时候返回的空数组。如果第一次添加数据的话那么数组扩容长度为DEFAULT_CAPACITY&#x3D;10。</p>
<p>EMPTY_ELEMENTDATA：出现在需要用到空数组的地方，其中一处就是使用自定义初始容量构造方法时候如果你指定初始容量为0的时候就会返回。</p>
<p>从下面可以看到如果是使用了空数组EMPTY_ELEMENTDATA话，那么不会返回默认的初始容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前数组是否是默认构造方法生成的空数组，如果是的话minCapacity=10反之则根据原来的值传入下一个方法去完成下一步的扩容判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//minCapacitt表示修改后的数组容量，minCapacity = size + 1 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//判断看看是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面谈谈ensureExplicitCapacity方法（modCount设计到Java的快速报错机制后面会谈到），可以看到如果修改后的数组容量大于当前的数组长度那么就需要调用grow进行扩容，反之则不需要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//判断当前ArrayList是否需要进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//快速报错机制</span></span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  最后看下ArrayList扩容的核心方法grow()，下面将针对三种情况对该方法进行解析：</p>
<ol>
<li><p>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p>
</li>
<li><p>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</p>
</li>
<li><p>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList扩容的核心方法，此方法用来决定扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h6 id="Java容器的快速报错机制ConcurrentModificationException："><a href="#Java容器的快速报错机制ConcurrentModificationException：" class="headerlink" title="Java容器的快速报错机制ConcurrentModificationException："></a>Java容器的快速报错机制ConcurrentModificationException：</h6><p>Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容。如果你在迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或修改此容器的某个对象，就会立刻抛出ConcurrentModificationException。</p>
<p>前文提到的迭代遍历指的就是使用迭代器Iterator(ListIterator)或者forEach语法，实际上一个类要使用forEach就必须实现Iterable接口并且重写它的Iterator方法所以forEach本质上还是使用Iterator。</p>
<p><img src="https://img-blog.csdn.net/20180531101951612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>从下面方法可以看到在迭代遍历的过程中都调用了方法checkForComodification来判断当前ArrayList是否是同步的。现在来举一个栗子，假设你往一个Integer类型的ArrayList插入了10条数据，那么每操作一次modCount（继承自父类AbstractList）就加一所以就变成10，而当你对这个集合进行遍历的时候就把modCount传到expectedModCount这个变量里，然后ArrayList在checkForComodification中通过判断两个变量是否相等来确认当前集合是否是同步的，如果不同步就抛出ConcurrentModificationException。所谓的不同步指的就是，如果你在遍历的过程中对ArrayList集合本身进行add,remove等操作时候就会发生。当然如果你用的是Iterator那么使用它的remove是允许的因为此时你直接操作的不是ArrayList集合而是它的Iterator对象。在代码后面将贴出前面提到的三种情况。此外在多线程也会存在这种情况，但是如果你在多线程中使用CopyOnWriteArrayList就可以避免了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// 下一个要返回的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 返回最后一个元素的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//防止篇幅过长省去了其中代码</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="comment">//防止篇幅过长省去其中代码</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一种情况使用Iterator：</strong></p>
<p><img src="https://img-blog.csdn.net/20180531105735346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>第二种情况使用forEach：</strong></p>
<p><img src="https://img-blog.csdn.net/20180531105905747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>第三种情况使用Iterator自身删除数据：</strong></p>
<p><img src="https://img-blog.csdn.net/20180531110055360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h6 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h6><p>在ArrayList中，声明了三个常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//默认容量大小为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//一个空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//一个默认容量的空数组</span></span><br></pre></td></tr></table></figure>

<p>还声明了一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>然后再看一下ArrayList的构造方法</p>
<p>这是无参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是有参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若是调用ArrayList的无参构造方法，会发生什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造方法中，它将DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值给elementData，这个DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的Object数组，而elementData就是ArrayList实际存储数据的容器。</p>
<p>由此可知，ArrayList在调用无参构造方法时创建的是一个长度为0的空数组，当调用add()方法添加元素时，ArrayList才会触发扩容机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>add()方法的第一行即是执行扩容流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法又会先计算扩容容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>初始elementData就是一个空数组，条件成立，它会从DEFAULT_CAPACITY和minCapacity中选择一个最大值返回，其中DEFAULT_CAPACITY表示默认的初始容量，它的值为10：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>


<p>而minCapacity是add()方法传递过来的，值为size + 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br></pre></td></tr></table></figure>


<p>所以calculateCapacity()方法将返回10，之后调用ensureExplicitCapacity()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>首先让modCount++，这是用来记录数组被修改次数的变量，我们先不管它，此时minCapacity的值为10，elementData.length的值为0，条件成立，执行grow()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>


<p>先将旧容量右移1位，再加上旧容量就得到了新容量，正数右移1位相当于除以2，在该基础上加旧容量，则等价于新容量 &#x3D; 旧容量 * 1.5，所以才有ArrayList每次扩容为旧容量的1.5倍的说法，最后调用Arrays.copyOf()方法进行拷贝，并将elementData指向新数组，而旧数组因为没有引用指向它，很快就会被垃圾收集器回收掉。</p>
<p>当第二次调用add()方法时，程序依然要走到扩容方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但此时的elementData已经不是空数组了，所以直接返回当前size + 1，即：2，接着调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为此时minCapacity小于数组长度，所以if判断不会成立，也就不会发生扩容。</p>
<p>当添加第11个元素时，ArrayList应该会触发第二次扩容，来看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>minCapacity的值为11，紧接着调用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>此时minCapacity的值大于elementData的长度，条件成立，触发扩容机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将原容量10右移一位得到5，再加上原容量10得到15，所以新数组的容量为15，最后对数组进行拷贝扩容就完成了。</p>
<p>当ArrayList进行第三次扩容后容量会是多少呢？我们知道，新容量一定是旧容量的1.5倍，而15 * 1.5 &#x3D; 22.5，那么新容量到底是22还是23呢？所以，如果你只知道新容量是旧容量的1.5倍，这个问题你就无法知道。事实上，ArrayList底层是通过移位操作计算得到的新容量。所以新容量应该等于15 &gt;&gt; 1 + 15 &#x3D; 22，由此可得，ArrayList经过第三次扩容后容量为22。</p>
<p>然而在addAll()方法中，扩容机制会有一定的变化，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.addAll(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完addAll()方法后，ArrayList的容量应该是多少呢？是15吗？来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>它将调用ensureCapacityInternal()方法进行扩容，并传入 size + numNew &#x3D; 11：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为初始elementData是一个空数组，符合条件，所以它将返回DEFAULT_CAPACITY和minCapacity中较大的那个，结果是minCapacity较大，所以返回11，这就导致addAll()方法执行结果后ArrayList的容量为11。</p>
<blockquote>
<p>addAll()方法总是选择扩容一次后的容量与旧容量加上添加的元素个数的容量中取一个最大值作为新的容量，比如：当前ArrayList中有10个元素，而addAll()方法需要添加6个元素，当ArrayList触发扩容后的新容量应该为15，而旧容量加上需要添加的元素容量为16，从中取一个较大值为16，所以新容量应该为16。</p>
</blockquote>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h6><p>Vector是集合当中的一个重要知识点，它于ArrayList相比，最大的区别在于Vector是线程安全的，在源码当中的添加，删除等重要方法当中都加入了关键字 synchronized，实现了操作的线程安全，与ArrayList一样，Vector同样实现了 RandomAccess, Cloneable, Serializable接口。</p>
<h6 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector():构造一个空的Vector对象。</span><br><span class="line">Vector(<span class="type">int</span> initialCapacity):构造一个具有给定初始容量的空的Vector对象。</span><br><span class="line">Vector(<span class="type">int</span> initialCapacity,<span class="type">int</span> capacityIncrement):构造一个具有给定初始容量和容量增量的空的Vector对象。</span><br></pre></td></tr></table></figure>

<h6 id="Vector-扩容机制"><a href="#Vector-扩容机制" class="headerlink" title="Vector 扩容机制"></a>Vector 扩容机制</h6><p><strong>使用无参构造器跟进</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210617122819739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>Vector中三个重要的属性：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210617123051412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210617123125532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>step 1：</strong><img src="https://img-blog.csdnimg.cn/20210617123332468.png" alt="img"></p>
<p><strong>step 2：</strong><img src="https://img-blog.csdnimg.cn/20210617123501756.png" alt="img"></p>
<p><strong>step 3：</strong><img src="https://img-blog.csdnimg.cn/2021061712373943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p> 实例化完成：</p>
<p>往Vector集合中添加 11个元素，看第11个元素的扩容机制：</p>
<p><img src="https://img-blog.csdnimg.cn/20210617124717477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>step 1：</p>
<p><img src="https://img-blog.csdnimg.cn/20210617124859168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>step 2：</p>
<p><img src="https://img-blog.csdnimg.cn/20210617124941946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>step 3：</p>
<p><img src="https://img-blog.csdnimg.cn/20210617125749832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p> step 4：方法弹栈消失。回到 add 方法中：</p>
<p><img src="https://img-blog.csdnimg.cn/20210617130253386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p> Vector 其他两个 构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        elementCount = a.length;</span><br><span class="line">        <span class="comment">// 1： 如果是 ArrayList 集合</span></span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            <span class="comment">// 2： 则把 ArrayList集合的 elementData 赋值给 当前 Vectory实例的elementData指向。</span></span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 3： 如果不是则 先数组拷贝。再赋值指向。</span></span><br><span class="line">            elementData = Arrays.copyOf(a, elementCount, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 如果用户给的 初始化长度是 小于 0 </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 初始化的elementData的数组的长度为 用户指定的长度。</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="comment">// 当前Vector实例的 容量增量是用户给的为准。</span></span><br><span class="line">        <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 如果使用此构造器实例化 Vector对象时。当集合中的元素的数量超过。elementData数组的容量时。则<br>&#x2F;&#x2F; Vector 底层的扩容的新数组的长度每次都是  ： 旧数组的容量 + 用户给定的容量增量。</p>
<h6 id="ArrayList和Vector比较"><a href="#ArrayList和Vector比较" class="headerlink" title="ArrayList和Vector比较"></a>ArrayList和Vector比较</h6><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>线程安全（同步）效率</th>
<th>库容倍数</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>jdk1.2</td>
<td>不安全，效率高</td>
<td>如果有参构造为1.5倍，<br />如果是无参，第一次为10，第二次则是第一次的1.5倍扩容</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>jdk1.0</td>
<td>安全，效率不高</td>
<td>如果是无参，默认10.满后，就按2倍扩容，<br />如果指定大小，则每次直接按2倍扩容</td>
</tr>
</tbody></table>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><h6 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h6><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=LinkedList&spm=1001.2101.3001.7020">LinkedList</a>类是List接口的实现类，它是一个集合，可以根据索引来随机的访问集合中的元素，还实现了Deque接口，它还是一个队列，可以被当成双端队列来使用。虽然LinkedList是一个List集合，但是它的实现方式和ArrayList是完全不同的，ArrayList的底层是通过一个动态的Object[]数组来实现的，而LinkedList的底层是通过链表来实现的，因此它的随机访问速度是比较差的，但是它的删除，插入操作会很快。</p>
<ul>
<li>LinkedList是基于双向链表实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</li>
<li>LinkedList同样是非线程安全的，只在单线程下适合使用。</li>
<li>LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221028163644521.png" alt="image-20221028163644521"></p>
<h6 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h6><p><strong>以下情况使用 ArrayList :</strong></p>
<ul>
<li>频繁访问列表中的某一个元素。</li>
<li>只需要在列表末尾进行添加和删除元素操作。</li>
</ul>
<p><strong>以下情况使用 LinkedList :</strong></p>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul>
<h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>继承关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">    java.util.AbstractCollection&lt;E&gt; </span><br><span class="line">        java.util.AbstractList&lt;E&gt; </span><br><span class="line">            java.util.AbstractSequentialList&lt;E&gt; </span><br><span class="line">                java.util.LinkedList&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, Deque&lt;E&gt;, List&lt;E&gt;, Queue&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>基本属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;    <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;     <span class="comment">//尾节点</span></span><br></pre></td></tr></table></figure>

<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNi8yMDE5MDMyODE2NDczNy5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201224105911185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM4Nzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h6><blockquote>
<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>　　链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向&#x2F;双向链表又可以分为循环链表和非循环链表，下面简单就这四种链表进行图解说明。</p>
<h3 id="1-单向链表"><a href="#1-单向链表" class="headerlink" title="1.单向链表"></a>1.单向链表</h3><p>　　　　单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0227/193331_JljJ_2927759.png" alt="img"></p>
<h3 id="2-单向循环链表"><a href="#2-单向循环链表" class="headerlink" title="2.单向循环链表"></a>2.单向循环链表</h3><p>　　　　单向循环链表和单向列表的不同是，最后一个节点的next不是指向null，而是指向head节点，形成一个“环”。</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0227/193412_xGR9_2927759.png" alt="img"></p>
<h3 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3.双向链表"></a>3.双向链表</h3><p>　　　　从名字就可以看出，双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0227/193440_9dt2_2927759.png" alt="img"></p>
<h3 id="4-双向循环链表"><a href="#4-双向循环链表" class="headerlink" title="4.双向循环链表"></a>4.双向循环链表</h3><p>　　　　双向循环链表和双向链表的不同在于，第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。<strong>而LinkedList就是基于双向循环链表设计的。</strong></p>
<p><img src="https://static.oschina.net/uploads/space/2018/0227/193526_9m6M_2927759.png" alt="img"></p>
</blockquote>
<h6 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h6><p>LinkedList是通过双向链表去实现的，既然是链表实现那么它的随机访问效率比ArrayList要低，顺序访问的效率要比较的高。每个节点都有一个前驱（之前前面节点的指针）和一个后继（指向后面节点的指针），效果如下图：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0227/193615_NxRG_2927759.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;<span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;   <span class="comment">//尾节点</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造方法，创建一个空的列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;  <span class="comment">//将头节点赋值给f节点</span></span><br><span class="line">        <span class="comment">//new 一个新的节点，此节点的data = e , pre = null , next - &gt; f </span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">        first = newNode; <span class="comment">//将新创建的节点地址复制给first</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)  <span class="comment">//f == null，表示此时LinkedList为空</span></span><br><span class="line">            last = newNode;  <span class="comment">//将新创建的节点赋值给last</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;  <span class="comment">//否则f.前驱指向newNode</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入尾节点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last; </span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在succ节点前插入e节点，并修改各个节点之间的前驱后继</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="literal">null</span>;</span><br><span class="line">        f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="literal">null</span>;</span><br><span class="line">        l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">            first = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定节点</span></span><br><span class="line">    E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;  <span class="comment">//获取指定节点的前驱</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;  <span class="comment">//获取指定节点的后继</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = next;   <span class="comment">//如果前驱为null, 说明此节点为头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;  <span class="comment">//前驱结点的后继节点指向当前节点的后继节点</span></span><br><span class="line">            x.prev = <span class="literal">null</span>;     <span class="comment">//当前节点的前驱置空</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;    <span class="comment">//如果当前节点的后继节点为null ,说明此节点为尾节点</span></span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;  <span class="comment">//当前节点的后继节点的前驱指向当前节点的前驱节点</span></span><br><span class="line">            x.next = <span class="literal">null</span>;     <span class="comment">//当前节点的后继置空</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        x.item = <span class="literal">null</span>;     <span class="comment">//当前节点的元素设置为null ,等待垃圾回收</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取LinkedList中的第一个节点信息</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取LinkedList中的最后一个节点信息</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将添加的元素设置为LinkedList的头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将添加的元素设置为LinkedList的尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断LinkedList是否包含指定的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回List中元素的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在LinkedList的尾部添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将集合中的元素添加到List中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将集合中的元素全部插入到List中，并从指定的位置开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"> </span><br><span class="line">        Object[] a = c.toArray();  <span class="comment">//将集合转化为数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;  <span class="comment">//获取集合中元素的数量</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)   <span class="comment">//集合中没有元素，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="literal">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index); <span class="comment">//获取位置为index的结点元素，并赋值给succ</span></span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;  <span class="comment">//遍历数组进行插入操作。修改节点的前驱后继</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除List中所有的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="literal">null</span>;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="literal">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取指定位置的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将节点防止在指定的位置</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将节点放置在指定的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定位置的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断索引是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断位置是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//索引溢出信息</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查节点是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查位置是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回指定位置的节点信息</span></span><br><span class="line">    <span class="comment">//LinkedList无法随机访问，只能通过遍历的方式找到相应的节点</span></span><br><span class="line">    <span class="comment">//为了提高效率，当前位置首先和元素数量的中间位置开始判断，小于中间位置，</span></span><br><span class="line">    <span class="comment">//从头节点开始遍历，大于中间位置从尾节点开始遍历</span></span><br><span class="line">    Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回第一次出现指定元素的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回最后一次出现元素的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//弹出第一个元素的值</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//弹出第一元素，并删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//添加到尾部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//添加到头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入到最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列操作</span></span><br><span class="line">    <span class="comment">//尝试弹出第一个元素，但是不删除元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//队列操作</span></span><br><span class="line">    <span class="comment">//尝试弹出最后一个元素，不删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : l.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弹出第一个元素，并删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//弹出最后一个元素，并删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如队列，添加到头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//出队列删除第一个节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//删除指定元素第一次出现的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定元素最后一次出现的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类，实现ListIterator接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; lastReturned = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"> </span><br><span class="line">        ListItr(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">            next = (index == size) ? <span class="literal">null</span> : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"> </span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"> </span><br><span class="line">            lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">            nextIndex--;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"> </span><br><span class="line">            Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">            unlink(lastReturned);</span><br><span class="line">            <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">                next = lastNext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextIndex--;</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned.item = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                linkLast(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkBefore(e, next);</span><br><span class="line">            nextIndex++;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类，创建节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"> </span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DescendingIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adapter to provide descending iterators via ListItr.previous</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DescendingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ListItr</span> <span class="variable">itr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(size());</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itr.previous();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            itr.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title function_">superClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &#123;<span class="doctag">@code</span> LinkedList&#125;. (The elements</span></span><br><span class="line"><span class="comment">     * themselves are not cloned.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this &#123;<span class="doctag">@code</span> LinkedList&#125; instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Put clone into &quot;virgin&quot; state</span></span><br><span class="line">        clone.first = clone.last = <span class="literal">null</span>;</span><br><span class="line">        clone.size = <span class="number">0</span>;</span><br><span class="line">        clone.modCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                                a.getClass().getComponentType(), size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Object[] result = a;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将对象写入到输出流中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            s.writeObject(x.item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//从输入流中将对象读出</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Read in size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            linkLast((E)s.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h6><p>LinkedList 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">LinkedList() </span><br><span class="line">LinkedList(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;E&gt;();   <span class="comment">// 普通创建方法</span></span><br><span class="line">或者</span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c); <span class="comment">// 使用集合创建链表</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>LinkedList没有长度的概念，所以不存在容量不足的问题，因此不需要提供初始化大小的构造方法，因此值提供了两个方法，一个是无参构造方法，初始一个LinkedList对象，和将指定的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>元素转化为LinkedList构造方法。</p>
</blockquote>
<p>创建一个简单的链表实例：</p>
<p>&#x2F;&#x2F; 引入 LinkedList 类</p>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">    System.out.println(sites);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以上实例，执行输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google, Runoob, Taobao, Weibo]</span><br></pre></td></tr></table></figure>

<h6 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h6><p>在了解LinkedList的实现原理之前，我们首先需要明白LinkedList中的一个节点是什么以及他的具体数据结构。LinkedList每个节点是一个Node类型的实例，每个Node实例除了保存节点的真实值(真实数据)外，还保存了这个节点的前一个节点的引用和后一个节点的引用，这样就实现了双线链表的数据结构。Node数据结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119130011320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FqMTUyMDE0MjY4OTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>从代码中我们可以看到，当创建一个Node节点时，我们需要传入三个参数，第一个参数就是当前节点的前驱节点，第二个就是节点的真实数据，第三个就是节点的后续节点。<br>了解完一个元素的具体数据结构，那么下面我们看看常用方法的具体实现：<br>1.add(E e)方法：add(E e)方法实际上调用的是linkLast(E e)方法，意思是把方法加到链表的最后。下面看看linkLast(E e)方法的具体实现：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119130059300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FqMTUyMDE0MjY4OTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>从代码中我们可以看到，代码中使用了变量first和last，这两个变量分别保存了当前链表第一个节点和最后一个节点的引用。在新增一个节点之前，首先把指向最后一个节点的引用（即变量 last）保存起来（即变量 l），然后新建一个节点，指定前驱节点是原来链表的最后一个节点，然后把指向最后一个节点的引用（last）指向新建的节点。紧接着就设置新建节点的前驱节点的后继节点指向新增的节点，最后把整个链表的总数加1，完成了新增一个节点的操作。完成新增后的链表结构类似如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119130115227.png" alt="在这里插入图片描述"></p>
<h6 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h6><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean add(E e)</td>
<td>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public void add(int index, E element)</td>
<td>向指定位置插入元素。</td>
</tr>
<tr>
<td>public boolean addAll(Collection c)</td>
<td>将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public boolean addAll(int index, Collection c)</td>
<td>将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public void addFirst(E e)</td>
<td>元素添加到头部。</td>
</tr>
<tr>
<td>public void addLast(E e)</td>
<td>元素添加到尾部。</td>
</tr>
<tr>
<td>public boolean offer(E e)</td>
<td>向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public boolean offerFirst(E e)</td>
<td>头部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public boolean offerLast(E e)</td>
<td>尾部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public void clear()</td>
<td>清空链表。</td>
</tr>
<tr>
<td>public E removeFirst()</td>
<td>删除并返回第一个元素。</td>
</tr>
<tr>
<td>public E removeLast()</td>
<td>删除并返回最后一个元素。</td>
</tr>
<tr>
<td>public boolean remove(Object o)</td>
<td>删除某一元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定位置的元素。</td>
</tr>
<tr>
<td>public E poll()</td>
<td>删除并返回第一个元素。</td>
</tr>
<tr>
<td>public E remove()</td>
<td>删除并返回第一个元素。</td>
</tr>
<tr>
<td>public boolean contains(Object o)</td>
<td>判断是否含有某一元素。</td>
</tr>
<tr>
<td>public E get(int index)</td>
<td>返回指定位置的元素。</td>
</tr>
<tr>
<td>public E getFirst()</td>
<td>返回第一个元素。</td>
</tr>
<tr>
<td>public E getLast()</td>
<td>返回最后一个元素。</td>
</tr>
<tr>
<td>public int indexOf(Object o)</td>
<td>查找指定元素从前往后第一次出现的索引。</td>
</tr>
<tr>
<td>public int lastIndexOf(Object o)</td>
<td>查找指定元素最后一次出现的索引。</td>
</tr>
<tr>
<td>public E peek()</td>
<td>返回第一个元素。</td>
</tr>
<tr>
<td>public E element()</td>
<td>返回第一个元素。</td>
</tr>
<tr>
<td>public E peekFirst()</td>
<td>返回头部元素。</td>
</tr>
<tr>
<td>public E peekLast()</td>
<td>返回尾部元素。</td>
</tr>
<tr>
<td>public E set(int index, E element)</td>
<td>设置指定位置的元素。</td>
</tr>
<tr>
<td>public Object clone()</td>
<td>克隆该列表。</td>
</tr>
<tr>
<td>public Iterator descendingIterator()</td>
<td>返回倒序迭代器。</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回链表元素个数。</td>
</tr>
<tr>
<td>public ListIterator listIterator(int index)</td>
<td>返回从指定位置开始到末尾的迭代器。</td>
</tr>
<tr>
<td>public Object[] toArray()</td>
<td>返回一个由链表元素组成的数组。</td>
</tr>
<tr>
<td>public T[] toArray(T[] a)</td>
<td>返回一个由链表元素转换类型而成的数组。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//引入LinkedList类</span></span><br><span class="line">        LinkedList&lt;String&gt; lList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        lList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        lList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        lList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        lList.add(<span class="string">&quot;LinkedList&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链表元素个数</span></span><br><span class="line">        System.out.println(lList.size());</span><br><span class="line">        <span class="comment">//getFirst()方法获取头部元素</span></span><br><span class="line">        System.out.println(lList.getFirst()); <span class="comment">//hello</span></span><br><span class="line">        <span class="comment">//addFirst() 在头部添加元素</span></span><br><span class="line">        lList.addFirst(<span class="string">&quot;the&quot;</span>);  <span class="comment">//[the, hello, world, java, LinkedList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">//addLast() 在尾部添加元素</span></span><br><span class="line">        lList.addLast(<span class="string">&quot;ArrayList&quot;</span>); <span class="comment">//[the, hello, world, java, LinkedList, ArrayList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">// removeFirst() 移除头部元素</span></span><br><span class="line">        lList.removeFirst();  <span class="comment">// [hello, world, java, LinkedList, ArrayList]</span></span><br><span class="line">        <span class="comment">// set(int index, E element) 指定元素替换指定位置的元素</span></span><br><span class="line">        lList.set(<span class="number">1</span>,<span class="string">&quot;the&quot;</span>); <span class="comment">//[hello, the, java, LinkedList, ArrayList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">// add( int index,E element) 指定位置插入元素</span></span><br><span class="line">        lList.add(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>); <span class="comment">//[hello, the, world, java, LinkedList, ArrayList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">// for-each 迭代元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;for-each 迭代元素:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : lList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="重要方法解析"><a href="#重要方法解析" class="headerlink" title="重要方法解析"></a>重要方法解析</h6><p> 添加方法-add(E e)</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>add(E e)</td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td>void</td>
<td>add(int index,E element)</td>
<td>在此列表中的指定位置插入指定的元素。</td>
</tr>
</tbody></table>
<p>（1）add()添加第一个元素(element &#x3D; 1),下面是测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        objects.add(<span class="number">1</span>);</span><br><span class="line">        objects.add(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>


<p>（2）把debug断点放在LinkedList这里，此时元素个数size &#x3D; 0，首节点first和尾节点last为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = &#123;LinkedList@<span class="number">522</span>&#125; <span class="string">&quot;[]&quot;</span></span><br><span class="line"> size = <span class="number">0</span></span><br><span class="line"> first = <span class="type">null</span></span><br><span class="line"> <span class="variable">last</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line"> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>（3）当debug执行到objects.add(1)时，Force Step Into强行进入源码，这里是做了一个装箱(int -&gt; Integer)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>（4）Step Out跳出再Force Step Into进入就是add()方法，此方法最重要的一步就是linkLast(e)，e是待添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>（5）跳入linkLast(e)方法，已知last &#x3D; null,于是把l &#x3D; null传入Node构造器，执行第二行代码final Node newNode &#x3D; new Node&lt;&gt;(l, e, null);跳入Node()构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（6）Node(上一个节点的引用prev，元素element，下一个节点的引用next)，已知l &#x3D; null,即Node(null, 1, null)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/b6519086b91d461880a3ce6a336328b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>（7）new一个新的节点，newNode &#x3D; new Node&lt;&gt;(null, 1, null)，新节点的引用为LinkedList$Node@531，再把newNode赋给尾节点last,进入if(l &#x3D;&#x3D; null) 最后把newNode赋给首节点first，于是newNode、first、last同时指向这个节点，所以当只存在一个节点时，首节点就是尾节点<br><img src="https://img-blog.csdnimg.cn/887136daa3b74d8cbf59452ef67d8ffd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/7b27836fd0fd4f0f99f9dc4bd20893da.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>此时前后指向依然为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newNode (slot_3) = &#123;LinkedList$Node@<span class="number">531</span>&#125; </span><br><span class="line"> item = &#123;Integer@<span class="number">530</span>&#125; <span class="number">1</span></span><br><span class="line">  value = <span class="number">1</span></span><br><span class="line"> next = <span class="type">null</span></span><br><span class="line"> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>（8）第一个元素添加完成，此时只存在一个节点，如果添加第二个元素就会形成双向链表，因为添加第二个元素底层又会创建一个节点，然后，此时底层通过改变两个节点的前后指向就能使两个节点连接起来形成双向链表</p>
<p><img src="https://img-blog.csdnimg.cn/0fd4e9ef03534a369a4cd62ab63b59e1.png" alt="在这里插入图片描述"></p>
<p>Debug信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = &#123;LinkedList@<span class="number">522</span>&#125; <span class="string">&quot;[1]&quot;</span></span><br><span class="line"> size = <span class="number">1</span></span><br><span class="line"> first = &#123;LinkedList$Node@<span class="number">531</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">530</span>&#125; <span class="number">1</span></span><br><span class="line">  next = <span class="type">null</span></span><br><span class="line">  <span class="variable">prev</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line"> <span class="variable">last</span> <span class="operator">=</span> &#123;LinkedList$Node@<span class="number">531</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">530</span>&#125; <span class="number">1</span></span><br><span class="line">  next = <span class="type">null</span></span><br><span class="line">  <span class="variable">prev</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line"> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>（8）添加第二个元素(element &#x3D; 8)</p>
<p><img src="https://img-blog.csdnimg.cn/5fa313fb43184443ae5f74a1813d616e.png" alt="在这里插入图片描述"></p>
<p>（9）这里我们直接看linkLast()方法的执行流程，此时last指向第一个节点，把last赋给new的第二个节点的prev，第二个节点就会指向第一个节点，再通过if判断，此时l不为空，于是把第二个节点的引用赋给第一个节点的next，于是第一个节点通过next指向第二个节点，双向链表形成</p>
<p><img src="https://img-blog.csdnimg.cn/59a59366daa24c3081405c27f6fae6fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>debug信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = &#123;LinkedList@<span class="number">522</span>&#125; <span class="string">&quot;[1, 8]&quot;</span></span><br><span class="line"> size = <span class="number">2</span></span><br><span class="line"> first = &#123;LinkedList$Node@<span class="number">530</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">551</span>&#125; <span class="number">1</span></span><br><span class="line">  next = &#123;LinkedList$Node@<span class="number">539</span>&#125; </span><br><span class="line">  prev = <span class="type">null</span></span><br><span class="line"> <span class="variable">last</span> <span class="operator">=</span> &#123;LinkedList$Node@<span class="number">539</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">535</span>&#125; <span class="number">8</span></span><br><span class="line">  next = <span class="type">null</span></span><br><span class="line">  <span class="variable">prev</span> <span class="operator">=</span> &#123;LinkedList$Node@<span class="number">530</span>&#125; </span><br><span class="line"> modCount = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>通过linkLast()方法可以看到第二个节点的引用为newNode&#x3D; {LinkedList$Node@539}，在通过debug展示的信息可以得知，存放元素1(item &#x3D; 1)的第一个节点的next也指向了这个引用，因为暂时只有两个节点，所以首节点first指向第一个Node对象，尾节点last指向第二个节点，根据程序可得，第一个节点的prev在创建时就没有赋值，而第二个节点的next也为空是因为在创建节点对象时Node newNode &#x3D; new Node&lt;&gt;(l, e, null);next是默认为null的，通俗的理解就是这两个节点的前后都没有节点对象，自然不需要指向，故首节点prev &#x3D; null同时尾节点next &#x3D; null<br><img src="https://img-blog.csdnimg.cn/81de6c0e14b84b559634f121d3b95e77.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p> 删除方法-remove()</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E</td>
<td><strong><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/LinkedList.html#remove--">remove</a></strong>()</td>
<td>检索并删除此列表的头（第一个元素）。</td>
</tr>
<tr>
<td>E</td>
<td><strong><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/LinkedList.html#remove-int-">remove</a></strong>(int index)</td>
<td>删除该列表中指定位置的元素。</td>
</tr>
<tr>
<td>boolean</td>
<td>remove(Object o)</td>
<td>从列表中删除指定元素的第一个出现（如果存在）。</td>
</tr>
</tbody></table>
<p>remove()默认删除首节点<br>（1）这里用无参的remove()进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       objects.add(<span class="number">1</span>);</span><br><span class="line">       objects.add(<span class="number">8</span>);</span><br><span class="line">       </span><br><span class="line">       objects.remove();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>（2）remove()调了removeFirst()，让对象f指向first首节点，所以remove()无参方法删除的是首节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>（3）unlinkFirst(Node f)方法是remove()删除首节点的核心方法，先取出首节点存储的数据item，然后f.next指向下一个节点，把数据置空，如果没有下一个节点就直接回收，first &#x3D; next(也就是first &#x3D; first.next)让first首节点指向下一个节点，将下一个节点的prev置空，最后返回之前取出的item,这套流程简单理解为让frist指向下一个节点，然后把原首节点全部置空，移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="literal">null</span>;</span><br><span class="line">        f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除方法，先循环遍历列表，找到item &#x3D;&#x3D; o 的节点，在调用unlink()方法删除</p>
</blockquote>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul>
<li>LinkedList是一个功能很强大的类，可以被当作List集合，双端队列和栈来使用。</li>
<li>LinkedList底层使用链表来保存集合中的元素，因此随机访问的性能较差，但是插入删除时性能非常的出色。</li>
<li>LinkedList在1.8版本有添加了一点新的内容，添加了一个static final 修饰的内部类LLSpliterator 并实现了Spliterator ，为了实现并行遍历而新添加的功能，整体的变化并不是很大，感兴趣的可以自己去看一下。</li>
</ul>
<h6 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h6><ol>
<li>从源码中很明显可以看出，LinkedList的实现是基于双向链表的，且头结点中不存放数据。</li>
<li>注意两个不同的构造方法。无参构造方法直接建立一个仅包含head节点的空链表，包含Collection的构造方法，先调用无参构造方法建立一个空链表，而后将Collection中的数据加入到链表的尾部后面。</li>
<li>在查找和删除某元素时，源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。</li>
<li>LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。</li>
<li>注意源码中的Entry<E> entry(int index)方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将index与长度size的一半比较，如果index&lt;size&#x2F;2，就只从位置0往后遍历到位置index处，而如果index&gt;size&#x2F;2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。</li>
<li>注意链表类对应的数据结构Entry。</li>
<li>LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。</li>
<li>要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。</li>
</ol>
<h6 id="ArrayList和LinkerList比较"><a href="#ArrayList和LinkerList比较" class="headerlink" title="ArrayList和LinkerList比较"></a>ArrayList和LinkerList比较</h6><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删的效率</th>
<th>改查的效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低<br />数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td>LinkerList</td>
<td>双向链表</td>
<td>较高，通过链表追加</td>
<td>较低</td>
</tr>
</tbody></table>
<p>如何选择</p>
<ol>
<li>如果改查的操作较多，选择ArrayList</li>
<li>如果增删的操作较多，选择LinkedList</li>
<li>一般来说，程序中，80%~90%都是查询，因此大部分情况下会选择ArrayList</li>
<li>在一个项目中，更具业务灵活选择，也可以这样，一个模块使用的是ArrayList，另一个模块使用的是LinkedList</li>
</ol>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>HashSet简单的理解就是HashSet对象中不能存储相同的数据，存储数据时是无序的。但是HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。存储是无序的这就和C++里的Set就不一样了C++里面的Set是有序的我认为这是在使用时候的主要区别。下面就是HashSet简单的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; hsahset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>括号里面的类型是随你的需要更改的。</p>
<h6 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line"></span><br><span class="line">  java.util.AbstractCollection&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    java.util.AbstractSet&lt;E&gt;</span><br><span class="line"></span><br><span class="line">     java.util.HashSet&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/98602324bd7a926fec1131f75eb9f312.png" alt="img"></p>
<p>(1) HashSet继承于AbstractSet，并且实现了Set接口。</p>
<p>(2) HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。</p>
<h6 id="HashSet底层机制说明"><a href="#HashSet底层机制说明" class="headerlink" title="HashSet底层机制说明"></a>HashSet底层机制说明</h6><ul>
<li>HashSet 底层是HashMap，HashMap底层是(数组+链表+红黑树)</li>
</ul>
<h6 id="模拟简单数组-链表结构"><a href="#模拟简单数组-链表结构" class="headerlink" title="模拟简单数组+链表结构"></a>模拟简单数组+链表结构</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101150619880.png" alt="image-20221101150619880"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;john&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        table[<span class="number">2</span>] = john;</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        john.next = jack;</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Rose&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        jack.next = rose;</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lucy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;lucy&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        table[<span class="number">3</span>] = lucy;</span><br><span class="line">        System.out.println(<span class="string">&quot;table=&quot;</span>+table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Object item; <span class="comment">//存放数据</span></span><br><span class="line">    Node next; <span class="comment">//指向下一个节点</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行结果为</span></span><br><span class="line">table=[Lcom.unfall.Collection_.Node;@4554617c</span><br></pre></td></tr></table></figure>

<h6 id="分析HashSet的添加元素底层是如何实现-hash-equals"><a href="#分析HashSet的添加元素底层是如何实现-hash-equals" class="headerlink" title="分析HashSet的添加元素底层是如何实现(hash()+equals())"></a>分析HashSet的添加元素底层是如何实现(<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>()+equals())</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101150911044.png" alt="image-20221101150911044"></p>
<ol>
<li><p>HashSet 的底层是 HashMap</p>
</li>
<li><p>添加一个元素时，先得到hash值，会转成 -&gt; 索引值</p>
</li>
<li><p>找到存储数据表table，看这个索引位置是否已经存放了元素</p>
</li>
<li><p>如果没有存放，则直接添加</p>
</li>
<li><p>如果存放了，调用 equals() 比较，如果相同，就放弃添加，如果不相同，则添加到最后</p>
</li>
<li><p>在java8中，如果一条 链表 的元素个数 大于 TREEIFY_THRESHOLD（默认是8）(链表准备添加第九个的时候) ，并且 table 的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认是64），就会进行树化(红黑树)</p>
</li>
</ol>
<h6 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h6><table>
<thead>
<tr>
<th>类型</th>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>boolena</td>
<td>add(E e)</td>
<td>如果当前列表中不存在e，则将e加入列表</td>
</tr>
<tr>
<td>void</td>
<td>clear()</td>
<td>从列表中删除所有元素</td>
</tr>
<tr>
<td>boolean</td>
<td>contains(Object j)</td>
<td>判断列表中是否有元素j</td>
</tr>
<tr>
<td>Iterator<E></td>
<td>iterator()</td>
<td>得到当前列表的遍历器</td>
</tr>
<tr>
<td>boolean</td>
<td>remove(Object j)</td>
<td>如果列表中存在元素j,则将其从列表中删除</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>得到列表中元素的个数</td>
</tr>
</tbody></table>
<p>add(E e)方法详解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet=&quot;</span>+hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">hashSet=[java,php]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行 HashSet hashSet &#x3D; new HashSet();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 hashSet.add(“java”);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="comment">//e = &quot;java&quot;</span></span><br><span class="line">    <span class="comment">//PRESENT -&gt; private static final Object PRESENT = new Object();</span></span><br><span class="line">    <span class="comment">//PRESENT的目的是为了占位</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 return map.put(e, PRESENT)&#x3D;&#x3D;null;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123; <span class="comment">//key = &quot;java&quot; value = PRESENT 共享</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先执行 hash(key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再执行 return putVal(hash(key), key, value, false, true);</p>
<ol>
<li><p>transient Node&lt;K,V&gt;[] table; 和 Node&lt;K,V&gt;[] tab;</p>
</li>
<li><p>if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</p>
</li>
<li><p>table和tab是引用赋值，所以两者的地址相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义了辅助变量</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i; </span><br><span class="line">    <span class="comment">//table 就是HashMap的一个数组，类型是Node[]</span></span><br><span class="line">    <span class="comment">//transient Node&lt;K,V&gt;[] table;</span></span><br><span class="line">    <span class="comment">//if语句表示如果当前table是null或者tab的大小为0，则执行下面的语句</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//执行 resize()，创建了大小为16的table数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(1)根据key得到的hash值去计算该key应该存放到tab表的哪个索引位置</span></span><br><span class="line">    <span class="comment">//并且把这个位置的对象，赋给p</span></span><br><span class="line">    <span class="comment">//(2)判断p是否为null</span></span><br><span class="line">    <span class="comment">//(2.1)如果p为null，表示还没有存放元素，就创建一个Node(key=&quot;java&quot;,value=&quot;PRESENT&quot;)</span></span><br><span class="line">    <span class="comment">//(2.2)就放在该位置 tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/df371fb454db4f7c9bfbbec4359120eb.png"></p>
</li>
</ol>
</li>
<li><p>执行 hashSet.add(“php”);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 return map.put(e, PRESENT)&#x3D;&#x3D;null;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先执行 hash(key)</p>
<ol>
<li>得到对应的hash值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再执行 return putVal(hash(key), key, value, false, true);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/d5eab1bf46e34aec824be1b0b427eac0.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56iL5bqP54y_6L-b5YyW54mI,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
<li><p>执行 hashSet.add(“java”);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 return map.put(e, PRESENT)&#x3D;&#x3D;null;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先执行 hash(key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再执行 return putVal(hash(key), key, value, false, true);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果当前索引位置对应的链表的第一个元素的hash值和准备添加的key的hash值一样</span></span><br><span class="line">        <span class="comment">//并且满足下面两个条件之一：</span></span><br><span class="line">        <span class="comment">//(1)准备加入的key和p指向的Node节点的key是同一个对象</span></span><br><span class="line">        <span class="comment">//(2)p指向的Node节点的key的equals()方法和准备加入的key比较后相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; </span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//再判断p是不是一颗红黑树</span></span><br><span class="line">        <span class="comment">//如果是一颗红黑树，就调用putTreeVal，来进行添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果table对应的索引位置，已经是一个链表，就使用for循环比较</span></span><br><span class="line">               <span class="comment">//(1)依次和该链表的每一个元素比较后(从链表的第二个元素开始比较)，都不相同，则 </span></span><br><span class="line">               <span class="comment">//     加入到该链表的最后</span></span><br><span class="line">               <span class="comment">//   注意：在把元素添加到链表后，立即判断该链表是否已经到达8个节点,</span></span><br><span class="line">               <span class="comment">//   如果到达了8个节点，就调用 treeifyBin(tab, hash); 如果满足</span></span><br><span class="line">               <span class="comment">//   if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //64</span></span><br><span class="line">               <span class="comment">//       resize();，</span></span><br><span class="line">               <span class="comment">//   则先对table扩容；如果该if语句不满足，则对当前这个链表进行树化(转成红黑树)</span></span><br><span class="line">               <span class="comment">//(2)依次和该链表的每一个元素的比较过程中，如果有相同的情况，则直接break</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//TREEIFY_THRESHOLD = 8;</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="分析HashSet的扩容和转成红黑树的机制"><a href="#分析HashSet的扩容和转成红黑树的机制" class="headerlink" title="分析HashSet的扩容和转成红黑树的机制"></a>分析HashSet的扩容和转成红黑树的机制</h6><ol>
<li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值(threshold)是 16*加载因子(loadFactor)是0.75 &#x3D; 12</li>
<li>如果table数组使用到了临界值12，就会扩容到 16 * 2 &#x3D; 32，新的临界值就是 32 * 0.75 &#x3D; 24</li>
<li>在java8中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8)，并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认是64），就会进行树化(转成红黑树)，否则仍然采用数组扩容机制。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">A</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet=&quot;</span>+hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line">hashSet=[demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行 hashSet.add(new A(1)); 时，数组的大小扩容到16</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164024174.png" alt="image-20221101164024174"></p>
</li>
<li><p>执行 hashSet.add(new A(9)); 时，数组的大小扩容到32</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164052223.png" alt="image-20221101164052223"></p>
</li>
<li><p>执行 hashSet.add(new A(10)); 时，数组的大小扩容到64</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164131906.png" alt="image-20221101164131906"></p>
</li>
<li><p>执行 hashSet.add(new A(11)); 时，将该链表进行树化(转成红黑树)</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164152038.png" alt="image-20221101164152038"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">A</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">B</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>无论是在table数组上还是在链表上加入元素，size都会加1，size(元素的个数)的大小大于临界值后，就会对数组进行扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行到 hashSet.add(new A(1)); 时，数组的大小扩容到16</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164713998.png" alt="image-20221101164713998"></p>
</li>
<li><p>执行到 hashSet.add(new B(6)); 时，数组的大小扩容到32</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164735506.png" alt="image-20221101164735506"></p>
</li>
</ul>
<h6 id="实现总结"><a href="#实现总结" class="headerlink" title="实现总结"></a>实现总结</h6><p>HashSet实现原理进行一个总结：<br>（1）基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p>
<p>（2）当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。</p>
<p>（3）HashSet的其他操作都是基于HashMap的。</p>
<h6 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的无参构造器，构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定collection中的元素的新set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层使用默认的加载因子0.75和足以包含指定</span></span><br><span class="line"><span class="comment">     * collection中所有元素的初始容量来创建一个HashMap。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">	addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数构造一个空的HashMap。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</span></span><br><span class="line"><span class="comment">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy 标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用底层HashMap的keySet来返回所有的key。</span></span><br><span class="line"><span class="comment">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上，</span></span><br><span class="line"><span class="comment">     * value使用一个static final的Object对象标识。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对此set中元素进行迭代的Iterator。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此set中的元素的数量（set的容量）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e))</span></span><br><span class="line"><span class="comment">     * 的e元素时，返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的containsKey判断是否包含指定key。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set中尚未包含指定元素，则添加指定元素。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2))</span></span><br><span class="line"><span class="comment">     * 的元素e2，则向此set 添加指定的元素e。</span></span><br><span class="line"><span class="comment">     * 如果此set已包含该元素，则该调用不更改set并返回false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际将将该元素作为key放入HashMap。</span></span><br><span class="line"><span class="comment">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key</span></span><br><span class="line"><span class="comment">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true），</span></span><br><span class="line"><span class="comment">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变，</span></span><br><span class="line"><span class="comment">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中，</span></span><br><span class="line"><span class="comment">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 将添加到此set中的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果指定元素存在于此set中，则将其移除。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e，</span></span><br><span class="line"><span class="comment">     * 则将其移除。如果此set已包含该元素，则返回true</span></span><br><span class="line"><span class="comment">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的remove方法删除指定Entry。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此set中移除所有元素。此调用返回后，该set将为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">	map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h6><ol>
<li><p>用Iterator来遍历</p>
<ol>
<li>&#96;&#96;&#96;java1<br>Iterao<String> iterator &#x3D; hashSet.iterator();<br>while(iterator.hasNext()){<br>System.out.println(iterator.next()+” “);<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 这是比较常用的方法， 但是这种方法在使用的时候HashSet修改一次之后如果想再次遍历，必须重新申请Iterator,否则        无法遍历，但是把Itetator放在一个函数里， 那么就省去多次申请Iterator了。</span><br><span class="line"></span><br><span class="line">2. 增强for循环遍历</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      for(Objrct o : hashset)&#123;</span><br><span class="line">      	System.out.println(o);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>简单试用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.java.text.Main;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main4</span> &#123;<span class="comment">//HashSet</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        String aString;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        	aString = ip.next();</span><br><span class="line">        	hashSet.add(aString);<span class="comment">//加入列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = hashSet.iterator();<span class="comment">//遍历器</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())System.out.print(iterator.next()+<span class="string">&quot; &quot;</span>);<span class="comment">//判断是否有，有就输出</span></span><br><span class="line">        String bString;</span><br><span class="line">        bString =  ip.next();</span><br><span class="line">        hashSet.remove(bString);<span class="comment">//删除</span></span><br><span class="line">        <span class="comment">/*Iterator iterator2 = hashSet.iterator();</span></span><br><span class="line"><span class="comment">        while(iterator2.hasNext()) &#123;//遍历器遍历</span></span><br><span class="line"><span class="comment">        	System.out.print(iterator2.next()+&quot;  &quot;);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(String string: hashSet)System.out.print(string + <span class="string">&quot; &quot;</span>);<span class="comment">//for循环遍历</span></span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>LinkedHashSet是一个 Set 的实现，它其中存的不是键值对，而是值。此实现与 HashSet 的不同之处在于，LinkedHashSet 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</p>
<ol>
<li>LinkedHashSet是HashSet的子类</li>
<li>LinkedHashSet底层是一个LinkedHashMap（hashmap的子类），底层维护了一个数组+双向链表</li>
<li>LinkedHashSet根据元素的hashcode值来决定元素的存储位置，同时使用链表维护元素的次序码，这使得元素看起来是以插入顺序保存的</li>
<li>LinkedHashSet不允许添加重复元素</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221103112727961.png" alt="image-20221103112727961"></p>
<p>说明：</p>
<ol>
<li>在linkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail)</li>
<li>每一个节点有before和after属性，这样可以形成双向链表</li>
<li>在添加一个元素时，先求hash值，再求索引，确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在(equals比较），不添加【原则和hashset一样])</li>
<li>这样的话，我们遍历linkedhashset也能确保插入顺序和遍历顺序一样</li>
<li>数组是hashMap[]类型 存放的元素&#x2F;数据是LinkedHashMap$Entry类型（数组多态）</li>
</ol>
<h6 id="LinkedHashSet实现"><a href="#LinkedHashSet实现" class="headerlink" title="LinkedHashSet实现"></a>LinkedHashSet实现</h6><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。LinkedHashSet 的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个带有指定初始容量和加载因子的新空链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个与指定collection中的元素相同的新链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个足以包含指定collection</span></span><br><span class="line"><span class="comment">     * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上几乎就是 LinkedHashSet 的全部代码了，不是说 LinkedHashSet 是基于 LinkedHashMap 实现的吗？那为什么在源码中甚至都没有看到出现过 LinkedHashMap。</p>
<p>可以看到在 LinkedHashSet 的构造方法中，其调用了父类的构造方法。可以看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</span></span><br><span class="line"><span class="comment">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy 标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在父类 HashSet 中，专为 LinkedHashSet 提供的构造方法如上，该方法为包访问权限，并未对外公开。</p>
<p>由上述源代码可见，LinkedHashSet 通过继承 HashSet，底层使用 LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能</p>
<h6 id="LinkedHashSet的源码解读"><a href="#LinkedHashSet的源码解读" class="headerlink" title="LinkedHashSet的源码解读"></a>LinkedHashSet的源码解读</h6><ul>
<li>LinkedHashSet 中维护了一个hash表和双向链表（LinkedHashSet 有 head 和 tail）</li>
<li>每一个节点都有 before 和 after 属性，这样可以形成双向链表</li>
<li>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和HashSet一样]）</li>
<li>这样的话，我们遍历LinkedHashSet 也能确保插入顺序和遍历顺序一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lhashset_</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">LinkedHashSet</span> <span class="variable">lhs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">13</span>));</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">14</span>));</span><br><span class="line">        System.out.println( <span class="string">&quot;lhs =&quot;</span> + lhs );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cus</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">cus</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\ncus&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">cus</span> <span class="variable">cus</span> <span class="operator">=</span> (cus) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span>= cus.num &amp;&amp; Objects.equals(name, cus.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">lhs =[</span><br><span class="line">cus&#123;name=<span class="string">&#x27;张三&#x27;</span>, num=<span class="number">12</span>&#125;, </span><br><span class="line">cus&#123;name=<span class="string">&#x27;李四&#x27;</span>, num=<span class="number">13</span>&#125;, </span><br><span class="line">cus&#123;name=<span class="string">&#x27;王五&#x27;</span>, num=<span class="number">14</span>&#125;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LinkedHashSet 集合添加和取出元素的顺序一致</p>
</blockquote>
<h6 id="LinkHashSet原理"><a href="#LinkHashSet原理" class="headerlink" title="LinkHashSet原理"></a>LinkHashSet原理</h6><ol>
<li>LinkedHashSet是HashSet的子类；</li>
<li>底层是节点数组加双向链表；</li>
<li>由于是双向链表，底层是LinkedHashMap，且底层机制是一个Entey后继是另一个Entey，所以导致输出是有序的；</li>
<li>同样不允许添加相同元素。</li>
<li>HashSet中 HashMap的元素数据类型是Node, 静态Node&lt;K,V&gt;类实现了Map接口，重写出属性Node&lt;K,V&gt; next(后继)，没有前驱；但由于LinkedHashSet类是双链表，所以这时候LinkedHashSet类构造自己的静态内部类Entry类，它继承于 HashMap的Node类，但是它有自己的属性before（前驱）和after（后继），数组类型仍然是节点Node，但是节点数组元素数据类型是LinkedHashSet类内部类Entry数据类型，相当于多态存储机制;</li>
<li>（LinkedHashMap的静态Entry内部类继承了HashMap的静态Node&lt;K,V&gt;类，并且重写加入自己的自己的属性before（前驱）和after（后继）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221103151105260.png" alt="image-20221103151105260"></p>
<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><ul>
<li>LinkedHashSet 是 Set 的一个具体实现，其维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</li>
<li>LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的（具体的区别大家可以自己去思考一下）。</li>
<li>如果我们需要迭代的顺序为插入顺序或者访问顺序，那么 LinkedHashSet 是需要你首先考虑的。</li>
</ul>
<h6 id="说说你对-LinkedHashSet-的理解及其与-HashSet-的关系？"><a href="#说说你对-LinkedHashSet-的理解及其与-HashSet-的关系？" class="headerlink" title="说说你对 LinkedHashSet 的理解及其与 HashSet 的关系？"></a>说说你对 LinkedHashSet 的理解及其与 HashSet 的关系？</h6><p>答：<strong>LinkedHashSet 是可以按照插入顺序或者访问顺序进行迭代的非并发安全 Set，</strong>其继承自 HashSet，而 HashSet 又专门提供了一个包访问权限的构造方法给 LinkedHashSet 使用，这个构造方法内部基于 LinkedHashMap 来实现，而普通的 HashSet 则是基于 HashMap 来实现，所以可以说 <strong>LinkedHashSet 底层使用  LinkedHashMap 来保存所有元素，其所有的操作方法与 HashSet 相同，故而 LinkedHashSet 的实现源码非常简单，仅仅只是实现了构造操作等。</strong></p>
<p><strong>LinkedHashSet 与 HashSet 的不同之处在于 LinkedHashSet 依靠 LinkedHashMap 维护着一个顺序链表结构用来迭代，而 HashSet 依靠 HashMap 维持着一个简单的哈希表存储访问；此外 LinkedHashSet 与 HashSet 没有任何区别，都支持元素为 null，都是非并发安全 Set。</strong></p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><h6 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h6><p>TreeSet 是一个有序的集合，它的作用是提供有序的 Set 集合。它继承于 AbstractSet 抽象类，实现了 NavigableSet<E>, Cloneable, java.io.Serializable 接口。<br>TreeSet 继承于 AbstractSet，所以它是一个 Set 集合，具有 Set 的属性和方法。<br>TreeSet 实现了 NavigableSet 接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br>TreeSet 实现了 Cloneable 接口，意味着它能被克隆。<br>TreeSet 实现了 java.io.Serializable 接口，意味着它支持序列化。</p>
<p>TreeSet 是基于 TreeMap 实现的。TreeSet 中的元素支持 2 种排序方式：<strong>自然排序</strong> 或者 根据创建 TreeSet 时提供的 <strong>Comparator</strong> 进行排序。这取决于使用的构造方法。<br>TreeSet 为基本操作（add、remove 和 contains）提供受保证的 log (n) 时间开销。<br>另外，TreeSet 是非同步的。 它的 iterator 方法返回的迭代器是 fail-fast 的。</p>
<h6 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/dd5eefebe83a646310128ee7548862cc.png"></p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p> 有序，不重复；key不能为空，value可以为null（总结一点：凡是有Tree的集合，都是有序的，凡是有Set的就是不重复的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个TreeSet：</span></span><br><span class="line">        TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        ts.add(<span class="number">12</span>);</span><br><span class="line">        ts.add(<span class="number">89</span>);</span><br><span class="line">        ts.add(<span class="number">1</span>);</span><br><span class="line">        ts.add(<span class="number">33</span>);</span><br><span class="line">        ts.add(<span class="number">89</span>);</span><br><span class="line">        ts.add(<span class="number">33</span>);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">        System.out.println(ts);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*结果依旧具有：唯一性*/</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12</span>, <span class="number">33</span>, <span class="number">89</span>]<span class="comment">//升序排序</span></span><br></pre></td></tr></table></figure>

<p>由结果可以直观的发现TreeSet的结果仍然是唯一的，重复的数据不能再次放入集合中；<br>另外也不难发现，打印顺序也同样不按照添加顺序，但再仔细发现，和HashSet不一样的是，TreeSet的打印结果是升序排序的。<br>所以既可以说TreeSet无序（不按照输入顺序进行输出），也可以说其有序（按照升序顺序进行遍历）。</p>
<h6 id="TreeSet的有序的实现"><a href="#TreeSet的有序的实现" class="headerlink" title="TreeSet的有序的实现"></a>TreeSet的有序的实现</h6><p>TreeSet 底层的数据结构使用的是<strong>二叉树</strong></p>
<p>TreeSet 中的元素支持 2 种排序方式：<strong>自然排序</strong> 或者 根据创建 TreeSet 时提供的构造方法  <strong>Comparator</strong> 进行排序</p>
<p>自然排序（Comparable）</p>
<ul>
<li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li>
<li>调用对象的compareTo()方法和集合中的对象比较</li>
<li>根据compareTo()方法返回的结果进行存储</li>
</ul>
<p>构造方法比较器排序（Comparator）</p>
<ul>
<li>创建TreeSet的时候可以制定 一个Comparator</li>
<li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li>
<li>add()方法内部会自动调用Comparator接口中compare()方法排序</li>
<li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TreeSet （)</td>
<td>此构造函数构造空树集，将在根据其元素的自然顺序按升序排序。</td>
</tr>
<tr>
<td align="left">TreeSet (集合 c)</td>
<td>此构造函数生成树的集合，它包含的元素的集合 c。</td>
</tr>
<tr>
<td align="left">TreeSet (比较器 comp)</td>
<td>此构造函数构造一个空树集，将根据给定的比较器进行排序。</td>
</tr>
<tr>
<td align="left">TreeSet (SortedSet ss)</td>
<td>此构造函数生成包含给定 SortedSet 的元素 TreeSet</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个外部比较器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//return ((String) o1).length() - ((String)o2).length();</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).compareTo((String) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//利用外部比较器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        TreeSet treeSet = new TreeSet();</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">cmp</span>());</span><br><span class="line"></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;jck&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;ck&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;ck&quot;</span>);   </span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;Treeset =&quot;</span> + treeSet );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*结果出现唯一性和有序性了*/</span></span><br><span class="line"></span><br><span class="line">Treeset =[a, ck, jack, jck]</span><br></pre></td></tr></table></figure>



<h6 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h6><table>
<thead>
<tr>
<th align="left">修饰符和类型</th>
<th>方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code></td>
<td><code>**add**(E e)</code>将指定的元素添加到这套，如果它已不存在。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td><code>**first**()</code>返回第一个 （最低） 元素当前在这一套。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td><code>**last**()</code>在这套目前返回的最后一个 （最高） 的元素</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td><code>**clear**()</code>从这一组中移除所有元素。</td>
</tr>
<tr>
<td align="left"><code>**int**</code></td>
<td><code>**size**()</code>在这套 （其基数） 中返回的元素的数目。</td>
</tr>
</tbody></table>
<h4 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h4><ol>
<li>List集合存储的数据有序可以重复，Set集合存储的数据无序不可以重复。</li>
<li>List是一个有序的容器，可以保证每一个插入元素的顺序，输出顺序就是输入顺序。</li>
<li>List可以插入多个null值，而Set只能插入一个null值。</li>
</ol>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="map介绍"><a href="#map介绍" class="headerlink" title="map介绍"></a>map介绍</h4><p> Map集合和Collection集合没有任何关系。Collection集合是以单个方式存储元素的，而Map集合是以键值对的方式存储元素，所有Map集合的Key是无序不可重复的，key和value都是引用数据类型，存的都是内存的地址。</p>
<p> Map集合的实现类主要为HashMap、HashTable。子接口有一个SortedMap，SortedMap有一个TreeMap实现类。</p>
<h4 id="Map接口实现类的特点"><a href="#Map接口实现类的特点" class="headerlink" title="Map接口实现类的特点"></a>Map接口实现类的特点</h4><p>注意:<br>这里讲的是JDK8的Map接口特点</p>
<ol>
<li>Map 与 Collection 并列存在。用于保存具有映射关系的数据: Key-Value</li>
<li>Map 中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中</li>
<li>Map 中的 key 不允许重复，原因和 HashSet 一样，前面博文中分析过源码.</li>
<li>Map 中的 value 可以重复</li>
<li>Map 的 key 可以为 null , value 也可以为 null ,注意 key 为 null ,只能有一个，</li>
<li>value为null ,可以多个.</li>
<li>常用 String 类作为 Map 的 key</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</li>
</ol>
<h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object put(Object key,Object value)</td>
<td>存放键值对。</td>
</tr>
<tr>
<td>Object get(Object key)</td>
<td>通过键对象查找得到值对象</td>
</tr>
<tr>
<td>Object remove(Object key)</td>
<td>删除键对象对应得键值对</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>Map容器中是否包含键对象对应的键值对</td>
</tr>
<tr>
<td>boolean conrainsValue(Object value)</td>
<td>Mao容器中是否包含值对象对应得键值对</td>
</tr>
<tr>
<td>int size()</td>
<td>包含键值对得数量</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>Map是否为空</td>
</tr>
<tr>
<td>void putAll(Map t)</td>
<td>将t的所有键值对存放到本Map对象</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空本Map对象所有的键值对</td>
</tr>
</tbody></table>
<h4 id="集合继承图"><a href="#集合继承图" class="headerlink" title="集合继承图"></a>集合继承图</h4><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/b35c014aebcc4b44be80d82df6706782.png" alt="在这里插入图片描述"></p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><blockquote>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>HashMap是Java程序员使用最频繁的的用于键值对(key value)数据处理的容器，在JDK1.7(Java Developmet Kit）时HashMap采取的是数组+链表的形式存储数据，JDK1.8对HashMap进行了存储结构上的优化，引入了红黑树数据结构，极大的增强了HashMap的存取性能！为什么会引入红黑树呢？因为HashMap存在一个问题，即使负载因子和Hash算法设计的再合理，也无法避免出现在链表上拉链过长的问题，如果极端情况下出现严重的Hash冲突，会严重影响HashMap的存取性能，于是HashMap在jdk1.8时，引入了红黑树，利用红黑树快速增删改查的特点来优化了HashMap的性能！</p>
</blockquote>
<h5 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a><strong>什么是哈希表</strong></h5><p>在讨论哈希表之前，我们先大概了解下其他<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>在新增，查找等基础操作执行性能</p>
<p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>
<p><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>
<p><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>
<p><strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下（后面会探讨下哈希冲突的情况），仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
<p>我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>
<p><strong>比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</strong><br>　　<br>这个函数可以简单描述为：<strong>存储位置 &#x3D; f(关键字)</strong> ，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：<br>插入过程如下图所示<br><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2018110221063296.png" alt="哈希表数据插入过程"></p>
<p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<h5 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h5><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="comment">//至于为什么这么做，后面会有详细分析。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>

<p>Entry是HashMap中的一个静态内部类。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="type">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102221702492.png" alt="在这里插入图片描述"></p>
<p>简单来说，<strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好。</strong></p>
<p>其他几个重要字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**实际存储的key-value键值对的个数*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，</span></span><br><span class="line"><span class="comment">threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到*/</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="comment">加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。</span></span><br><span class="line"><span class="comment">所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span></span><br><span class="line"><span class="comment">如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span></span><br><span class="line"><span class="comment">需要抛出异常ConcurrentModificationException*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>
<p>initialCapacity默认为16，loadFactory默认为0.75</p>
<p>看下其中一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">　　　　　<span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();<span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面这段代码可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），<strong>而是在执行put操作的时候才真正构建table数组</strong></p>
<h6 id="put操作的实现"><a href="#put操作的实现" class="headerlink" title="put操作的实现"></a>put操作的实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，</span></span><br><span class="line">        <span class="comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一步首先将k,v封装到Node对象当中（节点）。第二步它的底层会调用K的hashCode()方法得出hash值。第三步通过哈希表函数&#x2F;哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。</p>
<p>java1.8 中put 源码：put 中调用 putVal（）方法：</p>
<p>1.首先判断map中是否有数据，没有就执行resize方法</p>
<p>2.如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上即可</p>
<p>3.如果这个元素的key与要插入的一样，那么就替换一下。</p>
<p>4.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</p>
<p>5.遍历这条链子上的数据，完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法</p>
<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize&#x3D;13,则capacity&#x3D;16;to_size&#x3D;16,capacity&#x3D;16;to_size&#x3D;17,capacity&#x3D;32.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);<span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">        <span class="comment">/**此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span></span><br><span class="line"><span class="comment">        capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 */</span></span><br><span class="line">        threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">       <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="map-get-k-实现原理"><a href="#map-get-k-实现原理" class="headerlink" title="map.get(k)实现原理"></a>map.get(k)实现原理</h6><p>第一步：先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。第二步：通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;<span class="comment">//Entry对象数组</span></span><br><span class="line">    Node&lt;K,V&gt; first,e; <span class="comment">//在tab数组中经过散列的第一个位置</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/</span></span><br><span class="line">    <span class="comment">//也就是说在一条链上的hash值相同的</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/*检查第一个Node是不是要找的Node*/</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))<span class="comment">//判断条件是hash值要相同，key值要相同</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">      <span class="comment">/*检查first后面的node*/</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">/*遍历后面的链表，找到key值和hash值都相同的Node*/</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first&#x3D;tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。</p>
<h6 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**这是一个神奇的函数，用了很多的异或，移位等运算</span></span><br><span class="line"><span class="comment">对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1&#x3D;15，h&#x3D;18,转换成二进制计算为index&#x3D;2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>
<p>所以最终存储位置的确定流程是这样的：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102214046362.png" alt="HashMap如何确定元素位置"></p>
<h6 id="addEntry的实现"><a href="#addEntry的实现" class="headerlink" title="addEntry的实现"></a>addEntry的实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码能够得知，<strong>当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</strong></p>
<h5 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h5><h6 id="什么时候才需要扩容"><a href="#什么时候才需要扩容" class="headerlink" title="什么时候才需要扩容"></a>什么时候才需要扩容</h6><ul>
<li>在首次调用put方法的时候，初始化数组table</li>
<li>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75&#x3D;12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</li>
<li>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</li>
</ul>
<h6 id="hashMap扩容"><a href="#hashMap扩容" class="headerlink" title="hashMap扩容"></a>hashMap扩容</h6><p>扩容就是重新计算容量，向hashMap不停的添加元素，当hashMap无法装载新的元素，对象将需要扩大数组容量，以便装入更多的元素。</p>
<p>haspMap扩容跟数据迁移具有很大的关联，我们先用图解的方式来说明数据迁移.</p>
<p>进行扩容前先介绍一些hahMap源码的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="literal">null</span>,  loTail = <span class="literal">null</span>;   <span class="comment">//低位链表的头尾结点</span></span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;    <span class="comment">//高位链表的头尾结点</span></span><br><span class="line">Node&lt;K,V&gt; next;  <span class="comment">//next指针 指向下一个元素</span></span><br></pre></td></tr></table></figure>


<p>迁移前: 这里将其设置为长度为 8，扩容临界点 8 * 0.75 &#x3D; 6 主要是为了画图 （hashMap默认容量是16）<br>以下讲解都是基于数组容量为 8 讲解的，流程都是一样的.</p>
<p>从图可知，发生了扩容并且是2的次方，并且 A，B,C两元素新的位置刚好是原数组位置的索引位置，D,E，F刚好在原数组位置索引 + 8 即原数组位置索引+数组容量。是不是真的是这样呢？？，这时需要看源码分析一波</p>
<p>流程讲解<br>刚开始进行第一次扩容的时候，得到A的index索引为4，put进数组中，hashMap先会将A的hash进行 &amp; oldCap（8） 运算，判断是否 &#x3D;&#x3D;0，如果为true,则代表为低位链表，这里涉及到二进制运算，比如A的index &#x3D;4 (二进制 &#x3D; 0000 0100) oldCap &#x3D; 8(二进制&#x3D;0000 1000) &amp;运算之后 &#x3D;0，后4位为低位，当然hash肯定不是8个bit位，hashCode得到索引值为int类型，一个int类型占4个字节，一个字节占8个bit位，所以hash二进制所占bit为 32，后4位为低位，高位远远多于低位，所以这也是put操作的时候需要将高位参与进来，减少hasp冲突。（这是put流程，put详情操作请看我另一篇博客）</p>
<p>言归正传，当A进行判断后,会将 loHead和loTail赋值给A，此时链表只有A元素，当循环到第二次迁移后，也就是将B元素进行迁移 B进行 &amp;运算之后，同样为true，所以加入低位链表，而此时链表中有A元素，所以讲A链表的尾结点.next指向B元素即可，同理C也是一样，添加到B尾结点下面，直到添加完所有元素，当添加D元素时，因为D元素的hash为12, 进行 &amp; 运算时为false ，则代表添加到高位链表，此时 hiHead和 hiTail指向D 之后流程都是一样的。当结束循环之后，低位链表的元素将会以原数组下标索引添加到新数组中，但是高位链表的元素会将原数组的下标索引 + oldCap添加到新数组，并且低位高位都会讲原先的数组设置为null ,方便gc</p>
<p>源码实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;  <span class="comment">//数组容量（旧）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold; <span class="comment">//扩容临界点(旧)</span></span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//数组容量（新）、扩容临界点(新)</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧容量大于等于了最大的容量 2^30</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">//将临界值设置为Integer.MAX_VALUE</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扩容2倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 新阈值设置2倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// HashMap(int initialCapacity, float loadFactor)调用</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 第一次put操作的时候，因为jdk1.8hashMap先添加元素再扩容</span></span><br><span class="line">        <span class="comment">//构造函数将jdk1.7的扩容移动到这</span></span><br><span class="line">                    newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//默认容量 16</span></span><br><span class="line">                    <span class="comment">//临界值 16 *0.75 =12</span></span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新阈值为0，根据负载因子设置新阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;如果旧的数组中有数据，循环</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123; </span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>; <span class="comment">//gc处理</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//只有一个节点，赋值，返回</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是否为红黑树结点</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">//低位链表</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;  <span class="comment">//高位链表</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next; <span class="comment">//指向下个元素结点，做为while循环的条件</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//判断是否为低位链表</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)  <span class="comment">//链表没有元素，则将该元素作为头结点</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e; <span class="comment">//加在链表的下方</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123; &#123;<span class="comment">//不为0，元素位置在扩容后数组中的位置发生了改变，新的下</span></span><br><span class="line"><span class="comment">//标位置是（原下标位置+原数组长）</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//遍历完成后，进行数据迁移</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//链表最后</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将元素原位置迁移到新数组中，位置一样</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//高位链表迁移 + 旧数组容量</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结（扩容与迁移）：<br>1、扩容就是将旧表的数据迁移到新表<br>2、迁移过去的值需要重新计算hashCode，也就是他的存储位置<br>3、关于位置可以这样理解：比如旧表的长度8、新表长度16<br>旧表位置4有6个数据，假如前三个hashCode是一样的，后面的三个hashCode是一样的迁移的时候；就需要计算这6个值的存储位置<br>4、如何计算位置？采用低位链表和高位链表；如果位置4下面的数据e.hash &amp; oldCap等于0，那么它对应的就是低位链表，也就是数据位置不变,e.hash &amp; oldCap不等于0呢?就要重写计算他的位置也就是j + oldCap（4+8）；这个12，就是高位链表位置（新数组12位置）</p>
<h5 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a><strong>为何HashMap的数组长度一定是2的次幂？</strong></h5><p>HashMap的扩容公式：initailCapacity * loadFactor &#x3D; HashMap</p>
<p>其中initailCapacity是初始容量：默认值为16（懒加载机制，只有当第一次put的时候才创建）</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210708153056800.png" alt="在这里插入图片描述"><br>其中loadFactor是负载因子：默认值为0.75</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210708153021614.png" alt="在这里插入图片描述"></p>
<p>我们来继续看上面提到的resize方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果数组进行扩容，数组长度发生变化，而存储位置 index &#x3D; h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">　　　　　<span class="comment">//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>
<p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102223343298.png" alt="在这里插入图片描述"></p>
<p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102223421180.png" alt="在这里插入图片描述"><br>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index&#x3D;21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。<br><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2018110222343145.png" alt="在这里插入图片描述"><br>如果不是2的次幂，也就是低位不是全为1此时，要使得index&#x3D;21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<p><strong>get方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">　　　　 <span class="comment">//如果key为null,则直接去table[0]处去检索即可。</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       <span class="type">return</span> <span class="variable">null</span> <span class="operator">=</span>= entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="literal">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash &#x3D;&#x3D; hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<h5 id="重写equals方法需同时重写hashCode方法"><a href="#重写equals方法需同时重写hashCode方法" class="headerlink" title="重写equals方法需同时重写hashCode方法"></a><strong>重写equals方法需同时重写hashCode方法</strong></h5><p>最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="type">int</span> idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> idCard, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.idCard = idCard;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="comment">//两个对象是否等值，通过idCard来确定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Person, String&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1234</span>,<span class="string">&quot;乔峰&quot;</span>);</span><br><span class="line">        <span class="comment">//put到hashmap中去</span></span><br><span class="line">        map.put(person,<span class="string">&quot;天龙八部&quot;</span>);</span><br><span class="line">        <span class="comment">//get取出，从逻辑上讲应该能输出“天龙八部”</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果:&quot;</span>+map.get(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1234</span>,<span class="string">&quot;萧峰&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际输出结果：<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>
<p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h5 id="JDK1-8中HashMap的性能优化"><a href="#JDK1-8中HashMap的性能优化" class="headerlink" title="JDK1.8中HashMap的性能优化"></a><strong>JDK1.8中HashMap的性能优化</strong></h5><p>假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？<br>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。<br>关于这方面的探讨我们以后的文章再做说明。<br><strong>附：HashMap put方法逻辑图（JDK1.8）</strong><br><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181105181728652.png" alt="在这里插入图片描述"></p>
<h4 id="LinkHashMap"><a href="#LinkHashMap" class="headerlink" title="LinkHashMap"></a>LinkHashMap</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><pre><code>    LinkedHashMap是HashMap和双向链表的合二为一，即一个将所有Entry节点链入一个双向链表的HashMap（LinkedHashMap = HashMap + 双向链表）
</code></pre>
<ul>
<li><p>LinkedHashMap和HashMap是Java Collection Framework 的重要成员，也是Map族(如下图所示)</p>
</li>
<li><p>LinkedHashMap是HashMap的子类（拥有HashMap的所有特性）</p>
</li>
<li><p>LinkedHashMap和HashMap最多只允许一条Entry的键为Null(多条会覆盖)，但允许多条Entry的值为Null</p>
</li>
<li><p>LinkedHashMap 也是 Map 的一个非同步的实现</p>
</li>
<li><p>LinkedHashMap很好的支持LRU算法</p>
</li>
<li><p>HashMap是无序的，LinkedHashMap通过维护一个额外的双向链表保证了迭代顺序</p>
</li>
<li><p>迭代顺序可以是插入顺序，也可以是访问顺序（即根据链表中元素的顺序可以将LinkedHashMap分为：保持插入顺序的LinkedHashMap和保持访问顺序的LinkedHashMap，其中LinkedHashMap的默认实现是按插入顺序排序的）</p>
</li>
</ul>
<p> LinkedHashMap的原理图：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/17341aae7d364066b4088d91679d667c.png" alt="img"></p>
<p> LinkedHashMap和HashMap的Entry结构图：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/f7a0f34a145b4a83909811c5590db1b2.png" alt="img"></p>
<h5 id="在JDK中的定义"><a href="#在JDK中的定义" class="headerlink" title="在JDK中的定义"></a>在JDK中的定义</h5><h6 id="继承关系-2"><a href="#继承关系-2" class="headerlink" title="继承关系"></a>继承关系</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h6 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h6><ul>
<li><p>相比于Hashmap，LinkedHashMap新增 双向链表头结点header和标志位accessOrder </p>
</li>
<li><p>accessOrder：</p>
<ul>
<li>默认为false（即默认按照插入顺序迭代）    </li>
<li>为true时（按照访问顺序迭代，支持实现LRU算法时）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3801124242820219131L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;<span class="comment">//双向链表头节点，也即哨兵节点，里面不存储任何信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;<span class="comment">//有序性标识</span></span><br></pre></td></tr></table></figure>

<h6 id="构造方法（5种）"><a href="#构造方法（5种）" class="headerlink" title="构造方法（5种）"></a>构造方法（5种）</h6><ul>
<li>相比于Hashmap，LinkedHashMap并没有增加构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的参数为初始容量，加载因子，调用了父类的构造方法，按照插入顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的参数的初始容量，调用父类的构造方法，取得键值对的顺序是插入顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造，调用父类的构造方法，取得键值对的顺序是插入顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的参数是一个Map的集合，调用父类的构造方法，取得键值对的顺序是插入顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(m);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的参数为初始容量，加载因子，有序性标识（键值对保持顺序），调用了父类的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                         <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="init-方法"><a href="#init-方法" class="headerlink" title="init()方法"></a>init()方法</h6><p>由 LinkedHashMap的五种构造方法可知：</p>
<ul>
<li>无论采用何种方式创建LinkedHashMap，其都会调用HashMap相应的构造函数</li>
<li>不管调用HashMap的哪个构造函数，HashMap的构造函数都会在最后调用一个init()方法进行初始化</li>
<li>init()方法在HashMap中是一个空实现，而在LinkedHashMap中重写了它，用于初始化它所维护的双向链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hashmap</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">   threshold = (<span class="type">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">   table = <span class="keyword">new</span> <span class="title class_">Entry</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">   init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashmap</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//header初始化</span></span><br><span class="line">        <span class="comment">//hash为-1，其他的参数均为null</span></span><br><span class="line">        <span class="comment">//也就是说这个header不在数组中</span></span><br><span class="line">        <span class="comment">//只是用来标志开始元素和标志结束元素的</span></span><br><span class="line">        header = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        header.before = header.after = header;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="基本数据结构："><a href="#基本数据结构：" class="headerlink" title="基本数据结构："></a>基本数据结构：</h6><ul>
<li>LinkedHashMap中的Entry增加了两个指针 before 和 after，用于维护双向链接列表<ul>
<li>before、after用于维护Entry插入的先后顺序</li>
<li>next用于维护HashMap各个桶中Entry的连接顺序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line"> </span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p> LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)：</p>
<ul>
<li>构造一个与指定Map具有相同映射的 LinkedHashMap，其初始容量不小于16 (具体依赖于指定Map的大小)，负载因子是 0.75，是 Java Collection Framework 规范推荐提供的，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Constructs an insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with</span></span><br><span class="line"><span class="comment">* the same mappings as the specified map.  The &lt;tt&gt;LinkedHashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* instance is created with a default load factor (0.75) and an initial</span></span><br><span class="line"><span class="comment">* capacity sufficient to hold the mappings in the specified map.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(m);       <span class="comment">// 调用HashMap对应的构造函数</span></span><br><span class="line">  accessOrder = <span class="literal">false</span>;    <span class="comment">// 迭代顺序的默认值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="快速存取"><a href="#快速存取" class="headerlink" title="快速存取"></a>快速存取</h5><p>LinkedHashMap 的存储实现 : put(key, vlaue)</p>
<p>LinkedHashMap完全继承了HashMap的 put(Key,Value) 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;      <span class="comment">//数组为null时</span></span><br><span class="line">            inflateTable(threshold);     <span class="comment">//给数组根据阈值分配内容空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)      <span class="comment">//key为null时</span></span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);  <span class="comment">//通过key计算hash</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);  <span class="comment">//计算在数组中的索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">               <span class="comment">//使用的是LinkedHashMap重写的方法</span></span><br><span class="line">                         <span class="number">1</span> </span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);         </span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> 	 modCount++;</span><br><span class="line">   <span class="comment">//addEntry调用的是LinkedHashMap重写了的方法</span></span><br><span class="line">             <span class="number">2</span> </span><br><span class="line">    addEntry(hash, key, value, i);     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>只是对put(Key,Value)方法所调用的recordAccess方法和addEntry方法进行了重写</li>
<li>addEntry方法中还调用了removeEldestEntry方法，该方法是用来被重写的，一般如果用LinkedHashmap实现LRU算法，就要重写该方法</li>
<li>比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中putEntry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;      <span class="number">1</span></span><br><span class="line">            <span class="comment">//将传入的HashMap类型的m强制转换成LinkedHashMap类型的    </span></span><br><span class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  </span><br><span class="line">            <span class="comment">//accessOrder默认的是false，当accessOrder为true时进入</span></span><br><span class="line">            <span class="keyword">if</span> (lm.accessOrder) &#123; </span><br><span class="line">                lm.modCount++;</span><br><span class="line">                <span class="comment">//移除当前节点 </span></span><br><span class="line">                remove(); </span><br><span class="line">                <span class="number">3</span>      </span><br><span class="line">                addBefore(lm.header);           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;           </span><br><span class="line">        <span class="comment">// 重写了HashMap中的createEntry方法</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);  </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Remove eldest entry if instructed</span></span><br><span class="line">        Entry&lt;K,V&gt; eldest = header.after;   <span class="comment">//还是header自身</span></span><br><span class="line">        <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;            </span><br><span class="line">            removeEntryForKey(eldest.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//扩容到原来的2倍  </span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold)             </span><br><span class="line">            resize(<span class="number">2</span> * table.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在LinkedHashMap的addEntry方法中，它重写了HashMap中的createEntry方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123; </span><br><span class="line">    <span class="comment">// 向哈希表中插入Entry，这点与HashMap中相同 </span></span><br><span class="line">    <span class="comment">//创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  </span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;K,V&gt;(hash, key, value, old);  </span><br><span class="line">    table[bucketIndex] = e;     </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span></span><br><span class="line">    <span class="comment">//这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素</span></span><br><span class="line">    <span class="comment">//(LinkedHashMap根据双向链表重写了迭代器)</span></span><br><span class="line">    <span class="comment">//同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span></span><br><span class="line">    e.addBefore(header);  </span><br><span class="line">    size++;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中</li>
<li>addBefore方法本质上是一个双向链表的插入操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入有序不做处理，在访问有序做相应处理：addBefore（将当前节点插到header的前面）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;             <span class="number">3</span></span><br><span class="line">            after  = existingEntry;     <span class="comment">//existingEntry即为header</span></span><br><span class="line">            before = existingEntry.before;</span><br><span class="line">            before.after = <span class="built_in">this</span>;     <span class="comment">//this即为要插入的节点</span></span><br><span class="line">            after.before = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LinkedHashMap完全继承了HashMap的resize()方法，只是对它所调用的transfer方法进行了重写</li>
<li>Map扩容操作的核心在于重哈希</li>
<li>重哈希是指重新计算原HashMap中的元素在新table数组中的位置并进行复制处理的过程，鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对重哈希过程(transfer方法)进行了重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;       <span class="number">5</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 若 oldCapacity 已达到最大值，直接将 threshold 设为 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;             <span class="comment">// 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 否则，创建一个更大的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将每条Entry重新哈希到新的数组中</span></span><br><span class="line">            <span class="number">6</span></span><br><span class="line">    transfer(newTable);  <span class="comment">//LinkedHashMap对它所调用的transfer方法进行了重写</span></span><br><span class="line"> </span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);  <span class="comment">// 重新设定 threshold</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(HashMap.Entry[] newTable)</span> &#123;     <span class="number">6</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">// 与HashMap相比，借助于双向链表的特点进行重哈希使得代码更加简洁</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);   <span class="comment">// 计算每个Entry所在的桶</span></span><br><span class="line">        <span class="comment">// 将其链入桶中的链表</span></span><br><span class="line">        e.next = newTable[index];</span><br><span class="line">        newTable[index] = e;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 的读取实现 ：get(Object key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="comment">//调用父类HashMap的getEntry()方法，取得要查找的元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 记录访问顺序</span></span><br><span class="line">        e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line"> </span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在HashMap的put和get方法中，会调用该方法，在HashMap中该方法为空；</span></span><br><span class="line"><span class="comment">//在LinkedHashMap中，</span></span><br><span class="line"><span class="comment">//当按访问顺序排序时，该方法会将当前节点插入到链表尾部(头结点的前一个节点)，</span></span><br><span class="line"><span class="comment">//否则不做任何事</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">            <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">                lm.modCount++;</span><br><span class="line"><span class="comment">//移除当前节点</span></span><br><span class="line">                remove();</span><br><span class="line"><span class="comment">//将当前节点插入到头结点前面</span></span><br><span class="line">                addBefore(lm.header);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">            after  = existingEntry;</span><br><span class="line">            before = existingEntry.before;</span><br><span class="line">            before.after = <span class="built_in">this</span>;</span><br><span class="line">            after.before = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>recordAccess方法：</p>
<ul>
<li>如果链表中元素的排序规则是按照插入的先后顺序排序的话（accessOrder&#x3D;false），该方法什么也不做</li>
<li>如果链表中元素的排序规则是按照访问的先后顺序排序的话（accessOrder&#x3D;true），则将e移到链表的末尾处</li>
</ul>
</li>
<li><p>调用LinkedHashMap的get(Object key)方法，返回值是 NULL，有如下两种可能：</p>
<ul>
<li>该 key 对应的值就是 null</li>
<li>HashMap 中不存在该 key</li>
</ul>
</li>
</ul>
<h5 id="有序性原理分析"><a href="#有序性原理分析" class="headerlink" title="有序性原理分析"></a>有序性原理分析</h5><p> <strong>LinkedHashMap 增加了双向链表头结点header 和 标志位accessOrder两个属性用于保证迭代顺序。但是要想真正实现其有序性，还差临门一脚，那就是重写HashMap 的迭代器，其源码实现如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LinkedHashIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; nextEntry    = header.after;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">     * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">     * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;         <span class="comment">// 根据双向列表判断 </span></span><br><span class="line">            <span class="keyword">return</span> nextEntry != header;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"> </span><br><span class="line">            LinkedHashMap.<span class="built_in">this</span>.remove(lastReturned.key);</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry&lt;K,V&gt; <span class="title function_">nextEntry</span><span class="params">()</span> &#123;        <span class="comment">// 迭代输出双向链表各节点</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="keyword">if</span> (nextEntry == header)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"> </span><br><span class="line">            Entry&lt;K,V&gt; e = lastReturned = nextEntry;</span><br><span class="line">            nextEntry = e.after;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Key 迭代器，KeySet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span>&lt;K&gt; &#123;   </span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextEntry().getKey(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Value 迭代器，Values(Collection)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ValueIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextEntry().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Entry 迭代器，EntrySet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">EntryIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextEntry(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>上文是基于JDK1.6的实现，实际上JDK1.8对其进行了改动</p>
</li>
<li><p>linkedhashmap在hashmap的数组加链表结构的基础上，将所有节点连成了一个双向链表</p>
</li>
<li><p>当主动传入的accessOrder参数为false时, 使用put方法时，新加入元素不仅加入哈希桶中，还被加入双向链表末尾，get方法使用时不会把元素放到双向链表尾部</p>
</li>
<li><p>当主动传入的accessOrder参数为true时，使用put方法新加入的元素，如果遇到了哈希冲突，并且对key值相同的元素进行了替换，就会被放在双向链表的尾部，当元素超过上限且removeEldestEntry方法返回true时，直接删除最早元素以便新元素插入。如果没有冲突直接放入，同样加入到链表尾部。使用get方法时会把get到的元素放入双向链表尾部</p>
</li>
<li><p>inkedhashmap的扩容比hashmap来的方便，因为hashmap需要将原来的每个链表的元素分别在新数组进行反向插入链化，而linkedhashmap的元素都连在一个链表上，可以直接迭代然后插入</p>
</li>
<li><p>linkedhashmap的removeEldestEntry方法默认返回false，要实现LRU很重要的一点就是集合满时要将最久未访问的元素删除，在linkedhashmap中这个元素就是头指针指向的元素。实现LRU可以直接实现继承linkedhashmap并重写removeEldestEntry方法来设置缓存大小。jdk中实现了LRUCache也可以直接使用</p>
</li>
<li><p>在put操作上，虽然LinkedHashMap完全继承了HashMap的put操作，但是在细节上还是做了一定的调整，比如，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中</p>
</li>
<li><p>在扩容操作上，虽然LinkedHashMap完全继承了HashMap的resize操作，但是鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对其中的重哈希过程(transfer方法)进行了重写</p>
</li>
<li><p>在读取操作上，LinkedHashMap中重写了HashMap中的get方法（加入recordAccess方法，重写transfer方法），通过HashMap中的getEntry方法获取Entry对象</p>
</li>
</ul>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>HashTable类中，保存实际数据的，依然是Entry对象。其数据结构与HashMap是相同的。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20190313104521294.png" alt="在这里插入图片描述"></p>
<p>HashTable类继承自Dictionary类，实现了三个接口，分别是Map，Cloneable和java.io.Serializable，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20190313104529714.png" alt="在这里插入图片描述"></p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。</p>
<p>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。</p>
<p>Hashtable中的映射不是有序的。</p>
<p>Hashtable采用”拉链法”实现哈希表。</p>
<h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表</span></span><br><span class="line"><span class="comment"> * 的&quot;key-value键值对&quot;都是存储在Entry数组中的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，容量为11，加载因子为0.75。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定初始容量和指定加载因子构造一个新的空哈希表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个与给定的 Map 具有相同映射关系的新哈希表。</span></span><br><span class="line"><span class="comment"> * 设置table容器大小，其值==t.size * 2 + 1   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h6><p>put方法的主要逻辑如下：<br>先获取synchronized锁。<br>put方法不允许null值，如果发现是null，则直接抛出异常。<br>计算key的哈希值和index<br>遍历对应位置的链表，如果发现已经存在相同的hash和key，则更新value，并返回旧值。<br>如果不存在相同的key的Entry节点，则调用addEntry方法增加节点。<br>addEntry方法中，如果需要则进行扩容，之后添加新节点到链表头部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">​</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            rehash();</span><br><span class="line">​</span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h6><p>get方法的主要逻辑如下<br>先获取synchronized锁。<br>计算key的哈希值和index。<br>在对应位置的链表中寻找具有相同hash和key的节点，返回节点的value。<br>如果遍历结束都没有找到节点，则返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="rehash扩容方法"><a href="#rehash扩容方法" class="headerlink" title="rehash扩容方法"></a><strong>rehash扩容方法</strong></h6><p>rehash扩容方法主要逻辑如下：<br>数组长度增加一倍（如果超过上限，则设置成上限值）。<br>更新哈希表的扩容门限值。<br>遍历旧表中的节点，计算在新表中的index，插入到对应位置链表的头部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line">​</span><br><span class="line">        modCount++;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        table = newMap;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line">​</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h6><p>remove方法主要逻辑如下：<br>先获取synchronized锁。<br>计算key的哈希值和index。<br>遍历对应位置的链表，寻找待删除节点，如果存在，用e表示待删除节点，pre表示前驱节点。如果不存在，返回null。<br>更新前驱节点的next，指向e的next。返回待删除节点的value值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="literal">null</span> ; e != <span class="literal">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">//        hashtable.put(null,1);  //NullPointerException</span></span><br><span class="line"><span class="comment">//        hashtable.put(1,null); //NullPointerException</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack1&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack2&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack3&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack4&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack5&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack6&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack7&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">​</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.底层有数组 Hashtable$Entry[] 初始化大小为 11</span></span><br><span class="line"><span class="comment">2.临界值 threshold 8 = 11 * 0.75</span></span><br><span class="line"><span class="comment">3.扩容： 按照自己的扩容机制来进行即可</span></span><br><span class="line"><span class="comment">4.执行方法 addEntry(hash, key, value, index);添加 K-V 封装到Entry</span></span><br><span class="line"><span class="comment">5.满足if (count &gt;= threshold) 时，就进行扩容</span></span><br><span class="line"><span class="comment">6.int newCapacity = (oldCapacity &lt;&lt; 1) + 1; //两倍加一的大小扩容</span></span><br><span class="line"><span class="comment">​</span></span><br><span class="line"><span class="comment">底层解读：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">    public synchronized V put(K key, V value) &#123;</span></span><br><span class="line"><span class="comment">        // Make sure the value is not null</span></span><br><span class="line"><span class="comment">        if (value == null) &#123;</span></span><br><span class="line"><span class="comment">            throw new NullPointerException();</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">5.满足if (count &gt;= threshold) &#123; 扩容机制</span></span><br><span class="line"><span class="comment">int newCapacity = (oldCapacity &lt;&lt; 1) + 1; //两倍加一</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h5 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h5><ol>
<li><p>HashMap是非同步的，没有对读写等操作进行锁保护，所以是线程不安全的，在多线程场景下会出现数据不一致的问题。而HashTable是同步的，所有的读写等操作都进行了锁（synchronized）保护，在多线程环境下没有安全问题。但是锁保护也是有代价的，会对读写的效率产生较大影响。</p>
</li>
<li><p>HashMap的key可以使用null（但只能有一个），value可以为null，而HashTable都不允许存储key和value值为空的元素</p>
</li>
<li><p>HashMap继承了AbstractMap，HashTable继承了Dictionary抽象类，两者都实现了Map接口</p>
</li>
<li><p>HashMap的初始容量为16，HashTable的初始容量为11</p>
</li>
<li><p>HashMap的扩容机制为扩容两倍，而HashTable的扩容机制为两倍+1</p>
<ol>
<li>&#96;&#96;&#96;<br>int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. HashTable不会转换为红黑树</span><br><span class="line"></span><br><span class="line">7. HashMap的迭代器（Iterator）是fail-fast迭代器，但是Hashtable的迭代器（enumerator）不是fail-fast的。如果有其它线程对HashMap进行的添加/删除元素，将会抛出ConcurrentModificationException，但迭代器本身的remove方法移除元素则不会抛出异常。这条同样也是Enumeration和Iterator的区别。</span><br><span class="line"></span><br><span class="line">|           | 版本 | 线程安全（同步） | 效率 | 允许null键null值 |</span><br><span class="line">| :-------- | :--- | :--------------- | :--- | :--------------- |</span><br><span class="line">| HashMap   | 1.2  | 不安全           | 高   | 允许             |</span><br><span class="line">| Hashtable | 1.0  | 安全             | 较低 | 不允许           |</span><br><span class="line"></span><br><span class="line">#### porperties</span><br><span class="line"></span><br><span class="line">##### porperties介绍</span><br><span class="line"></span><br><span class="line">Properties（Java.util.Properties）是Java中一个比较重要的类，主要用于读取Java的配置文件。各种语言都有自己所支持的配置文件，配置文件中很多变量是经常改变的，这样做也是为了方便用户，让用户能够脱离程序本身去修改相关的变量设置。在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”或者“键 值”的格式，文本注释信息可以用&quot;#&quot;来注释。</span><br><span class="line"></span><br><span class="line">在做Java项目开发过程中，涉及到一些数据库服务连接配置、缓存服务器连接配置等，通常情况下我们会将这些不太变动的配置信息存储在以 .properties 结尾的配置文件中。当对应的服务器地址或者账号密码信息有所变动时，我们只需要修改一下配置文件中的信息即可。</span><br><span class="line"></span><br><span class="line"> Properties是一个Map体系集合类，因为其继承于Hashtable，而Hashtable继承于Dictionary类，实现了Map接口，所以Properties也保留了其相关特性。</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Unfalll/picgo/main/img/20201229131713135.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`Properties`继承于`Hashtable`，表示一个持久的属性集，属性列表中每个键及其对应值都是一个[字符串](https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020)。`Properties`类被许多`Java`类使用，例如在获取[环境变量](https://so.csdn.net/so/search?q=环境变量&amp;spm=1001.2101.3001.7020)时，它就作为`System.getProperties`方法的返回值。</span><br><span class="line"></span><br><span class="line">![properties汉化](https://raw.githubusercontent.com/Unfalll/picgo/main/img/2665b4ea840d9b588862a54c26c67274.png)</span><br><span class="line"></span><br><span class="line">##### Properties特点</span><br><span class="line"></span><br><span class="line">1. Properties是Hashtable&lt;Object,Object&gt;的子类；</span><br><span class="line">2. Properties类表示了一个可持久的属性集；</span><br><span class="line">3. Properties可以保存在流中或从流中加载；</span><br><span class="line">4. Properties中每个键和对应的值都是一个字符串（String类型）；</span><br><span class="line">5. Properties有一个特殊的作用：专门用来加载xxx.properties配置文件。</span><br><span class="line"></span><br><span class="line">##### Properties作为Map集合的使用</span><br><span class="line"></span><br><span class="line">&gt; ​      Properties作为Map集合使用时各种方法都与map集合一致（虽然可以但是不建议将Properties作为Map集合使用），但是有一点不同，就是在创建对象时不需要也不能给出泛型，否则会报错，默认所有的键值对类型都是Object类型。下面进行简单的添加和遍历演示。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//Properties作为map集合的使用</span><br><span class="line">private static void PropertiesMap() &#123;</span><br><span class="line">	Properties pro = new Properties();//不需要加泛型，所有的键值都是object类型</span><br><span class="line">	</span><br><span class="line">	//存储元素</span><br><span class="line">	pro.put(001, &quot;张三&quot;);</span><br><span class="line">	pro.put(002, &quot;李四&quot;);</span><br><span class="line">	pro.put(003, &quot;王五&quot;);</span><br><span class="line">	</span><br><span class="line">	//遍历集合</span><br><span class="line">	for(Object key : pro.keySet()) &#123;</span><br><span class="line">		System.out.println(key + &quot;:&quot; + pro.get(key));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<blockquote>
<p>注意：不要使用Hashtable里面定义的方法添加键值对！因为它们可以插入不是String 类型的数据。如果一个Properties中含有非String的键值对，那么这样的Properties是“不安全”的。调用 store 或者 save 方法将失败。</p>
</blockquote>
<h5 id="Properties作为集合的特有方法"><a href="#Properties作为集合的特有方法" class="headerlink" title="Properties作为集合的特有方法"></a>Properties作为集合的特有方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object setPorperty(String key,String value)</td>
<td>设置集合的键和值，都是String类型，底层调用Hashtable方法put</td>
</tr>
<tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set<String> stringPropertyNames()</td>
<td>从该属性中返回一个不可修改的键集，其中键及其对应的值是字符串</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Properties作为集合的特有方法</span></span><br><span class="line"><span class="comment"> * 		0bject setProperty(String key,String value):设置类合的链和值，都是String类型，底层调用Hashtable方法put</span></span><br><span class="line"><span class="comment"> * 		string getProperty ( String key):使用此属性列表中指定的性搜索属性</span></span><br><span class="line"><span class="comment"> * 		Set&lt;String&gt; stringPropert yNames():从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SpecialMethod</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	</span><br><span class="line">	pro.setProperty(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;张三&quot;</span>);<span class="comment">//键值都是String类型</span></span><br><span class="line">	pro.setProperty(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">	pro.setProperty(<span class="string">&quot;003&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	System.out.println(pro.getProperty(<span class="string">&quot;001&quot;</span>));<span class="comment">//根据键搜索属性</span></span><br><span class="line">	System.out.println(pro.getProperty(<span class="string">&quot;0011&quot;</span>));<span class="comment">//没有时返回null</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(pro);</span><br><span class="line">	</span><br><span class="line">	Set&lt;String&gt; s = pro.stringPropertyNames();<span class="comment">//返回一个不可修改的键集，其中键及其对应的值是字符串</span></span><br><span class="line">	System.out.println(s);</span><br><span class="line">	<span class="keyword">for</span>(String key : s) &#123;</span><br><span class="line">		System.out.println(key + <span class="string">&quot;:&quot;</span> + pro.getProperty(key));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221128225120730.png" alt="image-20221128225120730"></p>
<p>Properties文件处理<br>我们要处理properties文件就要用到Properties类，要用到一个类首先要干嘛？</p>
<p>我们需要至少一个Properties对象：</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个Properties对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br></pre></td></tr></table></figure>

<p>现在我们已经有了一个Properties对象，那么我们该如何用该对象往properties文件写数据呢？</p>
<p>不过在此之前，我们还得先想想现在有properties文件吗，好像并没有，所有我们还需要创建properties文件</p>
<p>在这里我们需要用到IO流跟异常的相关基础知识</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个test1.properties文件并通过文件输出流写入</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.properties&quot;</span>);</span><br><span class="line"><span class="comment">//引入Writer,可以明确该输出流的字符集,确保写入配置文件的中文编码正确（utf-8格式）</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">ops</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>好，现在我们已经有了一个名为test1的properties文件，现在我们要往里面写数据了，在这里我们需要用到Properties类中的setProperty方法</p>
<p>该方法API如下：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/586060fddb20963d96bec63a7613a13e.png" alt="setProperty"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将需要写入的属性内容通过set方法,存入properties对象中</span></span><br><span class="line">pros.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;一呆&quot;</span>);</span><br><span class="line">pros.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">pros.setProperty(<span class="string">&quot;money&quot;</span>,<span class="string">&quot;0&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>现在我们已经往里面写数据了，但这个数据只是临时数据，所以我们还需要保存数据，在这里我们需要用到Properties类中的store方法</p>
<p>该方法API如下：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/4309eca83af192cd9ecdc5f79630785c.png" alt="store"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用properties的存储方法</span></span><br><span class="line">pros.store(ops,<span class="string">&quot;测试数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在最后，我们需要释放使用的资源，换句话说，我们需要关闭资源</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">ops.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>


<p>我们现在总结一下要对properties文件进行处理都要干些啥：</p>
<ol>
<li>需要Properties对象</li>
<li>需要创建properties文件（通过IO流）</li>
<li>需要进行异常处理</li>
<li>需要通过Properties类中的setProperty方法往properties文件里写数据</li>
<li>需要通过Properties类中的store方法保存写入properties文件的数据</li>
<li>需要关闭资源</li>
</ol>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">propertiesTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先实例化一个Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建一个输出流对象</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//3.引入Writer,可以明确该输出流的字符集,确保写入配置文件的中文编码正确</span></span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">ops</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//4.将需要写入的属性内容通过set方法,存入properties对象中</span></span><br><span class="line">            pros.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;一呆&quot;</span>);</span><br><span class="line">            pros.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">            pros.setProperty(<span class="string">&quot;money&quot;</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">//5.调用properties的存储方法</span></span><br><span class="line">            pros.store(ops,<span class="string">&quot;测试数据&quot;</span>);</span><br><span class="line">            <span class="comment">//6.关闭资源</span></span><br><span class="line">            ops.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建的properties文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/7dc0cd7e0f26eab96a851432dbbfc671.png" alt="properties文件"></p>
<h5 id="所有方法"><a href="#所有方法" class="headerlink" title="所有方法"></a>所有方法</h5><table>
<thead>
<tr>
<th align="left">返回类型</th>
<th align="left">方法名和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String</code></td>
<td align="left"><code>getProperty(String key)</code>使用此属性列表中指定的键搜索属性。</td>
</tr>
<tr>
<td align="left"><code>String</code></td>
<td align="left"><code>getProperty(String key, String defaultValue)</code>使用此属性列表中指定的键搜索属性。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>list(PrintStream out)</code>将此属性列表打印到指定的输出流。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>list(PrintWriter out)</code>将此属性列表打印到指定的输出流。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>load(InputStream inStream)</code>从输入字节流读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>load(Reader reader)</code>以简单的线性格式从输入字符流读取属性列表（关键字和元素对）。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>loadFromXML(InputStream in)</code>将指定输入流中的XML文档表示的所有属性加载到此属性表中。</td>
</tr>
<tr>
<td align="left"><code>Enumeration&lt;?&gt;</code></td>
<td align="left"><code>propertyNames()</code>返回此属性列表中所有键的枚举，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>save(OutputStream out, String comments)</code><strong>已弃用</strong>如果在保存属性列表时发生I &#x2F; O错误，此方法不会抛出IOException。 保存属性列表的<code>store(OutputStream out, String comments)</code>方法是通过<code>store(OutputStream out, String comments)</code>方法或<code>storeToXML(OutputStream os, String comment)</code>方法。</td>
</tr>
<tr>
<td align="left"><code>Object</code></td>
<td align="left"><code>setProperty(String key, String value)</code>致电 <code>Hashtable</code>方法 <code>put</code> 。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>store(OutputStream out, String comments)</code>将此属性列表（键和元素对）写入此 <code>Properties</code>表中，以适合于使用 <a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Properties.html#load-java.io.InputStream-"><code>load(InputStream)</code></a>方法加载到 <code>Properties</code>表中的格式输出流。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>store(Writer writer, String comments)</code>将此属性列表（键和元素对）写入此 <code>Properties</code>表中，以适合使用 <a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Properties.html#load-java.io.Reader-"><code>load(Reader)</code></a>方法的格式输出到输出字符流。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>storeToXML(OutputStream os, String comment)</code>发出表示此表中包含的所有属性的XML文档。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>storeToXML(OutputStream os, String comment, String encoding)</code>使用指定的编码发出表示此表中包含的所有属性的XML文档。</td>
</tr>
<tr>
<td align="left"><code>Set&lt;String&gt;</code></td>
<td align="left"><code>stringPropertyNames()</code>返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。</td>
</tr>
</tbody></table>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>TreeMap是一个基于key有序的key value散列表。</p>
<ul>
<li>map根据其键的自然顺序排序，或者根据map创建时提供的Comparator排序</li>
<li>不是线程安全的</li>
<li>key 不可以存入null</li>
<li>底层是基于红黑树实现的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/26231590053a6617afad4b9e92747996.webp" alt="img"></p>
<p>以上是TreeMap的类结构图：</p>
<ol>
<li>实现了NavigableMap接口，NavigableMap又实现了Map接口，提供了导航相关的方法。</li>
<li>继承了AbstractMap，该方法实现Map操作的骨干逻辑。</li>
<li>实现了Cloneable接口，标记该类支持clone方法复制</li>
<li>实现了Serializable接口，标记该类支持序列化</li>
</ol>
<h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TreeMap()</td>
<td>使用键的自然排序构造一个新的空树映射。</td>
</tr>
<tr>
<td>TreeMap(Comparator&lt;? super K&gt; comparator)</td>
<td>构造一个新的空树映射，根据给定的比较器排序</td>
</tr>
<tr>
<td>TreeMap(Map&lt;? extends K,? extends V&gt; m)</td>
<td>构造一个新的树映射，包含与给定映射相同的映射，按照键的自然顺序排序。</td>
</tr>
<tr>
<td>TreeMap(Map&lt;? extends K,? extends V&gt; m)</td>
<td>构造一个新的树映射，包含相同的映射，并使用与指定排序映射相同的顺序。</td>
</tr>
</tbody></table>
<h5 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h5><h6 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个比较器，方便插入查找元素等操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//红黑树的根节点：每个节点是一个Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//集合元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//集合修改的记录</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>comparator是一个排序器，作为key的排序规则</li>
<li>root是红黑树的根节点，说明的确底层用的红黑树作为数据结构。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">     	<span class="comment">//左子树</span></span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">     	<span class="comment">//右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">     	<span class="comment">//父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">     	<span class="comment">//每个节点的颜色：红黑树属性。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> (key==<span class="literal">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">            <span class="type">int</span> <span class="variable">valueHash</span> <span class="operator">=</span> (value==<span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">            <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="查找get方法"><a href="#查找get方法" class="headerlink" title="查找get方法"></a>查找get方法</h6><p>TreeMap基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以 TreeMap 的查找操作流程和二叉查找树一致。二叉树的查找流程是这样的，先将目标值和根节点的值进行比较，如果目标值小于根节点的值，则再和根节点的左孩子进行比较。如果目标值大于根节点的值，则继续和根节点的右孩子比较。在查找过程中，如果目标值和二叉树中的某个节点值相等，则返回 true，否则返回 false。TreeMap 查找和此类似，只不过在 TreeMap 中，节点（Entry）存储的是键值对&lt;k,v&gt;。在查找过程中，比较的是键的大小，返回的是值，如果没找到，则返回null。TreeMap 中的查找方法是get。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">//调用 getEntry方法查找</span></span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p. value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    / 如果比较器为空，只是用key作为比较器查询</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    <span class="comment">// 取得root节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">   <span class="comment">//核心来了：从root节点开始查找，根据比较器判断是在左子树还是右子树</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key );</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p. left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p. right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="插入put方法"><a href="#插入put方法" class="headerlink" title="插入put方法"></a>插入put方法</h6><p>我们来看下关键的插入方法，在插入时候是如何维护key的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">       <span class="comment">// 1.如果根节点为 null，将新节点设为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"> </span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果root不为null，说明已存在元素 </span></span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">//如果比较器不为null 则使用比较器</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//找到元素的插入位置</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                 <span class="comment">//当前key小于节点key 向左子树查找</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                    <span class="comment">//当前key大于节点key 向右子树查找</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//相等的情况下 直接更新节点值</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//如果比较器为null 则使用默认比较器</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果key为null  则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">             <span class="comment">//找到元素的插入位置</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">      <span class="comment">//根据比较结果决定插入到左子树还是右子树</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">    <span class="comment">//保持红黑树性质，进行红黑树的旋转等操作</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>比较关键的就是fixAfterInsertion方法， 看懂这个方法需要你对红黑树的机制比较了解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新插入节点的颜色设置为红色</span></span><br><span class="line">    x. color = RED;</span><br><span class="line">    <span class="comment">// while循环，保证新插入节点x不是根节点或者新插入节点x的父节点不是红色（这两种情况不需要调整）</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x. parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">// 如果新插入节点x的父节点是祖父节点的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf (parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// 取得新插入节点x的叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf (parentOf(x)));</span><br><span class="line">            <span class="comment">// 如果新插入x的父节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                <span class="comment">// 将x的叔叔节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环</span></span><br><span class="line">                x = parentOf(parentOf (x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf( parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// 左旋父节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子</span></span><br><span class="line">                <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 右旋x的祖父节点</span></span><br><span class="line">                rotateRight( parentOf(parentOf (x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果新插入节点x的父节点是祖父节点的右孩子和上面的相似</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf (parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf (x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf( parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                rotateLeft( parentOf(parentOf (x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将根节点设置为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="删除remove方法"><a href="#删除remove方法" class="headerlink" title="删除remove方法"></a>删除remove方法</h6><p>删除remove是最复杂的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据key查找到对应的节点对象</span></span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 记录key对应的value，供返回使用</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p. value;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//元素个数减一</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 如果被删除的节点p的左孩子和右孩子都不为空，则查找其替代节</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="literal">null</span> &amp;&amp; p. right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找p的替代节点</span></span><br><span class="line">            Entry&lt;K,V&gt; s = successor (p);</span><br><span class="line">            p. key = s.key ;</span><br><span class="line">            p. value = s.value ;</span><br><span class="line">            p = s;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; replacement = (p. left != <span class="literal">null</span> ? p.left : p. right);</span><br><span class="line">        <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 将p的父节点拷贝给替代节点</span></span><br><span class="line">            replacement. parent = p.parent ;</span><br><span class="line">            <span class="comment">// 如果替代节点p的父节点为空，也就是p为跟节点，则将replacement设置为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="comment">// 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent. left)</span><br><span class="line">                p. parent.left   = replacement;</span><br><span class="line">            <span class="comment">// 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的右孩子</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p. parent.right = replacement;</span><br><span class="line">            <span class="comment">// 将替代节点p的left、right、parent的指针都指向空</span></span><br><span class="line">            p. left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 如果替代节点p的颜色是黑色，则需要调整红黑树以保持其平衡</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">            <span class="comment">// 如果要替代节点p没有父节点，代表p为根节点，直接删除即可</span></span><br><span class="line">            root = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果p的颜色是黑色，则调整红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(p);</span><br><span class="line">            <span class="comment">// 下面删除替代节点p</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 解除p的父节点对p的引用</span></span><br><span class="line">                <span class="keyword">if</span> (p == p.parent .left)</span><br><span class="line">                    p. parent.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent. right)</span><br><span class="line">                    p. parent.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 解除p对p父节点的引用</span></span><br><span class="line">                p. parent = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>TreeMap底层是红黑树，能够实现该Map集合有序~</p>
<p>如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较。否则，则使用Comparable的<code>compareTo(T o)</code>方法来比较。</p>
<ul>
<li>值得说明的是：如果使用的是<code>compareTo(T o)</code>方法来比较，<strong>key一定是不能为null</strong>，并且得实现了Comparable接口的。</li>
<li>即使是传入了Comparator对象，不用<code>compareTo(T o)</code>方法来比较，key<strong>也是</strong>不能为null的</li>
</ul>
<ol>
<li>由于底层是红黑树，那么时间复杂度可以保证为log(n)</li>
<li>key不能为null，为null为抛出NullPointException的</li>
<li>想要自定义比较，在构造方法中传入Comparator对象，否则使用key的自然排序来进行比较</li>
<li>TreeMap非同步的，想要同步可以使用Collections来进行封装</li>
</ol>
<h3 id="集合类如何选择"><a href="#集合类如何选择" class="headerlink" title="集合类如何选择"></a>集合类如何选择</h3><ol>
<li>先判断存储的类型（一组对象【单列】或一组键值对【双列】）</li>
<li>一组对象【单列】：collection接口<ol>
<li>允许重复：list    <ol>
<li>增删多：ListedList[底层维护了一个双向列表]</li>
<li>改查多：ArrayList[底层维护Object类型的可变数组]</li>
</ol>
</li>
<li>不允许重复：Set<ol>
<li>无序：HashSet[底层是HashMap，维护了一个哈希表，即（数组+链表+红黑树）]</li>
<li>排序：TreeSet</li>
<li>插入和取出顺序一致的；LinkedHashSet，维护数组+双向链表</li>
</ol>
</li>
</ol>
</li>
<li>一组键值对[双列]：Map<ol>
<li>键无序；HashMap[底层是哈希表，数组+链表+红黑树]</li>
<li>键排序：TreeMap</li>
<li>键插入和取出顺序一致，LinkedHashMap</li>
<li>读取文件 Porperties</li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Unfall</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://unfall.top/2022/11/15/Java_%E9%9B%86%E5%90%88/">https://unfall.top/2022/11/15/Java_%E9%9B%86%E5%90%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://unfall.top" target="_blank">Unfall_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/12/Java_IO%E6%B5%81/"><img class="prev-cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java_IO流</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/10/%E9%9B%86%E5%90%88%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img class="next-cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20221110201439.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">集合中常见的数据结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/" title="JAVA中的与和或（||，|，&&，&）"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">JAVA中的与和或（||，|，&&，&）</div></div></a></div><div><a href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">Java_动态绑定机制</div></div></a></div><div><a href="/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/" title="SDK和API的区别（转)"><img class="cover" src="https://img2.baidu.com/it/u=2890406970,1556514476&fm=253&fmt=auto&app=138&f=JPEG?w=898&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">SDK和API的区别（转)</div></div></a></div><div><a href="/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-28</div><div class="title">网络编程</div></div></a></div><div><a href="/2022/11/10/%E9%9B%86%E5%90%88%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="集合中常见的数据结构"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20221110201439.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">集合中常见的数据结构</div></div></a></div><div><a href="/2023/03/03/Cookie-Session/" title="JavaWeb_Cookie&Session"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">JavaWeb_Cookie&Session</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/03/08/bcZYpd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Unfall</div><div class="author-info__description">堂前种新树，花开已十年</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Unfalll"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:3201864395@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3201864395&amp;site=qq&amp;menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="https://steamcommunity.com/id/3201864395/" target="_blank" title=""><i class="fab fa-steam-symbol"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=295405999" target="_blank" title=""><i class="fas fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">顺其自然 无为而治</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text">集合的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">2.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">接口介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">2.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#List%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">List的继承、实现关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList"><span class="toc-number">2.2.4.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">主要成员变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">扩容机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Java%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8A%A5%E9%94%99%E6%9C%BA%E5%88%B6ConcurrentModificationException%EF%BC%9A"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">Java容器的快速报错机制ConcurrentModificationException：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">ArrayList扩容机制</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector"><span class="toc-number">2.2.5.</span> <span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Vector-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">Vector 扩容机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">ArrayList和Vector比较</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList"><span class="toc-number">2.2.6.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">使用情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">链表</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">什么是链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">1.单向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">2.单向循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">3.双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">4.双向循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">源码解析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Node"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">Node</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">4.0.0.5.</span> <span class="toc-text">重要方法解析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.0.0.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">4.0.0.7.</span> <span class="toc-text">补充说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList%E5%92%8CLinkerList%E6%AF%94%E8%BE%83"><span class="toc-number">4.0.0.8.</span> <span class="toc-text">ArrayList和LinkerList比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">4.1.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet"><span class="toc-number">4.1.1.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">HashSet底层机制说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%AE%80%E5%8D%95%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">模拟简单数组+链表结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90HashSet%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-hash-equals"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">分析HashSet的添加元素底层是如何实现(hash()+equals())</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90HashSet%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E8%BD%AC%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.1.6.</span> <span class="toc-text">分析HashSet的扩容和转成红黑树的机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.1.7.</span> <span class="toc-text">实现总结</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-number">4.1.1.8.</span> <span class="toc-text">源码解析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.1.9.</span> <span class="toc-text">遍历方式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">4.1.2.</span> <span class="toc-text">LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedHashSet%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">LinkedHashSet实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedHashSet%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">LinkedHashSet的源码解读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkHashSet%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">LinkHashSet原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-LinkedHashSet-%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E4%B8%8E-HashSet-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">4.1.2.5.</span> <span class="toc-text">说说你对 LinkedHashSet 的理解及其与 HashSet 的关系？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeSet"><span class="toc-number">4.1.3.</span> <span class="toc-text">TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-1"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TreeSet%E7%9A%84%E6%9C%89%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">TreeSet的有序的实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">List和Set的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">5.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">map介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">Map接口实现类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="toc-number">5.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E5%9B%BE"><span class="toc-number">5.4.</span> <span class="toc-text">集合继承图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">5.5.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text">什么是哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.5.2.</span> <span class="toc-text">HashMap的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#put%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">put操作的实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#map-get-k-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">map.get(k)实现原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#hash%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.2.3.</span> <span class="toc-text">hash函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#addEntry%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.2.4.</span> <span class="toc-text">addEntry的实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.3.</span> <span class="toc-text">HashMap的扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">什么时候才需要扩容</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#hashMap%E6%89%A9%E5%AE%B9"><span class="toc-number">5.5.3.2.</span> <span class="toc-text">hashMap扩容</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82%EF%BC%9F"><span class="toc-number">5.5.4.</span> <span class="toc-text">为何HashMap的数组长度一定是2的次幂？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E9%9C%80%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95"><span class="toc-number">5.5.5.</span> <span class="toc-text">重写equals方法需同时重写hashCode方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-8%E4%B8%ADHashMap%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">5.5.6.</span> <span class="toc-text">JDK1.8中HashMap的性能优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkHashMap"><span class="toc-number">5.6.</span> <span class="toc-text">LinkHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8JDK%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.6.2.</span> <span class="toc-text">在JDK中的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-2"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%885%E7%A7%8D%EF%BC%89"><span class="toc-number">5.6.2.3.</span> <span class="toc-text">构造方法（5种）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#init-%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.2.4.</span> <span class="toc-text">init()方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">5.6.2.5.</span> <span class="toc-text">基本数据结构：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%AD%98%E5%8F%96"><span class="toc-number">5.6.3.</span> <span class="toc-text">快速存取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">5.6.4.</span> <span class="toc-text">有序性原理分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-number">5.7.</span> <span class="toc-text">HashTable</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">5.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-number">5.7.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-5"><span class="toc-number">5.7.4.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.4.1.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.4.2.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rehash%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.4.3.</span> <span class="toc-text">rehash扩容方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.4.4.</span> <span class="toc-text">remove方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-1"><span class="toc-number">5.7.5.</span> <span class="toc-text">扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.6.</span> <span class="toc-text">HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Properties%E4%BD%9C%E4%B8%BA%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.7.</span> <span class="toc-text">Properties作为集合的特有方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.8.</span> <span class="toc-text">所有方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">5.8.</span> <span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">5.8.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2"><span class="toc-number">5.8.3.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-2"><span class="toc-number">5.8.3.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E6%89%BEget%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.3.2.</span> <span class="toc-text">查找get方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5put%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.3.3.</span> <span class="toc-text">插入put方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4remove%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.3.4.</span> <span class="toc-text">删除remove方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.8.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">6.</span> <span class="toc-text">集合类如何选择</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/23/%E5%89%8D%E7%AB%AF-HTML4/" title="前端_HTML4"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/v2-e7bd20c3911fa55f2aed5e416cf06211_250x0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端_HTML4"/></a><div class="content"><a class="title" href="/2023/11/23/%E5%89%8D%E7%AB%AF-HTML4/" title="前端_HTML4">前端_HTML4</a><time datetime="2023-11-23T13:44:56.000Z" title="发表于 2023-11-23 21:44:56">2023-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/03/Java-Http/" title="Java_Http"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_Http"/></a><div class="content"><a class="title" href="/2023/03/03/Java-Http/" title="Java_Http">Java_Http</a><time datetime="2023-03-03T09:10:01.000Z" title="发表于 2023-03-03 17:10:01">2023-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/03/Cookie-Session/" title="JavaWeb_Cookie&amp;Session"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb_Cookie&amp;Session"/></a><div class="content"><a class="title" href="/2023/03/03/Cookie-Session/" title="JavaWeb_Cookie&amp;Session">JavaWeb_Cookie&amp;Session</a><time datetime="2023-03-03T08:04:32.000Z" title="发表于 2023-03-03 16:04:32">2023-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/22/Java-Servlet/" title="JavaWeb_Servlet"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb_Servlet"/></a><div class="content"><a class="title" href="/2023/02/22/Java-Servlet/" title="JavaWeb_Servlet">JavaWeb_Servlet</a><time datetime="2023-02-22T09:47:41.000Z" title="发表于 2023-02-22 17:47:41">2023-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/13/Java-JDBC/" title="Java_JDBC"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_JDBC"/></a><div class="content"><a class="title" href="/2023/02/13/Java-JDBC/" title="Java_JDBC">Java_JDBC</a><time datetime="2023-02-13T11:07:22.000Z" title="发表于 2023-02-13 19:07:22">2023-02-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Unfall</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">愿世间美好与你环环相扣</div></div><div class="container" id="jsi-flying-fish-container"><script src="js/fish.js"></script></div><style>   @media only screen and (max-width: 767px){
   #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MBASlFAQqPMdjRJ7U5EeKDAP-MdYXbMMI',
      appKey: 'xrU9dH0DPN2JDUfDYKDpxoXQ',
      placeholder: '昵称输入QQ号自动获取头像邮箱',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://unfall.top/2022/11/15/Java_%E9%9B%86%E5%90%88/'
    this.page.identifier = '2022/11/15/Java_集合/'
    this.page.title = 'Java_集合'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js"></script><canvas id="universe"></canvas><script defer src="/js/myjs.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>