<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>八大排序 | Unfall_Blog</title><meta name="keywords" content="Java"><meta name="author" content="Unfall"><meta name="copyright" content="Unfall"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：   直接插入排序 希尔排序 简单选择排序 堆排序 冒泡排序 快速排序 归并排序 基数排序  这八大排序算法的实现可以参考Github：SortAlgorithms，其中也包括了排序测试模块[Test.java]和排序算法对比模块[Bench.java]，可以试运行。 它们都属于内部排序，也就是只考虑数据量较小仅">
<meta property="og:type" content="article">
<meta property="og:title" content="八大排序">
<meta property="og:url" content="https://unfall.top/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Unfall_Blog">
<meta property="og:description" content="概述对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：   直接插入排序 希尔排序 简单选择排序 堆排序 冒泡排序 快速排序 归并排序 基数排序  这八大排序算法的实现可以参考Github：SortAlgorithms，其中也包括了排序测试模块[Test.java]和排序算法对比模块[Bench.java]，可以试运行。 它们都属于内部排序，也就是只考虑数据量较小仅">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png">
<meta property="article:published_time" content="2022-05-15T06:23:34.000Z">
<meta property="article:modified_time" content="2022-10-28T03:47:35.394Z">
<meta property="article:author" content="Unfall">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png"><link rel="shortcut icon" href="/img/cat.png"><link rel="canonical" href="https://unfall.top/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八大排序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-28 11:47:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/03/08/bcZYpd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Unfall_Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">八大排序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-15T06:23:34.000Z" title="发表于 2022-05-15 14:23:34">2022-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-28T03:47:35.394Z" title="更新于 2022-10-28 11:47:35">2022-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="八大排序"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/big-o.png" alt="img"></a></p>
<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
<li>简单选择排序</li>
<li>堆排序</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<p>这八大排序算法的实现可以参考<a target="_blank" rel="noopener" href="https://github.com/iTimeTraveler/SortAlgorithms">Github：<strong>SortAlgorithms</strong></a>，其中也包括了排序测试模块[<a target="_blank" rel="noopener" href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java">Test.java]</a>和排序算法对比模块[<a target="_blank" rel="noopener" href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java">Bench.java]</a>，可以试运行。</p>
<p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p>
<p>⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪内部排序⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序{内部排序{插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序</p>
<h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr>
<p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p>
<p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p>
<h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p>
<h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/insert-sort.gif" alt="直接插入排序演示"></a>直接插入排序演示</p>
<p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p>
<p>如果<strong>比较操作</strong>的代价比<strong>交换操作</strong>大的话，可以采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95">二分查找法</a>来减少<em>比较操作</em>的数目。可以认为是<strong>插入排序</strong>的一个变种，称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&action=edit&redlink=1">二分查找插入排序</a>。</p>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line"> * 5. 将新元素插入到该位置后</span><br><span class="line"> * 6. 重复步骤2~5</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i = 1; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        int temp = arr[i];    // 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line">        for( int j = i; j &gt;= 0; j-- ) &#123;</span><br><span class="line">            if( j &gt; 0 &amp;&amp; arr[j-1] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-1];    // 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span><br><span class="line">                System.out.println(&quot;Temping:  &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将新元素插入到该位置后</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交换次数较多的实现</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i=0; i&lt;arr.length-1; i++ ) &#123;</span><br><span class="line">        for( int j=i+1; j&gt;0; j-- ) &#123;</span><br><span class="line">            if( arr[j-1] &lt;= arr[j] )</span><br><span class="line">                break;</span><br><span class="line">            int temp = arr[j];      //交换操作</span><br><span class="line">            arr[j] = arr[j-1];</span><br><span class="line">            arr[j-1] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接插入排序复杂度如下：</p>
<ul>
<li>最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1n−1；移动次数(RMN)为00。则对应的时间复杂度为O(n)O(n)。</li>
<li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22 ; 移动次数(RMN)为：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22。则对应的时间复杂度为O(n2)O(n2)。</li>
<li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n22n22，因此，<strong>直接插入排序的平均时间复杂度</strong>为O(n2)O(n2)。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p>
<h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr>
<blockquote>
<p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
</blockquote>
<p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p>
<p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/shell-sort.jpg" alt="img"></a></p>
<p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap&#x3D;1时，利用直接插入，完成排序。</p>
<p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>。</p>
<h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shellSort(int[] arr)&#123;</span><br><span class="line">    int gap = arr.length / 2;</span><br><span class="line">    for (; gap &gt; 0; gap /= 2) &#123;      //不断缩小gap，直到1为止</span><br><span class="line">        for (int j = 0; (j+gap) &lt; arr.length; j++)&#123;     //使用当前gap进行组内插入排序</span><br><span class="line">            for(int k = 0; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                if(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    int temp = arr[k+gap];      //交换操作</span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(&quot;    Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>①. 第一层for循环表示一共有多少个增量。增量的序列的个数，就是希尔排序的趟数。上面的增量序列为： <code>arr.length/2, arr.length/2/2, arr.length/2/2/2, .... 2, 1</code><br>②. 里层的两个for循环，实际上就是以一个gap拆分为一组的<strong>组内插入排序</strong>。</p>
<p>下面是维基百科官方实现，大家注意gap步长取值部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序（Wiki官方版）</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shell_sort(int[] arr) &#123;</span><br><span class="line">    int gap = 1, i, j, len = arr.length;</span><br><span class="line">    int temp;</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;      // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span><br><span class="line">    for (; gap &gt; 0; gap /= 3) &#123;</span><br><span class="line">        for (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是希尔排序复杂度:</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(nlog2 n)</td>
<td align="left">O(nlog2 n)</td>
<td align="left">O(nlog2 n)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></a>选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p>
</blockquote>
<p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>
<h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p>
<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>
<h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</span><br><span class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</span><br><span class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void selectionSort(int[] arr)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.length-1; i++)&#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for(int j = i+1; j &lt; arr.length; j++)&#123;    //选出之后待排序中值最小的位置</span><br><span class="line">            if(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min != i)&#123;</span><br><span class="line">            int temp = arr[min];      //交换操作</span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是选择排序复杂度:</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²&#x2F;2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p>
<h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr>
<blockquote>
<p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p>
</blockquote>
<p>堆的定义如下：nn个元素的序列 {k1,k2,⋅⋅⋅,kn}{k1,k2,···,kn} 当且仅当满足下关系时，称之为堆。</p>
<p>{kiki⩽k2i⩽k2i+1或{kiki⩾k2i⩾k2i+1(i&#x3D;1,2,⋅⋅⋅,⌊n2⌋){ki⩽k2iki⩽k2i+1或{ki⩾k2iki⩾k2i+1(i&#x3D;1,2,···,⌊n2⌋)</p>
<p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p>
<h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>
<h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列K[1..n]K[1..n]建成一个大顶堆, 那么此时第一个元素K1K1最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录K1K1 (即堆顶, 第一个元素)和无序区的最后一个记录 KnKn 交换, 由此得到新的无序区K[1..n−1]K[1..n−1]和有序区K[n]K[n], 且满足K[1..n−1].keys⩽K[n].keyK[1..n−1].keys⩽K[n].key<br>③. 交换K1K1 和 KnKn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p>
<p>动图效果如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></a>堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p>
<h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>
<p>总结起来就是定义了以下几种操作：</p>
<ul>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p>对于堆节点的访问：</p>
<ul>
<li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li>
<li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li>
<li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</span><br><span class="line"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</span><br><span class="line"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void heapSort(int[] arr)&#123;</span><br><span class="line">    for(int i = arr.length; i &gt; 0; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        int temp = arr[0];      //堆顶元素(第一个元素)与Kn交换</span><br><span class="line">        arr[0] = arr[i-1];</span><br><span class="line">        arr[i-1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void max_heapify(int[] arr, int limit)&#123;</span><br><span class="line">    if(arr.length &lt;= 0 || arr.length &lt; limit) return;</span><br><span class="line">    int parentIdx = limit / 2;</span><br><span class="line"></span><br><span class="line">    for(; parentIdx &gt;= 0; parentIdx--)&#123;</span><br><span class="line">        if(parentIdx * 2 &gt;= limit)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = parentIdx * 2;       //左子节点位置</span><br><span class="line">        int right = (left + 1) &gt;= limit ? left : (left + 1);    //右子节点位置，如果没有右节点，默认为左节点位置</span><br><span class="line"></span><br><span class="line">        int maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        if(arr[maxChildId] &gt; arr[parentIdx])&#123;   //交换父节点与左右子节点中的最大值</span><br><span class="line">            int temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Max_Heapify: &quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 &#x3D;&#x3D; Math.floor(x&#x2F;2) .</p>
</blockquote>
<p>以上,<br>①. 建立堆的过程, 从length&#x2F;2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(nlog2n)O(nlog2⁡n)</td>
<td align="left">O(nlog2n)O(nlog2⁡n)</td>
<td align="left">O(nlog2n)O(nlog2⁡n)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p>
<h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort02.gif" alt="冒泡排序的思想"></a>冒泡排序的思想</p>
<blockquote>
<p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort.gif" alt="冒泡排序演示"></a>冒泡排序演示</p>
<h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p>
<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>
<h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><br><span class="line"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><br><span class="line"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">    for (int i = arr.length; i &gt; 0; i--) &#123;      //外层循环移动游标</span><br><span class="line">        for(int j = 0; j &lt; i &amp;&amp; (j+1) &lt; i; j++)&#123;    //内层循环遍历游标及之后(或之前)的元素</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是冒泡排序算法复杂度:</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²&#x2F;2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p>
<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>
<h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr>
<p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p>
<h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p>
<p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></a>使用快速排序法对一列数字进行排序的过程</p>
<h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p>
<p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/quick-sort09.gif" alt="快速排序演示"></a>快速排序演示</p>
<h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p>
<p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></a>快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> * @param low   左边界</span><br><span class="line"> * @param high  右边界</span><br><span class="line"> */</span><br><span class="line">public static void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    if(low &gt;= high) return;</span><br><span class="line">    int left = low;</span><br><span class="line">    int right = high;</span><br><span class="line"></span><br><span class="line">    int temp = arr[left];   //挖坑1：保存基准的值</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-1);</span><br><span class="line">    quickSort(arr, left+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p>
<p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（非递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void quickSortByStack(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    //初始状态的左右指针入栈</span><br><span class="line">    stack.push(0);</span><br><span class="line">    stack.push(arr.length - 1);</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        int high = stack.pop();     //出栈进行划分</span><br><span class="line">        int low = stack.pop();</span><br><span class="line"></span><br><span class="line">        int pivotIdx = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        //保存中间变量</span><br><span class="line">        if(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= 0)&#123;</span><br><span class="line">            stack.push(pivotIdx + 1);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int partition(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return -1;</span><br><span class="line">    if(low &gt;= high) return -1;</span><br><span class="line">    int l = low;</span><br><span class="line">    int r = high;</span><br><span class="line"></span><br><span class="line">    int pivot = arr[l];    //挖坑1：保存基准的值</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<p>以下是快速排序算法复杂度:</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)（原地分区递归版）</td>
</tr>
</tbody></table>
<p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p>
<p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p>
<h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort_sample.jpg" alt="img"></a></p>
</blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="这个图很有概括性，来自维基"></a>这个图很有概括性，来自维基</p>
<h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p>
<ul>
<li>自上而下的递归</li>
<li>自下而上的迭代</li>
</ul>
<p><strong>一、递归法</strong>（假设序列共有n个元素）：</p>
<p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n&#x2F;2)个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 floor(n&#x2F;4)个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort.gif" alt="img"></a></p>
<p><strong>二、迭代法</strong></p>
<p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p>
<ul>
<li>分解：将序列每次折半拆分</li>
<li>合并：将划分后的序列段两两排序合并</li>
</ul>
<p>因此，归并排序实际上就是两个操作，拆分+合并</p>
<p><strong>如何合并？</strong></p>
<p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p>
<p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p>
<p><strong>如何分解？</strong></p>
<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<p>这里我写了递归算法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 归并排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span><br><span class="line"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span><br><span class="line"> * ③. 重复步骤②，直到所有元素排序完毕。</span><br><span class="line"> * @param arr	 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static int[] mergingSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line">    int num = arr.length &gt;&gt; 1;</span><br><span class="line">    int[] leftArr = Arrays.copyOfRange(arr, 0, num);</span><br><span class="line">    int[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(&quot;split two array: &quot; + Arrays.toString(leftArr) + &quot; And &quot; + Arrays.toString(rightArr));</span><br><span class="line">    return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      //不断拆分为最小单元，再排序合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] mergeTwoArray(int[] arr1, int[] arr2)&#123;</span><br><span class="line">    int i = 0, j = 0, k = 0;</span><br><span class="line">    int[] result = new int[arr1.length + arr2.length];  //申请额外的空间存储合并之后的数组</span><br><span class="line">    while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      //选取两个序列中的较小值放入新数组</span><br><span class="line">        if(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; arr1.length)&#123;     //序列1中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; arr2.length)&#123;     //序列2中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Merging: &quot; + Arrays.toString(result));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p>
<p>以下是归并排序算法复杂度:</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(n)</td>
</tr>
</tbody></table>
<p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p>
<blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr>
<p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p>
<p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<ul>
<li><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</li>
<li><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radix-sort_sample.gif" alt="基数排序LSD动图演示"></a>基数排序LSD动图演示</p>
<h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p>
<p>①. 取得数组中的最大数，并取得位数；<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p>
<ul>
<li><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</li>
<li><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序（LSD 从低位开始）</span><br><span class="line"> *</span><br><span class="line"> * 基数排序适用于：</span><br><span class="line"> *  (1)数据范围较小，建议在小于1000</span><br><span class="line"> *  (2)每个数值都要大于等于0</span><br><span class="line"> *</span><br><span class="line"> * ①. 取得数组中的最大数，并取得位数；</span><br><span class="line"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</span><br><span class="line"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span><br><span class="line"> * @param arr	 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">    //取得数组中的最大数，并取得位数</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(max &lt; arr[i])&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxDigit = 1;</span><br><span class="line">    while(max / 10 &gt; 0)&#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;maxDigit: &quot; + maxDigit);</span><br><span class="line"></span><br><span class="line">    //申请一个桶空间</span><br><span class="line">    int[][] buckets = new int[10][arr.length];</span><br><span class="line">    int base = 10;</span><br><span class="line"></span><br><span class="line">    //从低位到高位，对每一位遍历，将所有元素分配到桶中</span><br><span class="line">    for(int i = 0; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        int[] bktLen = new int[10];        //存储各个桶中存储元素的数量</span><br><span class="line">        </span><br><span class="line">        //分配：将所有元素分配到桶中</span><br><span class="line">        for(int j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            int whichBucket = (arr[j] % base) / (base / 10);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int b = 0; b &lt; buckets.length; b++)&#123;</span><br><span class="line">            for(int p = 0; p &lt; bktLen[b]; p++)&#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">        base *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是基数排序算法复杂度，其中k为最大数的位数：</p>
<table>
<thead>
<tr>
<th align="left">平均时间复杂度</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">O(d*(n+r))</td>
<td align="left">O(d*(n+r))</td>
<td align="left">O(d*(n+r))</td>
<td align="left">O(n+r)</td>
</tr>
</tbody></table>
<p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p>
<p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p>
<p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>各种排序性能对比如下，有些排序未详细介绍，暂且放到这里。实例测试结果可以看这里：<a target="_blank" rel="noopener" href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md"><strong>八大排序算法耗时对比</strong></a> 。</p>
<table>
<thead>
<tr>
<th align="left">排序类型</th>
<th align="left">平均情况</th>
<th align="left">最好情况</th>
<th align="left">最坏情况</th>
<th align="left">辅助空间</th>
<th align="left">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">选择排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">直接插入排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">折半插入排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td align="left">O(n^1.3)</td>
<td align="left">O(nlogn)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">归并排序</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(n)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">快速排序</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(n²)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(nlog₂n)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">计数排序</td>
<td align="left">O(n+k)</td>
<td align="left">O(n+k)</td>
<td align="left">O(n+k)</td>
<td align="left">O(k)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">桶排序</td>
<td align="left">O(n+k)</td>
<td align="left">O(n+k)</td>
<td align="left">O(n²)</td>
<td align="left">O(n+k)</td>
<td align="left">(不)稳定</td>
</tr>
<tr>
<td align="left">基数排序</td>
<td align="left">O(d(n+k))</td>
<td align="left">O(d(n+k))</td>
<td align="left">O(d(n+kd))</td>
<td align="left">O(n+kd)</td>
<td align="left">稳定</td>
</tr>
</tbody></table>
<p>从时间复杂度来说：</p>
<p>(1). 平方阶O(n²)排序：**<code>各类简单排序：直接插入、直接选择和冒泡排序</code>**；</p>
<p>(2). 线性对数阶O(nlog₂n)排序：**<code>快速排序、堆排序和归并排序</code>**；</p>
<p>(3). O(n1+§))排序，§是介于0和1之间的常数：**<code>希尔排序</code>**</p>
<p>(4). 线性阶O(n)排序：**<code>基数排序，此外还有桶、箱排序</code><strong>。<br>　　<br>到此，很多人会注意到</strong>基数排序**的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/gallery/sort-algorithms/radixsort-comparison.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radixsort-comparison.jpg" alt="img"></a></p>
<p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p>
<h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p>
<ol>
<li>计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数</li>
<li>基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值</li>
<li>桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li>
</ol>
<p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O( nlgn)</strong> 。参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24516934">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li>
<li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）</li>
<li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/2016-07-15_%25E5%25B8%25B8%25E7%2594%25A8%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Unfall</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://unfall.top/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/">https://unfall.top/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://unfall.top" target="_blank">Unfall_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/15/JavaSE/"><img class="prev-cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaSE</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/"><img class="next-cover" src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20220501010704.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Markdown文档常用写法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/" title="JAVA中的与和或（||，|，&&，&）"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">JAVA中的与和或（||，|，&&，&）</div></div></a></div><div><a href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">Java_动态绑定机制</div></div></a></div><div><a href="/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/" title="SDK和API的区别（转)"><img class="cover" src="https://img2.baidu.com/it/u=2890406970,1556514476&fm=253&fmt=auto&app=138&f=JPEG?w=898&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">SDK和API的区别（转)</div></div></a></div><div><a href="/2022/11/10/%E9%9B%86%E5%90%88%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="集合中常见的数据结构"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20221110201439.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">集合中常见的数据结构</div></div></a></div><div><a href="/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-28</div><div class="title">网络编程</div></div></a></div><div><a href="/2023/03/03/Cookie-Session/" title="JavaWeb_Cookie&Session"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">JavaWeb_Cookie&Session</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/03/08/bcZYpd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Unfall</div><div class="author-info__description">堂前种新树，花开已十年</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Unfalll"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:3201864395@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3201864395&amp;site=qq&amp;menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="https://steamcommunity.com/id/3201864395/" target="_blank" title=""><i class="fab fa-steam-symbol"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=295405999" target="_blank" title=""><i class="fas fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">顺其自然 无为而治</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">一、直接插入排序（Insertion Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell-Sort%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">二、希尔排序（Shell Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1"><span class="toc-number">3.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">3.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-Sort%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">三、选择排序（Selection Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2"><span class="toc-number">4.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">4.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">四、堆排序（Heap Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-3"><span class="toc-number">5.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">5.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">五、冒泡排序（Bubble Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-4"><span class="toc-number">6.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">6.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">6.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">六、快速排序（Quick Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-5"><span class="toc-number">7.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">7.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">7.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merging-Sort%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">七、归并排序（Merging Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-6"><span class="toc-number">8.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">8.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">8.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">八、基数排序（Radix Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-7"><span class="toc-number">9.1.</span> <span class="toc-text">1、基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-7"><span class="toc-number">9.2.</span> <span class="toc-text">2、算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">9.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9E%81%E9%99%90"><span class="toc-number">10.1.</span> <span class="toc-text">时间复杂度极限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">10.2.</span> <span class="toc-text">说明</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/03/Java-Http/" title="Java_Http"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_Http"/></a><div class="content"><a class="title" href="/2023/03/03/Java-Http/" title="Java_Http">Java_Http</a><time datetime="2023-03-03T09:10:01.000Z" title="发表于 2023-03-03 17:10:01">2023-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/03/Cookie-Session/" title="JavaWeb_Cookie&amp;Session"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb_Cookie&amp;Session"/></a><div class="content"><a class="title" href="/2023/03/03/Cookie-Session/" title="JavaWeb_Cookie&amp;Session">JavaWeb_Cookie&amp;Session</a><time datetime="2023-03-03T08:04:32.000Z" title="发表于 2023-03-03 16:04:32">2023-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/22/Java-Servlet/" title="JavaWeb_Servlet"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb_Servlet"/></a><div class="content"><a class="title" href="/2023/02/22/Java-Servlet/" title="JavaWeb_Servlet">JavaWeb_Servlet</a><time datetime="2023-02-22T09:47:41.000Z" title="发表于 2023-02-22 17:47:41">2023-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/13/Java-JDBC/" title="Java_JDBC"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_JDBC"/></a><div class="content"><a class="title" href="/2023/02/13/Java-JDBC/" title="Java_JDBC">Java_JDBC</a><time datetime="2023-02-13T11:07:22.000Z" title="发表于 2023-02-13 19:07:22">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_动态绑定机制"/></a><div class="content"><a class="title" href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制">Java_动态绑定机制</a><time datetime="2023-02-09T11:43:03.000Z" title="发表于 2023-02-09 19:43:03">2023-02-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Unfall</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">愿世间美好与你环环相扣</div></div><div class="container" id="jsi-flying-fish-container"><script src="js/fish.js"></script></div><style>   @media only screen and (max-width: 767px){
   #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MBASlFAQqPMdjRJ7U5EeKDAP-MdYXbMMI',
      appKey: 'xrU9dH0DPN2JDUfDYKDpxoXQ',
      placeholder: '昵称输入QQ号自动获取头像邮箱',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://unfall.top/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/'
    this.page.identifier = '2022/05/15/八大排序/'
    this.page.title = '八大排序'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js"></script><canvas id="universe"></canvas><script defer src="/js/myjs.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>