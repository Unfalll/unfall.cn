<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java_oop | Unfall_Blog</title><meta name="keywords" content="Java"><meta name="author" content="Unfall"><meta name="copyright" content="Unfall"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是面向对象面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。 在面向对象程序编程里，计算机程序会">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_oop">
<meta property="og:url" content="https://unfall.top/2022/05/15/Java-oop/index.html">
<meta property="og:site_name" content="Unfall_Blog">
<meta property="og:description" content="什么是面向对象面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。 在面向对象程序编程里，计算机程序会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png">
<meta property="article:published_time" content="2022-05-15T09:22:05.000Z">
<meta property="article:modified_time" content="2022-11-10T15:21:23.400Z">
<meta property="article:author" content="Unfall">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png"><link rel="shortcut icon" href="/img/cat.png"><link rel="canonical" href="https://unfall.top/2022/05/15/Java-oop/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java_oop',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-10 23:21:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/03/08/bcZYpd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Unfall_Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java_oop</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-15T09:22:05.000Z" title="发表于 2022-05-15 17:22:05">2022-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-10T15:21:23.400Z" title="更新于 2022-11-10 23:21:23">2022-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>92分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java_oop"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p>它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。</p>
<p>在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
<p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。</p>
<p>当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。</p>
<p>在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称OOD）方面的知识。</p>
<p>许多流行的编程语言是面向对象的,它们的风格就是会透由对象来创出实例。</p>
<p>重要的面向对象编程语言包含Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP等。</p>
<h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>属性：对象数据的描述<br>方法：对象的行为<br>构造方法：用于实例化对象<br>内部类：在类中声明的类（inner class）<br>块：分静态代码块与实例语句块。</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Java是一门面向对象的编程语言，理解Java，首先要理解类与对象这两个概念。</p>
<ul>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
<li>对象：对象：对象是类的一个实例。</li>
</ul>
<p>综上所述，看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br>对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p>
<p>类的定义：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220826114425837.png" alt="image-20220826114425837"></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例说明：</p>
<ul>
<li>public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符会在面向对象—封装中详细介绍</li>
<li>class 是定义类的关键字</li>
<li>Admin 是类名称</li>
</ul>
<p>对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。<br>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p>
<p>声明：声明一个对象，包括对象名称和对象类型。<br>实例化：使用关键字new来创建一个对象。<br>初始化：使用new创建对象时，会调用构造方法初始化对象。<br>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Admin admin=<span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br></pre></td></tr></table></figure>

<p>类和对象的内存分配机制</p>
<p>Java内存的结构分析</p>
<ol>
<li>栈：一般存放基本数据类型（局部变量）</li>
<li>堆：存放对象（Person p，数组）等</li>
<li>方法区：常量池（常量，比如字符串），类加载信息</li>
</ol>
<p>Java创建对象的流程简要分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = “jack”;</span><br><span class="line">p.age = <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>、先加载 Person 类信息(属性和方法信息, 只会加载一次)</span><br><span class="line">	<span class="number">2</span>、在堆中分配空间, 进行默认初始化(看规则)</span><br><span class="line">	<span class="number">3</span>、把地址赋给 p , p 就指向对象</span><br><span class="line">	<span class="number">4</span>、进行指定初始化， 比如 p.name =”jack” p.age = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827132411595.png" alt="image-20220827132411595"></p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827132444738.png" alt="image-20220827132444738"></p>
<p>Java创建对象的流程简单分析</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827141004875.png" alt="image-20220827141004875"></p>
<ol>
<li>先加载person类信息（属性信息，方法信息，只会加载一次）</li>
<li>在堆中分配空间，执行默认初始化</li>
<li>在栈中分配一个空间存放对象，该对象指向堆空间</li>
<li>给属性赋初始值（如：p.name &#x3D; “jack”; p.age &#x3D; 10）</li>
</ol>
<h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><p>1、类属性的定义</p>
<p>类的属性，是用来描述这一类的相关信息，例如管理员是一类人的总称，那么管理员就有自己的属性，大概包括姓名，年龄，用户名，密码等。定义类的属性通过声明变量的形式来完成。每个属性都有它对应的访问修饰符、数据类型、变量名。<br>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String loginName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String password;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ps：定义类的属性可以不为变量赋初始化值，属性的初始值会在类对象被实例化时进行赋值</strong></p>
<p>2、类属性的分类：</p>
<p>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。<br>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种。</p>
<p>3、this关键字</p>
<p>当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是 this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this，并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。在本类中，方法内可以通过this访问累的非静态变量和方法。</p>
<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>1、类方法的定义<br>Java语言中的“方法”（Method）在其他语言当中也可能被称为“函数”（Function）。对于一些复杂的代码逻辑，如果希望重复使用这些代码，并且做到“随时任意使用”，那么就可以将这些代码放在一个大括号“{}”当中，并且起一个名字。使用代码的时候，直接找到名字调用即可。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220826114941053.png" alt="image-20220826114941053"></p>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li>访问修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法会被谁访问到。</li>
<li>方法修饰符：用来修饰特殊方法的修饰符。</li>
<li>返回值类型：方法可能会返回值。return ValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。（构造方法除外）</li>
<li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>方法参数：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li>方法体：方法体包含具体的语句，定义该方法的功能，使用大括号作为方法范围。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>方法：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol>
<li>程序开始执行的时候是先执行main方法。因为main方法是一个入口。</li>
<li>在java语言中所有的方法体中的代码都必须遵循自上而下的顺序依次逐行执行。</li>
<li>main方法不需要程序员手动调用，是由JVM调用的。但是除了main方法之外其他的方法，都需要程序员手动调用。</li>
<li>方法只有调用的时候才会执行，方法不调用是不会执行的。</li>
<li>方法定义在类体当中。方法定义的先后顺序没有关系</li>
<li>方法中的变量都属于局部变量。方法结束之后，局部变量占用的内存会自动释放</li>
</ol>
<h3 id="方法定义，语法机制"><a href="#方法定义，语法机制" class="headerlink" title="方法定义，语法机制"></a>方法定义，语法机制</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">			方法体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>[] 符号叫做中括号，以上中括号[ ]里面的内容表示不是必须的，是<code>可选</code>的。</li>
<li>方法体由Java语句构成。</li>
<li>方法定义之后需要去调用，不调用是不会执行的。</li>
</ol>
<h4 id="修饰符列表"><a href="#修饰符列表" class="headerlink" title="修饰符列表"></a>修饰符列表</h4><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><ol>
<li>返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String…</li>
<li>什么是返回值？返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	<span class="comment">// 调用a方法</span></span><br><span class="line">	a();</span><br><span class="line">       <span class="comment">//如果a方法执行结束之后有返回值，这个返回值返回给main了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。</p>
<ol start="3">
<li><p>当一个方法执行结束不返回任何值的时候，返回值 类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。</p>
</li>
<li><p>如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用”return 值;”这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句,那么编译器会报错。<br>return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。</p>
</li>
<li><p>只要有“return”关键字的语句执行，当前方法必然结束。<br>return只要执行，当前所在的方法结束，记住：不是整个程序结束。</p>
</li>
<li><p>如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前 方法的。</p>
</li>
<li><p>除了void之外，剩下的都必须有“return 值;”这样的语句。</p>
</li>
</ol>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名要见名知意。（<code>驼峰命名</code>方式）<br>方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。</p>
<h4 id="形式参数列表"><a href="#形式参数列表" class="headerlink" title="形式参数列表"></a>形式参数列表</h4><ol>
<li>简称：形参</li>
<li>注意：形式参数列表中的每一个参数都是“<code>局部变量</code>”，方法结束之后内存<code>释放</code>。</li>
<li>形参的个数是：<code>0 ~ N</code>个。</li>
<li>形参的数据类型起决定性作用，形参对应的变量名是随意的。（方法重载会涉及！）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> d, String s)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参有多个的话使用“逗号,”隔开。逗号是英文的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><p>由Java语句构成。java语句以“<code>;</code>”结尾。<br>方法体当中编写的是业务逻辑代码，完成某个特定功能。<br>在方法体中的代码遵循自上而下的顺序依次逐行执行。<br>在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参</p>
<hr>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名(实际参数列表);</span><br></pre></td></tr></table></figure>

<p><strong>实参和形参的类型必须一一对应，另外个数也要一一对应。</strong></p>
<ul>
<li>在方法调用的时候，什么时候“类名.”是可以省略的。什么时候不能省略？<ul>
<li>a()方法调用b()方法的时候，a和b方法都在<code>同一个类</code>中，“类名.”<code>可以省略</code>。<br>如果不在同一个类中“类名.”不能省略。</li>
</ul>
</li>
</ul>
<h4 id="调用方法的三种形式"><a href="#调用方法的三种形式" class="headerlink" title="调用方法的三种形式"></a>调用方法的三种形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>赋值调用：</strong>调用方法，在方法前面定义变量，接收方法返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出语句调用：在输出语句中调用方法， System.out.println(方法名()) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能用输出语句调用void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</p>
<h3 id="方法的调用机制分析"><a href="#方法的调用机制分析" class="headerlink" title="方法的调用机制分析"></a>方法的调用机制分析</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827181717775.png" alt="image-20220827181717775"></p>
<p>方法调用：</p>
<ol>
<li>当程序执行到方法是时，就会开辟一个独立的空间（栈空间）</li>
<li>当方法执行完毕，或者执行到ruturn语句时，就会返回</li>
<li>返回到调用方法的地方</li>
<li>返回后，继续执行方法后面的代码</li>
<li>当main方法（栈）执行完毕，整个程序退出</li>
</ol>
<p>方法的注意事项</p>
<ol>
<li>方法不能定义在类中其他方法里面</li>
<li>方法名和变量名可以同名</li>
<li>方法要先定义后使用，方法要调用了才会执行</li>
<li>当方法有形参的时候,想调用该方法必须向其中传入相应的实际参数</li>
<li>形参和实际参数的变量名不需要相同,需要注意的是形参的个数,类型,类型顺序是否和实参一致</li>
<li>一个方法可以有多个return,但是只可能有一个return被执行</li>
</ol>
<h4 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h4><p>​            基本数据类型的传参机制</p>
<p>​            结论: 基本数据类型, 传递的是值(值拷贝) , 形参的任何改变不影响实参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Hsp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">		<span class="comment">// 创建AA对象 名字叫obj</span></span><br><span class="line">		<span class="type">AA</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">		obj.swap(a,b); <span class="comment">//调用swap :交换</span></span><br><span class="line">		System.out.println(“main方法: a=” + a + <span class="string">&quot; b= &quot;</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;a和b交换前的值a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);</span><br><span class="line">		<span class="comment">//完成了a和b的交换</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = tmp;</span><br><span class="line">		System.out.println(<span class="string">&quot;a和b交换后的值a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>内存分析法：</li>
</ul>
<ol>
<li>堆 : 一般存放基本数据类型(局部变量)</li>
<li>栈 : 存放对象(Cat cat，数组，引用数据类型等)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c31ef1ac7558489e8572a83446b3354c.png" alt="img"></p>
<ol start="3">
<li>最后输出的 a,b的值是在main方法中，要找的是main方法中的a和b的值，而主函数中的a,b并没有发生交换，所以是 a &#x3D; 10,b &#x3D; 20</li>
<li>swap方法中发生交换，但并不影响主方法中的交换，因为mian栈和swap是两个独立的空间，而且a、b都是基本数据类型，不是引用数据类型，所以不会影响到主方法中的a、b的值</li>
</ol>
<p>引用数据类型的传参机制</p>
<ul>
<li><p>B 类中编写一个方法 test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？</p>
<p>答案：会变化</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">M2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">         <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">         b.test100(arr);    <span class="comment">//调用方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot; main的 arr数组 &quot;</span>);</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         	System.out.print(arr[i] + <span class="string">&quot;	&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//B类中编写一个方法test100，</span></span><br><span class="line">    <span class="comment">//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">200</span>;<span class="comment">//修改元素</span></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot; test100的 arr数组 &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;	&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内存分析法：</p>
<ol>
<li>只要是调用一个方法就会产生一个新的栈</li>
<li>引用类型传递的是一个地址</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2437149496074802b6a9720445bacb15.png" alt="img"></p>
<ol start="3">
<li>B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？<strong>答案：会变化</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParameter02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;xdr630&quot;</span>;</span><br><span class="line">        p.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        b.test200(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age); <span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        person.age = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>结论:引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;xdr630&quot;</span>;</span><br><span class="line">        p.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        b.test200(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age); <span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>示意图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/f9478134046c4381948fbc2d305c1e14.png" alt="img"></p>
<p>2、特殊的方法—-构造方法</p>
<p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Admin</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Admin</span><span class="params">(String name,<span class="type">int</span> age,String loginName,String password)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">this</span>.age=age;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">this</span>.loginName=loginName;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">this</span>.password=password;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>Java中方法的重载，就是在一个类中，有相同的方法名称，但形参不同的方法。</p>
<h4 id="方法重载的规则"><a href="#方法重载的规则" class="headerlink" title="方法重载的规则"></a>方法重载的规则</h4><ul>
<li>方法名称<strong>必须相同</strong></li>
<li>形参列表<strong>必须不同</strong>（参数个数不同、或参数类型不同、参数排列顺序不同等）。</li>
<li>方法的返回类型可以相同也可以不相同。</li>
<li>仅仅返回类型不同，不足以称为方法的重载。</li>
<li><strong>同一个类中，不允许两个方法的方法名称和参数列表都相同</strong></li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>如下，代码中定义了三个<strong>max</strong>方法(即<strong>方法重载</strong>)，在调用它们时根据传入的实参类型和实参个数，分别调用了对应的 max 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mJane.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第一个max方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value1</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(max_value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第二个max方法，而不是第一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value2</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">25</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(max_value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为2个浮点数，匹配到第三个max方法</span></span><br><span class="line">		<span class="comment">//int max_value3 = (int)max(10.0,30.0);   //返回值类型为double， 高--&gt;低 : 强制转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">max_value3</span> <span class="operator">=</span> max(<span class="number">10.0</span>,<span class="number">30.0</span>);</span><br><span class="line">        System.out.println(max_value3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> num3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt; num3 ? result:num3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>方法名相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法执行，如果匹配失败(未找到对应方法)，则编译器报错。</p>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p><strong>重写（override）</strong>：也称覆盖。重写是子类对父类非静态，非private，非final方法的实现过程进行重新编写，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的）和形参都不能改变。即外壳不变，核心重写。</p>
<p><strong>【方法重写的规则】</strong>：<br>1.子类在重写父类的方法时，一般必须与父类方法原型一致：修饰符 返回值类型 方法名(参数列表) 要完全一致<br>2.JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的。<br>3.访问权限不能比父类中被重写的方法的访问权限更低。<br>4.父类被static、private 、final修饰的方法不能被重写。</p>
<p><strong>重写的作用</strong></p>
<p>重写是为了增强类的重用性和复用性，扩展性；</p>
<p>重写是对类中方法的扩充，因为继承用的是父类的东西，重写则不仅得到父类的东西，同时也加入了自己的东西，两全其美。</p>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>1.重载<br>重载的参数列表是必须修改的，而返回值类型，访问限定符是可以修改的</p>
<p>重载是静态绑定，即在编译时就根据实参类型确定了调用哪个方法。</p>
<p>2.重写<br>重写的参数列表，返回类型（可以是父子类），访问限定符（不能更严厉），一般是不能修改的。</p>
<p>重写是动态绑定，即在编译时不能确定具体的调用方法，而在程序运行时，才能确定具体的被调用的方法。</p>
<p>即：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>发生范围</th>
<th>方法名</th>
<th>形参列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>重载(overload)</td>
<td>本类</td>
<td>必须一样</td>
<td>类型，个数或者顺序至少有一个不同</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td>重写(override)</td>
<td>父子类</td>
<td>必须一样</td>
<td>相同</td>
<td>子类重写的方法，返回类和父类返回类型一样，或者是其子类</td>
<td>子类方法不能缩小父类方法的访问范围</td>
</tr>
</tbody></table>
<blockquote>
<p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>
</blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>可变参数(variable argument)允许你指定可以采用多个同类型参数的方法，而不需要事先确定参数的数目。</p>
<p>语法格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可变参数语法：</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> … args)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>调用可变参数的方法时, 编译器将自动创建一个数组保存传递给方法的可变参数，因此，程序员可以在方法体中以数组的形式访问可变参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ... nums)</span>&#123; </span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		sum += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个方法参数中只能使用一个省略号；且省略号必须出现在方法中参数列表的最后一个位置。<br>&#x2F;&#x2F;要把可变参数放到参数列表的后面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String s,<span class="type">int</span> ... nums)</span>&#123; <span class="comment">//把可变参数当成数组</span></span><br><span class="line">   	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">   		sum += nums[i];</span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>可变参数的实参可以为0个或者任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li>
<li>一个形参列表中只能出现一个可变参数</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li>在java编程中，主要的变量就是属性（成员变量）和局部变量</li>
<li>我们说的局部变量一般是指在成员方法中定义的变量</li>
<li>java中作用域的分类<ol>
<li>全局变量：也就是属性</li>
<li>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</li>
</ol>
</li>
<li>全局变量（属性）可以不赋值，直接使用，因为他有默认值，局部变量必须赋值后，才能使用，因为没有默认值</li>
</ol>
<p>注意事项：</p>
<ol>
<li>属性和局部变量可以重名，访问时遵循就近原则</li>
<li>在同一个作用域中，比如在同一个成员方法中，两恶搞局部变量，不能重名</li>
<li>属性生命周期长，伴随着对象的创建而创建，伴随则会对象的销毁而销毁，局部变量，生命周期较短，伴随着他的代码块的执行而创建，伴随这代码块的结束而销毁，即在一次方法调用过程中</li>
<li>作用域范围不同<ol>
<li>全局变量&#x2F;属性：可以被本类使用，或其他类使用(通过对象调用)</li>
<li>局部变量：只能在本类中对应的方法中使用</li>
</ol>
</li>
<li>修饰符不同<ol>
<li>全局变量&#x2F;属性可以加修饰符</li>
<li>局部变量不可以加修饰符</li>
</ol>
</li>
</ol>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>一般是指在成员方法中定义的变量</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;<span class="comment">//这是一个方法cry()</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">10</span>;<span class="comment">//这就是局部变量</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>



<p>局部变量没有默认值<br>如果出现没有赋值，那么就会报出为初始化变量</p>
<pre><code>public static void main(String[] args)&#123;
    Cat a1=new Cat();
    a1.cry();
&#125;
&#125;
class Cat&#123;
    public void cry()&#123;//这是一个方法cry()
        int n;//这就是局部变量
        System.out.println(n);
    &#125;
&#125;
</code></pre>
<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java: 可能尚未初始化变量n</span><br></pre></td></tr></table></figure>


<h4 id="全局变量（或者属性）"><a href="#全局变量（或者属性）" class="headerlink" title="全局变量（或者属性）"></a>全局变量（或者属性）</h4><p>可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.eat();<span class="comment">//调用eat方法</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">10</span>;<span class="comment">//全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;<span class="comment">//eat方法</span></span><br><span class="line">        System.out.println(age);<span class="comment">//输出全局变量age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>


<p>全局变量默认值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byet <span class="number">0</span></span><br><span class="line"><span class="type">short</span> <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0</span></span><br><span class="line"><span class="type">long</span> <span class="number">0</span></span><br><span class="line"><span class="type">float</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">double</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">char</span> \u0000</span><br><span class="line"><span class="type">boolean</span> <span class="literal">false</span></span><br><span class="line">String <span class="literal">null</span></span><br></pre></td></tr></table></figure>


<p>全局变量默认值可以直接输出</p>
<p>举例 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.eat();<span class="comment">//调用eat方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> age;<span class="comment">//全局变量age</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(age);<span class="comment">//输出age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>构造方法也叫构造器（constructor）是类的一种特殊的方法，他的主要作用是完成对<strong>新对象的初始化</strong>，</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>方法名和类名相同</li>
<li>没有返回值</li>
<li>在创建对象时，系统会自动的调用类的构造器完成对对象的初始化。</li>
</ol>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名 (形参列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>构造器的修饰符可以默认，也可以是public、private、protected</li>
<li>构造器<strong>没有返回值</strong></li>
<li>方法名和类名字必须一样</li>
<li>参数列表和成员方法一样的规则</li>
<li>构造器的调用由系统完成</li>
</ol>
<h4 id="注意事项-x2F-使用细节"><a href="#注意事项-x2F-使用细节" class="headerlink" title="注意事项&#x2F;使用细节"></a>注意事项&#x2F;使用细节</h4><ol>
<li><p>一个类可以定义多个不同的构造器，构造器重载比如：可以给Person类顶一个构造器，用来创建对象的收，只指定人名，不需要指定年龄。</p>
<ol>
<li>&#96;&#96;&#96;java<br>class Person{<br>String name;<br>int age;<br>public Person(String PName,int PAge){<br>    naem &#x3D; PName;<br>    aeg &#x3D; PAge;<br>}<br>public Person(String PName){<br>    name &#x3D; PName;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 构造器名和类名要相同</span><br><span class="line"></span><br><span class="line">3. 构造器没有返回值</span><br><span class="line"></span><br><span class="line">4. 构造器是完成对象的初始化，并不是创建对象</span><br><span class="line"></span><br><span class="line">5. 在创建对象时，系统会自动的调用该类的构造方法</span><br><span class="line"></span><br><span class="line">6. 如果没有定义构造方法，系统会自动给类一个默认无参构造方法（也叫默认构造方法），比如Person()&#123;&#125;,可使用**javap指令** 反编译查看</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      class Person&#123;</span><br><span class="line">          Person()&#123;&#125;//隐藏构造器</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>一旦定义了自己的构造器，默认的构造器就被覆盖，就不能再使用默认的无参构造器，除非显式的定义一下，即；Person(){}</p>
<ol>
<li>&#96;&#96;&#96;java<br>class Person{<br>String name;<br>&#x2F;&#x2F;手动定义的无参构造器<br>Person(){}<br>&#x2F;&#x2F;自己定义的有参构造器<br>public Person(String PNanme){<br>    name &#x3D; PName;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 访问修饰符</span><br><span class="line"></span><br><span class="line">有四种访问修饰符规定了定义的属性和方法能访问的区域</span><br><span class="line"></span><br><span class="line">1. private关键字</span><br><span class="line"></span><br><span class="line">   用private关键字修饰的属性和方法只能在该类的大括号内访问，出了这个类就不能被访问了。当一个子类继承一个父类的属性和方法时，若父类的属性或方法被private修饰，那么子类就不可以继承该属性或方法。</span><br><span class="line"></span><br><span class="line">2. default关键字（包访问权限）</span><br><span class="line"></span><br><span class="line">   default关键字修饰的属性或方法只能在同一个包中的所有类访问，且必须是同级的包，在一个包中的子包也不可以访问。但我们在定义属性和方法时不需要将default关键字写出来，没有关键字修饰的属性或方法就是包访问权限。</span><br><span class="line"></span><br><span class="line">3. protected关键字（继承访问权限）</span><br><span class="line"></span><br><span class="line">   被protected关键字修饰的属性或方法只能在同一个包中的所有类和不同包中的子类访问，出了一个包但不是该类的子类的话就不可以访问。</span><br><span class="line"></span><br><span class="line">4. public关键字</span><br><span class="line"></span><br><span class="line">   被public关键字修饰的属性或方法可以在任意位置被访问，没有使用的权限。</span><br><span class="line"></span><br><span class="line">&gt; 所以这四种访问修饰符使用的范围从小到大依次是</span><br><span class="line">&gt; [private](https://so.csdn.net/so/search?q=private&amp;spm=1001.2101.3001.7020) &lt; default &lt; protected &lt; public</span><br><span class="line"></span><br><span class="line">| 范围           | private    | Default(默认)     | Protected     | Public     |</span><br><span class="line">| :------------: | :--: | :--: | :--: | :--: |</span><br><span class="line">| 同一个类       |  √    |  √    |  √    |   √   |</span><br><span class="line">| 同一个包       |      |   √   |   √   |  √   |</span><br><span class="line">| 不同包的子类   |      |      |   √   |   √   |</span><br><span class="line">| 不同包的非子类 |      |      |      |   √   |</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line"></span><br><span class="line">1. 修饰符可以用来修饰类中的属性，成员方法以及类</span><br><span class="line">2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点</span><br><span class="line">3. 1</span><br><span class="line">4. 成员方法的访问规则和属性完全一样</span><br><span class="line"></span><br><span class="line">## This</span><br><span class="line"></span><br><span class="line">#### 注意事项，使用细节</span><br><span class="line"></span><br><span class="line">1. this关键字可以用来访问本类的属性、方法。构造器</span><br><span class="line">2. this用于区分当前类的属性和局部变量</span><br><span class="line">3. 访问成员方法的语法：this.方法名(参数列表)</span><br><span class="line">4. 访问构造器语法：this(参数列表);注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须位于第一行，而且只能出现一次）</span><br><span class="line">5. this不能在类定义的外部使用，只能在类定义的方法中使用</span><br><span class="line">6. 不能在一个类中的两个构造方法中使用this()互相调用</span><br><span class="line"></span><br><span class="line">this关键字的三种用法：</span><br><span class="line"></span><br><span class="line">- 通过this关键字可以明确的访问一个类的成员变量，解决成员变量与局部变量名称冲突问题。</span><br><span class="line">  实例：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class person&#123;</span><br><span class="line">        </span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">        </span><br><span class="line">        public person(String name,int age)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> 上面代码中<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">构造方法</a>中定义的参数name，age等它是局部变量，在类中也定义了name，age等成员变量，在构造方法中使用age则是访问局部变量，如果想访问类中的成员变量，使用this.age则是访问成员变量。</p>
</li>
</ol>
<ul>
<li><p>通过this关键字调用成员方法</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>class person{</p>
<pre><code>public void test()&#123;
    System.out.println(“该方法被调用”);
&#125;
public void test1()&#123;
    //调用test()方法
    this.test();
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在test2()方法中通过this.test1()访问test1()方法，注意此处的this关键字可以不写，效果是一样的。</p>
<p>class person{</p>
<pre><code>public void test()&#123;
    System.out.println(“该方法被调用”);
&#125;
public void test1()&#123;
    //调用test()方法
    test();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在构造方法中访问构造方法使用this([参数1]，[参数2].。。)</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class person&#123;</span><br><span class="line">        </span><br><span class="line">        int age;</span><br><span class="line">        </span><br><span class="line">        public person()&#123;</span><br><span class="line">            //无参构造</span><br><span class="line">        &#125;</span><br><span class="line">        public person(int age)&#123;</span><br><span class="line">            this();</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>错误用法</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>public class Student {<br>&#x2F;&#x2F;成员变量<br>String name;<br><br>public Student() {<br>    System.out.println(“无参构造方法…”);<br>    &#x2F;&#x2F;错误,必须位于第一行<br>    this(“张三”);<br>}<br><br>public Student(String name) {<br>    this.name &#x3D; name;<br>}<br>  }</p>
<p>public class Student {<br>String name;&#x2F;&#x2F;成员变量<br><br>public Student() {<br>    &#x2F;&#x2F;错误，不能相互调用<br>    this(“张三”);<br>}<br><br>public Student(String name) {<br>    &#x2F;&#x2F;错误，不能相互调用<br>    this();<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Super</span><br><span class="line"></span><br><span class="line">###  使用super调用父类中重写的方法、访问父类中被隐藏的字段</span><br><span class="line"></span><br><span class="line">子类重写了父类中的某一个方法，隐藏父类中的字段，假如想在子类中访问到父类中被重写的方法和隐藏父类的字段，可以在子类中通过使用关键字super来调用父类中被重写的方法和访问父类中被隐藏的字段。例如：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package first;</span><br><span class="line">class A&#123;</span><br><span class="line">    public String name=&quot;张飞&quot;;         //添加成员变量</span><br><span class="line">	public void say() &#123;                //添加成员方法say</span><br><span class="line">		System.out.println(&quot;我是父类A成员方法say&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public String name=&quot;关羽&quot;;         //与父类中同名的字段，隐藏父类</span><br><span class="line">	public void say()&#123;                 //重写方法say</span><br><span class="line">		super.say();                   //使用super关键字调用父类中的方法</span><br><span class="line">		System.out.println(&quot;我是子类B成员方法say&quot;);</span><br><span class="line">        System.out.println(&quot;父类的name名字：&quot;+super.name); //使用super关键字访问父类中的变量</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class myfirst &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	  B b=new B();                     //创建子类的一个实例对象</span><br><span class="line">	  b.say();                         //调用子类中重写的方法</span><br><span class="line">	  System.out.println(&quot;子类的name名字：&quot;+b.name);   //调用子类中的name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>运行结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是父类A成员方法say</span></span><br><span class="line"><span class="comment">//我是子类B成员方法say</span></span><br><span class="line"><span class="comment">//父类的name名字：张飞</span></span><br><span class="line"><span class="comment">//子类的name名字：关羽</span></span><br></pre></td></tr></table></figure>

<h3 id="使用super调用父类的无参数构造方法-x2F-有参数构造方法"><a href="#使用super调用父类的无参数构造方法-x2F-有参数构造方法" class="headerlink" title="使用super调用父类的无参数构造方法&#x2F;有参数构造方法"></a>使用super调用父类的无参数构造方法&#x2F;有参数构造方法</h3><p>子类不继承其父类的构造方法。</p>
<ul>
<li>当使用无参数的super()时，父类的无参数构造方法就会被调用；</li>
<li>当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;              <span class="comment">//创建父类SuperClass</span></span><br><span class="line">	  <span class="keyword">private</span> <span class="type">int</span> n;            <span class="comment">//声明一个私有变量n</span></span><br><span class="line">	  SuperClass()&#123;             <span class="comment">//父类无参数构造方法</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;这是父类SuperClass无参数构造方法&quot;</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	  SuperClass(<span class="type">int</span> n) &#123;       <span class="comment">//父类有参数构造方法</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;这是父类SuperClass有参数构造方法&quot;</span>);</span><br><span class="line">	    <span class="built_in">this</span>.n = n;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;     <span class="comment">// SubClass类继承SuperClass类</span></span><br><span class="line">	  <span class="keyword">private</span> <span class="type">int</span> n;                       <span class="comment">//声明一个私有变量n</span></span><br><span class="line">	  SubClass()&#123;                          <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;这是子类无参数构造方法&quot;</span>);</span><br><span class="line">	  &#125;  </span><br><span class="line">	  </span><br><span class="line">	  <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(<span class="type">int</span> n)</span>&#123;              <span class="comment">//子类有参数构造方法</span></span><br><span class="line">	    <span class="built_in">super</span>(<span class="number">300</span>);                        <span class="comment">//调用父类中带有参数的构造器</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;这是子类有参数构造方法&quot;</span>+n);</span><br><span class="line">	    <span class="built_in">this</span>.n = n;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		    <span class="type">SubClass</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();      <span class="comment">//创建子类SubClass实例对象，调用其无参数构造方法</span></span><br><span class="line">		    <span class="type">SubClass</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(<span class="number">100</span>);   <span class="comment">//创建子类SubClass实例对象，调用其有参数构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是父类SuperClass无参数构造方法</span></span><br><span class="line"><span class="comment">//这是子类无参数构造方法</span></span><br><span class="line"><span class="comment">//这是父类SuperClass有参数构造方法</span></span><br><span class="line"><span class="comment">//这是子类有参数构造方法100</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li><p>如果要初始化父类中的字段，可以在子类的构造方法中通过关键字super调用父类的构造方法；</p>
</li>
<li><p>对父类的构造放的调用必须放在子类构造方法的第一行；</p>
</li>
<li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器；</p>
</li>
<li><p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表；</p>
</li>
<li><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</p>
</li>
</ul>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。</p>
<h3 id="强调一下"><a href="#强调一下" class="headerlink" title="强调一下"></a>强调一下</h3><ul>
<li>static修饰的成员变量和方法，从属于类</li>
<li>普通变量和方法从属于对象</li>
<li>静态方法不能调用非静态成员，编译会报错</li>
</ul>
<h3 id="static关键字的用途"><a href="#static关键字的用途" class="headerlink" title="static关键字的用途"></a>static关键字的用途</h3><p>一句话描述就是：<strong>方便在没有创建对象的情况下进行调用(方法&#x2F;变量)。</strong></p>
<p>显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p>
<p>static可以用来修饰类的成员方法、类的成员变量，另外也可以编写static代码块来优化程序性能</p>
<h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><p>static方法也成为静态方法，由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this的，因为不依附于任何对象，既然都没有对象，就谈不上this了，并且由于此特性，在静态方法中不能访问类的非静态成员变量和非静态方法，因为非静态成员变量和非静态方法都必须依赖于具体的对象才能被调用。</p>
<p>虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量。</p>
<p>代码示例：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20180807172546687" alt="这里写图片描述"></p>
<p>从上面代码里看出：</p>
<p>静态方法test2()中调用非静态成员变量address，编译失败。这是因为，在编译期并没有对象生成，address变量根本就不存在。</p>
<p>静态方法test2()中调用非静态方法test1()，编译失败。这是因为，编译器无法预知在非静态成员方法test1()中是否访问了非静态成员变量，所以也禁止在静态方法中调用非静态成员方法</p>
<p>非静态成员方法test1()访问静态成员方法test2()&#x2F;变量name是没有限制的</p>
<p>所以，如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。最常见的静态方法就是main方法，这就是为什么main方法是静态方法就一目了然了，因为程序在执行main方法的时候没有创建任何对象，只有通过类名来访问。</p>
<p>特别说明：static方法是属于类的，非实例对象，在JVM加载类时，就已经存在内存中，不会被虚拟机GC回收掉，这样内存负荷会很大，但是非static方法会在运行完毕后被虚拟机GC掉，减轻内存压力</p>
<h3 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h3><p>static变量也称为静态变量，静态变量和非静态变量的区别：</p>
<p>静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化</p>
<p>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</p>
<p>static成员变量初始化顺序按照定义的顺序来进行初始化</p>
<h3 id="static块"><a href="#static块" class="headerlink" title="static块"></a>static块</h3><p>构造方法用于对象的初始化。静态初始化块，用于类的初始化操作。</p>
<p>在静态初始化块中不能直接访问非staic成员。</p>
<h4 id="static块的作用"><a href="#static块的作用" class="headerlink" title="static块的作用"></a>static块的作用</h4><p>静态初始化块的作用就是：提升程序性能。</p>
<p>为什么说静态初始化块能提升程序性能，代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBornBoomer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> Date.valueOf(<span class="string">&quot;1946&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> Date.valueOf(<span class="string">&quot;1964&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">&quot;1946&quot;</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">&quot;1964&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBornBoomer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行</p>
<p>静态初始化块可以置于类中的任何地方，类中可以有多个静态初始化块。<br>在类初次被加载时，会按照静态初始化块的顺序来执行每个块，并且只会执行一次。</p>
<hr>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><h3 id="类变量的定义"><a href="#类变量的定义" class="headerlink" title="类变量的定义"></a>类变量的定义</h3><p>类变量也叫静态变量&#x2F;静态方法,是该类的所有对象共享的变量,任何一个该类的对象访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量.</p>
<h3 id="类变量的定义语法"><a href="#类变量的定义语法" class="headerlink" title="类变量的定义语法"></a>类变量的定义语法</h3><p>推荐使用 :      访问修饰符 static 数据类型 变量名;<br>当然也可以:    static 访问修饰符 数据类型 变量名</p>
<h3 id="访问类变量"><a href="#访问类变量" class="headerlink" title="访问类变量"></a>访问类变量</h3><p>推荐使用: 类名.类变量名<br>当然也可以用: 对象名.类变量名<br>需要注意的是</p>
<p>静态变量的访问修饰符的访问权限和范围与普通类型是一样的<br>类变量是随着类加载而加载(用到类的时候会加载,只加载一次),所以即使没有创建实例对象也可以访问<br>访问变量名的代码解释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Visit</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.name);<span class="comment">//输出张三</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();              <span class="comment">//两个输出效果相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.name=&quot;</span>+a.name);<span class="comment">//输出a.name=张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol>
<li>什么时候需要用类变量<ol>
<li>需要让某个类的所有对象共享一个变量时,可以考虑使用类变量</li>
</ol>
</li>
<li>类变量和实例变量区别<ol>
<li>类变量是该类所有对象共享的,而实例变量是每个对象独享的</li>
</ol>
</li>
<li>加上static称为<strong>类变量</strong>或者<strong>静态变量</strong>,否则称为实例变量&#x2F;普通变量&#x2F;非静态变量，</li>
<li>实例变量不能用类名.变量名访问</li>
<li>类变量可以通过 <strong>类名.类变量名</strong> 或者  <strong>对象名.类变量名</strong>  来访问，但Java设计者推荐  类名.类变量名 方式访问</li>
<li>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了就可以使用类变量</li>
<li>类变量的生命周期随类的加载开始，随类消亡而销毁</li>
</ol>
<h3 id="关于静态变量-x2F-类变量在内存中的位置"><a href="#关于静态变量-x2F-类变量在内存中的位置" class="headerlink" title="关于静态变量&#x2F;类变量在内存中的位置"></a>关于静态变量&#x2F;类变量在内存中的位置</h3><p>关于这个问题网上流传版本不同,原因是随着jdk的版本不同,但却有以下共识</p>
<p>static变量是同一个类所有对象共享,不必知道其具体位置也行<br>static在类加载时生成,只加载一次,没有创建对象实例也可以通过类名.类变量来访问,生命周期随类加载而开始,随类消失而消亡那个,与对象无关</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类方法也叫静态方法</p>
<p>形式如下</p>
<p>访问修饰符 static 数据返回类型 方法名(){ }</p>
<p>static 访问修饰符 数据返回类型 方法名(){  }</p>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p><strong>类名.类方法名</strong>   或者    <strong>对象名.类方法名</strong>  </p>
<blockquote>
<p>前提是 满足访问修饰符的访问权限和范围</p>
</blockquote>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：<ol>
<li>类方法中无this的参数</li>
<li>普通方法中隐含着this的参数</li>
</ol>
</li>
<li>类方法可以通过类名调用，也可以通过对象名调用</li>
<li>普通方法和对象有关，需要通过对象名调用，比如<strong>对象名.方法名(参数)</strong>,不能通过类名调用</li>
</ol>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>** <strong>在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。</strong></p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；<br>非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p> 因为静态方法和静态数据成员会随着类的定义而被分配和装载入<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中，而非静态方法和非静态数据成员只有在类的对象创建时在对象的内存中才有这个方法的代码段。</p>
<p>引用静态方法时，可以用类名.方法名或者对象名.方法名的形式。<br>对以上描述进行验证的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        System.out.println(S.getStatic());<span class="comment">//使用类名加前缀访问静态方法</span></span><br><span class="line">        S s=<span class="keyword">new</span> <span class="title class_">S</span>();</span><br><span class="line">        System.out.println(s.getStatic());<span class="comment">//使用实例化对象名访问静态方法</span></span><br><span class="line">        System.out.println(s.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">S</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态初始器：由static和&#123;&#125;组成，只在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。</span></span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            a=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态方法只能访问静态数据成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getStatic</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getT</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态方法可以访问静态方法和非静态方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            getT();</span><br><span class="line">            getStatic();</span><br><span class="line">            t=a;<span class="comment">//非静态方法可以访问非静态数据成员和静态数据成员</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>（1）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>修饰的静态方法会随着类的定义而被分配和装载入内存中，编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然可能有多个实例，但这些实例共享该内存，特别值得注意的是，任何一个对象对静态数据成员的修改，都会影响其它对象。<br>（2）静态不能引用非静态这一特性，是由于静态的会随着类的定义而被分配和装载入内存中这一关键点决定的；如果静态引用了非静态的，根本无法从内存中找到非静态的代码段，势必会出错，这种做法是Java虚拟机决不允许的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>静态方法，只能访问静态成员</li>
<li>非静态方法，可以访问所有成员</li>
<li>遵守访问权限规则</li>
</ol>
<hr>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>定义：Java中，final 表示最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。</p>
<p>用途：final 应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变。</p>
<p>使用注意事项：</p>
<ol>
<li>final 修饰变量，表示变量的值不可改变，此时该变量可被称为常量。</li>
<li>final 修饰方法，表示方法不能被子类重写；<ol>
<li>重写概念：子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。</li>
</ol>
</li>
<li>final 用在类的前面表示该类不能有子类，即该类不可以被继承。</li>
</ol>
<h3 id="final修饰"><a href="#final修饰" class="headerlink" title="final修饰"></a>final修饰</h3><p>1、final变量<br>final变量，凡是对成员变量或者(在方法中的或者代码块中的变量称为本地变量)声明为 final 的都叫作 final 变量。final 变量经常和 static 关键字一起使用，作为常量。下面是 final 变量的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">NAME = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;李四&quot;</span>); <span class="comment">//invalid compilation error</span></span><br><span class="line"><span class="comment">//final 变量是只读的。</span></span><br></pre></td></tr></table></figure>

<p>2、final 方法<br>final 声明方法，这个方法不允许在派生类中进一步被覆写（override）。</p>
<p>Java 中非私有的成员方法默认都是虚方法，而虚方法就可以在派生类中被覆写。</p>
<p>为保证某个类上的某个虚方法不在派生类中被进一步覆写，就需要使用 final 修饰符来声明，让编译器（例如 javac）与 JVM 共同检查并保证这个限制总是成立。</p>
<p>下面是 final 方法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span>张三<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Reader extends User&#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public final String getName()&#123;</span></span><br><span class="line"><span class="string">        return &quot;</span>李四<span class="string">&quot;; //compilation error: overridden method is final</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>3、final 类<br>final 修饰的类叫作 final 类，final类通常是功能完整的，不能被继承，Java 中有许多类是 final 的，比如 String, Interger 以及其他包装类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>final 关键字，提高了性能，JVM 和 Java 应用都会缓存 final 变量。</li>
<li>final 变量，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>final 关键字可以用于修饰成员变量、本地变量、方法以及类。</li>
<li>final 成员变量，必须在声明的时初始化或者在构造器中初始化，否则报编译错误。</li>
<li>final 变量不能再次赋值；final 方法不能被重写；final 类不能被继承。</li>
<li>在匿名类中，所有变量都必须是 final 变量。</li>
<li>接口中，声明的所有变量本身是 final 的。</li>
<li>final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的。</li>
<li>声明时未初始化的 final 变量，称为空白 final 变量(blank final variable)，必须在构造器中进行初始化，或者调用 this() 初始化，否则，编译器会报错final变量(变量名)需要进行初始化。</li>
<li>按照 Java 编码规范，final 变量就是常量，而且通常常量名要大写。</li>
<li>对于集合对象声明为 final 指的是引用不能被更改。</li>
</ol>
<hr>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li>java虚拟机需要调用类的main()方法，所以该方法的访问必须是public</li>
<li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，</li>
<li>java执行的程序 参数1，参数2，参数3<ol>
<li><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919153604012.png" alt="image-20220919153604012"></li>
</ol>
</li>
</ol>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>public是一种访问权限修饰符，public中文翻译共有，正如它的实际意思一样，在Java里面所有被public修饰的方法，类等都可以在任意其他地方调用。main方法之所以是public，是因为一个Java程序在运行时首先创建一个JVM实例，程序要运行需要调用main方法，JVM从外部调用main方法这就需要访问权限修饰符必须给出外部访问的权限，所以只能用public。</p>
<p>static的定义是为了JVM在调用main方法时不用实例化对象，只需要在初始时加载main方法所在类，然后直接通过类名.main来调用main方法。</p>
<p>void表示main方法没有返回值，没有返回值的原因是因为Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序。</p>
<p>main的名称不能变是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。main方法作为程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程，非守护线程和守护线程，main方法属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以表明自己的线程是守护线程。当程序中所有的非守护线程终止时，JVM退出。也可以用Runtime类或者System.exit()来退出。</p>
<p>String[] args,是main方法中唯一可以改变的地方！args是arguments的缩写，只是一个变量默认名，习惯性写作它，但是也可以改变的，只要符合命名规则随便你写成什么。在使用集成开发工具的今天，String[] args更像是一种摆设了，很多初学者都不知道它的作用，其实它是程序运行传入的一个参数组。一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainMethod</span>&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;获取数组args[]的数据&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;第&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;个实参：&quot;</span> + args[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入实参（1 2 3）</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919164420682.png" alt="image-20220919164420682"></p>
<p>输出结果为：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919164850936.png" alt="image-20220919164850936"></p>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ol>
<li>在main()方法中，可以直接调用main方法所在类的静态方法或静态属性</li>
<li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li>
</ol>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>封装（encapsulation）就是把抽象出的数据[属性]和对数据的操作[方法]封装再一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法].才能对数据进行操作</p>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p>良好的封装能够减少耦合。</p>
</li>
<li><p>类内部的结构可以自由修改。</p>
</li>
<li><p>可以对成员变量进行更精确的控制。</p>
</li>
<li><p>隐藏信息，实现细节。<br>实现Java封装的步骤</p>
</li>
<li><p>修改属性的可见性来限制对属性的访问（一般限制为private），例如:</p>
<ol>
<li>&#96;&#96;&#96;java<br>public class person{<br>private String name;<br>private int age;<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</span><br><span class="line"></span><br><span class="line">2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class Person&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">      ​</span><br><span class="line">        public int getAge()&#123;</span><br><span class="line">         return age;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public String getName()&#123;</span><br><span class="line">         return name;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public void setAge(int age)&#123;</span><br><span class="line">         this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public void setName(String name)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</li>
</ol>
</li>
</ol>
<p>一个java封装类的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名: EncapTest.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncapTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String idNum;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getIdNum</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> idNum;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">( <span class="type">int</span> newAge)</span>&#123;</span><br><span class="line">   age = newAge;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span>&#123;</span><br><span class="line">   name = newName;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIdNum</span><span class="params">( String newId)</span>&#123;</span><br><span class="line">   idNum = newId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上实例中public方法是外部类访问该类成员变量的入口。</p>
<p>通常情况下，这些方法被称为getter和setter方法。</p>
<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p>
<p>通过如下的例子说明EncapTest类的变量怎样被访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* F文件名 : RunEncap.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunEncap</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">   <span class="type">EncapTest</span> <span class="variable">encap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncapTest</span>();</span><br><span class="line">   encap.setName(<span class="string">&quot;James&quot;</span>);</span><br><span class="line">   encap.setAge(<span class="number">20</span>);</span><br><span class="line">   encap.setIdNum(<span class="string">&quot;12343ms&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   System.out.print(<span class="string">&quot;Name : &quot;</span> + encap.getName()+ </span><br><span class="line">               <span class="string">&quot; Age : &quot;</span>+ encap.getAge());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码编译运行结果：</p>
<blockquote>
<p>Name : James   Age : 20</p>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>继承的作用：通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。</p>
<p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 父类&#123;</span><br><span class="line">    ...       <span class="comment">//成员变量、成员方法</span></span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">    ...       <span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">        Systme.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        s.age = <span class="number">19</span>;</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//学生</span></span><br><span class="line"><span class="comment">//Tom</span></span><br><span class="line"><span class="comment">//19</span></span><br></pre></td></tr></table></figure>

<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul>
<li>子类不能选择性继承父类；</li>
<li>Java不支持多重继承，但一个类可以实现多个接口，从而克服单继承的缺点；</li>
<li>构造方法不会被子类继承，但可以从子类中调用父类的构造方法</li>
<li>当子类对象创建好后，与父类创建了查找的关系</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>继承过来的字段和方法，可以像任何其他字段和方法一样被直接使用；</li>
<li>在子类中可以声明一个与父类中同名的新字段或静态方法，从而“隐藏”父类中的字段或方法；</li>
<li>可以在子类中声明一个在父类中没有的新字段和方法；</li>
<li>可以在子类中编写一个父类当中具有相同名的新实例方法，这称为“方法重写”或“方法覆盖”；</li>
<li>可以在子类中编写一个调用父类构造方法的子类构造方法，既可以隐式地实现，也可以通过使用关键字super来实现。</li>
</ul>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220914114141070.png" alt="image-20220914114141070"></p>
<h3 id="重写和隐藏父类方法"><a href="#重写和隐藏父类方法" class="headerlink" title="重写和隐藏父类方法"></a>重写和隐藏父类方法</h3><p>子类继承了父类中的所有成员及方法，但在某种情况下，子类中该方法所表示的行为与其父类中该方法所表示的行为不完全相同，例如，在父类语言中定义了说话这个方法，而在子类中说话的方法是不同的：外国人说英文，中国人说中文，这时我们就需要重写或隐藏父类的该方法。</p>
<h3 id="重写父类中的方法"><a href="#重写父类中的方法" class="headerlink" title="重写父类中的方法"></a>重写父类中的方法</h3><p>当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;                      <span class="comment">//输出英文欢迎</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,Welcome to Java!!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayBye</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;GoodBye,everyone&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;                      <span class="comment">//输出中文欢迎  </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好，欢迎学习Java！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	B b=<span class="keyword">new</span> <span class="title class_">B</span>();                                <span class="comment">//创建子类B的一个实例对象，使用默认构造方法</span></span><br><span class="line">	b.sayHello();                               <span class="comment">//调用子类中重写的方法</span></span><br><span class="line">	b.sayBye();                                 <span class="comment">//调用父类中的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大家好，欢迎学习Java！！！</span></span><br><span class="line"><span class="comment">//GoodBye,everyone</span></span><br></pre></td></tr></table></figure>

<p>注意：重写的方法具有与其所重写的方法相同的名称、参数数量、类型和返回值。</p>
<p>隐藏父类中的方法<br>如果一个子类定义了一个静态类方法，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。</p>
<ul>
<li><p>当调用被重写的方法时，调用的版本是子类的方法；</p>
</li>
<li><p>当调用被隐藏的方法时，调用的版本取决于是从父类中调用还是从子类中调用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;             <span class="comment">//静态类方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;大家好，这是A的静态类方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello2</span><span class="params">()</span> &#123;                   <span class="comment">//实例方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;大家好，这是A中的实例方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;             <span class="comment">//静态类方法</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好，这是B的静态类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello2</span><span class="params">()</span> &#123;                   <span class="comment">//实例方法</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好，这是B的实例方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	    B b=<span class="keyword">new</span> <span class="title class_">B</span>();                           <span class="comment">//创建B类的实例对象b</span></span><br><span class="line">	    A a=b;                                 <span class="comment">//隐式对象类型转换</span></span><br><span class="line">	    A.sayHello();                          <span class="comment">//调用A类的静态类方法</span></span><br><span class="line">	    a.sayHello();                          <span class="comment">//调用a对象的静态类方法</span></span><br><span class="line">	    B.sayHello();                          <span class="comment">//调用B类的静态方法</span></span><br><span class="line">	    a.sayHello2();                         <span class="comment">//调用a对象的实例方法</span></span><br><span class="line">	    b.sayHello2();                         <span class="comment">//调用b对象的的实例方法</span></span><br><span class="line">	    A a2=<span class="keyword">new</span> <span class="title class_">A</span>();                          <span class="comment">//创建A类的实例对象a2</span></span><br><span class="line">	    a2.sayHello2();                        <span class="comment">//调用a2对象的实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大家好，这是A的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是A的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的实例方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的实例方法</span></span><br><span class="line"><span class="comment">//大家好，这是A中的实例方法</span></span><br></pre></td></tr></table></figure>

<p>得到调用的隐藏方法是父类中的方法，而得到调用的重写方法是子类中的方法。</p>
<h3 id="方法重写和隐藏后的修饰符"><a href="#方法重写和隐藏后的修饰符" class="headerlink" title="方法重写和隐藏后的修饰符"></a>方法重写和隐藏后的修饰符</h3><p>在子类中被重写的方法，其访问权限允许大于但不允许小于被其重写的方法，例如：父类中一个受保护的实例方法(protected)在子类中可以是公共的(public)的，但不可以是私有的(private)。如果一个方法在父类中是static方法，那么在子类也必须是static方法；如果一个方法在父类中是实例方法，那么在子类中也必须是实例方法。</p>
<h3 id="子类访问父类私有成员"><a href="#子类访问父类私有成员" class="headerlink" title="子类访问父类私有成员"></a>子类访问父类私有成员</h3><p>子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。那么如何在子类中访问到父类中的字段呢，我们可以在父类中提供用来访问其私有字段的public或protected方法，子类使用这些方法来访问相应的字段。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;                     <span class="comment">//父类A</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value=<span class="number">10</span>;    <span class="comment">//声明一个私有变量value并赋值为10</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getvalue</span><span class="params">()</span> &#123;  <span class="comment">//声明一个公有成员方法getvalue，返回value</span></span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;           <span class="comment">//A的子类B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	  B b=<span class="keyword">new</span> <span class="title class_">B</span>();           <span class="comment">//创建子类B的一个实例对象</span></span><br><span class="line">	  System.out.println(<span class="string">&quot;子类通过父类提供的公共接口访问A中的私有字段value:&quot;</span>+b.getvalue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类通过父类提供的公共接口访问A中的私有字段value:10</span></span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h3><p>多态是面向对象程序设计（OOP）的一个重要特征，指同一个实体同时具有多种形式，即同一个对象，在不同时刻，代表的对象不一样，指的是对象的多种形态。</p>
<p>可以把不同的子类对象都当作父类来看，进而屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，统一调用标准。</p>
<p>比如，小猫、小狗、小猪我们可以把他们都归纳成小动物，每种小动物都需要吃东西,所以我们可以统一设置他们都必须吃，但是每种小动物的习性不一样，那这个就可以设置成小动物自己特有的功能,多态对象只能调用父类中定义子类中重写的功能,并不能调用子类的特有功能,这样就实现了代码的统一</p>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>通俗点讲，多态就是不同对象对同一物体或事件发出不同的反应或响应。比如stuendt是一个父类，那么在操场上上体育课的学生和在教室里面的学生就是它的子类。这时上课铃声响了，上体育课的学生去操场，在教室里面上课的学生则是回教室，不同的学生有着不同的反应，这就是多态。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>父类类型  引用名 &#x3D; new 子类类型();</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>多态的前提1：是继承</li>
<li>多态的前提2：要有方法的重写</li>
<li>父类引用指向子类对象,如：Animal a &#x3D; new Cat();</li>
<li>多态中，编译看左边，运行看右边</li>
</ol>
<h3 id="实现多态的条件"><a href="#实现多态的条件" class="headerlink" title="实现多态的条件"></a>实现多态的条件</h3><p>1.继承：必须要有子类继承父类的继承关系。<br>2.重写：子类需要对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法而不是原本父类的方法。<br>3.向上转型：在多态中需要将父类引用指向子类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220908100824809.png" alt="image-20220908100824809"></p>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ol>
<li>多态可以让我们不用关心某个对象到底具体是什么类型,就可以使用该对象的某些方法</li>
<li>提高了程序的可扩展性和可维护性</li>
</ol>
<h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p>前提:多态对象把自己看做是父类类型</p>
<ol>
<li>成员变量: 使用的是父类的</li>
<li>成员方法: 由于存在重写现象,所以使用的是子类的</li>
<li>属性没有重写之说，属性的值看编译类型</li>
<li>静态成员: 随着类的加载而加载,谁调用就返回谁的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.oop2;</span><br><span class="line"><span class="comment">/*本类用于测试多态成员的使用情况*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//7.创建纯纯的子类对象</span></span><br><span class="line">        <span class="type">Dog2</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2</span>();</span><br><span class="line">        System.out.println(d.sum);<span class="comment">//20,子类自己的属性</span></span><br><span class="line">        d.eat();<span class="comment">//小狗爱吃肉包子,子类自己的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.创建多态对象</span></span><br><span class="line">        <span class="comment">/*口诀1：父类引用指向子类对象*/</span></span><br><span class="line">        <span class="comment">/*口诀2：编译(保存)看左边，运行(效果)看右边*/</span></span><br><span class="line">        <span class="type">Animal2</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2</span>();</span><br><span class="line">        <span class="comment">/*多态中，成员变量使用的是父类的*/</span></span><br><span class="line">        System.out.println(a.sum);<span class="comment">//10</span></span><br><span class="line">        <span class="comment">/*多态中，方法的声明使用的是父类的，方法体使用的是子类的*/</span></span><br><span class="line">        a.eat();<span class="comment">//小狗爱吃肉包子</span></span><br><span class="line">        <span class="comment">/*多态中，调用的静态方法是父类的，因为多态对象把自己看作是父类类型</span></span><br><span class="line"><span class="comment">        * 直接使用父类中的静态资源*/</span></span><br><span class="line">        a.play();<span class="comment">//没有提示，玩啥都行~</span></span><br><span class="line">        Animal2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal2</span>&#123;</span><br><span class="line">    <span class="comment">//3.创建父类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//4.创建父类的普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃啥都行~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9.1定义父类的静态方法play</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩啥都行~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog2</span> <span class="keyword">extends</span> <span class="title class_">Animal2</span>&#123;</span><br><span class="line">    <span class="comment">//5.定义子类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//6.重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗爱吃肉包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9.2创建子类的静态方法play</span></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">/*这不是一个重写的方法，只是恰巧在两个类中出现了一模一样的两个静态方法</span></span><br><span class="line"><span class="comment">    * 静态方法属于类资源，只有一份，不存在重写的现象</span></span><br><span class="line"><span class="comment">    * 在哪个类里定义，就作为哪个类的资源使用*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗喜欢玩皮球~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h3><p>在JAVA中，继承是一个重要的特征，通过extends关键字，子类可以复用父类的功能，如果父类不能满足当前子类的需求，则子类可以重写父类中的方法来加以扩展。<br>那么在这个过程中就存在着多态的应用。存在着两种转型方式，分别是：向上转型和向下转型。</p>
<p><strong>向上转型</strong>：可以把不同的子类对象都当作父类来看，进而屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，统一调用标准。<br>比如：父类Parent,子类Child<br>父类的引用指向子类对象：Parent p&#x3D;new Child();<br>说明：向上转型时，子类对象当成父类对象，只能调用父类的功能，如果子类重写了父类中声明过的方法，方法体执行的就是子类重过后的功能。但是此时对象是把自己看做是父类类型的，所以其他资源使用的还是父类型的。<br>比如：花木兰替父从军，大家都把花木兰看做她爸，但是实际从军的是花木兰，而且，花木兰只能做她爸能做的事，在军营里是不可以化妆的。</p>
<p><strong>向下转型</strong>(较少)：子类的引用的指向子类对象，过程中必须要采取到强制转型。这个是之前向上造型过的子类对象仍然想执行子类的特有功能，所以需要重新恢复成子类对象<br>Parent p &#x3D; new Child();&#x2F;&#x2F;向上转型，此时，p是Parent类型<br>Child c &#x3D; (Child)p;&#x2F;&#x2F;此时，把Parent类型的p转成小类型Child<br>其实，相当于创建了一个子类对象一样，可以用父类的，也可以用自己的<br>说明：向下转型时，是为了方便使用子类的特殊方法，也就是说当子类方法做了功能拓展，就可以直接使用子类功能。<br>比如：花木兰打仗结束，就不需要再看做是她爸了，就可以”对镜贴花黄”了</p>
<h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());	<span class="comment">//40</span></span><br><span class="line">        System.out.println(a.sum1());	<span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>A a &#x3D; new B();是向上转型，调用方法看运行类型</strong><br><strong>a.sum()和a.sum1()分别输出40和30，这一点毫无疑问</strong></p>
<h3 id="动态绑定机制-调用对象方法"><a href="#动态绑定机制-调用对象方法" class="headerlink" title="动态绑定机制-调用对象方法"></a>动态绑定机制-调用对象方法</h3><p><strong>如果把上述子类中的sum()注释掉，结果会有什么不同</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这个时候a.sum()访问子类，发现子类中没有sum方法，再去访问父类，父类中有sum方法，调用的过程中getl()出现了分歧，父类和子类中都有getl()，该调用哪一个？</strong><br><strong>这里就体现出java的动态绑定机制</strong></p>
<blockquote>
<p><strong>java的动态绑定机制</strong><br><strong>1.当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</strong><br><strong>2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public int sum1()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>根据案例2中对动态绑定机制的描述，很容易分析出<br>a.sum()和a.sum1()分别输出30和20</strong></p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。而抽象类是指在普通类的结构里面增加抽象方法的组成部分。</p>
<p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而<strong>抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure>

<p>而拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。<br>定义一个抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: </span></span><br><span class="line"><span class="comment">//	Cannot instantiate the type A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	at com.wz.abstractdemo.TestDemo.main(TestDemo.java:15)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上可知，A是抽象的，无法直接进行实例化操作。为什么不能直接实例化呢？当一个类实例化之后，就意味着这个对象可以调用类中的属性或者放过了，但在抽象类里存在抽象方法，而抽象方法没有方法体，没有方法体就无法进行调用。既然无法进行方法调用的话，又怎么去产生实例化对象呢。</p>
<p>抽象类的使用原则如下：</p>
<ol>
<li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；</li>
<li>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；</li>
<li>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</li>
<li>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//B类是抽象类的子类，是一个普通类</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;<span class="comment">//强制要求覆写</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">		</span><br><span class="line">		a.print();<span class="comment">//被子类所覆写的过的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hello World!</span></span><br></pre></td></tr></table></figure>

<p>现在就可以清楚的发现：</p>
<ol>
<li>抽象类继承子类里面有明确的方法覆写要求，而普通类可以有选择性的来决定是否需要覆写；</li>
<li>抽象类实际上就比普通类多了一些抽象方法而已，其他组成部分和普通类完全一样；</li>
<li>普通类对象可以直接实例化，但抽象类的对象必须经过向上转型之后才可以得到。</li>
</ol>
<p>虽然一个类的子类可以去继承任意的一个普通类，可是从开发的实际要求来讲，普通类尽量不要去继承另外一个普通类，而是去继承抽象类。</p>
<p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong></p>
<h3 id="抽象类的使用限制"><a href="#抽象类的使用限制" class="headerlink" title="抽象类的使用限制"></a>抽象类的使用限制</h3><ol>
<li>抽象类中有构造方法，由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</li>
<li>抽象类不可以用final声明，因为抽象类必须有子类，而final定义的类不能有子类；</li>
<li>外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</li>
<li>可以直接调用抽象类中的static声明的方法，任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</li>
<li>有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类</li>
</ol>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<ol>
<li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<ol>
<li>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</li>
</ol>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<ol>
<li>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</li>
</ol>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<ol>
<li>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设 计。</li>
</ol>
</li>
<li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
<ol>
<li>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</li>
</ol>
</li>
</ol>
<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>有如下需求；</p>
<ul>
<li>有多个类，完成不同的任务job</li>
<li>要求统计得到的各自完成任务的时间</li>
</ul>
<p>抽象行为类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">time</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        job();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;运行时长为：&quot;</span> + (end - start) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>job_1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( <span class="string">&quot;aa =&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>job_2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( <span class="string">&quot;bb =&quot;</span> + num );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        AA aa = new AA();</span></span><br><span class="line"><span class="comment">//        aa.time();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        BB bb = new BB();</span></span><br><span class="line"><span class="comment">//        bb.time();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Template</span> <span class="variable">t_a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        t_a.time();</span><br><span class="line">        <span class="type">Template</span> <span class="variable">t_b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        t_b.time();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aa =3200040000</span></span><br><span class="line"><span class="comment">//运行时长为：1</span></span><br><span class="line"><span class="comment">//bb =200010000</span></span><br><span class="line"><span class="comment">//运行时长为：1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合。接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">class 子类 [extends 父类] [implemetns 接口<span class="number">1</span>,接口<span class="number">2</span>,...] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类只由抽象方法和全局常量组成，那么这种情况下不会将其定义为一个抽象类。只会定义为一个接口，所以接口严格的来讲属于一个特殊的类，而这个类里面只有抽象方法和全局常量，就连构造方法也没有。</p>
<p>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p>
<blockquote>
<p>解释：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</p>
</blockquote>
<p>定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。 </p>
<ul>
<li>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。</li>
<li>一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。</li>
<li>如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）</li>
<li>一个JAVA库中接口的例子是：Comparator 接口，这个接口代表了“能够进行比较”这种能力，任何类只要实现了这个Comparator接口的话，这个类也具备了“比较”这种能力，那么就可以用来进行排序操作了。</li>
</ul>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>由于接口里面存在抽象方法，所以接口对象不能直接使用关键字new进行实例化。接口的使用原则如下：</p>
<ol>
<li>接口必须要有子类，但此时一个子类可以使用implements关键字实现多个接口；</li>
<li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li>
<li>接口的对象可以利用子类对象的向上转型进行实例化。</li>
</ol>
<h3 id="实际应用（标准定义）"><a href="#实际应用（标准定义）" class="headerlink" title="实际应用（标准定义）"></a>实际应用（标准定义）</h3><p>在日常的生活之中，接口这一名词经常听到的，例如：USB接口、打印接口、充电接口等等。</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20161006002203942" alt="interface"></p>
<p>如果要进行开发，要先开发出USB接口标准，然后设备厂商才可以设计出USB设备。</p>
<p>现在假设每一个USB设备只有两个功能：安装驱动程序、工作。<br>定义一个USB的标准：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;   <span class="comment">// 操作标准       </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在电脑上应用此接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">plugin</span><span class="params">(USB usb)</span> &#123;</span><br><span class="line">          usb.install() ;</span><br><span class="line">          usb.work() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义USB设备—手机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装手机驱动程序。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;手机与电脑进行工作。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义USB设备—打印机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装打印机驱动程序。&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;进行文件打印。&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试主类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>() ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> <span class="title class_">Phone</span>()) ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装手机驱动程序。</span></span><br><span class="line"><span class="comment">//手机与电脑进行工作。</span></span><br><span class="line"><span class="comment">//安装打印机驱动程序。</span></span><br><span class="line"><span class="comment">//进行文件打印。</span></span><br></pre></td></tr></table></figure>

<h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol>
<li><p>接口不能被实例化</p>
</li>
<li><p>接口中所有的方法师public方法，接口中抽象方法，可以不用abstract修饰</p>
</li>
<li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p>
</li>
<li><p>抽象类实现接口，可以不用实现接口的方法</p>
</li>
<li><p>一个类可以实现多个接口</p>
</li>
<li><p>接口中的属性，只能是final的，而且是public static final修饰符，比如：</p>
<ol>
<li>&#96;&#96;&#96;java<br>int a &#x3D; 1;<br>&#x2F;&#x2F;实际上为<br>public static final int a &#x3D; 1;&#x2F;&#x2F;在接口中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 接口中属性的访问形式，接口名.属性名</span><br><span class="line"></span><br><span class="line">8. 一个接口不能继承其他的类，但是可以继承多个别的接口</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      interface A extends B,C&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>接口的修饰符只能是public和默认，这点和类的修饰符相同</p>
</li>
</ol>
<hr>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>代码块又称为初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p>
<h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[修饰符]&#123;</span></span><br><span class="line"><span class="comment">//	代码</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//普通代码块</span></span><br><span class="line">		&#123; </span><br><span class="line">		  ...普通代码块</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><p>也叫：实例代码块<br>定义在类中的代码块(不加修饰符)<br><strong>构造代码块一般用于初始化实例成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	&#123;  <span class="comment">//构造代码块</span></span><br><span class="line">        name = <span class="string">&quot;花花&quot;</span>;</span><br><span class="line">        sex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造代码块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>用 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>{ } 包裹起来的代码片段<br>只会执行一次，静态代码块优先于构造代码块执行，<strong>一般用于初始化静态成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">    money = <span class="number">100</span>;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是静态代码块！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919172541150.png" alt="image-20220919172541150"></p>
<p><strong>静态代码块在类加载时只执行一次</strong></p>
<p>在类加载阶段执行，在编译阶段时，编译器会将多个静态代码块按照定义的先后次序依次合并，最终放在生成的方法中</p>
<p>总结：</p>
<ul>
<li>静态代码块不管生成多少个对象，其只会执行一次</li>
<li>静态成员变量是类的属性，因此是在JVM加载类时开辟空间并初始化的</li>
<li>Java代码在经过编译器编译之后，如果要运行必须先要经过类加载子系统加载到JVM中才能运行</li>
<li>如果一个类中包含多个静态代码块，在编译代码时，编译器会按照定义的先后次序依次合并，最终放在生成的&lt;&gt;方法中，该方法在类加载时调用，并且只调用一次</li>
</ul>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>使用synchronized（）{}包裹起来的代码块，在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中</p>
<h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol>
<li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且他随着类的加载而执行，并且只会执行一次，如果时普通代码块，没创建一个对象，就执行一次</p>
</li>
<li><p>什么时候被加载</p>
<ol>
<li>普通代码块，创建对象实例时（new）创建一次，调用一次</li>
<li>创建子类对象实例，父类也会被加载（父类先被加载，子类后被加载）</li>
<li>使用类的静态成员时（静态属性，静态方法）</li>
</ol>
</li>
<li><p>普通的代码块，在创建对象实例时，会被隐式的调用，被创建一次就会调用一次，如果只是使用类的静态成员，普通代码块不会被执行</p>
</li>
<li><p>创建一个对象时，在一个类中的调用顺序：</p>
<ol>
<li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级语音，如果有多个静态代码块，和多个静态变量初始化，则按定义的顺序调用）</li>
<li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级语音，如果有多个普通代码块，和多个普通变量初始化，则按定义的顺序调用）</li>
<li>调用构造方法</li>
</ol>
</li>
<li><p>构造方法（构造器）的最前面隐含了super()和调用普通代码块。静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此时优先于构造器和普通代码块执行的</p>
</li>
<li><p>创建一个子列对象时（继承关系），静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法懂得调用顺序如下：</p>
<ol>
<li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>
<li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>
<li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>子类的构造方法</li>
</ol>
</li>
<li><p>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p>
</li>
</ol>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h3><blockquote>
<p>可以将一个类的定义放在里另一个类的内部，这就是内部类。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	我是一个外部类（外部是相对内部而言）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	我是一个内部类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><blockquote>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》</p>
</blockquote>
<p>也就是说内部类拥有类的基本特征。(eg：可以继承父类，实现接口。)在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。（注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，这里不推荐使用。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. Outer类继承了ClassA，实现了IFunctionA</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> <span class="keyword">extends</span> <span class="title class_">ClassA</span> <span class="keyword">implements</span> <span class="title class_">IFunctionA</span>&#123; </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	Inner类继承了ClassB，实现了IFunctionB</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> <span class="keyword">extends</span> <span class="title class_">ClassB</span> <span class="keyword">implements</span> <span class="title class_">IfunctionB</span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
</ol>
<p>具体来说，内部类信息（属性、方法）可以和外部类重名；内部类是具有类的基本特征的独立实体；可以利用访问修饰符隐藏内部类的实施细节，提供了更好的封装；静态内部类使用时可直接使用，不需先创造外部类。</p>
<h3 id="局部（方法）内部类"><a href="#局部（方法）内部类" class="headerlink" title="局部（方法）内部类"></a>局部（方法）内部类</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterType</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/** 局部内部类Inner*/</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>局部内部类类似方法的局部变量，所以在类外或者类的其他方法中不能访问这个内部类，但这并不代表局部内部类的实例和定义了它的方法中的局部变量具有相同的生命周期。</li>
<li>只能在方法内部，类（局部内部类）定义之后使用，不存在外部可见性问题，因此没有访问修饰符，但是可以使用final 或 abstract修饰。</li>
<li>不能在局部内部类中使用可变的局部变量</li>
<li>可以访问外围类的成员变量。如果是static方法，则只能访问static修饰的成员变量</li>
<li>作用域：仅仅在定义他的方法或代码块中</li>
<li>如果外部类和局部内部类的成员重名，默认遵循就近原则，如果访问外部类的成员，使用  外部类名.this.成员 去访问</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote>
<p><strong>一个接口&#x2F;类的</strong>方法的<strong>某个实现方式</strong>在程序中<strong>只会执行一次</strong>，但为了使用它，我们需要创建它的实现类&#x2F;<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>去实现&#x2F;重写。此时可以使用匿名内部类的方式，可以无需创建新的类，<strong>减少代码冗余</strong></p>
</blockquote>
<p>假设当前有一个接口，接口中只有一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使用该接口的show方法，我们需要去创建一个实现类，同时书写show方法的具体实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01Impl</span> <span class="keyword">implements</span> <span class="title class_">Interface01</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a impl class...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实现类Interface01Impl全程只使用一次，那么为了这一次的使用去创建一个类，未免太过麻烦。我们需要一个方式来帮助我们摆脱这个困境。匿名内部类则可以很好的解决这个问题。</p>
<p>我们使用匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Interface01</span> <span class="variable">interface01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interface01</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里使用了匿名内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//调用接口方法</span></span><br><span class="line">    interface01.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了匿名内部类</span></span><br></pre></td></tr></table></figure>

<h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 接口/类名(参数<span class="number">1</span>, 参数<span class="number">2.</span>..)&#123;</span><br><span class="line">    实现方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    实现方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在上文代码编译后，我们查看一下class文件的路径</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/BxrQZd.png" alt="BxrQZd.png"></p>
<p>再反编译一下看看</p>
<p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/BxsW1f.png" alt="BxsW1f.png"></p>
<p>至此，我们可以得知，匿名内部类在编译期间，会生成一个名称以<code>$编号</code>结尾的class文件，即<strong>它被识别为一个真实的类</strong>，仅在编译前（java文件）为匿名的形态。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>设存在具体类Class01，抽象类AbstractClass01，接口Interface01</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啦啦啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass01</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类TestInner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重写具体类的方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;具体类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写抽象类的抽象方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClass01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;抽象类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现接口的抽象方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Interface01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;接口&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是一个具体类</span></span><br><span class="line"><span class="comment">//我是一个抽象类</span></span><br><span class="line"><span class="comment">//我是一个接口</span></span><br></pre></td></tr></table></figure>

<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><strong>成员内部类</strong> ：定义在<strong>外部类中方法外</strong>的类</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类名 [extends 外部类的父类] [implements 外部类的父接口们] &#123;</span><br><span class="line">    [修饰符] class 内部类名 [extends 非静态内部类自己的父类] [implements 非静态内部类的父接口们] &#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 外部类的其他成员列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%96%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">外部类</a>、内部类的父类、父接口没有关系，各是各的</p>
</blockquote>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>成员内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和符 号 。 例 如 ： O u t e r 符号。例如：Outer符号。例如：OuterInner.class</li>
<li>成员内部类可以使用修饰符public，protected，缺省，private</li>
<li>成员内部类还可以使用final或abstract修饰</li>
<li>成员内部类中不可以声明静态成员</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的。如果成员内部类有与外部类的非静态属性重名时，可以通过“外部类名.this.属性”进行区别，如果与外部类的静态属性重名时，可以通过“外部类名.类变量”进行区别</li>
<li>外部类要访问内部类的成员，必须要建立内部类的对象</li>
</ul>
<h4 id="使用成员内部类"><a href="#使用成员内部类" class="headerlink" title="使用成员内部类"></a>使用成员内部类</h4><ul>
<li><p>在外部类中使用成员内部类</p>
<ul>
<li>在外部类的静态成员中不能使用非静态的成员内部类</li>
<li>在外部类的非静态成员中，直接创建内部类的对象来访问内部类的属性与方法。此时把它当做一个普通的类即可</li>
</ul>
</li>
<li><p>在外部类的外面使用成员内部类：</p>
<ul>
<li><p>要么通过外部类的对象，去创建内部类的对象</p>
</li>
<li><p>&#96;&#96;&#96;java<br>外部类名 外部对象名 &#x3D; new 外部类型();<br>内部类名 对象名 &#x3D; 外部对象名.new 外部类型();<br>&#x2F;&#x2F;可合并为：<br>外部类名.内部类名 对象名 &#x3D; new 外部类型().new 内部类型();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 要么通过外部类的对象，去获取内部类的对象</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Outer out = new Outer();</span><br><span class="line">  Outer.Inner in  = out.getInner();</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outerMethod();</span><br><span class="line">		<span class="comment">//通过外部类的对象，去创建内部类的对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        oi.innerMethod();</span><br><span class="line">		<span class="comment">//通过外部类的对象，去获取内部类的对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">obj</span> <span class="operator">=</span> out.getInner();</span><br><span class="line">        obj.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">/*Inner in = new Inner();//错误，静态成员中不能使用非静态成员内部类</span></span><br><span class="line"><span class="comment">		in.innerMethod();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的方法&quot;</span>);</span><br><span class="line">		<span class="comment">/*Inner in = new Inner();//可以</span></span><br><span class="line"><span class="comment">		in.innerMethod();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法访问外部类的私有非静态属性：&quot;</span>+Outer.<span class="built_in">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法访问外部类的私有静态属性：&quot;</span>+Outer.b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过外部类的某个方法返回内部类的对象</span></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有非静态属性：1</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有静态属性：2</span></span><br><span class="line"><span class="comment">//内部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有非静态属性：1</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有静态属性：2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义在<strong>外部类中方法外</strong>，使用 <code>static</code> 修饰的类</p>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类名 [extends 外部类的父类] [implements 外部类的父接口们] &#123;</span><br><span class="line">	[修饰符] <span class="keyword">static</span> class 内部类名 [extends 静态内部类自己的父类] [implements 静态内部类的父接口们] &#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="comment">// 外部类的其他成员列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>静态内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和符 号 。 例 如 ： O u t e r 符号。例如：Outer符号。例如：OuterInner.clas</li>
<li>静态内部类可以使用修饰符public，protected，default，private</li>
<li>静态内部类还可以使用final或abstract修饰</li>
<li>静态内部类中可以声明静态成员</li>
<li>静态内部类可以直接使用外部类的静态成员，包括私有的。但不能使用外部类的非静态成员。</li>
<li>静态内部类中有与外部类的静态属性重名时，如果要使用外部类的属性，那么用“外部类名.属性”</li>
</ul>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ul>
<li>在外部类中使用静态内部类：就和使用其他普通类一样</li>
<li>在外部类的外面使用成员内部类：<ul>
<li>使用静态内部类的静态成员：外部类名.静态内部类名.静态内部类的静态成员</li>
<li>使用静态内部类的非静态成员：外部类名.静态内部类名 obj &#x3D; new 外部类名.静态内部类名(); obj.静态内部类的非静态成员</li>
</ul>
</li>
</ul>
<h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.StaticInnerClass.innerStaticMethod();</span><br><span class="line">        Outer.<span class="type">StaticInnerClass</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInnerClass();</span><br><span class="line">        os.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        StaticInnerClass.innerStaticMethod();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        StaticInnerClass.innerStaticMethod();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">innerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的非静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.java265.com/JavaCourse/202109/1153.html">一篇文章让你彻底理解Java的单例设计模式 (java265.com)</a></p>
</blockquote>
<p>   <strong>单例（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Singleton&spm=1001.2101.3001.7020">Singleton</a>）模式的定义</strong>：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p>
<p>   在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p>
<p>   单例模式有 3 个特点：</p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>
</ol>
<h3 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h3><p>   单例模式是<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<p>   下面来分析其基本结构和实现方法。</p>
<h4 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h4><p>   单例模式的主要角色如下。</p>
<ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<p>   <img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c7c2f601aebbe257b1036cb74b93d339.gif" alt="img"></p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="(饿汉式)"></a>(饿汉式)</h4><p>   该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="(懒汉式)"></a>(懒汉式)</h4><p>   该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p>
<h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p>
<ul>
<li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Unfall</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://unfall.top/2022/05/15/Java-oop/">https://unfall.top/2022/05/15/Java-oop/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://unfall.top" target="_blank">Unfall_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/"><img class="prev-cover" src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20220406165022.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在线工具+资源</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/15/JavaSE/"><img class="next-cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/" title="JAVA中的与和或（||，|，&&，&）"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">JAVA中的与和或（||，|，&&，&）</div></div></a></div><div><a href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">Java_动态绑定机制</div></div></a></div><div><a href="/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/" title="SDK和API的区别（转)"><img class="cover" src="https://img2.baidu.com/it/u=2890406970,1556514476&fm=253&fmt=auto&app=138&f=JPEG?w=898&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">SDK和API的区别（转)</div></div></a></div><div><a href="/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-28</div><div class="title">网络编程</div></div></a></div><div><a href="/2022/11/10/%E9%9B%86%E5%90%88%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="集合中常见的数据结构"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20221110201439.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">集合中常见的数据结构</div></div></a></div><div><a href="/2022/12/31/Java-%E5%8F%8D%E5%B0%84/" title="Java_反射"><img class="cover" src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-31</div><div class="title">Java_反射</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/03/08/bcZYpd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Unfall</div><div class="author-info__description">堂前种新树，花开已十年</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Unfalll"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:3201864395@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3201864395&amp;site=qq&amp;menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="https://steamcommunity.com/id/3201864395/" target="_blank" title=""><i class="fab fa-steam-symbol"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=295405999" target="_blank" title=""><i class="fas fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">顺其自然 无为而治</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">什么是面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">类的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">类的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">类的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%AF%AD%E6%B3%95%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">方法定义，语法机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">修饰符列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">返回值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">3.2.5.</span> <span class="toc-text">方法名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.6.</span> <span class="toc-text">形式参数列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BD%93"><span class="toc-number">3.2.7.</span> <span class="toc-text">方法体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">调用方法的三种形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">方法的调用机制分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">成员方法传参机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">3.5.</span> <span class="toc-text">方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">3.5.2.</span> <span class="toc-text">方法重载的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.4.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">3.6.</span> <span class="toc-text">方法的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.8.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.8.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">3.8.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.9.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.9.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.9.2.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%88%E6%88%96%E8%80%85%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">3.9.3.</span> <span class="toc-text">全局变量（或者属性）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-x2F-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">3.10.</span> <span class="toc-text">构造方法&#x2F;构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.10.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.10.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.10.3.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-x2F-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.10.4.</span> <span class="toc-text">注意事项&#x2F;使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-x2F-%E6%9C%89%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.11.</span> <span class="toc-text">使用super调用父类的无参数构造方法&#x2F;有参数构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static"><span class="toc-number">4.</span> <span class="toc-text">Static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.1.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%B0%83%E4%B8%80%E4%B8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">强调一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">4.3.</span> <span class="toc-text">static关键字的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">static方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">static变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%9D%97"><span class="toc-number">4.6.</span> <span class="toc-text">static块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text">static块的作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">类变量的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">类变量的定义语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">访问类变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">5.4.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-x2F-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.5.</span> <span class="toc-text">关于静态变量&#x2F;类变量在内存中的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">调用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">5.8.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.9.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">5.9.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.9.2.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.9.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.10.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final"><span class="toc-number">6.</span> <span class="toc-text">Final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0"><span class="toc-number">6.2.</span> <span class="toc-text">final修饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">6.3.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main"><span class="toc-number">7.</span> <span class="toc-text">main</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.2.</span> <span class="toc-text">详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">7.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">8.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.0.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">8.0.2.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">9.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="toc-number">9.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">9.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3"><span class="toc-number">9.3.</span> <span class="toc-text">图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">重写和隐藏父类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.</span> <span class="toc-text">重写父类中的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E5%90%8E%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">9.6.</span> <span class="toc-text">方法重写和隐藏后的修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-number">9.7.</span> <span class="toc-text">子类访问父类私有成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">10.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">多态基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">10.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">10.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">10.4.</span> <span class="toc-text">实现多态的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.5.</span> <span class="toc-text">多态的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.6.</span> <span class="toc-text">多态的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">10.7.</span> <span class="toc-text">向上转型和向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">10.8.</span> <span class="toc-text">动态绑定机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6-%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">10.9.</span> <span class="toc-text">动态绑定机制-调用对象方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"><span class="toc-number">11.3.</span> <span class="toc-text">抽象类的使用限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">11.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.5.</span> <span class="toc-text">模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">12.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">12.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">12.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%88%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">12.4.</span> <span class="toc-text">实际应用（标准定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-1"><span class="toc-number">12.5.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">13.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">13.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">13.2.</span> <span class="toc-text">普通代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">13.3.</span> <span class="toc-text">构造代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">13.4.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">13.5.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-2"><span class="toc-number">13.6.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB-1"><span class="toc-number">14.1.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9B%A0"><span class="toc-number">14.2.</span> <span class="toc-text">使用原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.3.</span> <span class="toc-text">局部（方法）内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">14.3.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">14.3.2.</span> <span class="toc-text">规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.4.</span> <span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">14.4.1.</span> <span class="toc-text">基本格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.4.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.4.3.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.5.</span> <span class="toc-text">成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">14.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">14.5.2.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">14.5.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.5.4.</span> <span class="toc-text">使用成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">14.5.5.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.6.</span> <span class="toc-text">静态内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">14.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">14.6.2.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">14.6.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">14.6.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-1"><span class="toc-number">14.6.5.</span> <span class="toc-text">代码演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.</span> <span class="toc-text">单例模式的结构与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">15.2.1.</span> <span class="toc-text">单例模式的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">15.2.2.</span> <span class="toc-text">(饿汉式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">15.2.3.</span> <span class="toc-text">(懒汉式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.3.</span> <span class="toc-text">单例模式的应用场景</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_动态绑定机制"/></a><div class="content"><a class="title" href="/2023/02/09/Java-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/" title="Java_动态绑定机制">Java_动态绑定机制</a><time datetime="2023-02-09T11:43:03.000Z" title="发表于 2023-02-09 19:43:03">2023-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/02/Mysql/" title="Mysql"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20230102165739.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql"/></a><div class="content"><a class="title" href="/2023/01/02/Mysql/" title="Mysql">Mysql</a><time datetime="2023-01-02T08:50:43.000Z" title="发表于 2023-01-02 16:50:43">2023-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/Java-%E5%8F%8D%E5%B0%84/" title="Java_反射"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_反射"/></a><div class="content"><a class="title" href="/2022/12/31/Java-%E5%8F%8D%E5%B0%84/" title="Java_反射">Java_反射</a><time datetime="2022-12-31T02:45:41.000Z" title="发表于 2022-12-31 10:45:41">2022-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程"/></a><div class="content"><a class="title" href="/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程">网络编程</a><time datetime="2022-12-28T06:11:45.000Z" title="发表于 2022-12-28 14:11:45">2022-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/Java_IO%E6%B5%81/" title="Java_IO流"><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20220818121632.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java_IO流"/></a><div class="content"><a class="title" href="/2022/12/12/Java_IO%E6%B5%81/" title="Java_IO流">Java_IO流</a><time datetime="2022-12-12T07:43:29.000Z" title="发表于 2022-12-12 15:43:29">2022-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Unfall</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">愿世间美好与你环环相扣</div></div><div class="container" id="jsi-flying-fish-container"><script src="js/fish.js"></script></div><style>   @media only screen and (max-width: 767px){
   #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MBASlFAQqPMdjRJ7U5EeKDAP-MdYXbMMI',
      appKey: 'xrU9dH0DPN2JDUfDYKDpxoXQ',
      placeholder: '昵称输入QQ号自动获取头像邮箱',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://unfall.top/2022/05/15/Java-oop/'
    this.page.identifier = '2022/05/15/Java-oop/'
    this.page.title = 'Java_oop'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js"></script><canvas id="universe"></canvas><script defer src="/js/myjs.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>