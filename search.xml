<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基本功|Java即时编译器原理解析及实践</title>
      <link href="/2022/08/18/%E5%9F%BA%E6%9C%AC%E5%8A%9F-Java%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/08/18/%E5%9F%BA%E6%9C%AC%E5%8A%9F-Java%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、导读"><a href="#一、导读" class="headerlink" title="一、导读"></a>一、导读</h2><p>常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。</p><p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p><p>即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</p><h2 id="二、Java的执行过程"><a href="#二、Java的执行过程" class="headerlink" title="二、Java的执行过程"></a>二、Java的执行过程</h2><p>Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。</p><p>怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/ba83857ecf9f344e4972fd551c4973d653952.png@648w_454h_80q" alt="img"></p><h3 id="1-JVM中的编译器"><a href="#1-JVM中的编译器" class="headerlink" title="1. JVM中的编译器"></a>1. JVM中的编译器</h3><p>JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。</p><p><strong>Client Compiler</strong></p><p>HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</p><ul><li>局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。</li><li>将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。</li><li>最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。</li></ul><p><strong>Server Compiler</strong></p><p>Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。</p><p><strong>C2 Compiler</strong></p><p>在Hotspot VM中，默认的Server Compiler是C2编译器。</p><p>C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。</p><p>Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。</p><p>无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/4c33853195a4e5e11951a6324a698b6c108881.png@823w_864h_80q" alt="img"></p><p><strong>Graal Compiler</strong></p><p>从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：</p><ul><li>前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。</li><li>使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。</li><li>更深层次的优化，比如虚函数的内联、部分逃逸分析等。</li></ul><p>Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。</p><h3 id="2-分层编译"><a href="#2-分层编译" class="headerlink" title="2. 分层编译"></a>2. 分层编译</h3><p>在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</p><ol><li>解释执行。</li><li>执行不带profiling的C1代码。</li><li>执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。</li><li>执行带所有profiling的C1代码。</li><li>执行C2代码。</li></ol><p>profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。</p><p>通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&gt;2层&gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：</p><p><img src="https://p0.meituan.net/travelcube/9dee40c45e1abb392243e07666ff6d5b79153.png@863w_680h_80q" alt="img"></p><ul><li>图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</li><li>如果方法比较小（比如Java服务中常见的getter&#x2F;setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</li><li>在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</li><li>前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</li><li>如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</li></ul><p>总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。</p><h3 id="3-即时编译的触发"><a href="#3-即时编译的触发" class="headerlink" title="3. 即时编译的触发"></a>3. 即时编译的触发</h3><p>Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：</p><p>循环回边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(Object obj) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</p><p>字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(java.lang.Object);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_0</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: sipush        200</span><br><span class="line">       8: if_icmpge     21</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: iload_2</span><br><span class="line">      13: iadd</span><br><span class="line">      14: istore_1</span><br><span class="line">      15: iinc          2, 1</span><br><span class="line">      18: goto          4</span><br><span class="line">      21: return</span><br></pre></td></tr></table></figure><p>在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。</p><p>当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</p><p>开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：</p><ul><li>方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</li><li>方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</li></ul><p>分层编译触发条件公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s) </span><br><span class="line">i为调用次数，b是循环回边次数</span><br></pre></td></tr></table></figure><p>上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。</p><h2 id="三、编译优化"><a href="#三、编译优化" class="headerlink" title="三、编译优化"></a>三、编译优化</h2><p>即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</p><h3 id="1-中间表达形式（Intermediate-Representation）"><a href="#1-中间表达形式（Intermediate-Representation）" class="headerlink" title="1. 中间表达形式（Intermediate Representation）"></a>1. 中间表达形式（Intermediate Representation）</h3><p>在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</p><p>Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：</p><p>SSA IR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a = 1;</span><br><span class="line">  a = 2;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以轻易地发现a &#x3D; 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</p><p>上面代码的SSA IR形式的伪代码可以表示为：</p><p>SSA IR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a_1 = 1;</span><br><span class="line">  a_2 = 2;</span><br><span class="line">  b_1 = a_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</p><p>除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a = 2;</span><br><span class="line">  int b = 0</span><br><span class="line">  if(2 &gt; 1)&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    b = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到SSA IR伪代码：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_1 = 2;</span><br><span class="line">b_1 = 0</span><br><span class="line">if true:</span><br><span class="line">  a_2 = 1;</span><br><span class="line">else</span><br><span class="line">  b_2 = 2;</span><br><span class="line">add(a,b)</span><br></pre></td></tr></table></figure><p>编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">  int b = 0;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</p><p><strong>C1中的中间表达形式</strong></p><p>前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</p><p>HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/ecc6e309ee4a8f36cab407a6b5989c9b21165.png@262w_611h_80q" alt="img"></p><p>其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</p><p>从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：</p><p>字节码构造HIR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  字节码                     Local Value             operand stack              HIR</span><br><span class="line">5: iload_1                  [i1,i2]                 [i1]</span><br><span class="line">6: iload_2                  [i1,i2]                 [i1,i2]   </span><br><span class="line">                            ................................................   i3: i1 * i2</span><br><span class="line">7: imul                                   </span><br><span class="line">8: istore_3                 [i1,i2，i3]              [i3]</span><br></pre></td></tr></table></figure><p>可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。</p><p>C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</p><p><strong>Sea-of-Nodes IR</strong></p><p>C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：</p><p>example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int foo(int count) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的IR图如下所示：</p><p><img src="https://p0.meituan.net/travelcube/42ae260309e69d543bfdc4e7c3e1ea9a164249.png@1368w_1260h_80q" alt="img"></p><p>图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</p><p>这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</p><p>依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</p><p><strong>Phi And Region Nodes</strong></p><p>Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。</p><p>example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">int a = 0;</span><br><span class="line">  if(x == 1) &#123;</span><br><span class="line">    a = 5;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：</p><p><img src="https://p0.meituan.net/travelcube/41c8d6188f478a93566c2573b8ce263150102.png@631w_930h_80q" alt="img"></p><p>Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</p><p>Phi Nodes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">  a_1 = 0;</span><br><span class="line">  if(x == 1)&#123;</span><br><span class="line">    a_2 = 5;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    a_3 = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  a_4 = Phi(a_2,a_3);</span><br><span class="line">  return a_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Global Value Numbering</strong></p><p>Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</p><p>GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：</p><p>GVN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b = 2;</span><br><span class="line">c = a + b;</span><br><span class="line">d = a + b;</span><br><span class="line">e = d;</span><br></pre></td></tr></table></figure><p>GVN会利用Hash算法编号，计算a &#x3D; 1时，得到编号1，计算b &#x3D; 2时得到编号2，计算c &#x3D; a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d &#x3D; a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e &#x3D; d也可以由Hash表中查到而进行复用。</p><p>可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</p><h3 id="2-方法内联"><a href="#2-方法内联" class="headerlink" title="2.方法内联"></a>2.方法内联</h3><p>方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</p><p>Java服务中存在大量getter&#x2F;setter方法，如果没有方法内联，在调用getter&#x2F;setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter&#x2F;setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter&#x2F;setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：</p><p>方法内联的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean flag = true;</span><br><span class="line">public static int value0 = 0;</span><br><span class="line">public static int value1 = 1;</span><br><span class="line"></span><br><span class="line">public static int foo(int value) &#123;</span><br><span class="line">    int result = bar(flag);</span><br><span class="line">    if (result != 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int bar(boolean flag) &#123;</span><br><span class="line">    return flag ? value0 : value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bar方法的IR图：</p><p><img src="https://p1.meituan.net/travelcube/857398429cf23f82f291a9cbaceecea122617.png@794w_480h_80q" alt="img"></p><p>内联后的IR图：</p><p><img src="https://p0.meituan.net/travelcube/524631fb0c1db243b5b1fd08b185c23f59399.png@802w_1202h_80q" alt="img"></p><p>内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</p><p>被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</p><p>调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号&#x3D;&#x3D;节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</p><p>如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</p><p><strong>方法内联的条件</strong></p><p>编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</p><p>可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：</p><p><img src="https://p0.meituan.net/travelcube/5edc4a89d148535e6e4ef659a61882fc128193.png@1350w_612h_80q" alt="img"></p><p><strong>虚函数内联</strong></p><p>内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</p><p>C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：</p><p>virtual call</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj = new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 = new VirtualInvoke1();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000113369d37: callq  0x00000001132950a0  ; OopMap&#123;off=476&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  //代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 18)</span><br><span class="line">                                               ;   &#123;optimized virtual_call&#125;  //虚调用已经被优化</span><br></pre></td></tr></table></figure><p>可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</p><p>比如下面这段代码，我们增加一个实现：</p><p>多实现的虚调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj = new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 = new VirtualInvoke1();</span><br><span class="line">        VirtualInvoke2 obj2 = new VirtualInvoke2();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        invokeMethod(obj2);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class VirtualInvoke2 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反编译得到下面的汇编代码：</p><p>代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000000011f5f0a37: callq  0x000000011f4fd2e0  ; OopMap&#123;off=28&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  //代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 20)</span><br><span class="line">                                               ;   &#123;virtual_call&#125;  //虚调用未被优化</span><br></pre></td></tr></table></figure><p>可以看到多个实现的虚调用未被优化，依然是virtual_call。</p><p>Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。</p><h3 id="3-逃逸分析"><a href="#3-逃逸分析" class="headerlink" title="3. 逃逸分析"></a>3. 逃逸分析</h3><p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：</p><ol><li>对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。</li><li>对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</li></ol><p>逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      example();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void example() &#123;</span><br><span class="line">      Foo foo = new Foo();</span><br><span class="line">      Bar bar = new Bar();</span><br><span class="line">      bar.setFoo(foo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Foo &#123;&#125;</span><br><span class="line"></span><br><span class="line">  class Bar &#123;</span><br><span class="line">    private Foo foo;</span><br><span class="line">    public void setFoo(Foo foo) &#123;</span><br><span class="line">      this.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</p><p><strong>锁消除</strong></p><p>在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</p><p>如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</p><p><strong>栈上分配</strong></p><p>我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：</p><p>标量替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    Cat cat = new Cat(1,10);</span><br><span class="line">    addAgeAndWeight(cat.age,Cat.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    int age = 1;</span><br><span class="line">    int weight = 10;</span><br><span class="line">    addAgeAndWeight(age,weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>部分逃逸分析</strong></p><p>部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</p><h3 id="4-Loop-Transformations"><a href="#4-Loop-Transformations" class="headerlink" title="4. Loop Transformations"></a>4. Loop Transformations</h3><p>在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。</p><p><strong>循环展开</strong></p><p>循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。</p><p>循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：</p><p>循环展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i = 0;i&lt;200;i++)&#123;</span><br><span class="line">    delete(i);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：</p><p>循环展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i = 0;i&lt;200;i+=5)&#123;</span><br><span class="line">    delete(i);</span><br><span class="line">    delete(i+1);</span><br><span class="line">    delete(i+2);</span><br><span class="line">    delete(i+3);</span><br><span class="line">    delete(i+4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</p><p><strong>循环分离</strong></p><p>循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：</p><p>循环分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] = x[i] + x[a];</span><br><span class="line">  a = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这段代码除了第一次循环a &#x3D; 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：</p><p>循环分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[0] = x[0] + 10;</span><br><span class="line">for(int i = 1;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] = x[i] + x[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</p><h3 id="5-窥孔优化与寄存器分配"><a href="#5-窥孔优化与寄存器分配" class="headerlink" title="5. 窥孔优化与寄存器分配"></a>5. 窥孔优化与寄存器分配</h3><p>前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：</p><p>强度削减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y1=x1*3  经过强度削减后得到  y1=(x1&lt;&lt;1)+x1</span><br></pre></td></tr></table></figure><p>编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</p><p>寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</p><p>寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><p>即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。</p><h3 id="1-编译相关的重-要参数"><a href="#1-编译相关的重-要参数" class="headerlink" title="1. 编译相关的重* 要参数"></a>1. 编译相关的重* 要参数</h3><ul><li>-XX:+TieredCompilation：开启分层编译，JDK8之后默认开启</li><li>-XX:+CICompilerCount&#x3D;N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 &#x3D; 1:2</li><li>-XX:TierXBackEdgeThreshold：OSR编译的阈值</li><li>-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</li><li>-XX:TierXCompileThreshold：开启分层编译后的编译阈值</li><li>-XX:ReservedCodeCacheSize：codeCache最大大小</li><li>-XX:InitialCodeCacheSize：codeCache初始大小</li></ul><p>-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。</p><p>由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。</p><h3 id="2-通过JITwatch分析编译日志"><a href="#2-通过JITwatch分析编译日志" class="headerlink" title="2. 通过JITwatch分析编译日志"></a>2. 通过JITwatch分析编译日志</h3><p>通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile&#x3D;LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/5d82c16cf7739e16b1de7e5f5fa53123555106.png%25403360w_2099h_80q" alt="img"><img src="https://p0.meituan.net/travelcube/1a2cb3082b79eb778360e79f5acd1e83545877.png@3360w_2033h_80q" alt="img"></p><p>如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：</p><p><img src="https://p0.meituan.net/travelcube/b089edabd2fa9bb1fc7f068df79c8c8361195.png@1920w_218h_80q" alt="img"></p><p>我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。</p><p>区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。</p><h3 id="3-使用Graal编译器"><a href="#3-使用Graal编译器" class="headerlink" title="3. 使用Graal编译器"></a>3. 使用Graal编译器</h3><p>由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。</p><p>为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。</p><p>前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</p><p>前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。</p><p>这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。</p><p><strong>使用Graal编译器后性能表现</strong></p><p>在我们的线上服务中，启用Graal编译后，TP9999从60ms -&gt; 50ms ，下降10ms，下降幅度达16.7%。</p><p>运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。</p><p><strong>Graal编译器的问题</strong></p><p>Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。</p><p>考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><ul><li>《深入理解Java虚拟机》</li><li>《Proceedings of the Java™ Virtual Machine Research and Technology Symposium》Monterey, California, USA April 23–24, 2001</li><li>《Visualization of Program Dependence Graphs》 Thomas Würthinger</li><li>《深入拆解Java虚拟机》 郑宇迪</li><li><a href="https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ">JIT的Profile神器JITWatch</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线工具+资源</title>
      <link href="/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/"/>
      <url>/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="在线工具-资源"><a href="#在线工具-资源" class="headerlink" title="在线工具+资源"></a>在线工具+资源</h1><h3 id="常用-x2F-未归类"><a href="#常用-x2F-未归类" class="headerlink" title="常用&#x2F;未归类"></a>常用&#x2F;未归类</h3><ul><li>有道翻译：<a href="https://fanyi.youdao.com/">https://fanyi.youdao.com</a></li><li>谷歌翻译：<a href="https://translate.google.cn/">https://translate.google.cn</a></li><li>蓝奏云盘：<a href="https://pc.woozooo.com/u">https://pc.woozooo.com/u</a></li><li>免费4k视频：<a href="https://www.4kdv.com/">https://www.4kdv.com</a></li><li>日本域名申请：<a href="https://www.value-domain.com/">https://www.value-domain.com</a></li><li><code>大量在线工具（网站内右上角搜索想要的工具）</code>：<a href="https://www.fly63.com/tool/home.html">https://www.fly63.com/tool/home.html</a></li><li>在线代码截图工具：<a href="https://carbon.now.sh/">https://carbon.now.sh/</a></li><li>在线短链接工具：<a href="https://urlify.cn/">https://urlify.cn/</a></li><li>0x3.me 短网址：<a href="https://0x3.me/">https://0x3.me</a></li></ul><h3 id="免费软件、资源下载"><a href="#免费软件、资源下载" class="headerlink" title="免费软件、资源下载"></a>免费软件、资源下载</h3><ul><li>吾爱破解论坛：<a href="https://52pojie.cn/">https://52pojie.cn/</a></li><li>免费正版Windows系统：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a></li><li>免费Mac软件：<a href="https://www.macwk.com/">https://www.macwk.com</a></li><li>小蚂蚁资源网：<a href="https://www.xmy7.com/">https://www.xmy7.com</a></li></ul><h3 id="视频、音频、图片、壁纸、二维码"><a href="#视频、音频、图片、壁纸、二维码" class="headerlink" title="视频、音频、图片、壁纸、二维码"></a>视频、音频、图片、壁纸、二维码</h3><ul><li>在线多媒体转换器合集：<a href="https://cn.office-converter.com/">https://cn.office-converter.com/</a></li><li>视频转GIF工具：<a href="http://www.fly63.com/tool/giftxt/">http://www.fly63.com/tool/giftxt/</a></li><li>在线音频剪辑：<a href="https://www.weixinsyt.com/">https://www.weixinsyt.com/</a></li><li>在线视频剪辑：<a href="https://www.kapwing.com/">https://www.kapwing.com/</a></li></ul><hr><ul><li>SVG转PNG工具：<a href="http://www.fly63.com/tool/svg2img/">http://www.fly63.com/tool/svg2img/</a></li><li>JPG 转换成WEBP：<a href="https://onlineconvertfree.com/zh/convert-format/jpg-to-webp/">https://onlineconvertfree.com/zh/convert-format/jpg-to-webp/</a></li><li>图片压缩：<a href="https://tinypng.com/">https://tinypng.com</a></li><li>图片智能放大工具：<a href="https://bigjpg.com/">https://bigjpg.com/</a></li></ul><hr><ul><li>在线抠图工具：<a href="https://www.remove.bg/zh">https://www.remove.bg/zh</a></li><li>在线PS：<a href="https://www.uupoop.com/#/old">https://www.uupoop.com/#/old</a></li><li>在线海报设计工具：<a href="https://www.designcap.com/">https://www.designcap.com/</a></li></ul><hr><ul><li>免费透明背景图片素材：<a href="http://pngimg.com/">http://pngimg.com/</a></li><li>免费PNG图片库：<a href="https://pluspng.com/">https://pluspng.com/</a></li><li>Pixabay图片素材库：<a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></li><li>Unsplash图片素材库：<a href="https://unsplash.com/">https://unsplash.com/</a></li><li>Pexels图片素材库：<a href="http://www.pexels.com/">http://www.pexels.com/</a></li><li>NASA图片视频素材库：<a href="https://images.nasa.gov/">https://images.nasa.gov/</a></li><li>千库网：<a href="https://588ku.com/">https://588ku.com</a></li><li>PngPix：<a href="https://www.pngpix.com/download/tag/fire">https://www.pngpix.com/download/tag/fire</a></li></ul><hr><ul><li>极简壁纸：<a href="https://bz.zzzmh.cn/">https://bz.zzzmh.cn/</a></li><li>Wallpaper Abyss壁纸：<a href="https://wall.alphacoders.com/">https://wall.alphacoders.com/</a></li><li>免费壁纸下载：<a href="https://wallhaven.cc/">https://wallhaven.cc</a></li></ul><hr><ul><li>二维码在线生成器：<a href="http://www.fly63.com/tool/ewm/">http://www.fly63.com/tool/ewm/</a></li><li>二维码在线解码：<a href="http://www.fly63.com/php/decoder/">http://www.fly63.com/php/decoder/</a></li><li>二维码美化器：<a href="https://mh.cli.im/">https://mh.cli.im/</a></li></ul><h3 id="图床、思维导图、流程图"><a href="#图床、思维导图、流程图" class="headerlink" title="图床、思维导图、流程图"></a>图床、思维导图、流程图</h3><ul><li>路过图床：<a href="https://imgtu.com/">https://imgtu.com</a></li><li>sm.ms图床：<a href="https://sm.ms/">https://sm.ms</a></li><li>图壳图床：<a href="https://imgkr.com/">https://imgkr.com/</a></li><li>图片上传 | PicX 图床神器：<a href="https://picx.xpoet.cn/">https://picx.xpoet.cn/</a></li></ul><hr><ul><li>在线画图工具ProcessOn：<a href="https://www.processon.com/">https://www.processon.com/</a></li><li>在线画图工具Draw.io：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a></li><li>在线思维导图工具MindLine：<a href="http://www.mindline.cn/webapp">http://www.mindline.cn/webapp</a></li></ul><h3 id="ICO、字体图标、logo、Emoji表情"><a href="#ICO、字体图标、logo、Emoji表情" class="headerlink" title="ICO、字体图标、logo、Emoji表情"></a>ICO、字体图标、logo、Emoji表情</h3><ul><li>ICO图标在线生成：<a href="http://www.fly63.com/php/ico/">http://www.fly63.com/php/ico/</a></li><li>ico图标包：[ICO_Sweet_Paranoia.rar：<a href="https://wws.lanzoub.com/ing8408aok7a">https://wws.lanzoub.com/ing8408aok7a</a></li><li>图标分享 | 30 个免费 icon 下载网站：<a href="https://zhuanlan.zhihu.com/p/431105940">https://zhuanlan.zhihu.com/p/431105940</a></li><li>Font Awesome-ico图标：<a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></li><li>Font Awesome 图标-菜鸟教程：<a href="https://www.runoob.com/font-awesome/fontawesome-tutorial.html">https://www.runoob.com/font-awesome/fontawesome-tutorial.html</a></li><li>免费logo在线制作：<a href="http://www.uugai.com/">http://www.uugai.com/</a></li><li>ICON图标在线下载：<a href="https://www.iconfinder.com/">https://www.iconfinder.com/</a></li><li>open source icons：<a href="https://feathericons.com/">https://feathericons.com/</a></li><li>阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></li><li>艺术字体在线生成：<a href="https://www.qt86.com/">https://www.qt86.com/</a></li></ul><hr><ul><li>Emoji表情搜索：<a href="https://emoji.svend.cc/">https://emoji.svend.cc/</a></li><li>Emoji表情包下载：<a href="https://emojiisland.com/">https://emojiisland.com/</a></li><li>表情包在线网站：<a href="https://fabiaoqing.com/">https://fabiaoqing.com/</a></li></ul><h3 id="文字、文本、PDF、表格、文件、RGB颜色"><a href="#文字、文本、PDF、表格、文件、RGB颜色" class="headerlink" title="文字、文本、PDF、表格、文件、RGB颜色"></a>文字、文本、PDF、表格、文件、RGB颜色</h3><ul><li>在线文字识别工具：<a href="https://ocr.wdku.net/">https://ocr.wdku.net/</a></li><li>在线字数统计：<a href="https://www.eteste.com/">https://www.eteste.com/</a></li><li>mdnice markdown排版工具：<a href="https://mdnice.com/">https://mdnice.com/</a></li><li>md2all markdown排版工具：<a href="http://md.aclickall.com/">http://md.aclickall.com/</a></li><li>在线文本代码对比工具：<a href="https://www.fly63.com/tool/textdiff/">https://www.fly63.com/tool/textdiff/</a></li><li>在线文本替换：<a href="http://www.fly63.com/tool/textreplace/">http://www.fly63.com/tool/textreplace/</a></li></ul><hr><ul><li>pdf在线处理套装1：<a href="https://tools.pdf24.org/zh/">https://tools.pdf24.org/zh/</a></li><li>pdf在线处理套装2：<a href="https://smallpdf.com/cn/pdf-tools">https://smallpdf.com/cn/pdf-tools</a></li><li>pdf转word在线工具：<a href="https://www.pdftoword.com/">https://www.pdftoword.com/</a></li><li>PDF to Markdown：<a href="https://pdf2md.morethan.io/">https://pdf2md.morethan.io</a></li><li>在线表格转换工具：<a href="https://tableconvert.com/">https://tableconvert.com/</a></li><li>在线文件压缩工具：<a href="https://docsmall.com/">https://docsmall.com/</a></li></ul><hr><ul><li>RGB颜色转换：<a href="https://www.zxgj.cn/g/yansezhi">https://www.zxgj.cn/g/yansezhi</a></li><li>RGB颜色对照表：<a href="https://bj.96weixin.com/tools/rgb">https://bj.96weixin.com/tools/rgb</a></li><li>貌似打开不了：<a href="http://xh.5156edu.com/page/z1015m9220j18754.html">http://xh.5156edu.com/page/z1015m9220j18754.html</a></li></ul><h3 id="json、xml、yaml、sql、css格式化"><a href="#json、xml、yaml、sql、css格式化" class="headerlink" title="json、xml、yaml、sql、css格式化"></a>json、xml、yaml、sql、css格式化</h3><ul><li>在线JSON解析：<a href="http://www.json.cn/">http://www.json.cn/</a></li><li>JSON&#x2F;YAML在线转换：<a href="http://www.fly63.com/tool/jsonyaml/">http://www.fly63.com/tool/jsonyaml/</a></li><li>JSON和XML在线转换：<a href="https://www.zxgj.cn/g/jsonxml">https://www.zxgj.cn/g/jsonxml</a></li><li>XML格式化工具：<a href="https://www.zxgj.cn/g/xmlformat">https://www.zxgj.cn/g/xmlformat</a></li><li>在线JS代码格式化工具：<a href="https://prettier.io/playground/">https://prettier.io/playground/</a></li><li>在线JSON解析：<a href="http://www.json.cn/">http://www.json.cn/</a></li><li>SQL压缩&#x2F;格式化工具：<a href="https://www.zxgj.cn/g/sqlformat">https://www.zxgj.cn/g/sqlformat</a></li><li>在线CSS代码可视化工具：<a href="https://enjoycss.com/">https://enjoycss.com/</a></li><li>在线数据可视化：<a href="https://flourish.studio/">https://flourish.studio/</a></li><li>在线前端编辑器：<a href="https://codepen.io/">https://codepen.io/</a></li></ul><h3 id="时间、进制、计量单位、人民币大小写转换"><a href="#时间、进制、计量单位、人民币大小写转换" class="headerlink" title="时间、进制、计量单位、人民币大小写转换"></a>时间、进制、计量单位、人民币大小写转换</h3><ul><li>时间戳转换工具：<a href="https://www.zxgj.cn/g/unix">https://www.zxgj.cn/g/unix</a></li><li>通用进制转换工具：<a href="https://www.zxgj.cn/g/jinzhi">https://www.zxgj.cn/g/jinzhi</a></li><li>在线浮点数十进制转换：<a href="http://www.binaryconvert.com/">http://www.binaryconvert.com/</a></li><li>计量单位换算工具：<a href="http://www.fly63.com/tool/unitable/">http://www.fly63.com/tool/unitable/</a></li><li>人民币大小写转换工具：<a href="http://www.fly63.com/tool/renmingbi/">http://www.fly63.com/tool/renmingbi/</a></li></ul><h3 id="随机数、正则表达式、接口测试"><a href="#随机数、正则表达式、接口测试" class="headerlink" title="随机数、正则表达式、接口测试"></a>随机数、正则表达式、接口测试</h3><ul><li>UUID在线生成器：<a href="https://www.zxgj.cn/g/uuid">https://www.zxgj.cn/g/uuid</a></li><li>随机数生成器：<a href="https://www.zxgj.cn/g/suijishu">https://www.zxgj.cn/g/suijishu</a></li></ul><hr><ul><li>正则表达式可视化工具：<a href="https://jex.im/regulex/#!flags=&amp;re=^">https://jex.im/regulex/#!flags=&amp;re=^</a>(a|b*%3F%24</li><li>正则表达式调试工具：<a href="https://regexr.com/">https://regexr.com/</a></li></ul><hr><ul><li>HTTP在线接口测试工具：<a href="http://www.fly63.com/php/http/">http://www.fly63.com/php/http/</a></li><li>在线接口文档管理工具：<a href="http://xiaoyaoji.cn/">http://xiaoyaoji.cn</a></li></ul><h3 id="Nginx、IP查询、CDN、谷歌插件、ASCII码"><a href="#Nginx、IP查询、CDN、谷歌插件、ASCII码" class="headerlink" title="Nginx、IP查询、CDN、谷歌插件、ASCII码"></a>Nginx、IP查询、CDN、谷歌插件、ASCII码</h3><ul><li>在线Nginx配置工具：<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN</a></li></ul><hr><ul><li>IP地址归属地查询：<a href="https://www.ip138.com/">https://www.ip138.com/</a></li><li>IP地址查询：<a href="https://www.ipip.net/ip.html">https://www.ipip.net/ip.html</a></li></ul><hr><ul><li>CDN查询：<a href="https://www.itdog.cn/">https://www.itdog.cn</a></li></ul><hr><ul><li>在线Chrome浏览器插件：<a href="https://www.crx4chrome.com/">https://www.crx4chrome.com</a></li></ul><hr><ul><li>在线ASCII码对照表：<a href="http://www.fly63.com/tool/ascii/">http://www.fly63.com/tool/ascii/</a></li></ul><h3 id="编译运行、编解码、加解密"><a href="#编译运行、编解码、加解密" class="headerlink" title="编译运行、编解码、加解密"></a>编译运行、编解码、加解密</h3><ul><li>C#在线编译运行：<a href="https://rextester.com/">https://rextester.com</a></li><li>C&#x2F;C++在线编译调试：<a href="https://www.onlinegdb.com/">https://www.onlinegdb.com</a></li><li>在线编译工具套装：<a href="https://c.runoob.com/">https://c.runoob.com</a></li></ul><hr><ul><li>BASE64编解码工具：<a href="https://base64.supfree.net/">https://base64.supfree.net/</a></li><li>MD5编码工具：<a href="https://www.zxgj.cn/g/md5">https://www.zxgj.cn/g/md5</a></li><li>JWT解码工具：<a href="http://jwt.calebb.net/">http://jwt.calebb.net/</a></li><li>ASCII编解码工具：<a href="https://www.matools.com/code-convert-ascii">https://www.matools.com/code-convert-ascii</a></li><li>Unicode编解码工具：<a href="https://www.zxgj.cn/g/unicode">https://www.zxgj.cn/g/unicode</a></li><li>UTF-8编解码工具：<a href="https://www.zxgj.cn/g/utf8">https://www.zxgj.cn/g/utf8</a></li><li>字符串编解码工具：<a href="https://www.zxgj.cn/g/enstring">https://www.zxgj.cn/g/enstring</a></li><li>URL编解码工具：<a href="http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1">http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1</a></li></ul><hr><ul><li>AES&#x2F;DES加解密：<a href="http://www.fly63.com/tool/cipher/">http://www.fly63.com/tool/cipher/</a></li></ul><h3 id="文档笔记工具"><a href="#文档笔记工具" class="headerlink" title="文档笔记工具"></a>文档笔记工具</h3><ul><li>onenote：<a href="https://www.onenote.com/">https://www.onenote.com</a></li><li>simplenote：<a href="https://simplenote.com/">https://simplenote.com</a></li><li>为知笔记：<a href="https://www.wiz.cn/zh-cn">https://www.wiz.cn/zh-cn</a></li><li>印象笔记：<a href="https://www.yinxiang.com/">https://www.yinxiang.com</a></li><li>幕布：<a href="https://mubu.com/home">https://mubu.com/home</a></li><li>有道笔记：<a href="https://note.youdao.com/">https://note.youdao.com</a></li><li>石墨：<a href="https://shimo.im/">https://shimo.im</a></li><li>语雀：<a href="https://www.yuque.com/">https://www.yuque.com</a></li></ul><h3 id="编程学习网"><a href="#编程学习网" class="headerlink" title="编程学习网"></a>编程学习网</h3><ul><li>哔哩哔哩：<a href="https://www.bilibili.com/">https://www.bilibili.com/</a></li><li>C语言网：<a href="https://www.dotcpp.com/">https://www.dotcpp.com/</a></li><li>cppreference：<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/首页</a></li><li>中国大学MOOC：<a href="https://www.icourse163.org/">https://www.icourse163.org/</a></li><li>网易公开课：<a href="https://open.163.com/">https://open.163.com/</a></li><li>CodeGym：<a href="https://codegym.cc/">https://codegym.cc/</a></li><li>BeginnersBook：<a href="https://beginnersbook.com/">https://beginnersbook.com/</a></li><li>codecademy：<a href="https://www.codecademy.com/">https://www.codecademy.com/</a></li><li>Coursera：<a href="https://www.coursera.org/">https://www.coursera.org/</a></li><li>StackOverFlow：<a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li><li>学破解论坛：<a href="https://www.52hb.com/">https://www.52hb.com</a></li><li>我要自学网：<a href="https://www.51zxw.net/">https://www.51zxw.net/</a></li><li>逆向未来：<a href="https://www.pd521.com/">https://www.pd521.com</a></li></ul><h3 id="在线教程和文档"><a href="#在线教程和文档" class="headerlink" title="在线教程和文档"></a>在线教程和文档</h3><ul><li>SVN中文手册：<a href="http://svnbook.red-bean.com/nightly/zh/index.html">http://svnbook.red-bean.com/nightly/zh/index.html</a></li><li>jQuery API中文文档：<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a></li><li>Nginx中文文档：<a href="https://www.nginx.cn/doc/index.html">https://www.nginx.cn/doc/index.html</a></li><li>Kafka中文文档：<a href="https://kafka.apachecn.org/">https://kafka.apachecn.org/</a></li><li>Mybatis中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li><li>微信小程序官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li><li>Nodejs中文教程文档：<a href="http://nodejs.cn/learn/">http://nodejs.cn/learn/</a></li><li>Apache Web Server文档：<a href="http://httpd.apache.org/docs/">http://httpd.apache.org/docs/</a></li><li>Golang标准库文档中文版：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></li><li>Tomcat 8官方文档：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></li><li>RabbitMQ官方文档：<a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></li><li>RocketMQ官方文档：<a href="http://rocketmq.apache.org/docs/quick-start/">http://rocketmq.apache.org/docs/quick-start/</a></li><li>Dubbo中文文档：<a href="https://dubbo.apache.org/zh/docs/">https://dubbo.apache.org/zh/docs/</a></li><li>Netty官方文档：<a href="https://netty.io/wiki/index.html">https://netty.io/wiki/index.html</a></li><li>Elasticsearch官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li>kubernetes中文文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a></li><li>thymeleaf官方文档：<a href="https://www.thymeleaf.org/documentation.html">https://www.thymeleaf.org/documentation.html</a></li><li>Vue.js中文文档：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></li><li>React.js官方文档：<a href="https://reactjs.org/docs/getting-started.html">https://reactjs.org/docs/getting-started.html</a></li><li>Jenkins中文文档：<a href="https://www.jenkins.io/zh/doc/">https://www.jenkins.io/zh/doc/</a></li><li>Oracle Help Center：<a href="https://docs.oracle.com/en/">https://docs.oracle.com/en/</a></li><li>敬伟PS教程全集：<a href="https://www.bilibili.com/video/av18792821?p=172&amp;vd_source=c57311942d38847adc4597a126bba185">https://www.bilibili.com/video/av18792821?p=172&amp;vd_source=c57311942d38847adc4597a126bba185</a></li></ul><h3 id="博主个人备忘书签"><a href="#博主个人备忘书签" class="headerlink" title="博主个人备忘书签"></a>博主个人备忘书签</h3><ul><li><a href="https://zx.js.cool/">https://zx.js.cool</a></li><li><a href="https://mail.qq.com/">https://mail.qq.com</a></li><li><a href="https://www.zhipin.com/">https://www.zhipin.com</a></li><li><a href="https://www.zhaopin.com/">https://www.zhaopin.com</a></li><li><a href="https://cloud.tencent.co蔰m(s忽泆hell瀄蚨root/">https://cloud.tencent.com（shell登录用户名root</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java oop</title>
      <link href="/2022/05/15/Java-oop/"/>
      <url>/2022/05/15/Java-oop/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p>它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。</p><p>在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p><p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。</p><p>当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。</p><p>在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称OOD）方面的知识。</p><p>许多流行的编程语言是面向对象的,它们的风格就是会透由对象来创出实例。</p><p>重要的面向对象编程语言包含Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP等。</p><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>属性：对象数据的描述<br>方法：对象的行为<br>构造方法：用于实例化对象<br>内部类：在类中声明的类（inner class）<br>块：分静态代码块与实例语句块。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.name = <span class="string">&quot;奥利给&quot;</span>;</span><br><span class="line">    System.out.println(test.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量默认带有初始值，也可以自己定义初始值。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//Body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] 方法名称([参数])&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li><li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li><li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li><li>方法体：方法具体要干的事情</li><li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li></ul><p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//缺少retrun语句！</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">//在循环内返回了！和break区别？</span></span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;淦&quot;</span>);   <span class="comment">//还会到这里吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Test</span>().swap(a, b);</span><br><span class="line">  System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//传递的仅仅是值而已！</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">  a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(B b)</span>&#123;  <span class="comment">//传递的是对象的引用，而不是值</span></span><br><span class="line">    System.out.println(b.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  b.name = <span class="string">&quot;lbw&quot;</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">A</span>().test(b);</span><br><span class="line">  System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法之间可以相互调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//xxxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p><h2 id="三大基本特征"><a href="#三大基本特征" class="headerlink" title="三大基本特征"></a>三大基本特征</h2><h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>具备封装性（Encapsulation）的面向对象编程隐藏了某一方法的具体运行步骤，取而代之的是通过消息传递机制发送消息给它。封装是通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。</p><p>通常来说，成员会依它们的访问权限被分为3种：公有成员、私有成员以及保护成员。</p><p>有些语言更进一步：Java可以限制同一包内不同类的访问；C#和VB.NET保留了为类的成员聚集准备的关键字：internal（C#）和Friend（VB.NET）；Eiffel语言则可以让用户指定哪个类可以访问所有成员。</p><p>具备封装性（Encapsulation）的面向对象程序设计隐藏了某一方法的具体执行步骤，取而代之的是通过消息传递机制传送消息给它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">secret</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printName 就是一个共有方法，可以被外界调用。</p><p>secrect 是一个私有方法，外界无法直接访问。</p><p>个人理解：属性的访问级别，可以让外部不用关心具体的细节，也便于后期的调整，尽可能少的和外界交互，也是一种设计准则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承性（Inheritance）是指，在某种情况下，一个类会有“子类”。子类比原本的类（称为父类）要更加具体化。</p><p>集成可以大大降低我们的代码编程量。</p><p>比如我们定义一种人，包含年龄的信息，我们可以直接使用继承的方式。</p><p>在伪代码中我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.houbb.java.basic.learn.p01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> binbin.hou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgedPerson</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgedPerson</span><span class="params">(String name, String age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类从多个父类继承时，我们称之为“多重继承”。</p><p>多重继承并不总是被支持的，因为它很难理解，又很难被好好使用。</p><p>ps: java 只支持单层胡继承，但是支持实现多个接口。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态（Polymorphism）是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。</p><p>例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.houbb.java.basic.learn.p01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> binbin.hou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgedPerson</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgedPerson</span><span class="params">(String name, String age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aged name: unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在子类中可以重写父类的 <code>printName()</code> 名称，不同的子类可以有不同的实现。</p><p> [java]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person(&quot;person&quot;);</span><br><span class="line">person.printName();</span><br><span class="line"></span><br><span class="line">AgedPerson agedPerson = new AgedPerson(&quot;person&quot;, &quot;10&quot;);</span><br><span class="line">agedPerson.printName();</span><br></pre></td></tr></table></figure><p>测试日志如下：</p><p> [plaintext]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: person</span><br><span class="line">Aged name: unknown</span><br></pre></td></tr></table></figure><h1 id="抽象性"><a href="#抽象性" class="headerlink" title="抽象性"></a>抽象性</h1><p>抽象（Abstraction）是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</p><p>举例说明，莱丝在大多数时候都被当作一条狗，但是如果想要让它做牧羊犬做的事，你完全可以调用牧羊犬的方法。如果狗这个类还有动物的父类，那么你完全可以视莱丝为一个动物。</p><h2 id="为什么Java不是纯粹面向对象的语言？"><a href="#为什么Java不是纯粹面向对象的语言？" class="headerlink" title="为什么Java不是纯粹面向对象的语言？"></a>为什么Java不是纯粹面向对象的语言？</h2><h2 id="纯粹的面向对象语言"><a href="#纯粹的面向对象语言" class="headerlink" title="纯粹的面向对象语言"></a>纯粹的面向对象语言</h2><p>对于编程语言来说，纯粹的面向对象有七个特质需要满足。</p><p>他们是：</p><ol><li>封装&#x2F;数据隐藏</li><li>遗传</li><li>多态性</li><li>抽象化</li><li>所有预定义类型都是对象</li><li>所有用户定义的类型都是对象</li><li>在对象上执行的所有操作必须仅通过在对象上暴露的方法。</li></ol><p>例如：Smalltalk</p><h2 id="为什么-java-不是纯粹面向对象？"><a href="#为什么-java-不是纯粹面向对象？" class="headerlink" title="为什么 java 不是纯粹面向对象？"></a>为什么 java 不是纯粹面向对象？</h2><p>Java支持属性1,2,3,4和6，但不支持上面给出的属性5和7。</p><p>（1）java 有 8 大基本类型</p><p>（2）静态关键字</p><p>当我们声明一个类为静态的时候，它可以在没有使用Java中的对象的情况下使用。</p><p>如果我们使用静态函数或静态变量，那么我们不能通过使用点（<code>.</code>）或类对象违反面向对象的特性来调用该函数或变量。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/2022/05/15/JavaSE/"/>
      <url>/2022/05/15/JavaSE/</url>
      
        <content type="html"><![CDATA[<h2 id="编译型、解释型"><a href="#编译型、解释型" class="headerlink" title="编译型、解释型"></a>编译型、解释型</h2><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>​            使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>​            在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>现有的C、C++、Objective等都属于编译型语言。</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/70-164708429946416-164708454272221.png"></p><h3 id="解释性语言"><a href="#解释性语言" class="headerlink" title="解释性语言"></a>解释性语言</h3><p>​            使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>​            解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>Python等属于解释型语言</li></ol><p><img src="https://img-blog.csdn.net/20180802084124396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxODQ1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><hr><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。</p><p>​        JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</p><p>  　　JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac&#x2F;java&#x2F;jdb等）和Java基础的类库（即Java API 包括rt.jar）</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​        JRE是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。</p><p>​        JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。</p><p>  　　与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​        jvm就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><p>​        也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机（相当于中间层）间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><p>  　　只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p><p>  　　JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p><h3 id="三者之间关系"><a href="#三者之间关系" class="headerlink" title="三者之间关系"></a>三者之间关系</h3><p> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/jdkjeejvm.png">)</p><h3 id="JAVA应用程序的运行机制"><a href="#JAVA应用程序的运行机制" class="headerlink" title="JAVA应用程序的运行机制"></a>JAVA应用程序的运行机制</h3><p><img src="https://img-blog.csdnimg.cn/20190401111217837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xnbDc4MjUxOTE5Nw==,size_16,color_FFFFFF,t_70"></p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</p><h3 id="八大基本类型（primitiv-type）"><a href="#八大基本类型（primitiv-type）" class="headerlink" title="八大基本类型（primitiv  type）"></a>八大基本类型（primitiv  type）</h3><p>​        基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p><h4 id="Java的基本类型及其封装器类"><a href="#Java的基本类型及其封装器类" class="headerlink" title="Java的基本类型及其封装器类"></a>Java的基本类型及其封装器类</h4><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下：</p><ul><li>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之</li><li>short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。</li><li>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</li><li>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</li><li>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</li><li>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</li><li>boolean：只有true和false两个取值。</li><li>char：16位，存储Unicode码，用单引号赋值。</li></ul><p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。</p><table><thead><tr><th>简单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th><th>void</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td><td>–</td></tr><tr><td>封装器类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Void</td></tr></tbody></table><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p><p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p><p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p><p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p><p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p><p>注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。</p><p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p><p>基本类型的优势：数据存储相对简单，运算效率比较高</p><p>包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="自动类型转换-隐式类型转换"><a href="#自动类型转换-隐式类型转换" class="headerlink" title="自动类型转换(隐式类型转换)"></a>自动类型转换(隐式类型转换)</h4><p>整型、实型(常量)、字符型数据可以混合运算。不同类型的数据先转化为同类型再进行运算</p><p>自动转换按从低级到高级顺序:</p><pre><code>      char       ↓       Byte→short→int→long---›float→double</code></pre><p>自动转换有以下规律：</p><p>小的类型自动转化为大的类型</p><p>整数类型可以自动转化为浮点类型，可能会产生舍入误差</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ol><li>强制类型转换 将 取值范围大的类型 强制转换成 取值范围小的类型</li><li>特点 : 代码需要进行特殊的格式处理, 不能自动完成</li><li>转换格式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span><br><span class="line">int i = (int) 1.7; // 强制转化后 i--&gt; 1</span><br></pre></td></tr></table></figure><ol start="4"><li>代码展示</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IntLongDoubleChange &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(getType(((int) 100L)));  // Long ---&gt; int</span><br><span class="line">        int i = (int) 100L; // 100L是长整型</span><br><span class="line">        System.out.println(getType((short) i));  //  int ---&gt; short</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    private static String getType(Object a) &#123;  // 获取这些数据的数据类型</span><br><span class="line">        return a.getClass().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意事项； </p><ol><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>再把高容量转换到低容量的时候，强制转换</li><li>转换的时候可能存在内存溢出，或者精度问题</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型分为：数组，类，接口，字符串。</p><p>数组：其实就是一个容器，存储同一种数据类型的集合；如 int[] a &#x3D; {1,2,3,4}</p><pre><code>类：对象是对事物的抽象，而类是对对象的抽象和归纳；如 public class Person&#123; ......&#125; 接口：使用interface来定义一个接口，只能定义方法，不能有方法的实现；如public interface personImpl&#123;......&#125; 字符串：是存放数据区（静态区）以Unicode编码的字符集合，如 String a=&quot;你好&quot;</code></pre><p>基本类型与引用类型的区别：</p><p>（1）基本数据类型传值，对形参的修改不会影响实参；<br>（2）引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；<br>（3）String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</p><hr><h2 id="什么是标识符？"><a href="#什么是标识符？" class="headerlink" title="什么是标识符？"></a>什么是标识符？</h2><p>  凡是可以由自己命名的地方都称为标识符。<br>  例如，对于常量、变量、函数、语句块、类、项目等都需要一个名字，这些我们都统统称为标识符。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>标识符有字母、数字、_(下划线)、$所组成，其中不能以数字开头，不能用Java中的保留字（关键字）</li><li>标识符采用有意义的简单命名</li><li>“$”不要在代码中出现。（是由于在后面内部类中，编译后会出现$符号）</li></ol><ul><li>类名和接口名：每个单词的首字母，其余为小写。（大驼峰）</li><li>方法名：第二个单词起的首字母为大写，其余全为小写。（小驼峰）</li><li>常量名：基本数据类型的常量名使用全部大写字母，字与字之间用下划线分隔。</li></ul><hr><h2 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java关键字是<a href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91%E8%AF%AD%E8%A8%80">电脑语言</a>里事先定义的，有特别意义的<a href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&spm=1001.2101.3001.7020">标识符</a>，有时又叫<a href="https://baike.baidu.com/item/%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><table><thead><tr><th><a href="https://baike.baidu.com/item/abstract">abstract</a></th><th><a href="https://baike.baidu.com/item/assert"> assert</a></th><th><a href="https://baike.baidu.com/item/boolean"> boolean</a></th><th>break</th><th><a href="https://baike.baidu.com/item/byte"> byte</a></th></tr></thead><tbody><tr><td>case</td><td><a href="https://baike.baidu.com/item/catch">catch</a></td><td><a href="https://baike.baidu.com/item/char">char</a></td><td><a href="https://baike.baidu.com/item/class">class</a></td><td>const</td></tr><tr><td>continue</td><td><a href="https://baike.baidu.com/item/default">default</a></td><td><a href="https://baike.baidu.com/item/do">do</a></td><td><a href="https://baike.baidu.com/item/double">double</a></td><td><a href="https://baike.baidu.com/item/else">else</a></td></tr><tr><td><a href="https://baike.baidu.com/item/enum">enum</a></td><td><a href="https://baike.baidu.com/item/extends">extends</a></td><td><a href="https://baike.baidu.com/item/final">final</a></td><td><a href="https://baike.baidu.com/item/finally">finally</a></td><td>float</td></tr><tr><td><a href="https://baike.baidu.com/item/for">for</a></td><td>goto</td><td><a href="https://baike.baidu.com/item/if">if</a></td><td><a href="https://baike.baidu.com/item/implements">implements</a></td><td><a href="https://baike.baidu.com/item/import">import</a></td></tr><tr><td><a href="https://baike.baidu.com/item/instanceof">instanceof</a></td><td><a href="https://baike.baidu.com/item/int">int</a></td><td><a href="https://baike.baidu.com/item/interface">interface</a></td><td>long</td><td>native</td></tr><tr><td>new</td><td><a href="https://baike.baidu.com/item/package">package</a></td><td><a href="https://baike.baidu.com/item/private">private</a></td><td><a href="https://baike.baidu.com/item/protected">protected</a></td><td><a href="https://baike.baidu.com/item/public">public</a></td></tr><tr><td><a href="https://baike.baidu.com/item/return">return</a></td><td><a href="https://baike.baidu.com/item/strictfp">strictfp</a></td><td><a href="https://baike.baidu.com/item/short">short</a></td><td><a href="https://baike.baidu.com/item/static">static</a></td><td><a href="https://baike.baidu.com/item/super">super</a></td></tr><tr><td><a href="https://baike.baidu.com/item/switch">switch</a></td><td><a href="https://baike.baidu.com/item/synchronized">synchronized</a></td><td><a href="https://baike.baidu.com/item/this">this</a></td><td><a href="https://baike.baidu.com/item/throw">throw</a></td><td><a href="https://baike.baidu.com/item/throws">throws</a></td></tr><tr><td><a href="https://baike.baidu.com/item/transient">transient</a></td><td>try</td><td><a href="https://baike.baidu.com/item/void">void</a></td><td><a href="https://baike.baidu.com/item/volatile">volatile</a></td><td><a href="https://baike.baidu.com/item/while">while</a></td></tr><tr><td>true</td><td>false</td><td>null</td><td></td><td></td></tr></tbody></table><p>　另外，Java还有3个保留字:true、false、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样,它们也不可以作为标识符使用。参考<a href="https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_43">https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_43</a></p><h3 id="定义类、接口、抽象类"><a href="#定义类、接口、抽象类" class="headerlink" title="定义类、接口、抽象类"></a>定义类、接口、抽象类</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>class</td><td>声明一个类</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr></tbody></table><h3 id="用于建立类与类之间关系"><a href="#用于建立类与类之间关系" class="headerlink" title="用于建立类与类之间关系"></a>用于建立类与类之间关系</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>implements</td><td>表明一个类实现了给定的接口类</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型，常见的类型有类和接口</td></tr></tbody></table><h3 id="用于定义访问权限修饰符"><a href="#用于定义访问权限修饰符" class="headerlink" title="用于定义访问权限修饰符"></a>用于定义访问权限修饰符</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>private</td><td>私有权限，修饰的属性和方法仅供本类引用</td></tr><tr><td>protected</td><td>保护权限，保护子类，当前包内和继承的子类中可以引用</td></tr><tr><td>default</td><td>默认模式，不写任何访问修饰权限，本包内可以使用</td></tr><tr><td>public</td><td>公用模式，可跨包使用，凡是环境下的类和方法都可以使用，需导入包</td></tr></tbody></table><h3 id="用于定义建立实例及引用实例、判断实例"><a href="#用于定义建立实例及引用实例、判断实例" class="headerlink" title="用于定义建立实例及引用实例、判断实例"></a>用于定义建立实例及引用实例、判断实例</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>用来创建新的实例对象</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr></tbody></table><h3 id="用于定义类、函数、变量修饰符"><a href="#用于定义类、函数、变量修饰符" class="headerlink" title="用于定义类、函数、变量修饰符"></a>用于定义类、函数、变量修饰符</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>final</td><td>终结器，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td></tr><tr><td>static</td><td>表示具有静态属性</td></tr><tr><td>synchronized</td><td>线程同步，修饰一段代码表示多个线程都能同步执行</td></tr><tr><td>volatile</td><td>意识，表明两个或者多个变量必须同步地发生变化</td></tr><tr><td>native</td><td>本地用来声明一个方法是由计算机相关语言实现的(如C&#x2F;C++语言等)</td></tr></tbody></table><h3 id="用于异常处理"><a href="#用于异常处理" class="headerlink" title="用于异常处理"></a>用于异常处理</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>finally</td><td>用于异常处理情况，用来声明一个基本肯定会被执行到的语句块（有没有异常都执行）</td></tr><tr><td>throw</td><td>通常用在方法体中，并且抛出一个异常对象，程序在执行到throw语句时立即停止，它后面的语句都不执行</td></tr><tr><td>throws</td><td>如果一个方法可以引发异常，本身不对异常进行处理，将异常抛给调用者使程序可以继续执行下去</td></tr></tbody></table><h3 id="用于包的关键字"><a href="#用于包的关键字" class="headerlink" title="用于包的关键字"></a>用于包的关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>import</td><td>导入这个类所存在的包</td></tr><tr><td>package</td><td>定义包的关键字，将有关类放在一个包中</td></tr></tbody></table><h3 id="其他修饰符关键字"><a href="#其他修饰符关键字" class="headerlink" title="其他修饰符关键字"></a>其他修饰符关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>assert</td><td>断言，用来进行程序调试</td></tr></tbody></table><hr><h2 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>变量</strong>是可以变化的量<br><strong>java</strong>是一种强类型语言，每个变量都必须声明其类型。<br><strong>java</strong>变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><h4 id="变量可分为：成员变量、局部变量、静态变量"><a href="#变量可分为：成员变量、局部变量、静态变量" class="headerlink" title="变量可分为：成员变量、局部变量、静态变量"></a>变量可分为：成员变量、局部变量、静态变量</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>在某个方法外部，类内部定义的变量，从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型默认的初始值。部分变量的默认初始值如下表所示</p><table><thead><tr><th>数据类型</th><th>初始值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVariable</span>&#123;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//成员变量，会自动初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">TestVariable</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestVariable</span>();</span><br><span class="line">        System.out.println(test.a);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量是方法或语句块内部定义的变量，其<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>是从声明位置开始到方法或语句块执行完毕为止。局部变量在使用前必须先声明并初始化（赋值），否则会出错。<br>局部变量的初始化有两种方式，一种是先定义再初始化，代码中方式一所示，另外一种是定义的同时进行初始化，如方式二所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">age=<span class="number">18</span>;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">int</span> weight=<span class="number">50</span>;</span><br><span class="line"><span class="comment">//错误赋值示例！！！注意这样写是错误的，不要模仿！！！！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">height</span>&#123;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line">height=<span class="number">180</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量使用static定义，从属于类，声明周期伴随类始终，从类加载时产生，类卸载时结束。如果不进行初始化，与成员变量一样，会自行初始化成该类型的默认初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> a;<span class="comment">//静态变量，会自动初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>每个变量都有类型，类型可以是基本类型，也可以是引用类型。<br>变量名必须是合法的标识符。<br>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span>&#123;     </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">       <span class="comment">// int a,b,c;</span></span><br><span class="line">       <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">       String name=<span class="string">&quot;ZDJ&quot;</span>;</span><br><span class="line">       <span class="type">char</span> x=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">       <span class="type">double</span> pi=<span class="number">3.14</span>;     </span><br><span class="line">       <span class="comment">//定义变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h4><p><a href="https://www.bilibili.com/video/BV12J41137hu?p=26">狂神说java</a></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/b743599935054ed5b26cf550604d5cb6.png" alt="在这里插入图片描述"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>常量定义：在程序执行的过程中，其值不可以发生改变的量。常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义。</li><li>常量值定义：常量和常量值是不同的概念，常量值又称为字面常量，它是通过数据直接表示的。</li><li>关系：常量值是常量的具体和直观的表现形式，常量是形式化的表现。通常在程序中既可以直接使用常量值，也可以使用常量。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>字符串常量 用双引号括起来的内容(“HelloWorld”)</li><li>整数常量 所有整数(12,-23)</li><li>小数常量 所有小数(12.34)</li><li>字符常量 用单引号括起来的内容(‘a’,’A’,’0’)</li><li>布尔常量 较为特有，只有true和false</li><li>空常量 null</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>Java 语言使用 final 关键字来定义一个常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> COUNT=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> HEIGHT=<span class="number">10.2F</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>在定义常量时就需要对该常量进行初始化。</li><li>final 关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</li><li>为了与变量区别，常量取名一般都用大写字符。</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>java中作用域用花括号位置决定。JAVA用一对大括号作为语句块的范围，称为作用域，在作用域里定义的变量，只有在该作用域结束之前才可使用。</p><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>求和</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>乘积</td></tr><tr><td>&#x2F;</td><td>商</td></tr><tr><td>%</td><td>求余数（求模）</td></tr><tr><td>++</td><td>自加一</td></tr><tr><td>–</td><td>自减一</td></tr></tbody></table><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="++运算符"></a>++运算符</h4><ul><li>++在变量前</li><li>当++出现在变量前，会先自加一，在做赋值运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ++x;</span><br><span class="line">步骤： ② ①</span><br><span class="line">System.out.println(x); <span class="comment">// 101</span></span><br><span class="line">System.out.println(y); <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><ul><li>++在变量后</li><li>当++出现在变量后，会先做赋值运算，再自加1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m++;</span><br><span class="line">步骤： ① ②</span><br><span class="line">System.out.println(n); <span class="comment">// 20</span></span><br><span class="line">System.out.println(m); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><ul><li>特别地，在print中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">System.out.println(c++);  <span class="comment">// 传，这个“传”在这里有一个隐形的赋值运算。90</span></span><br><span class="line"><span class="comment">// 把上面代码拆解开</span></span><br><span class="line"><span class="comment">//int temp = c++;</span></span><br><span class="line"><span class="comment">//System.out.println(temp);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">System.out.println(++d); <span class="comment">//81</span></span><br><span class="line"><span class="comment">// 拆解</span></span><br><span class="line"><span class="comment">//int temp2 = ++d;</span></span><br><span class="line"><span class="comment">//System.out.println(temp2);</span></span><br></pre></td></tr></table></figure><h4 id="–运算符（例子同-运算符）"><a href="#–运算符（例子同-运算符）" class="headerlink" title="–运算符（例子同++运算符）"></a>–运算符（例子同++运算符）</h4><ul><li><p>–在变量前</p><ul><li><strong>当–出现在变量前，会先自减一，在做赋值运算</strong></li></ul></li><li><p>–在变量后</p><ul><li><strong>当–出现在变量后，会先做赋值运算，再自减1</strong></li></ul></li></ul><blockquote><p>注意:<br>对于++运算符来说：<br>  1.可以出现在变量前，也可以出现在变量后。<br>  2.不管出现在变量前还是后，总之++执行结束之后，变量的值一定会自加1。</p></blockquote><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr></tbody></table><blockquote><p><em><strong>注意</strong></em>：所有的关系运算符的运算结果都是布尔类型，不是true就是false，不可能是其他值。</p></blockquote><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>＆</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr><tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr><tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr><tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td></tr><tr><td>+&#x3D;</td><td>加等（原先的基础上加上&#x2F;追加这个数）</td></tr><tr><td>-&#x3D;</td><td>减等（同理）</td></tr><tr><td>*&#x3D;</td><td>乘等（同理）</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等（同理）</td></tr><tr><td>%&#x3D;</td><td>模等（同理）</td></tr></tbody></table><blockquote><p>注：除了第一个是赋值运算符，其他都死拓展赋值运算符！！</p></blockquote><h4 id="很重要的语法机制："><a href="#很重要的语法机制：" class="headerlink" title="很重要的语法机制："></a>很重要的语法机制：</h4><p>使用扩展赋值运算符的时候，永远都不会改变运算结果类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">m += <span class="number">10</span>; 类似于 m = m + <span class="number">10</span>;-------&gt;注意是类似！！！！</span><br><span class="line"></span><br><span class="line">实际不同：</span><br><span class="line">i = i + <span class="number">10</span>; 和 i += <span class="number">10</span>;一样吗？</span><br><span class="line"><span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">i += <span class="number">10</span>;-----&gt;没报错</span><br><span class="line">其实 x += <span class="number">1</span> 等同于：x = (<span class="type">byte</span>)(x + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">i = i + <span class="number">10</span>;----&gt;错误: 不兼容的类型: 从<span class="type">int</span>转换到<span class="type">byte</span>可能会有损失</span><br><span class="line">编译器检测到x + <span class="number">1</span>是<span class="type">int</span>类型，<span class="type">int</span>类型不可以直接赋值给<span class="type">byte</span>类型的变量x！</span><br><span class="line">详见Java类型转换的时候需要遵循的规则第六点</span><br><span class="line"></span><br><span class="line">i += <span class="number">190</span>; <span class="comment">// i = (byte)(i + 190);</span></span><br><span class="line">System.out.println(i); <span class="comment">// 44 （当然会自动损失精度了。）</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>含义</th><th>结果</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与（可以翻译成并且）</td><td>两边都是true，结果才是true</td></tr><tr><td>│</td><td>逻辑或（可以翻译成或者）</td><td>有一边是true，结果就是true</td></tr><tr><td>!</td><td>逻辑非（取反）</td><td>!true &#x3D; false、!false &#x3D; true</td></tr><tr><td>&amp;&amp;</td><td>短路与</td><td>两边都是true，结果才是true</td></tr><tr><td>││</td><td>短路或</td><td>有一边是true，结果就是true</td></tr></tbody></table><h4 id="短路与-amp-amp"><a href="#短路与-amp-amp" class="headerlink" title="短路与 &amp;&amp;"></a>短路与 &amp;&amp;</h4><ul><li>短路与&amp;&amp; 和 逻辑与 &amp;有什么区别？<ul><li>首先这两个运算符的运算结果没有任何区别，完全相同。</li><li>只不过“短路与&amp;&amp;”会发生短路现象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">System.out.println(x &gt; y &amp; x &gt; y++); <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路与&amp;&amp;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路与&amp;&amp;的时候，当左边的表达式为false的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &gt; n &amp;&amp; m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><ul><li><p>什么是短路现象呢？</p><ul><li>右边表达式不执行，这种现象叫做短路现象。</li></ul></li><li><p>什么时候使用&amp;&amp;，什么时候使用&amp; ？</p><ul><li>从效率方面来说，&amp;&amp;比&amp;的效率高一些。</li><li>因为逻辑与&amp;不管第一个表达式结果是什么，第二个表达式一定会执行。</li></ul></li></ul><p>以后的开发中，短路与&amp;&amp;和逻辑与还是需要同时并存的。<br>大部分情况下都建议使用短路与&amp;&amp;只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&amp;。</p><h4 id="短路或"><a href="#短路或" class="headerlink" title="短路或 ||"></a>短路或 ||</h4><h4 id="跟短路与类似"><a href="#跟短路与类似" class="headerlink" title="跟短路与类似"></a>跟短路与类似</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">System.out.println(x &lt; y | x &gt; y++); <span class="comment">//teur</span></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路或||</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路或||的时候，当左边的表达式为true的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &lt; n || m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>使用短路与 &amp;&amp; 的时候，当左边的表达式为false的时候，右边的表达式不执行    </li><li>使用短路或 || 的时候当左边的表达式结果是true的时候，右边的表达式不执行</li><li>注意：逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。</li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><h4 id="语法格式：（三目运算符。）"><a href="#语法格式：（三目运算符。）" class="headerlink" title="语法格式：（三目运算符。）"></a>语法格式：（三目运算符。）</h4><ul><li>布尔表达式 ? 表达式1 : 表达式2</li></ul><h4 id="执行原理是什么？"><a href="#执行原理是什么？" class="headerlink" title="执行原理是什么？"></a>执行原理是什么？</h4><ul><li>布尔表达式的结果为true时，表达式1的执行结果作为整个表达式的结果。</li><li>布尔表达式的结果为false时，表达式2的执行结果作为整个表达式的结果。</li></ul><h4 id="好玩点："><a href="#好玩点：" class="headerlink" title="好玩点："></a>好玩点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br><span class="line">以上两个都报错。</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面可以</span></span><br><span class="line"> <span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> s += <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符(+)"></a>字符串连接运算符(+)</h3><h4 id="运算符在java语言中有两个作用。"><a href="#运算符在java语言中有两个作用。" class="headerlink" title="+运算符在java语言中有两个作用。"></a>+运算符在java语言中有两个作用。</h4><ul><li><p>作用1：求和</p></li><li><p>作用2：字符串拼接</p></li></ul><h4 id="什么时候求和？什么时候进行字符串的拼接呢？"><a href="#什么时候求和？什么时候进行字符串的拼接呢？" class="headerlink" title="什么时候求和？什么时候进行字符串的拼接呢？"></a>什么时候求和？什么时候进行字符串的拼接呢？</h4><ul><li><p>当 + 运算符两边都是数字类型的时候，求和。</p></li><li><p>当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。</p></li></ul><h4 id="一定要记住：字符串拼接完之后的结果还是一个字符串。"><a href="#一定要记住：字符串拼接完之后的结果还是一个字符串。" class="headerlink" title="一定要记住：字符串拼接完之后的结果还是一个字符串。"></a>一定要记住：字符串拼接完之后的结果还是一个字符串。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 这里的 + 两边都是数字，所以加法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span>  + a + b);<span class="comment">//100+200=100200</span></span><br><span class="line">System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span>  + (a + b));<span class="comment">//100+200=300</span></span><br></pre></td></tr></table></figure><blockquote><p>注：遵循“自左向右”的顺序依次执行。（除非额外添加了小括号，小括号的优先级高）</p></blockquote><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>方法：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li>程序开始执行的时候是先执行main方法。因为main方法是一个入口。</li><li>在java语言中所有的方法体中的代码都必须遵循自上而下的顺序依次逐行执行。</li><li>main方法不需要程序员手动调用，是由JVM调用的。但是除了main方法之外其他的方法，都需要程序员手动调用。</li><li>方法只有调用的时候才会执行，方法不调用是不会执行的。</li><li>方法定义在类体当中。方法定义的先后顺序没有关系</li><li>方法中的变量都属于局部变量。方法结束之后，局部变量占用的内存会自动释放</li></ol><h3 id="方法定义，语法机制"><a href="#方法定义，语法机制" class="headerlink" title="方法定义，语法机制"></a>方法定义，语法机制</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">方法体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>[] 符号叫做中括号，以上中括号[ ]里面的内容表示不是必须的，是<code>可选</code>的。</li><li>方法体由Java语句构成。</li><li>方法定义之后需要去调用，不调用是不会执行的。</li></ol><h4 id="修饰符列表"><a href="#修饰符列表" class="headerlink" title="修饰符列表"></a>修饰符列表</h4><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><ol><li>返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String…</li><li>什么是返回值？返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line"><span class="comment">// 调用a方法</span></span><br><span class="line">a();</span><br><span class="line">       <span class="comment">//如果a方法执行结束之后有返回值，这个返回值返回给main了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。</p><ol start="3"><li><p>当一个方法执行结束不返回任何值的时候，返回值 类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。</p></li><li><p>如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用”return 值;”这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句,那么编译器会报错。<br>return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。</p></li><li><p>只要有“return”关键字的语句执行，当前方法必然结束。<br>return只要执行，当前所在的方法结束，记住：不是整个程序结束。</p></li><li><p>如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前 方法的。</p></li><li><p>除了void之外，剩下的都必须有“return 值;”这样的语句。</p></li></ol><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名要见名知意。（<code>驼峰命名</code>方式）<br>方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。</p><h4 id="形式参数列表"><a href="#形式参数列表" class="headerlink" title="形式参数列表"></a>形式参数列表</h4><ol><li>简称：形参</li><li>注意：形式参数列表中的每一个参数都是“<code>局部变量</code>”，方法结束之后内存<code>释放</code>。</li><li>形参的个数是：<code>0 ~ N</code>个。</li><li>形参的数据类型起决定性作用，形参对应的变量名是随意的。（方法重载会涉及！）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> d, String s)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参有多个的话使用“逗号,”隔开。逗号是英文的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><p>由Java语句构成。java语句以“<code>;</code>”结尾。<br>方法体当中编写的是业务逻辑代码，完成某个特定功能。<br>在方法体中的代码遵循自上而下的顺序依次逐行执行。<br>在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参</p><hr><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名(实际参数列表);</span><br></pre></td></tr></table></figure><p><strong>实参和形参的类型必须一一对应，另外个数也要一一对应。</strong></p><ul><li>在方法调用的时候，什么时候“类名.”是可以省略的。什么时候不能省略？<ul><li>a()方法调用b()方法的时候，a和b方法都在<code>同一个类</code>中，“类名.”<code>可以省略</code>。<br>如果不在同一个类中“类名.”不能省略。</li></ul></li></ul><h4 id="调用方法的三种形式"><a href="#调用方法的三种形式" class="headerlink" title="调用方法的三种形式"></a>调用方法的三种形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赋值调用：</strong>调用方法，在方法前面定义变量，接收方法返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出语句调用：在输出语句中调用方法， System.out.println(方法名()) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能用输出语句调用void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>Java中方法的重载，就是在一个类中，有相同的方法名称，但形参不同的方法。</p><h4 id="方法重载的规则"><a href="#方法重载的规则" class="headerlink" title="方法重载的规则"></a>方法重载的规则</h4><ul><li>方法名称<strong>必须相同</strong></li><li>参数列表<strong>必须不同</strong>（参数个数不同、或参数类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同，不足以称为方法的重载。</li><li><strong>同一个类中，不允许两个方法的方法名称和参数列表都相同</strong></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>如下，代码中定义了三个<strong>max</strong>方法(即<strong>方法重载</strong>)，在调用它们时根据传入的实参类型和实参个数，分别调用了对应的 max 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mJane.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第一个max方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value1</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(max_value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第二个max方法，而不是第一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value2</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">25</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(max_value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为2个浮点数，匹配到第三个max方法</span></span><br><span class="line"><span class="comment">//int max_value3 = (int)max(10.0,30.0);   //返回值类型为double， 高--&gt;低 : 强制转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">max_value3</span> <span class="operator">=</span> max(<span class="number">10.0</span>,<span class="number">30.0</span>);</span><br><span class="line">        System.out.println(max_value3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> num3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt; num3 ? result:num3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>方法名相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法执行，如果匹配失败(未找到对应方法)，则编译器报错。</p><hr><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><blockquote><ul><li>Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</li><li>顺序结构是最简单的算法结构。</li><li><strong>顺序结构是任何一个算法都离不开的一种基本算法结构。</strong></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501213059243.png" alt="image-20220501213059243"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;到&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;依&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if单选择机构"><a href="#if单选择机构" class="headerlink" title="if单选择机构"></a>if单选择机构</h3><blockquote><ul><li>if语句的执行步骤<ul><li>对条件进行判断</li><li>判断条件为true，则执行代码块</li><li>判断条件为false，则跳过该语句</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501213713847.png" alt="image-20220501213713847"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h3><blockquote><ul><li>if-else的执行语句<ul><li>对条件进行判断</li><li>如果条件为true，则执行代码1</li><li>如果条件为false，则执行代码2</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501214013036.png" alt="image-20220501214013036"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h3><p>在if-else if-else语句中，if以及多个else-if后面的一对（）内的表达式的值必须为boolean类型。程序执行该语句时按照语句中表达式的顺序，首先计算表达式1的值，如果结果为true则执行紧跟着的复合语句，结束当前该语句的执行。如果结果为false则继续执行表达式2的值，以此类推，假设第M个表达式的值为true则执行跟着的复合语句，结束当前语句的执行，否则执行第M+1个表达式的值，如果所有的表达式的值都为false则执行关键字else后面的复合语句，结束当前语句的执行。</p><blockquote><p>执行流程：</p><ul><li>表达式1为true，则执行代码块1，再退出整个结构。</li><li>表达式2为true，则执行代码块2，再退出整个结构。</li><li>表达式3为true，则执行代码块3，再退出整个结构。</li><li>以上均为false，则执行代码块4，再退出整个结构。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>) &#123;</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (<span class="keyword">if</span>表达式<span class="number">2</span>)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (<span class="keyword">if</span>表达式<span class="number">3</span>)&#123;</span><br><span class="line">语句块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">else</span>(条件表达式n)&#123;</span><br><span class="line">语句块n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501214837908.png" alt="image-20220501214837908"></p><h3 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的if语句</h3><p>很多问题是一次简单的选择判断结构所解决不了的，需要进行多次选择判断，嵌套的if语句便是其中的一种解决方法。嵌套的if语句是一种多重选择结构。多重选择结构，顾名思义，就是有多种选择可以经过多次判断的结构。</p><blockquote><p>执行流程：</p><ul><li>当外层条件满足时，再判断内层条件。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">2</span>) &#123;</span><br><span class="line">语句 <span class="number">1</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">语句 <span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">3</span>) &#123;</span><br><span class="line">语句 <span class="number">3</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">语句 <span class="number">4</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501215733141.png" alt="image-20220501215733141"></p><h3 id="Switch选择语句"><a href="#Switch选择语句" class="headerlink" title="Switch选择语句"></a>Switch选择语句</h3><blockquote><p>switch语句和if的区别在于，switch只能进行等值判断，其限制较大</p></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501222540416.png" alt="image-20220501222540416"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">1</span>：</span><br><span class="line">语句块 <span class="number">1</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">2</span>：</span><br><span class="line">语句块 <span class="number">2</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">3</span>：</span><br><span class="line">语句块 <span class="number">3</span>；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line"><span class="keyword">case</span> 常量值n:</span><br><span class="line">语句块 n；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">default</span>：</span><br><span class="line">语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">while</span>( 布尔表达式 )&#123;</span><br><span class="line"><span class="comment">//循环结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>只要布尔表达式为true，循环就会一直执行下去。</p></li><li><p>我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。</p></li><li><p>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</p></li><li><p>循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或造成程序卡死崩溃</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//计算1+2+3+4+...+100=?</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><ul><li><p>对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p></li><li><p>do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (a&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="while和do…while的区别："><a href="#while和do…while的区别：" class="headerlink" title="while和do…while的区别："></a>while和do…while的区别：</h3><ul><li>while先判断后执行。dowhile是先执行后判断！</li><li>do…while总是保证循环体会被至少执行一次！这是他们的主要差别。</li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul><li>虽然所有循环结构都可以使用while或者do…while表示，但Java提供了另一种语句—for循环，使一些循环结构变得更加简单。</li><li>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</li><li>for循环执行的次数是在执行前就确定的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//初始化条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(a&lt;=<span class="number">100</span>)&#123;<span class="comment">//条件判断</span></span><br><span class="line">            System.out.println(a);<span class="comment">//循环体</span></span><br><span class="line">            a+=<span class="number">2</span>;<span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;while循环结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;for循环结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        关于for循环有以下几点说明：</span></span><br><span class="line"><span class="comment">        最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</span></span><br><span class="line"><span class="comment">        然后检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</span></span><br><span class="line"><span class="comment">        执行一次循环后，更新循环控制变量（迭代因子控制循环变量的增减）。</span></span><br><span class="line"><span class="comment">        再次检测布尔表达式。循环执行上面的过程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">for</span> ( ; ;)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(声明语句 : 表达式 )&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句快，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;; <span class="comment">//定义了一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123; </span><br><span class="line">            System.out.println(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历数组的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:numbers)&#123;<span class="comment">//增强for循环</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="breal、continue、return"><a href="#breal、continue、return" class="headerlink" title="breal、continue、return"></a>breal、continue、return</h2><h3 id="break和continue的作用和区别"><a href="#break和continue的作用和区别" class="headerlink" title="break和continue的作用和区别"></a>break和continue的作用和区别</h3><h4 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h4><p>break和continue都是用来控制循环结构的，主要作用是停止循环。</p><h4 id="break和continue的区别"><a href="#break和continue的区别" class="headerlink" title="break和continue的区别"></a>break和continue的区别</h4><p>1、break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。</p><p><strong>注意</strong>：</p><ul><li>只能在循环体内和switch语句体内使用break。</li><li>不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。</li><li>当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。</li></ul><p>2、continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。</p><p><strong>注意</strong>：</p><ul><li>continue语句并没有使整个循环终止。</li><li>continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。</li></ul><h4 id="break、return、continue的区别"><a href="#break、return、continue的区别" class="headerlink" title="break、return、continue的区别"></a>break、return、continue的区别</h4><p>break用于完全结束一个循环，跳出循环体。不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 break不仅可以结束其所在的循环，还可结束其外层循环。此时需要在break后紧跟一个标签，这个标签用于标识一个外层循环。Java中的标签就是一个紧跟着英文冒号（:）的标识符。且它必须放在循环语句之前才有作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakTest2</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// 外层循环，outer作为标识符</span></span><br><span class="line">　　　　outer:</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line">　　　　　　<span class="comment">// 内层循环</span></span><br><span class="line">　　　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span> ; j++ )&#123;</span><br><span class="line">　　　　　　　　System.out.println(<span class="string">&quot;i的值为:&quot;</span> + i + <span class="string">&quot; j的值为:&quot;</span> + j);</span><br><span class="line">　　　　　　　　<span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　　　<span class="comment">// 跳出outer标签所标识的循环。</span></span><br><span class="line">　　　　　　　　　　　<span class="keyword">break</span> outer;</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>continue的功能和break有点类似，区别是continue只是中止本次循环，接着开始下一次循环。而break则是完全中止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinueTest</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">// 一个简单的for循环</span></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">&quot;i的值是&quot;</span> + i);</span><br><span class="line">　　　　　　　<span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　　<span class="comment">// 忽略本次循环的剩下语句</span></span><br><span class="line">　　　　　　　　　<span class="keyword">continue</span>;</span><br><span class="line">　　　　　　　&#125;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">&quot;continue后的输出语句&quot;</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return关键字并不是专门用于跳出循环的，return的功能是结束一个方法。 一旦在循环体内执行到一个return语句，return语句将会结束该方法，循环自然也随之结束。与continue和break不同的是，return直接结束整个方法，不管这个return处于多少层循环之内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnTest</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// 一个简单的for循环</span></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;i的值是&quot;</span> + i);</span><br><span class="line">　　　　　　<span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;return后的输出语句&quot;</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归，就是在运行的过程中调用自己。"><a href="#递归，就是在运行的过程中调用自己。" class="headerlink" title="递归，就是在运行的过程中调用自己。"></a><strong>递归，就是在运行的过程中调用自己。</strong></h3><p>递归结构包含两个部分：</p><ul><li><strong>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环</strong></li><li><strong>递归体：什么时候需要调用自身方法</strong></li></ul><p>构成递归需具备的条件：<br><strong>1. 子问题须与原始问题为同样的事，且更为简单；</strong><br><strong>2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。</strong></p><h3 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h3><p>我们知道递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方，也就是下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(参数<span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recursion(参数<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>对递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处。</p><p><strong>阶乘</strong></p><p>一个最简单的递归调用-阶乘，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">System.out.println( f(<span class="number">5</span>) );</span><br><span class="line"><span class="comment">//结果：120</span></span><br></pre></td></tr></table></figure><p>第2-3行是终止条件，第5行是调用自己。就用n等于5的时候来画个图看一下递归究竟是怎么调用的</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220513152851533.png" alt="image-20220513152851533"></p><p>这种递归还是很简单的，我们求f(5)的时候，只需要求出f(4)即可，如果求f(4)我们要求出f(3)……，一层一层的调用，当n&#x3D;1的时候，我们直接返回1，然后再一层一层的返回，直到返回f(5)为止。</p><p>递归的目的是把一个大的问题细分为更小的子问题，我们只需要知道递归函数的功能即可，不要把递归一层一层的拆开来想，如果同时调用多次的话这样你很可能会陷入循环而出不来。比如上面的题中要求f(5)，我们只需要计算f(4)即可，即f(5)&#x3D;5*f(4)；至于f(4)是怎么计算的，我们就不要管了。因为我们知道f(n)中的n可以代表任何正整数，我们只需要传入4就可以计算f(4)。</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。</strong></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>其长度是确定的，数组一旦被创建，它的大小就是不可以改变的</li><li>其元素必须是相同类型的，不允许出现混合类型</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型</li><li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量，</li></ul><p>数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，都是可以的</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>数组的两种常见初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>格式：</p><blockquote><p>数组存储的数据类型[ ] 数组名字 &#x3D; new 数组存储的数据类型[数组长度];<br>数组存储的数据类型 数组名字[ ] &#x3D; new 数组存储的数据类型[数组长度];</p></blockquote><ul><li><p>数组定义格式详解：</p></li><li><p>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</p></li><li><p>[] : 表示数组。</p></li><li><p>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</p></li><li><p>new：关键字，创建数组使用的关键字。</p></li><li><p>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</p></li><li><p>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</p></li><li><p>注意：数组有定长特性，长度一旦指定，不可更改。</p></li></ul><p>和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。<br>举例:<br>定义可以存储3个整数的数组容器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];  </span><br><span class="line"><span class="type">int</span>   arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 可以拆分 </span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><ul><li>格式：</li></ul><blockquote><p>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,元素3…};</p></blockquote><ul><li>举例： 定义存储1，2，3，4，5整数的数组容器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">// 可以拆分 </span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="静态初始化省略格式（不能拆分）"><a href="#静态初始化省略格式（不能拆分）" class="headerlink" title="静态初始化省略格式（不能拆分）"></a>静态初始化省略格式（不能拆分）</h4><ul><li>格式：</li></ul><blockquote><p>数据类型[] 数组名 &#x3D; {元素1,元素2,元素3…};</p></blockquote><ul><li>举例：</li></ul><p>定义存储1，2，3，4，5整数的数组容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><ul><li><p>索引：  每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。</p></li><li><p>格式：</p><blockquote><p>数组名[索引]</p></blockquote></li><li><p>数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数组的最大索引值为数组名.length-1。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">  System.out.println(arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>索引访问数组中的元素：</p><blockquote><p>数组名[索引] &#x3D; 数值，为数组中的元素赋值<br>变量 &#x3D; 数组名[索引]，获取出数组中的元素</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5 </span></span><br><span class="line"> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="comment">//为0索引元素赋值为6 </span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">6</span>; </span><br><span class="line">  <span class="comment">//获取数组0索引上的元素 </span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr[<span class="number">0</span>]; </span><br><span class="line">  System.out.println(i); </span><br><span class="line">  <span class="comment">//直接输出数组0索引元素 </span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组初始化</p><p>同一维数组一样，共有4总不同形式的定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> array2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> array3[][] = &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="type">int</span> array4[][] = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;&#125;;</span><br></pre></td></tr></table></figure><p>不定长二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">array[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>获取二维数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">// 获取二维数组的第一维长度（3）</span></span><br><span class="line">System.out.println(length1);</span><br><span class="line"><span class="comment">// 获取二维数组的第一维的第一个数组长度（1）</span></span><br><span class="line">System.out.println(length2);</span><br></pre></td></tr></table></figure><p>遍历打印二位数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = &#123; &#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">         System.out.print( array[i][j] );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>Sparse Array 稀疏数组。</p><h4 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h4><p>先来看一个实际需求，比较好思考</p><p>编写五子棋程序中的 <strong>存盘退出</strong> 和 <strong>续上盘</strong> 功能</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703215903031.8ffc1996.png" alt="image-20200703215903031"></p><p>我们首先能想到的就是使用一个 <strong>二维数组</strong>，如上图所示：</p><ul><li>0：表示没有棋子</li><li>1：表示黑棋</li><li>2：表示白棋</li></ul><h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>可以看到二维数组中很多值都是 0，因此记录了很多没有意义的数据。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>定义：当一个数组中 <strong>大部分元素为 0（或是同一个值）</strong> 时，可以使用 <strong>稀疏数组</strong> 来保存该数组</p><p>处理方法：</p><ol><li>记录数组一共有 <strong>几行几列</strong>，<strong>有多少个不同的值</strong></li><li>把具有 <strong>不同值的元素</strong> 的 <strong>行列及值</strong> 记录在一个 <strong>小规模的数组</strong> 中，从而缩小程序的规模</li></ol><p>这个小规模的数组就称为 <strong>稀疏数组</strong>，举个例子，如下图</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703221437344.19a0a264.png" alt="image-20200703221437344"></p><p>左侧是原始的二维数组 <code>6x7 = 42 个格子</code>，右侧是稀疏数组 <code>9 x 3 = 27 个格子</code></p><ul><li><p><code>[0]</code>：记录了棋盘的大小，6 行 7 列，棋盘上有 8 个不为 0 的值</p></li><li><p>其他行：分别记录每一个非 0 值的所在行、所在列、值</p><p>比如 <code>[1]</code>：在第 0 行第 3 列上有一个 22（这里的行列都是下标）</p></li></ul><p>可以看到原始 42 个数据，压缩成 27 个数据。一定程度上压缩了数据。</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>使用 <strong>稀疏数组</strong> 保留类似前面的 <strong>二维数组</strong>（如棋盘、地图等等的场景），把 <strong>稀疏数组存盘</strong>，并且可以从新 <strong>恢复原来的二维数组</strong></p><p>####稀疏数组与二维数组互转思路</p><p>以前面的棋盘数据来讲解</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703223528941.02cbe7fb.png" alt="image-20200703223528941"></p><p>如上图，总结出来稀疏数组为右侧那样。那么他们互转思路如下：</p><p>二维数组转稀疏数组思路：</p><ol><li>遍历原始的二维数组，得到有效个数 sum</li><li>根据 sum 创建 <strong>稀疏数组</strong> <code>sparseArr = int[sum + 1][3]</code></li><li>将二维数据的有效数据存入到稀疏数组中（从第 2 行开始存储）</li><li>最后将棋盘大小和有效个数写入第一行</li></ol><p>稀疏数组转原始二维数组思路：</p><ol><li>读取第一行数据，根据棋盘大小，创建原始的二维数组 <code>chessArr = int [11][11]</code></li><li>从第二行开始，将有效数据还原到原始数组中</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrcode.study.dsalgtutorialdemo.datastructure.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  稀疏数组：</span></span><br><span class="line"><span class="comment"> *      1. 二维数组转稀疏数组</span></span><br><span class="line"><span class="comment"> *      2. 稀疏数组转二维数组</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原始二维数组</span></span><br><span class="line">        <span class="comment">// 0：没有棋子，1：黑棋，2：白棋</span></span><br><span class="line">        <span class="comment">// 棋盘大小 11 x 11</span></span><br><span class="line">        <span class="type">int</span> chessArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 预览棋盘上的棋子位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;预览原始数组&quot;</span>);</span><br><span class="line">        printChessArray(chessArr);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 二维数组转稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = chessToSparse(chessArr);</span><br><span class="line"><span class="comment">// int[][] sparseArr = chessToSparse2(chessArr); // 紧凑版本可以参考笔记配套项目</span></span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组转稀疏数组&quot;</span>);</span><br><span class="line">        printChessArray(sparseArr);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 稀疏数组转二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr2 = sparseToChess(sparseArr);</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组转二维数组&quot;</span>);</span><br><span class="line">        printChessArray(chessArr2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二维数组转稀疏数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] chessToSparse(<span class="type">int</span>[][] chessArr) &#123;</span><br><span class="line">        <span class="comment">// 1. 遍历数组得到有效棋子个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> chess : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chess != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 3. 将二维数据的有效数据存入到稀疏数组中（从第 2 行开始存储）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chessRow</span> <span class="operator">=</span> chessArr.length;  <span class="comment">// 行： 棋盘大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chessCol</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 列： 棋盘大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前是第几个非 0 的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rows = chessArr[i];</span><br><span class="line">            <span class="keyword">if</span> (chessCol == <span class="number">0</span>) &#123;</span><br><span class="line">                chessCol = rows.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; rows.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">chess</span> <span class="operator">=</span> rows[j];</span><br><span class="line">                <span class="keyword">if</span> (chess == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;  <span class="comment">// 第一行是棋盘信息，所以先自增</span></span><br><span class="line">                sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                sparseArr[count][<span class="number">2</span>] = chess;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 补全第一行的棋盘大小和有效数据</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = chessRow;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = chessCol;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="keyword">return</span> sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 稀疏数组转二维数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sparseArr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] sparseToChess(<span class="type">int</span>[][] sparseArr) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 2. 恢复有效数据到二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rows = sparseArr[i];</span><br><span class="line">            chessArr[rows[<span class="number">0</span>]][rows[<span class="number">1</span>]] = rows[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chessArr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印棋盘上的棋子布局</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printChessArray</span><span class="params">(<span class="type">int</span>[][] chessArr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                <span class="comment">// 左对齐，使用两个空格补齐 2 位数</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%-2d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">预览原始数组</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">二维数组转稀疏数组</span><br><span class="line"><span class="number">11</span><span class="number">11</span><span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line">稀疏数组转二维数组</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="八大排序"><a href="#八大排序" class="headerlink" title="八大排序"></a>八大排序</h2><hr><h2 id="栈、堆"><a href="#栈、堆" class="headerlink" title="栈、堆"></a>栈、堆</h2><p>Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a><strong>栈内存</strong></h3><p>栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a><strong>堆内存</strong></h3><p>存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p><p>主函数里的语句   int [] arr&#x3D;new int [3];在内存中是怎么被定义的：</p><p>主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220514173855512.png" alt="image-20220514173855512"></p><h3 id="堆和栈是怎么联系起来的呢"><a href="#堆和栈是怎么联系起来的呢" class="headerlink" title="堆和栈是怎么联系起来的呢?"></a>堆和栈是怎么联系起来的呢?</h3><p> 给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。</p><p>如果当<strong>int [] arr&#x3D;null;</strong></p><p> arr不做任何指向，null的作用就是取消引用数据类型的指向。、</p><p> 当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。<br>  所以堆与栈的区别很明显：</p><ol><li>栈内存存储的是局部变量而堆内存存储的是实体</li><li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li></ol><hr><h2 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h2><p>javadoc是Sun公司提供的一个技术，它从程序<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969">源代码</a>中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。</p><p>javadoc命令是用来生成自己<a href="https://baike.baidu.com/item/API/10154">API</a>文档的，使用方式：使用命令行在目标文件所在目录输入javadoc +文件名.java。</p><table><thead><tr><th>标签</th><th>说明</th><th>JDK 1.1 doclet</th><th>标准doclet</th><th>标签类型</th></tr></thead><tbody><tr><td>@author 作者</td><td>作者标识</td><td>√</td><td>√</td><td>包、 类、接口</td></tr><tr><td>@version 版本号</td><td>版本号</td><td>√</td><td>√</td><td>包、 类、接口</td></tr><tr><td>@param 参数名 描述</td><td>方法的入参名及描述信息，如入参有特别要求，可在此注释。</td><td>√</td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@return 描述</td><td>对函数返回值的注释</td><td>√</td><td>√</td><td>方法</td></tr><tr><td>@deprecated 过期文本</td><td>标识随着程序版本的提升，当前API已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个API。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>@throws异常类名</td><td>构造函数或方法所会抛出的异常。</td><td></td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@exception 异常类名</td><td>同@throws。</td><td>√</td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@see 引用</td><td>查看相关内容，如类、方法、变量等。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>@since 描述文本</td><td>API在什么程序的什么版本后开发支持。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>{@link包.类#成员 标签}</td><td>链接到某个特定的成员对应的文档中。</td><td></td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>{@value}</td><td>当对常量进行注释时，如果想将其值包含在文档中，则通过该标签来引用常量的值。</td><td></td><td>√(JDK1.4)</td><td>静态值域</td></tr></tbody></table><p>此外还有@serial、@serialField、@serialData、{@docRoot}、{@inheritDoc}、{@literal}、{@code} {@value arg}几个不常用的标签，由于不常使用，我们不展开叙述，感兴趣的读者可以查看帮助文档。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序</title>
      <link href="/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/big-o.png" alt="img"></a></p><ul><li>直接插入排序</li><li>希尔排序</li><li>简单选择排序</li><li>堆排序</li><li>冒泡排序</li><li>快速排序</li><li>归并排序</li><li>基数排序</li></ul><p>这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms">Github：<strong>SortAlgorithms</strong></a>，其中也包括了排序测试模块[<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java">Test.java]</a>和排序算法对比模块[<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java">Bench.java]</a>，可以试运行。</p><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p>⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪内部排序⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序{内部排序{插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序</p><h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p><p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p><h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/insert-sort.gif" alt="直接插入排序演示"></a>直接插入排序演示</p><p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p><p>如果<strong>比较操作</strong>的代价比<strong>交换操作</strong>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95">二分查找法</a>来减少<em>比较操作</em>的数目。可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&action=edit&redlink=1">二分查找插入排序</a>。</p><h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line"> * 5. 将新元素插入到该位置后</span><br><span class="line"> * 6. 重复步骤2~5</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i = 1; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        int temp = arr[i];    // 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line">        for( int j = i; j &gt;= 0; j-- ) &#123;</span><br><span class="line">            if( j &gt; 0 &amp;&amp; arr[j-1] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-1];    // 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span><br><span class="line">                System.out.println(&quot;Temping:  &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将新元素插入到该位置后</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交换次数较多的实现</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i=0; i&lt;arr.length-1; i++ ) &#123;</span><br><span class="line">        for( int j=i+1; j&gt;0; j-- ) &#123;</span><br><span class="line">            if( arr[j-1] &lt;= arr[j] )</span><br><span class="line">                break;</span><br><span class="line">            int temp = arr[j];      //交换操作</span><br><span class="line">            arr[j] = arr[j-1];</span><br><span class="line">            arr[j-1] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序复杂度如下：</p><ul><li>最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1n−1；移动次数(RMN)为00。则对应的时间复杂度为O(n)O(n)。</li><li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22 ; 移动次数(RMN)为：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22。则对应的时间复杂度为O(n2)O(n2)。</li><li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n22n22，因此，<strong>直接插入排序的平均时间复杂度</strong>为O(n2)O(n2)。</li></ul><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/shell-sort.jpg" alt="img"></a></p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap&#x3D;1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>。</p><h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shellSort(int[] arr)&#123;</span><br><span class="line">    int gap = arr.length / 2;</span><br><span class="line">    for (; gap &gt; 0; gap /= 2) &#123;      //不断缩小gap，直到1为止</span><br><span class="line">        for (int j = 0; (j+gap) &lt; arr.length; j++)&#123;     //使用当前gap进行组内插入排序</span><br><span class="line">            for(int k = 0; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                if(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    int temp = arr[k+gap];      //交换操作</span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(&quot;    Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>①. 第一层for循环表示一共有多少个增量。增量的序列的个数，就是希尔排序的趟数。上面的增量序列为： <code>arr.length/2, arr.length/2/2, arr.length/2/2/2, .... 2, 1</code><br>②. 里层的两个for循环，实际上就是以一个gap拆分为一组的<strong>组内插入排序</strong>。</p><p>下面是维基百科官方实现，大家注意gap步长取值部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序（Wiki官方版）</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shell_sort(int[] arr) &#123;</span><br><span class="line">    int gap = 1, i, j, len = arr.length;</span><br><span class="line">    int temp;</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;      // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span><br><span class="line">    for (; gap &gt; 0; gap /= 3) &#123;</span><br><span class="line">        for (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是希尔排序复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog2 n)</td><td align="left">O(nlog2 n)</td><td align="left">O(nlog2 n)</td><td align="left">O(1)</td></tr></tbody></table><h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr><blockquote><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></a>选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p></blockquote><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p><h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</span><br><span class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</span><br><span class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void selectionSort(int[] arr)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.length-1; i++)&#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for(int j = i+1; j &lt; arr.length; j++)&#123;    //选出之后待排序中值最小的位置</span><br><span class="line">            if(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min != i)&#123;</span><br><span class="line">            int temp = arr[min];      //交换操作</span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是选择排序复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²&#x2F;2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：nn个元素的序列 {k1,k2,⋅⋅⋅,kn}{k1,k2,···,kn} 当且仅当满足下关系时，称之为堆。</p><p>{kiki⩽k2i⩽k2i+1或{kiki⩾k2i⩾k2i+1(i&#x3D;1,2,⋅⋅⋅,⌊n2⌋){ki⩽k2iki⩽k2i+1或{ki⩾k2iki⩾k2i+1(i&#x3D;1,2,···,⌊n2⌋)</p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列K[1..n]K[1..n]建成一个大顶堆, 那么此时第一个元素K1K1最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录K1K1 (即堆顶, 第一个元素)和无序区的最后一个记录 KnKn 交换, 由此得到新的无序区K[1..n−1]K[1..n−1]和有序区K[n]K[n], 且满足K[1..n−1].keys⩽K[n].keyK[1..n−1].keys⩽K[n].key<br>③. 交换K1K1 和 KnKn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p><p>动图效果如下所示：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></a>堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p><h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</span><br><span class="line"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</span><br><span class="line"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void heapSort(int[] arr)&#123;</span><br><span class="line">    for(int i = arr.length; i &gt; 0; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        int temp = arr[0];      //堆顶元素(第一个元素)与Kn交换</span><br><span class="line">        arr[0] = arr[i-1];</span><br><span class="line">        arr[i-1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void max_heapify(int[] arr, int limit)&#123;</span><br><span class="line">    if(arr.length &lt;= 0 || arr.length &lt; limit) return;</span><br><span class="line">    int parentIdx = limit / 2;</span><br><span class="line"></span><br><span class="line">    for(; parentIdx &gt;= 0; parentIdx--)&#123;</span><br><span class="line">        if(parentIdx * 2 &gt;= limit)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = parentIdx * 2;       //左子节点位置</span><br><span class="line">        int right = (left + 1) &gt;= limit ? left : (left + 1);    //右子节点位置，如果没有右节点，默认为左节点位置</span><br><span class="line"></span><br><span class="line">        int maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        if(arr[maxChildId] &gt; arr[parentIdx])&#123;   //交换父节点与左右子节点中的最大值</span><br><span class="line">            int temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Max_Heapify: &quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 &#x3D;&#x3D; Math.floor(x&#x2F;2) .</p></blockquote><p>以上,<br>①. 建立堆的过程, 从length&#x2F;2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(1)</td></tr></tbody></table><p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p><h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort02.gif" alt="冒泡排序的思想"></a>冒泡排序的思想</p><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort.gif" alt="冒泡排序演示"></a>冒泡排序演示</p><h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p><h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><br><span class="line"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><br><span class="line"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">    for (int i = arr.length; i &gt; 0; i--) &#123;      //外层循环移动游标</span><br><span class="line">        for(int j = 0; j &lt; i &amp;&amp; (j+1) &lt; i; j++)&#123;    //内层循环遍历游标及之后(或之前)的元素</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²&#x2F;2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p><h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></a>使用快速排序法对一列数字进行排序的过程</p><h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/quick-sort09.gif" alt="快速排序演示"></a>快速排序演示</p><h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p><p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></a>快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> * @param low   左边界</span><br><span class="line"> * @param high  右边界</span><br><span class="line"> */</span><br><span class="line">public static void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    if(low &gt;= high) return;</span><br><span class="line">    int left = low;</span><br><span class="line">    int right = high;</span><br><span class="line"></span><br><span class="line">    int temp = arr[left];   //挖坑1：保存基准的值</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-1);</span><br><span class="line">    quickSort(arr, left+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（非递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void quickSortByStack(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    //初始状态的左右指针入栈</span><br><span class="line">    stack.push(0);</span><br><span class="line">    stack.push(arr.length - 1);</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        int high = stack.pop();     //出栈进行划分</span><br><span class="line">        int low = stack.pop();</span><br><span class="line"></span><br><span class="line">        int pivotIdx = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        //保存中间变量</span><br><span class="line">        if(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= 0)&#123;</span><br><span class="line">            stack.push(pivotIdx + 1);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int partition(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return -1;</span><br><span class="line">    if(low &gt;= high) return -1;</span><br><span class="line">    int l = low;</span><br><span class="line">    int r = high;</span><br><span class="line"></span><br><span class="line">    int pivot = arr[l];    //挖坑1：保存基准的值</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><p>以下是快速排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n²)</td><td align="left">O(1)（原地分区递归版）</td></tr></tbody></table><p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p><p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p><h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr><blockquote><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort_sample.jpg" alt="img"></a></p></blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="这个图很有概括性，来自维基"></a>这个图很有概括性，来自维基</p><h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>一、递归法</strong>（假设序列共有n个元素）：</p><p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n&#x2F;2)个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 floor(n&#x2F;4)个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort.gif" alt="img"></a></p><p><strong>二、迭代法</strong></p><p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p><h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p><strong>如何合并？</strong></p><p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p><p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p><p><strong>如何分解？</strong></p><p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p>这里我写了递归算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 归并排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span><br><span class="line"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span><br><span class="line"> * ③. 重复步骤②，直到所有元素排序完毕。</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static int[] mergingSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line">    int num = arr.length &gt;&gt; 1;</span><br><span class="line">    int[] leftArr = Arrays.copyOfRange(arr, 0, num);</span><br><span class="line">    int[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(&quot;split two array: &quot; + Arrays.toString(leftArr) + &quot; And &quot; + Arrays.toString(rightArr));</span><br><span class="line">    return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      //不断拆分为最小单元，再排序合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] mergeTwoArray(int[] arr1, int[] arr2)&#123;</span><br><span class="line">    int i = 0, j = 0, k = 0;</span><br><span class="line">    int[] result = new int[arr1.length + arr2.length];  //申请额外的空间存储合并之后的数组</span><br><span class="line">    while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      //选取两个序列中的较小值放入新数组</span><br><span class="line">        if(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; arr1.length)&#123;     //序列1中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; arr2.length)&#123;     //序列2中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Merging: &quot; + Arrays.toString(result));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p><p>以下是归并排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</li><li><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</li></ul><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radix-sort_sample.gif" alt="基数排序LSD动图演示"></a>基数排序LSD动图演示</p><h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数；<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</li><li><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序（LSD 从低位开始）</span><br><span class="line"> *</span><br><span class="line"> * 基数排序适用于：</span><br><span class="line"> *  (1)数据范围较小，建议在小于1000</span><br><span class="line"> *  (2)每个数值都要大于等于0</span><br><span class="line"> *</span><br><span class="line"> * ①. 取得数组中的最大数，并取得位数；</span><br><span class="line"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</span><br><span class="line"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">    //取得数组中的最大数，并取得位数</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(max &lt; arr[i])&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxDigit = 1;</span><br><span class="line">    while(max / 10 &gt; 0)&#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;maxDigit: &quot; + maxDigit);</span><br><span class="line"></span><br><span class="line">    //申请一个桶空间</span><br><span class="line">    int[][] buckets = new int[10][arr.length];</span><br><span class="line">    int base = 10;</span><br><span class="line"></span><br><span class="line">    //从低位到高位，对每一位遍历，将所有元素分配到桶中</span><br><span class="line">    for(int i = 0; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        int[] bktLen = new int[10];        //存储各个桶中存储元素的数量</span><br><span class="line">        </span><br><span class="line">        //分配：将所有元素分配到桶中</span><br><span class="line">        for(int j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            int whichBucket = (arr[j] % base) / (base / 10);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int b = 0; b &lt; buckets.length; b++)&#123;</span><br><span class="line">            for(int p = 0; p &lt; bktLen[b]; p++)&#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">        base *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(d*(n+r))</td><td align="left">O(d*(n+r))</td><td align="left">O(d*(n+r))</td><td align="left">O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p><p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>各种排序性能对比如下，有些排序未详细介绍，暂且放到这里。实例测试结果可以看这里：<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md"><strong>八大排序算法耗时对比</strong></a> 。</p><table><thead><tr><th align="left">排序类型</th><th align="left">平均情况</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">辅助空间</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">选择排序</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">直接插入排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">折半插入排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">希尔排序</td><td align="left">O(n^1.3)</td><td align="left">O(nlogn)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">归并排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n)</td><td align="left">稳定</td></tr><tr><td align="left">快速排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n²)</td><td align="left">O(nlog₂n)</td><td align="left">不稳定</td></tr><tr><td align="left">堆排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">计数排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(k)</td><td align="left">稳定</td></tr><tr><td align="left">桶排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n²)</td><td align="left">O(n+k)</td><td align="left">(不)稳定</td></tr><tr><td align="left">基数排序</td><td align="left">O(d(n+k))</td><td align="left">O(d(n+k))</td><td align="left">O(d(n+kd))</td><td align="left">O(n+kd)</td><td align="left">稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><p>(1). 平方阶O(n²)排序：**<code>各类简单排序：直接插入、直接选择和冒泡排序</code>**；</p><p>(2). 线性对数阶O(nlog₂n)排序：**<code>快速排序、堆排序和归并排序</code>**；</p><p>(3). O(n1+§))排序，§是介于0和1之间的常数：**<code>希尔排序</code>**</p><p>(4). 线性阶O(n)排序：**<code>基数排序，此外还有桶、箱排序</code><strong>。<br>　　<br>到此，很多人会注意到</strong>基数排序**的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/radixsort-comparison.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radixsort-comparison.jpg" alt="img"></a></p><p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p><h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p><ol><li>计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数</li><li>基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值</li><li>桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li></ol><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O( nlgn)</strong> 。参考<a href="https://www.zhihu.com/question/24516934">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/2016-07-15_%25E5%25B8%25B8%25E7%2594%25A8%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown文档常用写法</title>
      <link href="/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/"/>
      <url>/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><p>第一种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165256359-1045755089.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165419890-1445220158.png" alt="img"></p><p>前面带#号，后面带文字，分别表示h1-h6,上图可以看出，只到h6，而且h1下面会有一条横线，注意，#号后面有空格</p><p>第二种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165937218-1530465248.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165947968-314903197.png" alt="img"></p><p>这种方式好像只能表示一级和二级标题，而且&#x3D;和-的数量没有限制，只要大于一个就行</p><p>第三种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121170247156-1219352477.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121170255531-442290753.png" alt="img"></p><p>这里的标题支持h1-h6，为了减少篇幅，我就偷个懒，只写前面二个，这个比较好理解，相当于标签闭合，注意，标题与#号要有空格</p><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121172350078-1462814017.png" alt="img"></p><p>在线地址请看这里： <a href="http://tool.oschina.net/markdown/">markdown在线编辑</a> （只是想看看背后的转换原理，没有广告之嫌）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>我们都知道，列表分为有序列表和无序列表，下面直接展示2种列表的写法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121171909093-661987876.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121171919343-1747027523.png" alt="img"></p><p>可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121173226140-1875382054.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121173239421-1080651187.png" alt="img"></p><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的，比如说：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175940718-1084956249.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175948687-1987133124.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175958281-1526944139.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180005984-1893005909.png" alt="img"></p><p>第一组本来是3 2 1 倒序，但是现实3 4 5 ，后面一组 序号是乱的， 但是还是显示 3 4 5 ，这点必须注意了</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174024531-1893848795.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174034406-909064775.png" alt="img"></p><p>无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格</p><p>引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174722343-1828411427.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174734109-810075211.png" alt="img"></p><p>将上面的代码稍微改一下，全部加上引用标签，就变成了一个大的引用，还有引用里面还有引用，那引用嵌套引用还没有别的写法呢？</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175159984-1386789693.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175207031-1980491226.png" alt="img"></p><p>上图可以看出，想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的&gt;是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧</p><h2 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h2><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180722171-1035491697.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180731562-316920662.png" alt="img"></p><p>应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121181659734-1035365203.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121181708390-1994007685.png" alt="img"></p><p>上图可知，行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中，举一反三，经常出现的列表链接就应该这样写：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121182158531-1522139664.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121182206671-1837073264.png" alt="img"></p><p>链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来</p><p><img src="https://images2015.cnblogs.com/blog/600165/201701/600165-20170121182852468-1462512454.png" alt="img"></p><p>这是行内式的写法，参数式的怎么写：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121183435890-1350949010.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121183445640-1750855701.png" alt="img"></p><p>这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系，参数定义时，这3种写法都可以：</p><p>还支持这种写法，如果你不想混淆的话：</p><p>其实还有一种隐式链接的写法，但是我觉得那种写法不直观，所以就不写了，经常用的一般就上面2种，如果你想了解隐式链接，可以看我文章最后放出的参考地址</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片也有2种方式：行内式和参数式，</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121185054312-549083784.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121185106031-1426410254.png" alt="img"></p><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190316875-1459932813.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190325703-1235022505.png" alt="img"></p><p>要是多行这个就不行了，多行可以用这个：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190613718-1073029883.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190635656-1896064058.png" alt="img"></p><p>多行用三个反引号，如果要写注释，可以在反引号后面写</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这个写的有点麻烦，注意看</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121192302156-105192980.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121192312453-411896732.png" alt="img"></p><p>从这3种不同写法看，表格的格式不一定要对的非常起，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的，不过现实出来的结果是，表格外面并没有线框包起来，不知道别人的怎么弄的</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193336406-237336360.png" alt="img">   <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193346781-1402792187.png" alt="img"></p><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193837156-99120890.png" alt="img">   <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193847093-1553208687.png" alt="img"></p><p>就不一一列举了，基本上跟js转义是一样的</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><img src="https://images2015.cnblogs.com/blog/600165/201701/600165-20170121194131015-499064556.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121194138656-989711852.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必备网站大全，给你全面惊喜</title>
      <link href="/2022/04/06/%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99%E5%A4%A7%E5%85%A8%EF%BC%8C%E7%BB%99%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%83%8A%E5%96%9C/"/>
      <url>/2022/04/06/%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99%E5%A4%A7%E5%85%A8%EF%BC%8C%E7%BB%99%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%83%8A%E5%96%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="学习类"><a href="#学习类" class="headerlink" title="学习类"></a>学习类</h1><p>CSDN： <a href="https://www.csdn.net/">https://www.csdn.net/</a><br>TED（最优质的演讲）：<a href="https://www.ted.com/">https://www.ted.com/</a><br>谷粉学术： <a href="https://gfsoso.99lb.net/scholar.html">https://gfsoso.99lb.net/scholar.html</a><br>大学资源网：<a href="http://www.dxzy163.com/">http://www.dxzy163.com/</a><br>简答题：<a href="http://www.jiandati.com/">http://www.jiandati.com/</a><br>网易公开课：<a href="https://open.163.com/ted/">https://open.163.com/ted/</a><br>网易云课堂：<a href="https://study.163.com/">https://study.163.com/</a><br>中国大学MOOC：<a href="http://www.icourse163.org/">www.icourse163.org</a><br>网易云课堂：<a href="https://study.163.com/">https://study.163.com</a><br>哔哩哔哩弹幕网： <a href="http://www.bilibili.com/">www.bilibili.com</a><br>我要自学网： <a href="http://www.51zxw.net/">www.51zxw.net</a><br>知乎：<a href="http://www.zhihu.com/">www.zhihu.com</a><br>学堂在线：<a href="http://www.xuetangx.com/">www.xuetangx.com</a><br>爱课程：<a href="http://www.icourses.cn/">www.icourses.cn</a><br>猫咪论文：<a href="https://lunwen.im/">https://lunwen.im/</a><br>iData（论文搜索）：<a href="http://www.cn-ki.net/">www.cn-ki.net</a><br>文泉考试：<a href="https://www.wqkaoshi.com/">https://www.wqkaoshi.com</a></p><h1 id="书籍类"><a href="#书籍类" class="headerlink" title="书籍类"></a>书籍类</h1><p>书栈网（极力推荐）： <a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a><br>码农之家（计算机电子书下载）：<a href="http://www.xz577.com/">www.xz577.com</a><br>鸠摩搜书：<a href="http://www.jiumodiary.com/">www.jiumodiary.com</a><br>云海电子图书馆：<a href="http://www.pdfbook.cn/">www.pdfbook.cn</a><br>周读（书籍搜索）：<a href="http://ireadweek.com/">http://ireadweek.com</a><br>知轩藏书：<a href="http://www.zxcs.me/">http://www.zxcs.me/</a><br>脚本之家电子书下载：<a href="https://www.jb51.net/books/">https://www.jb51.net/books/</a><br>搜书VIP-电子书搜索：<a href="http://www.soshuvip.com/all.html">http://www.soshuvip.com/all.html</a><br>书格（在线古籍图书馆）：<a href="https://new.shuge.org/">https://new.shuge.org/</a><br>caj云阅读：<a href="http://cajviewer.cnki.net/cajcloud/">http://cajviewer.cnki.net/cajcloud/</a><br>必看网（人生必看的书籍）：<a href="https://www.biikan.com/">https://www.biikan.com/</a></p><h1 id="冷知识-x2F-黑科技"><a href="#冷知识-x2F-黑科技" class="headerlink" title="冷知识 &#x2F; 黑科技"></a>冷知识 &#x2F; 黑科技</h1><p>上班摸鱼必备（假装电脑系统升级）： <a href="http://fakeupdate.net/">http://fakeupdate.net/</a><br>PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）： <a href="http://www.species-in-pieces.com/">http://www.species-in-pieces.com/</a><br>图片立体像素画： <a href="https://pissang.github.io/voxelize-image/">https://pissang.github.io/voxelize-image/</a><br>福利单词（一个不太正经的背单词网站）： <a href="http://dict.ftqq.com/">http://dict.ftqq.com</a><br>查无此人（刷新网站，展现一张AI 生成的人脸照片）：<a href="https://thispersondoesnotexist.com/">https://thispersondoesnotexist.com/</a><br>在线制作地图图例：<a href="https://mapchart.net/">https://mapchart.net/</a><br>创意光线绘画：<a href="http://weavesilk.com/">http://weavesilk.com/</a><br>星系观察： <a href="https://stellarium-web.org/">https://stellarium-web.org/</a><br>煎蛋：<a href="http://jandan.net/">http://jandan.net/</a><br>渣男-说话的艺术：<a href="https://lovelive.tools/">https://lovelive.tools/</a><br>全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a><br>iData：<a href="https://www.cn-ki.net/">https://www.cn-ki.net/</a><br>术语在线：<a href="http://www.termonline.cn/">http://www.termonline.cn/</a></p><h1 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h1><p>GitHub：<a href="https://github.com/">https://github.com/</a><br>码云：<a href="https://gitee.com/">https://gitee.com/</a><br>源码之家：<a href="https://www.mycodes.net/">https://www.mycodes.net/</a><br>JSON to Dart： <a href="https://javiercbk.github.io/json_to_dart/">https://javiercbk.github.io/json_to_dart/</a><br>Json在线解析验证： <a href="https://www.json.cn/">https://www.json.cn/</a><br>在线接口测试（Getman）：<a href="https://getman.cn/">https://getman.cn/</a></p><h1 id="搜资源"><a href="#搜资源" class="headerlink" title="搜资源"></a>搜资源</h1><p>DogeDoge搜索引擎：<a href="http://www.dogedoge.com/">www.dogedoge.com</a><br>秘迹搜索：<a href="https://mijisou.com/">https://mijisou.com/</a><br>小白盘：<a href="https://www.xiaobaipan.com/">https://www.xiaobaipan.com/</a><br>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com/">www.yunpanjingling.com</a><br>虫部落（资源搜索）：<a href="http://www.chongbuluo.com/">www.chongbuluo.com</a><br>如风搜（资源搜索）：<a href="http://www.rufengso.net/">http://www.rufengso.net/</a><br>爱扒：<a href="https://www.zyboe.com/">https://www.zyboe.com/</a></p><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><p>奶牛快传（在线传输文件利器）： <a href="http://cowtransfer.com/">http://cowtransfer.com</a><br>文叔叔（大文件传输，不限速）：<a href="https://www.wenshushu.cn/">https://www.wenshushu.cn/</a><br>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/">https://uzer.me/</a><br>香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：<a href="https://www.xiangdang.net/">https://www.xiangdang.net/</a><br>二维码生成：<a href="https://cli.im/">https://cli.im/</a><br>搜狗翻译：<a href="http://fanyi.sogou.com/">http://fanyi.sogou.com</a><br>熵数（图表制作，数据可视化）：<a href="https://dydata.io/appv2/#/pages/index/home">https://dydata.io/appv2/#/pages/index/home</a><br>拷贝兔：<a href="https://cp.anyknew.com/">https://cp.anyknew.com/</a><br>图片无限变放大：<a href="http://bigjpg.com/zh">http://bigjpg.com/zh</a><br>幕布（在线大纲笔记工具）：mubu.com<br>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/">https://zh.justcnw.com/</a><br>调查问卷制作：<a href="https://www.wenjuan.com/">https://www.wenjuan.com/</a><br>果核剥壳（软件下载）：<a href="https://www.ghpym.com/">https://www.ghpym.com/</a><br>软件下载：<a href="https://www.unyoo.com/">https://www.unyoo.com/</a><br>MSDN我告诉你（windows10系统镜像下载）：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p><h1 id="导航页"><a href="#导航页" class="headerlink" title="导航页"></a>导航页</h1><p>世界各国网址大全： <a href="http://www.world68.com/">http://www.world68.com/</a><br>小森林导航：<a href="http://www.xsldh6.com/">http://www.xsldh6.com/</a><br>简捷工具：<a href="http://www.shulijp.com/">http://www.shulijp.com/</a><br>NiceTool.net 好工具网：<a href="http://www.nicetool.net/">http://www.nicetool.net/</a><br>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/">http://tool.uixsj.cn/</a><br>蓝调网站：<a href="http://lcoc.top/">http://lcoc.top/</a><br>偷渡鱼：<a href="https://touduyu.com/">https://touduyu.com/</a><br>牛导航：<a href="http://www.ziliao6.com/">http://www.ziliao6.com/</a><br>小呆导航：<a href="https://www.webjike.com/index.html">https://www.webjike.com/index.html</a><br>简法主页：<a href="http://www.jianfast.com/">http://www.jianfast.com/</a><br>KIM主页：<a href="https://kim.plopco.com/">https://kim.plopco.com/</a><br>聚BT：<a href="https://jubt.net/cn/index.html">https://jubt.net/cn/index.html</a><br>精准云工具合集：<a href="https://jingzhunyun.com/">https://jingzhunyun.com/</a><br>兔2工具合集：<a href="https://www.tool2.cn/">https://www.tool2.cn/</a><br>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com/">www.toolnb.com</a><br>工具导航：<a href="https://hao.logosc.cn/">https://hao.logosc.cn/</a></p><h1 id="看视频"><a href="#看视频" class="headerlink" title="看视频"></a>看视频</h1><p>阿木影视： <a href="https://www.aosk.online/">https://www.aosk.online/</a><br>电影推荐（分类别致）：<a href="http://www.mvcat.com/">http://www.mvcat.com</a><br>APP影院：<a href="https://app.movie/">https://app.movie/</a><br>去看TV：<a href="https://www.qukantv.net/">https://www.qukantv.net/</a><br>动漫视频网：<a href="http://www.zzzfun.com/">http://www.zzzfun.com/</a><br>94神马电影网：<a href="http://www.9rmb.com/">http://www.9rmb.com/</a><br>NO视频官网：<a href="http://www.novipnoad.com/">http://www.novipnoad.com/</a><br>蓝光画质电影：<a href="http://www.languang.co/">http://www.languang.co/</a><br>在线看剧：<a href="http://dy.27234.cn/">http://dy.27234.cn/</a><br>大数据导航：<a href="http://hao.199it.com/">http://hao.199it.com/</a><br>多功能图片网站：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a><br>牛牛TV：<a href="http://www.ziliao6.com/tv/">http://www.ziliao6.com/tv/</a><br>VideoFk解析视频：<a href="http://www.videofk.com/">http://www.videofk.com/</a><br>蓝调网站：<a href="http://lcoc.top/vip2.3/">http://lcoc.top/vip2.3/</a><br>永久资源采集网：<a href="http://www.yongjiuzy1.com/">http://www.yongjiuzy1.com/</a></p><h1 id="学设计"><a href="#学设计" class="headerlink" title="学设计"></a>学设计</h1><p>码力全开（产品&#x2F;设计师&#x2F;独立开发者的资源库）： <a href="https://www.maliquankai.com/designnav/">https://www.maliquankai.com/designnav/</a><br>免费音频素材：<a href="https://icons8.cn/music">https://icons8.cn/music</a><br>新CG儿（视频素材模板，无水印+免费下载）：<a href="https://www.newcger.com/">https://www.newcger.com/</a><br>Iconfont（阿里巴巴矢量图标库）： <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a><br>小图标下载：<a href="https://www.easyicon.net/">https://www.easyicon.net/</a><br>Flight Icon：<a href="https://www.flighticon.co/">https://www.flighticon.co/</a><br>第一字体转换器：<a href="http://www.diyiziti.com/">http://www.diyiziti.com/</a><br>doyoudosh（平面设计）：<a href="http://www.doyoudo.com/">www.doyoudo.com</a><br>企业宣传视频在线制作：<a href="https://duomu.tv/">https://duomu.tv/</a><br>MAKE海报设计官网：<a href="http://maka.im/">http://maka.im/</a><br>一键海报神器：<a href="https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral">https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral</a><br>字由（字体设计）：<a href="http://www.hellofont.cn/">http://www.hellofont.cn/</a><br>查字体网站：<a href="https://fonts.safe.360.cn/">https://fonts.safe.360.cn/</a><br>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）： <a href="http://www.aigei.com/">http://www.aigei.com/</a><br>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor">https://bilibili.clipchamp.com/editor</a></p><h1 id="搞文档"><a href="#搞文档" class="headerlink" title="搞文档"></a>搞文档</h1><p>即书（在线制作PPT）：<a href="https://www.keysuper.com/">https://www.keysuper.com/</a><br>PDF处理：<a href="https://smallpdf.com/cn">https://smallpdf.com/cn</a><br>PDF处理：<a href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a><br>PDF处理： <a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a><br>PDF处理：<a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a><br>图片压缩，PDF处理：<a href="https://docsmall.com/">https://docsmall.com/</a><br>腾讯文档（在线协作编辑和管理文档）：<a href="http://docs.qq.com/">http://docs.qq.com</a><br>ProcessOn（在线协作制作结构图）：<a href="http://www.processon.com/">www.processon.com</a><br>iLovePDF（在线转换PDF利器）：<a href="http://www.ilovepdf.com/">www.ilovepdf.com</a><br>PPT在线制作：<a href="https://www.woodo.cn/">https://www.woodo.cn/</a><br>PDF24工具（pdf处理工具）：<a href="https://tools.pdf24.org/en">https://tools.pdf24.org/en</a><br>IMGBOT（在线图片处理）：<a href="http://www.imgbot.ai/">www.imgbot.ai</a><br>福昕云编辑（在线编辑PDF）：<a href="http://edit.foxitcloud.cn/">http://edit.foxitcloud.cn</a><br>TinyPNG（在线压缩图片）：<a href="http://tinypng.com/">http://tinypng.com</a><br>UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套<br>）：<a href="http://uzer.me/">http://uzer.me</a><br>优品PPT（模板下载）： <a href="http://www.ypppt.com/">http://www.ypppt.com/</a><br>第一PPT（模板下载）：<a href="http://www.1ppt.com/xiazai/">http://www.1ppt.com/xiazai/</a><br>三顿PPT导航：sandunppt.com<br>Excel函数表： <a href="https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188">https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188</a></p><h1 id="找图片"><a href="#找图片" class="headerlink" title="找图片"></a>找图片</h1><p>电脑壁纸：<a href="http://lcoc.top/bizhi/">http://lcoc.top/bizhi/</a><br><a href="https://unsplash.com/">https://unsplash.com/</a><br><a href="https://pixabay.com/">https://pixabay.com/</a><br><a href="https://www.pexels.com/">https://www.pexels.com/</a><br><a href="https://visualhunt.com/">https://visualhunt.com/</a><br><a href="https://www.ssyer.com/">https://www.ssyer.com/</a><br>彼岸图网：<a href="http://pic.netbian.com/">http://pic.netbian.com/</a><br>极像素（超高清大图）：<a href="https://www.sigoo.com/">https://www.sigoo.com/</a><br>免费版权图片搜索：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly页脚养鱼</title>
      <link href="/2022/04/04/Hexo-Butterfly%E9%A1%B5%E8%84%9A%E5%85%BB%E9%B1%BC/"/>
      <url>/2022/04/04/Hexo-Butterfly%E9%A1%B5%E8%84%9A%E5%85%BB%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<p>最终效果在本站页脚，向下滑动即可看到。</p><hr><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>参考文章一共介绍了两种方法，第一种是有针对于Butterfly主题的修改。第二种方法是通用方法（其他也主题可参考）</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>打开站点的主题配置文件_config.butterfly.yml，找到inject，在bottom处直接引入以下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li>找到footer.pug文件：\themes\butterfly\layout\includes\footer.pug，写入以下内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#jsi-flying-fish-container.container</span><br><span class="line">   script(src=&#x27;js/fish.js&#x27;)</span><br><span class="line">style.</span><br><span class="line"></span><br><span class="line">       @media only screen and (max-width: 767px)&#123;</span><br><span class="line">       #sidebar_search_box input[type=text]&#123;width:calc(100% - 24px)&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>点的主题配置文件_config.butterfly.yml，找到inject，在bottom处直接引入<a href="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js">https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>​        注意：引入的js文件需要依赖jquery，所以在之前如果没有引用过的就需要在bottom处的最开始引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>这样效果就出现了。但是引入之后页脚会过高，需要修改footer.styl文件：\themes\butterfly\source\css_layout\footer.styl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#footer</span><br><span class="line">  position: relative</span><br><span class="line">  background: $light-blue</span><br><span class="line">  background-attachment: local</span><br><span class="line">  background-position: bottom</span><br><span class="line">  background-size: cover</span><br><span class="line"></span><br><span class="line">  if hexo-config(&#x27;footer_bg&#x27;) != false</span><br><span class="line">    &amp;:before</span><br><span class="line">      position: absolute</span><br><span class="line">      width: 100%</span><br><span class="line">      height: 100%</span><br><span class="line">      background-color: alpha($dark-black, .1) </span><br><span class="line">      content: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#footer-wrap</span><br><span class="line">  position: absolute</span><br><span class="line">  padding: 1.2rem 1rem 1.4rem</span><br><span class="line">  color: var(--light-grey)</span><br><span class="line">  text-align: center</span><br><span class="line">  left: 0</span><br><span class="line">  right: 0</span><br><span class="line">  top: 0</span><br><span class="line">  bottom: 0</span><br><span class="line"></span><br><span class="line">  a</span><br><span class="line">    color: var(--light-grey)</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      text-decoration: underline</span><br><span class="line"></span><br><span class="line">  .footer-separator</span><br><span class="line">    margin: 0 .2rem</span><br><span class="line"></span><br><span class="line">  .icp-icon</span><br><span class="line">    padding: 0 4px</span><br><span class="line">    vertical-align: text-bottom</span><br><span class="line">    max-height: 1.4em</span><br><span class="line">    width auto</span><br></pre></td></tr></table></figure></li><li><p>参考文章的技术流程写到这里就结束了，如果还有页脚文字被遮挡的情况，可以修改页脚的透明度，在\themes\butterfly\source\css路径下创建一个xxx.css文件，在文件中添加如下代码：</p></li></ol><ul><li>页脚半透明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 页脚半透明 */</span><br><span class="line">#footer &#123;</span><br><span class="line">    background: rgba(255, 255, 255, 0);</span><br><span class="line">    color: #000;</span><br><span class="line">    border-top-right-radius: 20px;</span><br><span class="line">    border-top-left-radius: 20px;</span><br><span class="line">    backdrop-filter: saturate(100%) blur(5px)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer::before &#123;</span><br><span class="line">    background: rgba(255,255,255,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer #footer-wrap &#123;</span><br><span class="line">    color: var(--font-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer #footer-wrap a &#123;</span><br><span class="line">    color: var(--font-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页脚全透明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 页脚透明 */</span><br><span class="line">#footer &#123;</span><br><span class="line">    background: transparent !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后将该文件引入到inject的head处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>至此操作结束，去看看你的页脚有没有发生变化吧。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个更为简单的方法，引入带有颜色的页脚养鱼，效果如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/fish.png" alt="img"></p><p>只需要在_config.butterfly.yml文件中，找到inject，在bottom处直接引入：<a href="https://uuuuu.cf/js/fishes.js">https://uuuuu.cf/js/fishes.js</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script defer src=&quot;https://uuuuu.cf/js/fishes.js&quot;&gt;&lt;/script&gt; # 页脚养鱼(彩色)</span><br></pre></td></tr></table></figure><p>注意：该操作同样需要在之前引入jquery。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> Butterfly魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Butterfly魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARK方舟Windows ARK Server Manager开服教程</title>
      <link href="/2022/04/04/ARK%E6%96%B9%E8%88%9FWindows-ARK-Server-Manager%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/ARK%E6%96%B9%E8%88%9FWindows-ARK-Server-Manager%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h3><ul><li>内存：4G能满足游戏运行，不过容易卡顿，6G能稳定运行。推荐8G以上。</li><li>网络：2M~4M上行带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力，避免卡顿。</li><li>端口：默认UDP 777，UDP 27015</li></ul><h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><p>[官网下载](<a href="https://redirect.viglink.com/?format=go&amp;jsonp=vglnk_163763550743810&amp;key=71fe2139a887ad501313cd8cce3053c5&amp;libId=kwbhw0zk0102ylrr000DLkz08zkab&amp;loc=https://arkservermanager.freeforums.net/thread/5193/downloads?page=1&scrollTo=29985&amp;ccpaConsent=1---&amp;v=1&amp;out=https://raw.githubusercontent.com/Bletch1971/ServerManagers/master/ASM/latest.exe&amp;ref=https://arkservermanager.freeforums.net/&amp;title=Downloads">https://redirect.viglink.com/?format=go&amp;jsonp=vglnk_163763550743810&amp;key=71fe2139a887ad501313cd8cce3053c5&amp;libId=kwbhw0zk0102ylrr000DLkz08zkab&amp;loc=https%3A%2F%2Farkservermanager.freeforums.net%2Fthread%2F5193%2Fdownloads%3Fpage%3D1%26scrollTo%3D29985&amp;ccpaConsent=1---&amp;v=1&amp;out=https%3A%2F%2Fraw.githubusercontent.com%2FBletch1971%2FServerManagers%2Fmaster%2FASM%2Flatest.exe&amp;ref=https%3A%2F%2Farkservermanager.freeforums.net%2F&amp;title=Downloads</a> | ARK Server Manager&amp;txt&#x3D;Latest.exe)ARK Server Manager</p><p><a href="https://pan.wapriaily.com/index.php/s/L6W3QfDZL7oJH9b">国内下载</a>ARK Server Manager</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>新建一个ARK文件夹，把ARK Server Manager移动到文件夹内运行</li><li>安装完后启动ARK Server Manager，会提示缺少SteamCMD，一路确定就会自动安装SteamCMD</li><li>安装完SteamCMD后ARK Server Manager就打开了</li></ul><h3 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h3><ul><li>在右上角找到设置按钮，将语言设置为中文。</li><li>然后返回主界面新建配置文件</li><li>点击右边安装按钮等待安装</li></ul><h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><ul><li>首先需要在地图和MOD功能里选择地图</li><li>然后就可以更改服务器的名称</li><li>根据自己的服务器配置调整服务器端口以及最大玩家数量</li></ul><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><ul><li>配置好服务器后点击右上角开始按钮启动服务器即可</li><li>启动时间根据服务器配置而定，时间可能较长</li><li>如长时间没有启动成功，重新启动即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七日杀(7 Days to Die)Liunx开服教程</title>
      <link href="/2022/04/04/%E4%B8%83%E6%97%A5%E6%9D%80-7-Days-to-Die-Liunx%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/%E4%B8%83%E6%97%A5%E6%9D%80-7-Days-to-Die-Liunx%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G能满足正常进行游戏，内存越大，支持的人数越多。推荐8G以上。</li><li>网络：2M~4M上行带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 27000，TCP 27021，TCP 27020</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 或 Debian</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> update</span><br><span class="line">$ sudo apt-<span class="built_in">get</span><span class="built_in"> upgrade</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># CentOS</span></span><br><span class="line">$ yum update -y</span><br><span class="line">$ yum<span class="built_in"> upgrade </span>-y</span><br></pre></td></tr></table></figure><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><h3 id="首先添加一个单独的用户"><a href="#首先添加一个单独的用户" class="headerlink" title="首先添加一个单独的用户"></a>首先添加一个单独的用户</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>adduser <span class="number">7</span>dtd</span><br></pre></td></tr></table></figure><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> glibc.i686 libstdc++i686 -y</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ yum <span class="keyword">install</span> glibc.i686 libstdc++i686 -y</span><br></pre></td></tr></table></figure><h3 id="安装终端复用器"><a href="#安装终端复用器" class="headerlink" title="安装终端复用器"></a>安装终端复用器</h3><p>根据个人喜好安装其中一个</p><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> tmux</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt <span class="keyword">install </span><span class="keyword">screen</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#CentOS</span></span><br><span class="line">$ yum <span class="keyword">install </span><span class="keyword">screen</span></span><br></pre></td></tr></table></figure><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - <span class="number">7</span>dtd</span><br><span class="line">cd <span class="regexp">/home/</span>steam</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Tmux</span></span><br><span class="line"><span class="attribute">tmux</span> new -s <span class="number">7</span>dtd</span><br><span class="line"><span class="comment">#Screen</span></span><br><span class="line"><span class="attribute">screen</span> -s <span class="number">7</span>dtd</span><br></pre></td></tr></table></figure><h3 id="下载SteamCMD"><a href="#下载SteamCMD" class="headerlink" title="下载SteamCMD"></a>下载SteamCMD</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>steamcdn-a.akamaihd.net<span class="regexp">/client/i</span>nstaller/steamcmd_linux.tar.gz</span><br><span class="line">tar -xvzf steamcmd_liunx.tar.gz</span><br></pre></td></tr></table></figure><h3 id="下载服务端"><a href="#下载服务端" class="headerlink" title="下载服务端"></a>下载服务端</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./steamcmd.sh</span><br><span class="line">login anonymous</span><br><span class="line">force_install_dir <span class="regexp">/home/</span>steam/<span class="number">7</span>DaysToDieServer</span><br><span class="line">app_update <span class="number">294420</span> validate</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam/<span class="number">7</span>DaysToDieServer</span><br><span class="line">vi serverconfig.xml</span><br></pre></td></tr></table></figure><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/7DaysToDieServer</span></span><br><span class="line"><span class="string">./startserver.sh</span> -configfile=serverconfig.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>饥荒Liunx SteamCMD开服教程</title>
      <link href="/2022/04/04/%E9%A5%A5%E8%8D%92Liunx-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/%E9%A5%A5%E8%8D%92Liunx-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G能满足5个人左右正常游玩，4G够10个人左右，根据人数选服务器即可，大量MOD需要高配置的服务器。</li><li>网络：4M以上的带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 10998,TCP 10999</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">sudo yum-y <span class="keyword">install</span> glibc.i686 libstdc++i686</span><br></pre></td></tr></table></figure><h2 id="安装终端复用器"><a href="#安装终端复用器" class="headerlink" title="安装终端复用器"></a>安装终端复用器</h2><p>根据个人喜好安装其中一个</p><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> tmux</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt <span class="keyword">install </span><span class="keyword">screen</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#CentOS</span></span><br><span class="line">$ yum <span class="keyword">install </span><span class="keyword">screen</span></span><br></pre></td></tr></table></figure><h2 id="安装SteamCMD"><a href="#安装SteamCMD" class="headerlink" title="安装SteamCMD"></a>安装SteamCMD</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adduser dst</span><br><span class="line">su -dst</span><br><span class="line">cd /home/steam</span><br><span class="line">n-<span class="selector-tag">a</span><span class="selector-class">.akamaihd</span>.net/client/installer/steamcmd_linux<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">tar -xvzf steamcmd_liunx<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">./steamcmd.sh</span><br></pre></td></tr></table></figure><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br><span class="line">force_install_dir <span class="regexp">/home/</span>steam/dstserver</span><br><span class="line">app_update <span class="number">343050</span> validate</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>Liunx服务端的组件有错误，需要更改一下后启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>lib<span class="regexp">/libcurl.so.4  /</span>home<span class="regexp">/steam/</span>dstserver<span class="regexp">/bin/</span>lib32/libcurl-gnutls.so.<span class="number">4</span></span><br><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstserver/</span>bin</span><br><span class="line">echo <span class="string">&quot;./dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root /home/dstsave -conf_dir dst -cluster World1 -shard Master&quot;</span> &amp;gt; master_start.sh</span><br><span class="line">echo <span class="string">&quot;./dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root /home/dstsave -conf_dir dst -cluster World1 -shard Caves&quot;</span> &amp;gt; cave_start.sh</span><br><span class="line">chmod +x master_start.sh cave_start.sh</span><br><span class="line">.master_start.sh</span><br></pre></td></tr></table></figure><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>启动完后关闭进程</p><p>在&#x2F;home&#x2F;steam&#x2F;dstserver&#x2F;dst&#x2F;World1&#x2F;文件会生成默认的配置文件</p><p>接下来我们需要将电脑上的配置文件传到服务端上，有能力的可以直接在服务端更改配置即可</p><p>打开游戏，创建新的世界，配置好名词，描述，密码，地洞等</p><p>创建好世界后退出世界，返回主界面，点击左下角的游戏数据</p><p>找到Cluster_1文件夹（后面数字为创建的世界顺序）</p><p>打开文件夹后将所有文件上传到服务端的home&#x2F;steam&#x2F;dstserver&#x2F;dst&#x2F;World1&#x2F;目录</p><p>上传完后，在游戏主界面点击左下角的账号信息，点击查看我的游戏按钮</p><p>点击右上角Don’t Strave Together Servers</p><p>拉到最后输入Token名称，点击添加新的服务器，就会生成Token</p><p>复制Token，粘贴到服务端World1目录里的cluster_token.txt里，不会编辑的可以在本地电脑创建同名的txt文件上传替换即可</p><h2 id="启动世界"><a href="#启动世界" class="headerlink" title="启动世界"></a>启动世界</h2><p>依次启动主世界和洞穴，以下教程使用Tmux</p><h3 id="主世界"><a href="#主世界" class="headerlink" title="主世界"></a>主世界</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/steam/dstserver</span><br><span class="line">tmux new -s master</span><br><span class="line">./master_start.sh</span><br></pre></td></tr></table></figure><h3 id="洞穴"><a href="#洞穴" class="headerlink" title="洞穴"></a>洞穴</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmux -s cave</span><br><span class="line">./cave_start.sh</span><br></pre></td></tr></table></figure><p>启动完以上进程后就可以再游戏你们看到服务器了</p><h2 id="配置MOD"><a href="#配置MOD" class="headerlink" title="配置MOD"></a>配置MOD</h2><p>将World1文件夹里的modoverrides.lua文件打开</p><p>找到MOD们的workshop数字ID记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstserver/m</span>ods</span><br></pre></td></tr></table></figure><p>找到dedicated_server_mods_setup.lua文件并打开</p><p>在最后一栏注释上面将所有MOD以下面格式添加</p><p>ServerModSetup(“workshop数字ID”)</p><p>添加完后重启服务器MOD就配置完毕了</p><p>不会编辑的朋友可以将文件下载下来，编辑后上传即可</p><h2 id="配置服主管理员"><a href="#配置服主管理员" class="headerlink" title="配置服主管理员"></a>配置服主管理员</h2><p>点击主界面的账号信息</p><p>找到KLEI用户ID记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstsave/</span>dst<span class="regexp">/World1/</span></span><br><span class="line">vim adminlist.txt</span><br></pre></td></tr></table></figure><p>创建好txt文件后将KLEI用户ID输入后保存</p>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unturned未转变者Windows SteamCMD开服教程</title>
      <link href="/2022/04/04/Unturned%E6%9C%AA%E8%BD%AC%E5%8F%98%E8%80%85Windows-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/Unturned%E6%9C%AA%E8%BD%AC%E5%8F%98%E8%80%85Windows-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G以上即可，越高越好，根据期望用户量增加。</li><li>网络：2M以上的带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 27015</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip">点击下载</a>SteamCMD</p><p><a href="https://gsf-fl.softonic.com/3a8/2ff/6c396563e808aef56baa9e1ac9b34960d3/npp.8.1.9.Installer.exe?Expires=1637759025&Signature=f8fb1aaa36e1203e3d7094c455eea099b751b5c2&url=https://notepad-plus.en.softonic.com&Filename=npp.8.1.9.Installer.exe">点击下载</a>Notepad++</p><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><p>在桌面创建一个SteamCMD文件夹，将下载的SteamCMD压缩包解压进去</p><p>右键管理员启动SteamCMD等待下载安装</p><p>显示Steam&gt;时代表已经安装完毕</p><h2 id="使用SteamCMD安装"><a href="#使用SteamCMD安装" class="headerlink" title="使用SteamCMD安装"></a>使用SteamCMD安装</h2><p>若仅是个人开服请使用下方的Steam安装方法更加方便以及无需翻墙</p><p>  1.启动SteamCMD，以匿名用户登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br></pre></td></tr></table></figure><p>  2.安装服务端（时间比较久，大约1.7G，并且可能需要梯子，请注意日志）同时本指令可以用于以后的服务端更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_update 1110390</span><br></pre></td></tr></table></figure><p>  3.输入以下指令关闭SteamCMD（不建议直接叉掉）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><p>  4.现在你的服务端文件将存于<code>SteamCMD目录``/steamapps/common/U3DS</code>内</p><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>在SteamCMD\steamapps\common\U3DS\找到服务端启动Unturned.exe</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220408213735639.png" alt="image-20220408213735639"></p><p>显示这个界面即为运行完成，然后输入shutdown关闭服务器</p><p>第一次启动服务端是为了生成世界</p><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>在U3DS目录找到Servers文件夹，打开默认服务器文件夹Default</p><p>打开Server文件夹，会看到一个Commands.dat文件</p><p>使用Notepad++编辑该文件，按个人需求选填以下指令，当然不添加新的指令在原本的指令更改也可以。</p><table><thead><tr><th>配置代码</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>Name</td><td>服务器名称</td><td></td></tr><tr><td>Map</td><td>地图类型</td><td>默认PEI</td></tr><tr><td>Password</td><td>服务器密码</td><td>公开不填</td></tr><tr><td>Welcome</td><td>服务器欢迎语</td><td></td></tr><tr><td>Maxplayer</td><td>服务器人数</td><td>根据服务器配置填</td></tr><tr><td>Mode</td><td>服务器难度</td><td>可填Eazy,Normal,Hard</td></tr><tr><td>Perspective</td><td>服务器视角限制</td><td>可填First,Third,Both,Vehicle</td></tr><tr><td>PVE</td><td>开启PVE模式</td><td>留空为PVP</td></tr><tr><td>Cheats</td><td>服务器作弊模式</td><td>开True关False</td></tr><tr><td>Port</td><td>服务器端口</td><td>默认27015,更改需要开放端口</td></tr></tbody></table><p>或许你可能不知道这些代表着什么，下面介绍几个常用的</p><ul><li><p><strong>Map</strong> ——此类型可以选择地图<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map Russia</span><br></pre></td></tr></table></figure></li></ul><p>这样就是设置Russia地图了，默认不填写情况下是使用PEI地图</p><ul><li><p><strong>Port</strong> ——此类型选择你的服务器端口<br>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 23333</span><br></pre></td></tr></table></figure></li></ul><p>这样则是设置了使用23333端口，默认不填写情况下是使用27015 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请注意，在改版后，运行公共服务器（也就是Internet模式）需要向你的端口号+1来分别负责与服务器列表通信和与游戏流量传输，比如我使用23333端口来开服，此端口会用于游戏列表通信，23334端口来与客户端游戏通信，也就是会占用2个端口</span><br></pre></td></tr></table></figure><ul><li><p><strong>Name</strong> ——你的服务器名称（将会显示在服务器列表）<br>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name 你的服务器名称</span><br></pre></td></tr></table></figure></li><li><p><strong>Password</strong>——服务器密码，若填写上去并且后面写入字符将会要求提供密码才能加入服务器，一般不需要填写，也不用写上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Password 114514</span><br></pre></td></tr></table></figure></li></ul><p>这样就要求提供密码才能加入</p><ul><li><p><strong>Perspective</strong> ——视角限制，可以填入有<code>First</code>, <code>Third</code>, <code>Both</code>, <code>Vehicle</code>，分别对应仅限第一人称、仅限第三人称、任意、只能在驾驶载具时使用第三人称<br>示例;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perspective Both</span><br></pre></td></tr></table></figure></li></ul><p>这样就能够第一第三人称任意切换</p><ul><li><p><strong>Cheats</strong> ——作弊设置，可以填入的有<code>True</code>和<code>False</code>，分别对应开和关，打开后只能管理员作弊，关闭后管理员都不能作弊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cheats True</span><br></pre></td></tr></table></figure></li></ul><p>这样管理员就能作弊了(没有试过，具体功效不明)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name (服务器名字，不能有数字不能有字符名字必须大于五个字）</span><br><span class="line">password （密码）</span><br><span class="line">Map （地图）</span><br><span class="line">Maxplayers 8 （最大玩家数）</span><br><span class="line">Mode Normal （游戏难度）</span><br><span class="line">PVE（玩家间伤害，不填写则是默认为PVP）</span><br><span class="line">Port 25444 （端口）</span><br><span class="line">Cheats on （作弊是否开启）</span><br><span class="line">Perspective both （第一人称和第三人称的限制）</span><br><span class="line">Loadout 255/(id)  (服务器开局物品）</span><br><span class="line">Welcome （服务器欢迎语）</span><br></pre></td></tr></table></figure><p>配置完后保存，启动steamCMD\steamapps\common\U3DS\Unturned.exe文件</p><p>加载完毕我们就可以看到服务器了(记得放行上方配置文件配置的端口)</p><blockquote><p>部分人在连接服务器时会出现“未能初始化steam网络身份验证”（懒狗，没截图）得情况</p><p>这是因为steam在国内被墙，使用加速器加速steam即可</p></blockquote><h2 id="创意工坊"><a href="#创意工坊" class="headerlink" title="创意工坊"></a>创意工坊</h2><p>在SteamCMD\steamapps\common\U3DS\Servers\Default</p><p>咱们能看到WorkshopDownloadConfig.json文件</p><p>使用Notepad++编辑该文件添加你想要添加的创意工坊文件ID即可</p><h2 id="Rocket与OpenMod"><a href="#Rocket与OpenMod" class="headerlink" title="Rocket与OpenMod"></a>Rocket与OpenMod</h2><p>| Rocket是一种旧式的插件适配框架，OpenMod是新出的插件框架，Rocket具有更多的插件，OpenMod具有更好的兼容性，两者可以同时使用</p><h3 id="Rocket安装方法"><a href="#Rocket安装方法" class="headerlink" title="Rocket安装方法"></a>Rocket安装方法</h3><ol><li>打开服务端文件夹（非服务器文件夹），找到<code>Extras</code>目录，将其中的<code>Rocket.Unturned</code>文件复制</li><li>返回上一级，找到<code>Modules</code>文件夹，将其粘贴在文件夹内即可完成安装</li></ol><h3 id="OpenMod安装方法"><a href="#OpenMod安装方法" class="headerlink" title="OpenMod安装方法"></a>OpenMod安装方法</h3><p>OpenMod有两种安装方法，一种是通过Rocket安装，还有一种是手动安装</p><h5 id="通过Rocket安装OpenMod"><a href="#通过Rocket安装OpenMod" class="headerlink" title="通过Rocket安装OpenMod"></a>通过Rocket安装OpenMod</h5><ol><li>在<a href="https://github.com/openmod/OpenMod.Installer.RocketMod/releases/">此处</a>下载OpenMod安装程序插件</li><li>将dll文件移动至<code>/Rocket/Plugins</code>文件夹下并且重启服务端</li><li>重启服务器端后在窗口内输入&#x2F;openmod install并且按照其说明进行安装即可</li><li>安装完毕后您可以在<a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https://openmod.github.io/openmod-docs/userdoc/concepts/plugins.html">此处</a>查看OpenMod的插件安装方法</li></ol><h5 id="通过离线安装OpenMod"><a href="#通过离线安装OpenMod" class="headerlink" title="通过离线安装OpenMod"></a>通过离线安装OpenMod</h5><ol><li>在<a href="https://github.com/openmod/OpenMod/releases/latest">此处</a>下载最新的OpenMod模块，名字通常为<code>OpenMod.Unturned.Module-vX.X.X.zip</code></li><li>将压缩包中的<code>OpenMod.Unturned</code>文件夹复制到Unturned安装目录中的<code>Modules</code>文件夹中</li><li>启动你的服务器，第一次启动需要一段时间，因为 OpenMod 会下载所需的核心组件</li><li>安装完毕后您可以在<a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https://openmod.github.io/openmod-docs/userdoc/concepts/plugins.html">此处</a>查看OpenMod的插件安装方法</li></ol><h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><h3 id="Rocket插件安装方法"><a href="#Rocket插件安装方法" class="headerlink" title="Rocket插件安装方法"></a>Rocket插件安装方法</h3><p>只需要将dll文间移至<code>/Rocket/Plugins</code>文件夹并重启服务器端即可，而后的内容请参考插件手册</p><h3 id="OpenMod插件安装方法"><a href="#OpenMod插件安装方法" class="headerlink" title="OpenMod插件安装方法"></a>OpenMod插件安装方法</h3><ul><li>您可以通过<a href="https://www.nuget.org/packages?q=openmod-plugin">NuGet市场</a>或<a href="https://openmod.github.io/openmod-plugins/search">OpenMod插件列表</a>来查找您所需的插件</li><li>您可以在OpenMod插件列表直接点击<strong>COPY INSTALL COMMAND</strong>按钮来获得安装命令，将其复制在服务器窗口中并回车即可安装</li><li>在NuGet市场中找到您心仪的插件时，您只需要输入<code>openmod install &lt;package id&gt;</code>来安装插件或输入<code>openmod install &lt;package id&gt;@&lt;version&gt;</code>来安装特定版本，以及可以输入<code>openmod install &lt;package id&gt; -Pre</code>来安装测试版（记得去除掉&lt;&gt;）</li><li>输入<code>openmod install &lt;package id&gt;</code>来更新插件</li><li>您也可以下载好插件以及所需库后将其放置到<code>/openmod/plugins</code>文件夹来手动安装插件，当然如果只有dll也可以通过<code>openmod install &lt;package id&gt;</code>来安装所需库，如果需要更新请自行替换dll</li><li>手动安装的插件需要自行删除dll文件，在线安装的插件可以通过<code>openmod remove &lt;package id&gt;</code>来卸载插件</li><li>在安装、删除、更新插件后都需要输入<code>openmod reload</code>来重新加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux上搭建QQ搜图机器人——基于go-cqhttp和cq-picsearcher-bot</title>
      <link href="/2022/03/22/%E5%9C%A8linux%E4%B8%8A%E6%90%AD%E5%BB%BAQQ%E6%90%9C%E5%9B%BE%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ego-cqhttp%E5%92%8Ccq-picsearcher-bot/"/>
      <url>/2022/03/22/%E5%9C%A8linux%E4%B8%8A%E6%90%AD%E5%BB%BAQQ%E6%90%9C%E5%9B%BE%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ego-cqhttp%E5%92%8Ccq-picsearcher-bot/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系统：CentOS</p><p>文中服务器已安装<a href="https://www.bt.cn/download/linux.html">宝塔Linux面板</a>，并以其演示</p><p>FinalShell  SHH终端</p><p>主要用到的程序 <a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> 和 <a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">cq-picsearcher-bot</a></p><p><a href="https://github.com/Mrs4s/go-cqhttp">https://github.com/Mrs4s/go-cqhttp</a></p><p><a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">https://github.com/Tsuk1ko/cq-picsearcher-bot</a></p></blockquote><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget git screen nodejs</span><br></pre></td></tr></table></figure><h2 id="创建目录，并到该目录下"><a href="#创建目录，并到该目录下" class="headerlink" title="创建目录，并到该目录下"></a>创建目录，并到该目录下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir go-cqhttp &amp;&amp; cd go-cqhttp</span><br></pre></td></tr></table></figure><h2 id="下载-go-cqhttp"><a href="#下载-go-cqhttp" class="headerlink" title="下载 go-cqhttp"></a>下载 go-cqhttp</h2><p>先下载该项目程序：</p><p><a href="https://github.com/Mrs4s/go-cqhttp/releases">https://github.com/Mrs4s/go-cqhttp/releases</a></p><p>一般默认选 go-cqhttp_linux_amd64.tar.gz 作为我们 amd64 架构服务器用到的程序（arm 架构系统选用 arm64）</p><ul><li>Windows 下 32 位文件为 go-cqhttp-v*-windows-386.zip</li><li>Windows 下 64 位文件为 go-cqhttp-v*-windows-amd64.zip</li><li>Windows 下 arm 用 (如使用高通 CPU 的笔记本) 文件为 go-cqhttp-v*-windows-arm.zip</li><li>Linux 下 32 位文件为 go-cqhttp-v*-linux-386.tar.gz</li><li>Linux 下 64 位文件为 go-cqhttp-v*-linux-amd64.tar.gz</li><li>Linux 下 arm 用 (如树莓派) 文件为 go-cqhttp-v*-linux-arm.tar.gz</li><li>MD5 文件为 *.md5 , 用于校验文件完整性</li><li>如果没有你所使用的系统版本或者希望自己构建，请移步 进阶指南 - 如何自己构建</li></ul><p>然后在服务器上下载这个压缩包</p><p>解压该压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf [文件名]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/go-cqhttp.png"></p><p>解压完只有这三个文件。</p><p>然后输入以下命令，回车</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./go-cqhttp</span><br></pre></td></tr></table></figure><p>选择第二个 ws，输入数字 2 回车即可（你甚至可以全部选择，输入 1234 回车）然后生成 config.yml 以后可以 <code>ctrl+c</code> 终止进程</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322140753738.png" alt="image-20220322140753738"></p><h2 id="配置-go-cqhttp"><a href="#配置-go-cqhttp" class="headerlink" title="配置 go-cqhttp"></a>配置 go-cqhttp</h2><p>宝塔中刷新目录，然后会发现多出了个 <code>config.yml</code> 文件，打开然后编辑</p><p>主要就是填入 QQ 账号和密码，别的都不用管</p><p>然后 Save 保存文件即可</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322141236497.png" alt="image-20220322141236497"></p><h2 id="加载-go-cqhttp"><a href="#加载-go-cqhttp" class="headerlink" title="加载 go-cqhttp"></a>加载 go-cqhttp</h2><p>然后再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./go-cqhttp</span><br></pre></td></tr></table></figure><p>如图即正常加载了</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322142536140.png" alt="image-20220322142536140"></p><p>当然，估计你因为异地登录会让你输入滑块验证码反馈</p><p>查看宝塔面板go-cqhttp目录，会生成一张二维码图片，打开手机QQ扫码登陆即可</p><p>或另一种解决方案：<a href="https://docs.go-cqhttp.org/faq/slider.html">https://docs.go-cqhttp.org/faq/slider.html</a></p><p>那么这时候按照他的指示，复制网址到浏览器打开，然后先不要拖动滑块，先按 F12 打开开发者工具</p><p>选择 network，抓取 <code>ticket</code> 字段，并黏贴到 ssh 里要求输入的地方，即可通过。</p><h2 id="安装部署-qc-picsearcher-bot"><a href="#安装部署-qc-picsearcher-bot" class="headerlink" title="安装部署 qc-picsearcher-bot"></a>安装部署 qc-picsearcher-bot</h2><p>然后ctrl c 退出登录。</p><p>回到上级目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>到cq-picsearcher-bot下载最新的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Tsuk1ko/cq-picsearcher-bot &amp;&amp; cd cq-picsearcher-bot &amp;&amp; cp config.default.jsonc config.jsonc</span><br></pre></td></tr></table></figure><p>下载完毕之后，再输入指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i </span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>config.jsonc 文件需要配置的地方太多了，而且根据每个人不同的习惯都各不相同，这个还请自行配置，参考官方配置文档：</p><p><a href="https://github.com/Tsuk1ko/cq-picsearcher-bot/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">https://github.com/Tsuk1ko/cq-picsearcher-bot/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E</a></p><p>其中几个地方都需要配置 api 才能使用，如 saucenao 和 setu 功能 </p><p>因为要用到saucenao的搜图，要注册拿到api key</p><p>注册：<a href="https://saucenao.com/user.php">https://saucenao.com/user.php</a>?</p><p>api key: <a href="https://saucenao.com/user.php?page=search-api">https://saucenao.com/user.php?page=search-api</a></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20210330233614736.png" alt="img"></p><p>复制，粘贴到cq-picsearcher-bot目录中的config.jsonc文件中。（拉到最下面）</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20210330233943367.png" alt="img"></p><h2 id="启动-qc-picsearcher-bot"><a href="#启动-qc-picsearcher-bot" class="headerlink" title="启动 qc-picsearcher-bot"></a>启动 qc-picsearcher-bot</h2><p>配置完成后先启动 go-cqhttp 再运行本程序 ！</p><p>回到go-cqhttp目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">cd go-cqhttp</span><br><span class="line"></span><br><span class="line">//启动后台登录</span><br><span class="line"></span><br><span class="line">nohup ./go-cqhttp &gt; /dev/null 2&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>回到cq-picsearcher-bot目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .. </span><br><span class="line">cd cq-picsearcher-bot</span><br></pre></td></tr></table></figure><p>然后输入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322143158880.png" alt="image-20220322143158880"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm stop</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm restart</span><br></pre></td></tr></table></figure><h3 id="查看日志（平时日志也会保存在-logs-文件夹内）"><a href="#查看日志（平时日志也会保存在-logs-文件夹内）" class="headerlink" title="查看日志（平时日志也会保存在 logs 文件夹内）"></a>查看日志（平时日志也会保存在 logs 文件夹内）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run log</span><br></pre></td></tr></table></figure><h2 id="食用"><a href="#食用" class="headerlink" title="食用"></a>食用</h2><ul><li>私聊<ul><li>直接发送图片即可</li></ul></li><li>群组<ul><li>@ 机器人并发送图片</li><li>回复某人（也可以是自己）发送的图片，在消息中 @ 机器人</li></ul></li><li>可以在同一条消息中包含多张图片，会自动批量搜索</li><li>搜索图片时可以在消息内包含以下参数来指定搜索范围或者使用某项功能，参数之间除 –debug 外互斥，优先级从上到下<ul><li>–get-url：获取图片的在线链接（不会搜图）</li><li>–all：全库搜索（默认）</li><li>–pixiv：从 P 站中搜索</li><li>–danbooru：从 Danbooru 中搜索</li><li>–doujin：搜索本子</li><li>–anime：搜索番剧</li><li>–a2d：使用 ascii2d 进行搜索（优势搜索局部图能力较强）</li><li>–debug：调试，会在控制台中输出搜图时网络请求的内容</li></ul></li><li>对于 saucenao<ul><li>如果得到的结果相似度低于 60%（可配置），会自动使用 ascii2d 进行搜索（可配置）</li><li>如果额度耗尽，会自动使用 ascii2d 进行搜索（可配置）</li><li>如果搜索到本子，会自动在 nhentai 中搜索并返回链接（如果有汉化本会优先返回汉化本链接）</li><li>如果搜到番剧，会自动使用 WhatAnime 搜索番剧详细信息<ul><li>AnimeDB 与 WhatAnime 的结果可能会不一致，是正常现象，毕竟这是两个不同的搜索引擎</li><li>同时展示这两个搜索的目的是为了尽力得到你可能想要的识别结果</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> bot </category>
          
          <category> qqx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bot </tag>
            
            <tag> qq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + GitHub搭建个人图床</title>
      <link href="/2022/03/12/PicGo%20+%20GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/03/12/PicGo%20+%20GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="配置GtiHub"><a href="#配置GtiHub" class="headerlink" title="配置GtiHub"></a>配置GtiHub</h2><p>新建仓库</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312230017936.png"></p><p>这里需要注意：仓库得设置为 Public 。因为后面通过客户端访问算是外部访问，因此无法访问 Private ，这样的话图片传上来之后只能存储不能显示。</p><p>仓库建好之后，点击页面右上角，进入 Settings：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211350596.png" alt="image-20220426211350596"></p><p>然后进入 Developer settings：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/O%40%7DH%5D%7D%7B%7EYV8D6%7E%24%7BLGAF96A.png"></p><p>点击 Personal access tokens，再点 Generate new token 新建 token</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211239697.png" alt="image-20220426211239697"></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211253151.png" alt="image-20220426211253151"></p><p>填写 Notes 信息，选择 token 过期时间，为了安全，GitHub 会强烈建议不要设置成永久。这个大家根据自己实际情况选择，到期之后重新生成即可。</p><p>复选框的话，repo 一定要全选，其他的无所谓，我是都勾选了。</p><p>确定之后，就生成我们需要的 token 了。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211453791.png" alt="image-20220426211453791"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>下载 PicGo：点击<a href="https://link.segmentfault.com/?enc=Ptgik6w7iSuBHgEgu5ndyA==.OxB/dUe4VpLBJtUlwtNy8DWnb+AJo1LHGidh20qqXVQNEQbpfnvA7chetn/FaQuN">下载地址</a>，然后安装。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312230958908.png"></p><ul><li>设定仓库名：上文在 GitHub 创建的仓库。</li><li>设定分支名：main。</li><li>设定 Token：上文生成的 token。</li><li>指定存储路径：为空的话会上传到跟目录，也可以指定路径。</li></ul><p>配置完成后就可以使用了。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231444544.png"></p><p>直接拖拽，或者点击上传都可以。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231619090.png"></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231643155.png"></p><p>最后，在相册里复制外链，粘贴到我们的 markdown 文档中，就可以看到图片了。</p><h2 id="Typora关联PicGo粘贴图片自动上传"><a href="#Typora关联PicGo粘贴图片自动上传" class="headerlink" title="Typora关联PicGo粘贴图片自动上传"></a>Typora关联PicGo粘贴图片自动上传</h2><p>打开设置———偏好设置</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211924526.png" alt="image-20220426211924526"></p><p>选择图像——在上传服务设定一栏中上传服务选择PicGo、路径选择PicGo安装路径</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426212043248.png" alt="image-20220426212043248"></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joplin与坚果云搭建免费云盘</title>
      <link href="/2022/03/12/Joplin%E4%B8%8E%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E7%9B%98/"/>
      <url>/2022/03/12/Joplin%E4%B8%8E%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><h2 id="Joplin"><a href="#Joplin" class="headerlink" title="Joplin"></a>Joplin</h2><p>一款开源的、支持自定义同步服务器、多平台支持的makedown笔记。<br>joplin官网<a href="https://joplinapp.org/">https://joplinapp.org/</a><br>第一眼看到joplin发现布局很像印象笔记，就决定用来代替印象笔记了。<br>功能上当然没有印象笔记多，但是基本的makedown、标签、全笔记搜索、目录结构、多平台、云同步还是有的。<br>编辑功能少了一点，但是开源可以进行二次开发，也不知道有没有朋友已经在开发了。</p><h2 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h2><p>一款国内的云存储服务，主要支持<a href="https://so.csdn.net/so/search?q=webdav&spm=1001.2101.3001.7020">webdav</a>可以供joplin实现云同步。<br>可以创建免费用户，每个月有1G上传和3G下载的流量，对于笔记来说应该是很够的了，速度对于笔记来讲也是足够的。</p><h2 id="搭建开始"><a href="#搭建开始" class="headerlink" title="搭建开始"></a>搭建开始</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>注册坚果云账户，在根目录创建一个joplin云储存的文件夹。</p><p><img src="https://img-blog.csdnimg.cn/20200624221255552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><h3 id="步骤2-创建webdav应用"><a href="#步骤2-创建webdav应用" class="headerlink" title="步骤2     创建webdav应用"></a>步骤2     创建webdav应用</h3><p>点击右上角的用户头像进入账户信息页面</p><p><img src="https://img-blog.csdnimg.cn/20200624221430930.png"></p><p>选择安全选项，右下方添加应用（我的已经添加了）</p><p><img src="https://img-blog.csdnimg.cn/20200624221558205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>现在我们有了webdav三个内容：服务器地址，账户，密码</p><h3 id="步骤3-下载安装joplin（想要哪个平台下哪个）"><a href="#步骤3-下载安装joplin（想要哪个平台下哪个）" class="headerlink" title="步骤3 下载安装joplin（想要哪个平台下哪个）"></a>步骤3 下载安装joplin（想要哪个平台下哪个）</h3><h3 id="步骤4-joplin接入云同步"><a href="#步骤4-joplin接入云同步" class="headerlink" title="步骤4 joplin接入云同步"></a>步骤4 joplin接入云同步</h3><p>点击 工具 -》 选项 -》 同步，按照如下填写webdav账户信息，这里需要注意网站后面要加上在坚果云创建的文件夹名字&#x2F;joplin</p><p><img src="https://img-blog.csdnimg.cn/20200624221944862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>点击 检查同步配置，成功之后，就可以通过ctrl+s把文件同步上去了</p><p><img src="https://img-blog.csdnimg.cn/20200624222108517.png"></p><p>其他平台类似方法接入同一个webdav即可时间多设备云同步。<br>我们同步完成之后，坚果云joplin文件夹下便存放我们的笔记内容</p><p><img src="https://img-blog.csdnimg.cn/20200624222508898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>.md后缀是我们的文本笔记<br>笔记里面的图片、附件等内容则在resources</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青龙面板批量部署依赖库</title>
      <link href="/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>把常见的依赖库都给它装上去，免得以后运行其他羊毛脚本的时候提示各种错误。</p><p>这里分享下<a href="https://unfall.top/tags/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/">青龙面板</a>的部署教程《<a href="https://unfall.top/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/">青龙面板自动领JD京豆</a>》，再此基础上部署依赖库。再此基础上部署依赖库。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看青龙面板 Docker 是否正常运行，记下青龙 Docker 的容器名字，如果是按照缙哥哥的部署教程操作，那么默认的名称就是<code>qinglong</code></p><p><img src="https://img.dujin.org/uploads/2021/12/20211219214338.png"></p><p>输入一键安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it qinglong bash</span><br></pre></td></tr></table></figure><p>如果你的青龙容器不叫<code>qinglong</code>，那自己替换为相应的容器名字。</p><p>安装依赖命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/shufflewzc/QLDependency/main/Shell/QLOneKeyDependency.sh | sh</span><br></pre></td></tr></table></figure><p>然后慢慢等就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> JD </tag>
            
            <tag> 青龙面板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青龙面板自动领JD京豆</title>
      <link href="/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/"/>
      <url>/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/</url>
      
        <content type="html"><![CDATA[<p>青龙面板是一个多功能的可视化面板，本教程利用青龙面板来自动执行京东领京豆，做东东农场任务签到浇水免费领水果，京喜牧场养小鸡收集鸡蛋，京东极速版金币，京东赚赚领金币，东东萌宠喂养。同时还能自动领取京东红包、京喜红包、京东极速版红包……</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ol><li>需要一台服务器，最好是国内的，毕竟你是在国内使用京东购物，挂机服务器在海外太过明显。</li><li>全新安装 CentOS操作系统，并放开 22、5600 端口，如果想安装宝塔，则额外放开 888、8888 端口。</li></ol><h1 id="安装青龙面板"><a href="#安装青龙面板" class="headerlink" title="安装青龙面板"></a>安装青龙面板</h1><p>通过 SSH 连接服务器，安装 Docker 环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>启动 Docker（下方第一行），并设置 Docker 开机自动启动 （下方第二行） 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>直接执行下方代码拉取镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull whyour/qinglong:latest</span><br></pre></td></tr></table></figure><p>如果你是群辉之类的 NAS 安装青龙镜像，在 Dockers 官方镜像列表中拉取最新版的青龙镜像，直接使用 Dockers 搜索镜像<code>qinglong</code>即可。</p><p>接着部署青龙面板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">-v $PWD/ql/config:/ql/config \</span><br><span class="line">-v $PWD/ql/log:/ql/log \</span><br><span class="line">-v $PWD/ql/db:/ql/db \</span><br><span class="line">-p 5600:5600 \</span><br><span class="line">--name qinglong \</span><br><span class="line">--hostname qinglong \</span><br><span class="line">--restart always \</span><br><span class="line">whyour/qinglong:latest</span><br></pre></td></tr></table></figure><h1 id="初始化青龙面板"><a href="#初始化青龙面板" class="headerlink" title="初始化青龙面板"></a>初始化青龙面板</h1><p>部署完成后，直接访问<code>IP:5600</code>访问青龙面板的安装界面。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184333.png"></p><p>直接开始安装进入下一步。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184403.png"></p><p>这里可以根据你自己的喜欢设置通知方式，比如每天22:00告诉你今天领取了多少京豆、多少金币、多少红包……当然，你也可以直接跳过该步骤。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184443.png"></p><p>设置管理员账号密码，这是初始化安装青龙面板最重要的步骤，当然，如果你不小心忘了，或者说不明原因没有进入这个配置页面，也没有关系，可以通过 SSH 执行下方命令查看账号及密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it qinglong cat /ql/config/auth.json</span><br></pre></td></tr></table></figure><h1 id="配置青龙面板定时任务"><a href="#配置青龙面板定时任务" class="headerlink" title="配置青龙面板定时任务"></a>配置青龙面板定时任务</h1><p>青龙面板本身不具备京东脚本的功能，只是一个管理和执行相应脚本的可视化平台。为了使其能够完成媷羊毛的功能，接下来使用青龙面板拉去一些库，使其自动更新一些功能。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184720.png"></p><p>登录面板后选择<code>定时任务</code>→<code>添加任务</code>。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216185453.png"></p><h1 id="京东定时任务库"><a href="#京东定时任务库" class="headerlink" title="京东定时任务库"></a>京东定时任务库</h1><p>下方整理 GitHub 上的一些任务库，通过添加任务，并设置定时规则，使其自动拉取、更新羊毛任务。</p><p><strong>KingRan&#x2F;KR（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/KingRan/KR.git &quot;jd_|jx_|jdCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|function|sign|sendNotify|ql|JDJR&quot;</span><br></pre></td></tr></table></figure><p><strong>Curtinlv 仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/curtinlv/JD-Script.git</span><br></pre></td></tr></table></figure><p><strong>Zy143L&#x2F;wskey（wskey转换库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/Zy143L/wskey.git &quot;wskey&quot;</span><br></pre></td></tr></table></figure><p><strong>smiek2121（开卡库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo ql repo https://github.com/smiek2121/scripts.git &quot;jd_|gua_&quot; &quot;&quot; &quot;ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js|cleancart_activity.js|jdCookie.js|sendNotify.js&quot;</span><br></pre></td></tr></table></figure><p><strong>Yun-City&#x2F;City（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/Yun-City/City.git &quot;jd_|jx_|gua_|jddj_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|function|utils|sendnotify|ZooFaker_Necklace|jd_Cookie|JDJRValidator_|sign_graphics_validate|ql|magic|cleancart_activity&quot;</span><br></pre></td></tr></table></figure><p><strong>6dylan6&#x2F;jdpro（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/6dylan6/jdpro.git &quot;jd_|jx_|jddj_&quot; &quot;backUp&quot; &quot;^jd[^_]|USER|JD|function|sendNotify&quot;</span><br></pre></td></tr></table></figure><p><strong>gys619&#x2F;Absinthe（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/gys619/Absinthe.git &quot;jd_|jx_|jddj_|gua_|getJDCookie|wskey&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|ZooFaker_Necklace|JDJRValidator_|sign_graphics_validate|jddj_cookie|function|ql|magic|JDJR|JD&quot; &quot;main&quot;</span><br></pre></td></tr></table></figure><p><strong>zero205&#x2F;JD_tencent_scf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/zero205/JD_tencent_scf.git &quot;jd_|jx_|jdCookie&quot; &quot;backUp|icon&quot; &quot;^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql&quot; &quot;main&quot;</span><br></pre></td></tr></table></figure><p><strong>龙珠</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/whyour/hundun.git &quot;quanx&quot; &quot;tokens|caiyun|didi|donate|fold|Env&quot;</span><br></pre></td></tr></table></figure><p>为了防止漏掉某些羊毛，<strong>上方所有的库</strong>新建定时任务拉取，里面有重复脚本禁用脚本，重复的内容会被禁用的。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216185930.png"></p><h1 id="定时规则"><a href="#定时规则" class="headerlink" title="定时规则"></a>定时规则</h1><p>这里的定时规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">秒 分 时 天 月 周</span><br></pre></td></tr></table></figure><p>各个单位之间分别以空格分割，假设该任务需要每天12:23:45执行一次。那么则应该这么设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 23 12 * * *</span><br></pre></td></tr></table></figure><p>拉完之后记得运行，不运行的话要等到你设置好的时间才会自动执行。运行后会自动拉去一些执行活动的脚本</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216190140.png"></p><h1 id="获取京东Cookie"><a href="#获取京东Cookie" class="headerlink" title="获取京东Cookie"></a>获取京东Cookie</h1><p>使用 Chrome 内核浏览器（比如 Google 浏览器、Edge 浏览器、360 极速浏览器……），打开开发者模式（快捷键：F12），打开 Network（网络）标签，浏览器当前页面访问京东移动端登录地址<code>m.jd.com</code>，按照提示登录你的京东账号，复制你的京东账号 Cookie，也就是下图所示内容：</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216214832.png"></p><p>然后打开青龙面板，选择<code>环境变量</code>→<code>添加变量</code>，名称为<code>JD_COOKIE</code>，值为刚复制的京东账号<code>Cookie</code>，备注自己填方便识别，别的不需要动。添加后点<code>确定</code>就可以，如果需要添加多个账号，只需要获取多个Cookie添加上去就可以了，名称仍然为<code>JD_COOKIE</code>。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216190257.png"></p><p>添加好京东账号 Cookie 之后就可以去执行脚本了，如果等不及想尝试，可以自己触发脚本运行，否则就会在相应的时间执行。</p><p>顺带一说，Cookie 值并不需要这么多，只需要里面的<code>pt_key</code>与<code>pt_pin</code>两个就行了，懂的人自行提取，不懂的人全部复制粘贴上去。</p><p><strong>温馨提醒：</strong>不要频繁的去执行，避免黑号。还有就是建议京东账号绑定微信，有个活动抽奖抽到微信红包会自动提现到微信钱包。</p><h1 id="开启京东游戏任务"><a href="#开启京东游戏任务" class="headerlink" title="开启京东游戏任务"></a>开启京东游戏任务</h1><p>建议把所有活动游戏都点击一次，京东工厂这种需要自己选产品的建议自己选，不然会自动选一个，有的干脆不选。这里给大家说下各个游戏入口位置：</p><p>京东APP</p><ul><li><p>摇钱树：京东APP→右下角我的→中间更多工具</p></li><li><p>东东萌宠：京东APP→右下角我的</p></li><li><p>宠汪汪：京东APP→右下角我的</p></li><li><p>东东农场：京东APP→右下角我的</p></li><li><p>京喜工厂：惊喜APP→右下角我的</p></li><li><p>京喜牧场：惊喜APP→右下角我的</p></li><li><p>京喜财富岛：惊喜APP→右下角我的</p></li><li><p>发财大赢家：京东极速版→右下角我的</p></li><li><p>汪汪乐园：京东极速版→右下角我的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> JD </tag>
            
            <tag> 青龙面板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访客地图</title>
      <link href="/2022/03/10/%E8%AE%BF%E5%AE%A2%E5%9C%B0%E5%9B%BE/"/>
      <url>/2022/03/10/%E8%AE%BF%E5%AE%A2%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="访客地图"><a href="#访客地图" class="headerlink" title="访客地图"></a>访客地图</h1><p>前往 clustrmaps 网站注册一个帐号。</p><p>找到 Free Tools下面的 Website Widget, 点击 Get Map Widget。</p><p>输入你的博客网址，点击Next。根据你自己的喜好选择样式Map widget 或 Globe Widget。</p><p>找到如下代码，记住 src (** 的部分):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; id=&quot;clstr_globe&quot; src=&quot;**********************&quot;&gt;</span><br></pre></td></tr></table></figure><p>在 <strong>themes\Butterfly\layout\includes\widget</strong>文件夹新建<strong>card_map.pug</strong>文件，文件内容如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-map</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_map&#x27;)</span><br><span class="line">    script#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;此处填入你自己的代码&quot;)</span><br></pre></td></tr></table></figure><p>编辑 <strong>themes\Butterfly\layout\includes\widget\index.pug</strong> 文件，在你想要显示的位置插入以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!=partial(&#x27;includes/widget/card_map&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>（切记：如果主题版本大于3.6，请务必将**{cache:theme.fragment_cache}** 改为 { **cache:true }**）：</p><p>编辑_config.butterfly.yml 文件，在<strong>card_webinfo</strong> 下面添加一行<strong>card_map: true</strong></p><p>编辑<strong>themes\Butterfly\languages\zh-CN.yml</strong>文件 (请根据你的网站语言选择)，找到<strong>card_announcement:</strong> 公告 , 在下面添加一行<strong>card_map: 访客地图</strong> (后面的文本可自定义),繁体字方法一样，修改<strong>themes\Butterfly\languages\zh-TW.yml</strong>文件就行。</p><p>如果不想显示，直接把 <strong>_config.butterfly.yml</strong>文件的<strong>card_map: true</strong> 改为 <strong>card_map: false</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> Butterfly美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pixie日推</title>
      <link href="/2022/03/08/pixie%E6%97%A5%E6%8E%A8/"/>
      <url>/2022/03/08/pixie%E6%97%A5%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pixie日推"><a href="#pixie日推" class="headerlink" title="pixie日推"></a>pixie日推</h1><blockquote><p>注意： <a href="https://cloud.mokeyjay.com/pixiv">https://cloud.mokeyjay.com/pixiv</a> 使用的是<a href="https://www.mokeyjay.com/">超能小紫</a>提供的服务，也可以自行搭建，搭建方式请看这里-&gt;<a href="https://www.mokeyjay.com/archives/1063">传送门</a></p></blockquote><h2 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h2><ol><li><p>在 <strong>themes\Butterfly\layout\includes\widget</strong>文件夹新建card_pixiv.pug 文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-pixiv</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-image(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_pixiv&#x27;)</span><br><span class="line">    iframe(src=&quot;https://cloud.mokeyjay.com/pixiv&quot; frameborder=&quot;0&quot; style=&quot;width:99%;height:380px;margin:0;&quot;)</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>themes\Butterfly\layout\includes\widget\index.pug</strong> 文件，在你想要显示的位置插入以下代码（注意要对齐还有不要有空格符）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_pixiv</span><br><span class="line">       !=partial(&#x27;includes/widget/card_pixiv&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>butterfly.yml</strong> 文件，在 <strong>card_webinfo</strong> 下面添加一行 <strong>card_pixiv: true</strong></p></li><li><p>编辑 <strong>themes\Butterfly\languages\zh-CN.yml</strong> 文件 (请根据你的网站语言选择)，找到 <strong>card_announcement:</strong> 公告 , 在下面添加一行 <strong>card_pixiv: Pixiv日榜Top50</strong>(后面的文本可自定义)</p></li><li><p>如果不想显示，直接把 <strong>butterfly.yml</strong> 文件的 <strong>card_pixiv: true</strong> 改为 <strong>card_pixiv: false</strong> 即可</p></li></ol><blockquote><p><strong>文章来自转载：</strong></p><p><strong>文章作者:</strong> <a href="mailto:undefined">bt-sonny</a></p><p><strong>文章链接:</strong> <a href="https://chuchendjs.github.io/posts/BY-MOchange/">https://chuchendjs.github.io/posts/BY-MOchange/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Butterfly美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/01/hello-world/"/>
      <url>/2022/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
