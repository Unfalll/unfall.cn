<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络编程</title>
      <link href="/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/12/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_IO流</title>
      <link href="/2022/12/12/Java_IO%E6%B5%81/"/>
      <url>/2022/12/12/Java_IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>流：是一抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流。更具体一点，是内存与存储设备之间传输数据的通道。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200921134045111.png" alt="在这里插入图片描述"></p><p>IO流：对于数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I&#x2F;O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221214225804423.png" alt="image-20221214225804423"></p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><h3 id="按方向分"><a href="#按方向分" class="headerlink" title="按方向分"></a>按方向分</h3><ul><li>输入流:只能从中读取数据，而不能向其写入数据，由InputStream和Reader作为基类。</li><li>输出流: 只能向其写入数据，而不能从中读取数据。由OutputStream和Writer作为基类。</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/81c50a44a0d349d59e15eea707e08279.png" alt="img"></p><h3 id="按单位分"><a href="#按单位分" class="headerlink" title="按单位分"></a>按单位分</h3><ul><li><p>字节流: 它处理单元为1个字节（byte），操作字节和字节数组，存储的是二进制文件，如果是音频文件、图片、歌曲，就用字节流好点（1byte &#x3D; 8位）；</p></li><li><p>字符流: 它处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，如果是关系到中文（文本）的，用字符流好点（1Unicode &#x3D; 2字节 &#x3D; 16位）；</p><p>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p><p>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。</p><p>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联 在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的</p></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/a22149c96bff496f805c613dc9bd4835.png" alt="img"></p><h3 id="按功能分"><a href="#按功能分" class="headerlink" title="按功能分"></a>按功能分</h3><ul><li><p>节点流: 可以从一个特定的数据源读写数据，如<strong>FileInputStream</strong> ，<strong>FileOutputStream</strong> ，<strong>FileReader</strong> ，<strong>FileWriter</strong></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1425408a149f4c72993613ddb53f7aff.png" alt="在这里插入图片描述"></p></li><li><p>处理流: 也叫<code>包装流</code>，是在“连接”已经存在的流（节点流或者处理流）之上，为程序提供更加强大的读写功能，也更加灵活，如<strong>BufferedReader</strong> ，<strong>BufferedWriter</strong></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1888e2f837dc4fb98c49468600624697.png" alt="在这里插入图片描述"></p></li></ul><p>节点流是面向各种物理节点的流，比如面向读写文件的FileInputStream和FileOutputStream；面向对象的ObjectInputStream和ObjectOutputStream等等。</p><p>处理流则需要依附于节点流，用来对节点流的功能进行拓展和加强。比如BufferedInputStream，用它来包装FileInputStream（或者其他的节点输入流也一样）以后 ，直接调用BufferedInputStream的read方法，这个read方法的效果和FileInputStream的read方法的效果相比，就多出来一个缓存的功能。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221214230714412.png" alt="image-20221214230714412"></p><h2 id="IO流一览"><a href="#IO流一览" class="headerlink" title="IO流一览"></a>IO流一览</h2><table><thead><tr><th>分类</th><th>字节输入流</th><th>字节输出流</th><th>字符输入流</th><th>字符输出流</th></tr></thead><tbody><tr><td>抽象基类</td><td><em>InputStream</em></td><td><em>OutputStream</em></td><td><em>Reader</em></td><td><em>Writer</em></td></tr><tr><td>访问文件</td><td><strong>FileInputStream</strong></td><td><strong>FileOutputStream</strong></td><td><strong>FileReader</strong></td><td><strong>FileWriter</strong></td></tr><tr><td>访问数组</td><td><strong>ByteArrayInputStream</strong></td><td><strong>ByteArrayOutputStream</strong></td><td><strong>CharArrayReader</strong></td><td><strong>CharArrayWriter</strong></td></tr><tr><td>访问管道</td><td><strong>PipedInputStream</strong></td><td><strong>PipedOutputStream</strong></td><td><strong>PipedReader</strong></td><td><strong>PipedWriter</strong></td></tr><tr><td>访问字符串</td><td></td><td></td><td><strong>StringReader</strong></td><td><strong>StringWriter</strong></td></tr><tr><td>缓冲流</td><td>BufferedInputStream</td><td>BufferedOutputStream</td><td>BufferedReader</td><td>BufferedWriter</td></tr><tr><td>转换流</td><td></td><td></td><td>InputStreamReader</td><td>OutputStreamWriter</td></tr><tr><td>对象流</td><td>ObjectInputStream</td><td>ObjectOutputStream</td><td></td><td></td></tr><tr><td>抽象基类</td><td><em>FilterInputStream</em></td><td><em>FilterOutputStream</em></td><td><em>FilterReader</em></td><td><em>FilterWriter</em></td></tr><tr><td>打印流</td><td></td><td>PrintStream</td><td></td><td>PringWriter</td></tr><tr><td>退回输入流</td><td>PushbackInputStream</td><td></td><td>PushbackReader</td><td></td></tr><tr><td>特殊流</td><td>DataInputStream</td><td>DataOutputStream</td><td></td><td></td></tr></tbody></table><p>注:斜体表示抽象类,无法创建实例,加粗表示节点流,必须直接与指定的物理节点关联</p><h2 id="IO流的作用"><a href="#IO流的作用" class="headerlink" title="IO流的作用"></a>IO流的作用</h2><p>数据在各个设备之间的传输，是通过流的方式完成的</p><h2 id="io流的使用场景"><a href="#io流的使用场景" class="headerlink" title="io流的使用场景"></a>io流的使用场景</h2><p>字节流使用场景：字节流适用于处理非文本、文字相关数据外所有的流问题，如，png&#x2F;jpg&#x2F;avi&#x2F;map4&#x2F;mp3&#x2F;exe&#x2F;doc<br>InputStream OutputStream FileInputStream FileOutputStream</p><p>字符流使用场景：只适合处理【运算】文本、文字相关数据（编码乱码问题），主要是用来将读取的数据进行运算。例如，判断某字符串出现的次数等<br>Reader Writer FileReader FileWriter</p><p>转换流使用场景：当别人给提供了字节流，而需要处理文本数据，这时候，就需要用转换流转换一下，更方便处理文本数据（注意：只有转换流可以设置字符集）<br>InputStreamReader OutputStreamWriter</p><p>缓冲流（包装流）使用场景：适用于大文件的上传和下载。（可以使用标记和回读和预读）<br>BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter</p><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><blockquote><p>IO流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以IO流还得从文件File类讲起。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li><li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li><li>File对象可以作为参数传递给流的构造器，指明读取或写入的”终点”。</li></ol><h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><h3 id="绝对路径-x2F-相对路径"><a href="#绝对路径-x2F-相对路径" class="headerlink" title="绝对路径&#x2F;相对路径"></a>绝对路径&#x2F;相对路径</h3><ol><li>绝对路径：是一个固定的路径,从盘符开始</li><li>相对路径：是相对于某个位置开始</li></ol><ul><li><code>main（）</code>方法中的相对路径是相对于当前工程</li><li>单元测试方法中的相对路径是相对于当前模块</li></ul><h3 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a>路径分隔符</h3><ol><li><p>路径中的每级目录之间用一个路径分隔符隔开。</p></li><li><p>路径分隔符和系统有关：</p><ol><li>windows和DOS系统默认使用”&quot;来表示</li><li>UNIX和URL使用”&#x2F;“来表示</li></ol></li><li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。<br>为了解决这个隐患，File类提供了一个常量：<br>public static final String separator:根据操作系统，动态的提供分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\atguigu\\info.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;atguigu&quot;</span> + File.separator + <span class="string">&quot;info.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/atguigu&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><table><thead><tr><th>静态成员变量</th><th>描述</th></tr></thead><tbody><tr><td><code>public static String pathSeparator</code></td><td>系统中多个路径的分隔符 windows;</td></tr><tr><td><code>public static String separator</code></td><td>系统中一个路径中多个名称之间的分隔符号 windows\</td></tr></tbody></table><h3 id="常用构造器"><a href="#常用构造器" class="headerlink" title="常用构造器"></a>常用构造器</h3><table><thead><tr><th align="left">构造器</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>File(File parent, String child)</code></td><td>从父抽象路径名和子路径名字符串创建新的 <code>File</code>实例。</td></tr><tr><td align="left"><code>File(String pathname)</code></td><td>通过将给定的路径名字符串转换为抽象路径名来创建新的 <code>File</code>实例。</td></tr><tr><td align="left"><code>File(String parent, String child)</code></td><td>从父路径名字符串和子路径名字符串创建新的 <code>File</code>实例。</td></tr><tr><td align="left"><code>File(URI uri)</code></td><td>通过将给定的 <code>file:</code> URI转换为抽象路径名来创建新的 <code>File</code>实例。</td></tr></tbody></table><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        new FileCreate().create01();</span></span><br><span class="line"><span class="comment">//        new FileCreate().create02();</span></span><br><span class="line"><span class="comment">//        new FileCreate().create03();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileCreate</span>().create04();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//File(String pathname)</span></span><br><span class="line">    <span class="comment">//通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;D:\\code File\\new1.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//File(File parent, String child)</span></span><br><span class="line">    <span class="comment">//从父抽象路径名和子路径名字符串创建新的 File实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\code File&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;new02.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file, child);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file1.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//File(String parent, String child)</span></span><br><span class="line">    <span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;D:\\code File&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;new03.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//File(URI uri)</span></span><br><span class="line">    <span class="comment">//通过将给定的 file: URI转换为抽象路径名来创建新的 File实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\code File\\new04.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String getAbsolutePath()</td><td>获得绝对路径字符串。</td></tr><tr><td>String getPath()</td><td>获得创建文件对象时指定的路径字符串。</td></tr><tr><td>String getName()</td><td>获得文件名或文件夹名称。</td></tr><tr><td>long length()</td><td>获得文件大小，单位是：字节<br/>注意：只能获取文件的大小，不能获取文件夹的大小。</td></tr><tr><td>File getParentFile()</td><td>获得父路径文件对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:/aaa/bbb/ccc&quot;</span>);</span><br><span class="line">       <span class="comment">//获得绝对路径字符串</span></span><br><span class="line">        System.out.println(f.getAbsolutePath());<span class="comment">//H:\aaa\bbb\ccc</span></span><br><span class="line">        <span class="comment">//获得创建文件对象时指定的路径字符串</span></span><br><span class="line">        System.out.println(f.getPath());<span class="comment">//H:\aaa\bbb\ccc</span></span><br><span class="line">        <span class="comment">//获得文件名</span></span><br><span class="line">        System.out.println(f.getName());<span class="comment">//ccc</span></span><br><span class="line">        <span class="comment">//获得文件大小</span></span><br><span class="line">        System.out.println(f.length());</span><br><span class="line">        <span class="comment">//获得父路径文件对象</span></span><br><span class="line">        System.out.println(f.getParentFile());<span class="comment">//H:\aaa\bbb</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean exists()</td><td>判断文件或文件夹是否存在，存在则返回true，否则返回false</td></tr><tr><td>boolean isDirectory()</td><td>判断是否是文件夹，是返回true，否则false<br/>如果文件夹不存在，则返回false</td></tr><tr><td>boolean isFile()</td><td>判断是否是文件，是返回true，否则返回false<br/>如果文件夹不存在，则返回false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//判断文件是否存在</span></span><br><span class="line">        System.out.println(f.exists());<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f.isDirectory());<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//判断是否是文件，是返回true，否则返回false</span></span><br><span class="line">        System.out.println(f.isFile());<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean createNewFile()</td><td>根据文件对象指定的路径创建文件</td></tr><tr><td>boolean delete()</td><td>删除文件或文件夹</td></tr><tr><td>boolean mkdir() &#x3D;&#x3D;&gt;make directory</td><td>创建单级文件夹，如果文件已经存在，则不会创建了，返回false</td></tr><tr><td>boolean mkdirs()</td><td>创建多级文件夹，如果父文件不存在，则会先创建父文件</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:/aaa/bbb/ccc.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件</span></span><br><span class="line">        <span class="comment">//System.out.println(f.createNewFile());//true</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//创建单级文件夹</span></span><br><span class="line">        <span class="comment">//System.out.println(f.mkdir());</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//创建多级文件夹</span></span><br><span class="line">        <span class="comment">//System.out.println(f.mkdirs());</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//删除文件</span></span><br><span class="line">        System.out.println(f.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历目录的方法"><a href="#遍历目录的方法" class="headerlink" title="遍历目录的方法"></a>遍历目录的方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String[] list()</td><td>返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录</td></tr><tr><td>File[] listFiles()</td><td>获取文件夹下所有的文件，返回文件数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:\\aaa\\bbb&quot;</span>);</span><br><span class="line">        <span class="comment">//获得文件夹下的所有文件，返回文件数组</span></span><br><span class="line">        File[] files = f.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="字节流抽象基类"><a href="#字节流抽象基类" class="headerlink" title="字节流抽象基类"></a>字节流抽象基类</h2><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c92be2e423a542928409039c32dab28a.png" alt="img"></p><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>java.io.InputStream：字节输入流<br>此抽象类是表示字节输入流的所有类的超类</p><p>定义了所有子类共性的方法</p><ul><li>int read()从输入流中读取数据的下一个字节。</li><li>int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。</li><li>void close() 关闭此输入流并释放与该流关联的所有系统资源。</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1c012e0754bd430fa02ac1d5c8a128cc.png" alt="img"></p><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><ul><li><p>java.io.OutputStream 字节输出流</p></li><li><p>此抽象类是表示字节输出流所有类的超类</p></li><li><p>定义了所有子类共性的方法</p><ul><li><p>void write(int b)<br>讲解：将指定的字节写入输出流</p></li><li><p>void write(byte[] b)throws IOException<br>讲解：将b.length个字节的byte数组写入当前输出流</p></li><li><p>void flush() throws IOException<br>讲解： write是写到缓冲区中，可以认为是内存中,当缓冲区满时系统会⾃自动将缓冲区的内容写入文件，但是一般还有一部分有可能会留在内存这个缓冲区中, 所以需要调用flush空缓冲区数据。</p></li><li><p>void close() throws IOException<br>讲解：关闭输入流并释放与该流关联的系统资源</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/a83b0682975248bba3adad88b2e430b2.png" alt="img"></p><p>子类名特点：子类名称都是以其父类名作为子类名的后缀</p><h2 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h2><h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><p>使用字节输入流读取数据：使用 InputStream的子类FileInputStream</p><h4 id="FileInputStream-类的构造方法"><a href="#FileInputStream-类的构造方法" class="headerlink" title="FileInputStream 类的构造方法"></a>FileInputStream 类的构造方法</h4><table><thead><tr><th align="left">方法名和描述</th></tr></thead><tbody><tr><td align="left"><code>FileInputStream(File file)</code>通过打开与实际文件的连接创建一个 <code>FileInputStream</code> ，该文件由文件系统中的 <code>File</code>对象 <code>file</code>命名。</td></tr><tr><td align="left"><code>FileInputStream(FileDescriptor fdObj)</code>创建 <code>FileInputStream</code>通过使用文件描述符 <code>fdObj</code> ，其表示在文件系统中的现有连接到一个实际的文件。</td></tr><tr><td align="left"><code>FileInputStream(String name)</code>通过打开与实际文件的连接来创建一个 <code>FileInputStream</code> ，该文件由文件系统中的路径名 <code>name</code>命名。</td></tr></tbody></table><h4 id="FileInputStream的成员方法"><a href="#FileInputStream的成员方法" class="headerlink" title="FileInputStream的成员方法"></a>FileInputStream的成员方法</h4><table><thead><tr><th align="left">返回类型</th><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>int</code></td><td align="left"><code>available()</code>。</td><td>返回从此输入流中可以读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>close()</code></td><td>关闭此文件输入流并释放与流相关联的任何系统资源。</td></tr><tr><td align="left"><code>protected void</code></td><td align="left"><code>finalize()</code></td><td>确保当这个文件输入流的 <code>close</code>方法没有更多的引用时被调用。</td></tr><tr><td align="left"><code>FileChannel</code></td><td align="left"><code>getChannel()</code></td><td>返回与此文件输入流相关联的唯一的<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/nio/channels/FileChannel.html"><code>FileChannel</code></a>对象。</td></tr><tr><td align="left"><code>FileDescriptor</code></td><td align="left"><code>getFD()</code></td><td>返回表示与此 <code>FileInputStream</code>正在使用的文件系统中实际文件的连接的 <code>FileDescriptor</code>对象。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read()</code></td><td>从该输入流读取一个字节的数据。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read(byte[] b)</code></td><td>从该输入流读取最多 <code>b.length</code>个字节的数据为字节数组。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read(byte[] b, int off, int len)</code></td><td>从该输入流读取最多 <code>len</code>字节的数据为字节数组。</td></tr><tr><td align="left"><code>long</code></td><td align="left"><code>skip(long n)</code></td><td>跳过并从输入流中丢弃 <code>n</code>字节的数据。</td></tr></tbody></table><h4 id="字节输入流读取数据的操作步骤："><a href="#字节输入流读取数据的操作步骤：" class="headerlink" title="字节输入流读取数据的操作步骤："></a><strong>字节输入流读取数据的操作步骤：</strong></h4><ul><li>第一步：创建字节输入流对象 ，并指定文件路径，不指定文件路径默认在项目路径。如果该路径没有该文件，便会报出找不到文件的错误</li><li>第二步：调用read()方法读取数据，并把数据显示在控制台</li><li>第三步：关闭流对象</li></ul><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取数据//字节读取流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02_IO_FileInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字节输入流对象，并且在 () 中填写文件名称，在创建对象时会在指定项目中已经存在的文件，准备读取文件中内容</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数据量小时候使用单个字节读取即可，假如我们要读取字节数比较大的文件的时候，我们就不能一次读取一个字节了，就要一次读取一个字节数组。</span></span><br><span class="line"><span class="comment">    并且因为中文在utf-8编码中文占三个字节，GBK占两个字节，所以单个字符读取会乱码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="comment">/*   int in = 0;</span></span><br><span class="line"><span class="comment">        // 读取，赋值，判断</span></span><br><span class="line"><span class="comment">        while ((in =  fileInputStream.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            System.out.print((char) in);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//数据量大时，推荐使用下面这个方法，读取快且不会乱码</span></span><br><span class="line">            <span class="comment">// 数组的长度一般是1024或者1024的整数倍</span></span><br><span class="line">            <span class="comment">//注：此处数组长度设置为1024的原因，是因为 read(byte[] b)方法一次读取的是一整个字节数组，也就是一次读取1024个字节</span></span><br><span class="line">            <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bys, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><p>使用 <strong>OutputStream 它的子类 FileOutputStream</strong></p><h4 id="FileOutputStream-类的构造方法"><a href="#FileOutputStream-类的构造方法" class="headerlink" title="FileOutputStream 类的构造方法"></a>FileOutputStream 类的构造方法</h4><table><thead><tr><th align="left">方法名和描述</th></tr></thead><tbody><tr><td align="left"><code>FileOutputStream(File file)</code>创建文件输出流以写入由指定的 <code>File</code>对象表示的文件。</td></tr><tr><td align="left"><code>FileOutputStream(File file, boolean append)</code>创建文件输出流以写入由指定的 <code>File</code>对象表示的文件。</td></tr><tr><td align="left"><code>FileOutputStream(FileDescriptor fdObj)</code>创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。</td></tr><tr><td align="left"><code>FileOutputStream(String name)</code>创建文件输出流以指定的名称写入文件。</td></tr><tr><td align="left"><code>FileOutputStream(String name, boolean append)</code>创建文件输出流以指定的名称写入文件。</td></tr></tbody></table><h4 id="FileOutputStream类的成员方法"><a href="#FileOutputStream类的成员方法" class="headerlink" title="FileOutputStream类的成员方法"></a>FileOutputStream类的成员方法</h4><table><thead><tr><th align="left">返回类型</th><th align="left">方法名</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>void</code></td><td align="left"><code>close()</code></td><td>关闭此文件输出流并释放与此流相关联的任何系统资源。</td></tr><tr><td align="left"><code>protected void</code></td><td align="left"><code>finalize()</code></td><td>清理与文件的连接，并确保当没有更多的引用此流时，将调用此文件输出流的 <code>close</code>方法。</td></tr><tr><td align="left"><code>FileChannel</code></td><td align="left"><code>getChannel()</code></td><td>返回与此文件输出流相关联的唯一的<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/nio/channels/FileChannel.html"><code>FileChannel</code></a>对象。</td></tr><tr><td align="left"><code>FileDescriptor</code></td><td align="left"><code>getFD()</code></td><td>返回与此流相关联的文件描述符。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(byte[] b)</code></td><td>将 <code>b.length</code>个字节从指定的字节数组写入此文件输出流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(byte[] b, int off, int len)</code></td><td>将 <code>len</code>字节从位于偏移量 <code>off</code>的指定字节数组写入此文件输出流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(int b)</code></td><td>将指定的字节写入此文件输出流。</td></tr></tbody></table><h4 id="字节输出流写入数据的操作步骤"><a href="#字节输出流写入数据的操作步骤" class="headerlink" title="字节输出流写入数据的操作步骤"></a>字节输出流写入数据的操作步骤</h4><ul><li>第一步：创建字节输出流对象 ，并指定文件路径，不指定文件路径默认在项目路径。如果该路径没有该文件，创建字节输入流对象会将该文件创建出来</li><li>第二步：用输出流对象点 write() 方法，根据传入的参数确认调用的那个写入的方法，并将参数内容写入流对象指定的文件中</li><li>第三步：关闭流对象</li></ul><h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamDemo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> <span class="comment">// 创建字节输出流对象（FileOutputStream的这两种构造方法效果是一样的用那个都可以）</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// FileOutputStream(File file)</span></span><br><span class="line"> <span class="comment">// File file = new File(&quot;fos.txt&quot;);</span></span><br><span class="line"> <span class="comment">// FileOutputStream fos = new FileOutputStream(file);</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//构造方法： FileOutputStream(String name)</span></span><br><span class="line"> <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 调用write()方法,向fos文件中写入数据，写入一个字节</span></span><br><span class="line">     fos.write(<span class="number">97</span>); <span class="comment">//输出结果是97 -- 底层二进制数据 -- 通过记事本打开 -- 找97对应的字符值 -- a</span></span><br><span class="line">     <span class="comment">//换行</span></span><br><span class="line">     fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">     <span class="comment">//public void write(byte[] b):写一个字节数组</span></span><br><span class="line">     <span class="type">byte</span>[] bys=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">     fos.write(bys);<span class="comment">//输出结果是abcde</span></span><br><span class="line">     <span class="comment">//换行</span></span><br><span class="line">     fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">     <span class="comment">//public void write(byte[] b,int off,int len):写一个字节数组的一部分,存储数据下标范围</span></span><br><span class="line">     fos.write(bys,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//输出结果是bcd</span></span><br><span class="line">     <span class="comment">//换行</span></span><br><span class="line">     fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">     <span class="comment">//调用write()方法,向fos文件中写入数据，写入一段字符串并转换成 Byte 数组</span></span><br><span class="line">     fos.write(<span class="string">&quot;HelloWorld\t&quot;</span>.getBytes());</span><br><span class="line">     fos.write(<span class="string">&quot;JAVA\t&quot;</span>.getBytes());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">//释放资源，这一步很重要，如果不关闭流，流对象就会始终存在，占用的内容空间！！！</span></span><br><span class="line">     <span class="comment">//关闭此文件输出流并释放与此流有关的所有系统资源。</span></span><br><span class="line">     fos.close();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>在利用字节流读写数据时默认方法为一个字节一个字节的读写，这样读写的次数明显增多，使得效率大大下降，并且频繁的读写对磁盘也不友好，所以为了提高读写的效率就诞生了缓冲流。</p><p> 那么什么是缓冲流呢？都知道利用字节流写数据时是可以写入一个数组，读数据时也可以一次读取一个字节数组，此种方法可以在一定程度上提高流的读写速率，并且差距可以达到一千倍之多。而字节缓冲流简单来说就是在字节流的基础上封装内置了一个缓冲区，该缓冲区就是一个字节数组，默认大小为8192字节（即8k），写（读）字节时，先将字节写（读）入缓冲区，当缓冲区写（读）满时，在一次性的将数据写（读）到文件里。这样就降低了写（读）的次数，提高了效率。</p><h2 id="字节缓冲输入流"><a href="#字节缓冲输入流" class="headerlink" title="字节缓冲输入流"></a>字节缓冲输入流</h2><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>BufferedInputStream 是缓冲输入流。它继承于**FilterInputStream。<br>**BufferedInputStream 的作用是为另一个输入流添加一些功能，例如，提供“缓冲功能”以及支持“mark()标记”和“reset()重置方法”。<br>BufferedInputStream 本质上是通过一个内部缓冲区数组实现的。例如，在新建某输入流对应的BufferedInputStream后，当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置</p><p>字节缓冲流的使用方法与字节流的使用方法基本一致，其主要区别就在于字节缓冲流内部封装了一个字节数组，因此在创建对象时要先创建字节流，再创建字节缓冲流对字节流进行封装（字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作）。</p><p>（1）创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br></pre></td></tr></table></figure><p> （2）基本使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次提取一个字节</span></span><br><span class="line"><span class="type">int</span> by;</span><br><span class="line"><span class="keyword">while</span>((by = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println((<span class="type">char</span>)by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/28dd03d0ec9b485399c2302266d06ee8.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读取一个字节数组的数据</span></span><br><span class="line"><span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = bis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上两种读取方法在同一个数据流中只能只用一种。</p></blockquote><h2 id="字节缓冲输出流"><a href="#字节缓冲输出流" class="headerlink" title="字节缓冲输出流"></a>字节缓冲输出流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">bos.write(<span class="string">&quot;Holle!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节缓冲流：默认缓冲区大小为8192字节</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 字节缓冲流:</span></span><br><span class="line"><span class="comment"> * (1)BufferOutputStream:该类实现缓冲输出流。</span></span><br><span class="line"><span class="comment"> *通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</span></span><br><span class="line"><span class="comment"> * (2)BufferedlnputStream:创建Bufferedlnputstream将创建一个内部缓冲区数组。</span></span><br><span class="line"><span class="comment"> *当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充。一次很多字节</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造方法:</span></span><br><span class="line"><span class="comment"> * (1)字节缓冲输出流:BufferedOutputStream(OutputStream out)</span></span><br><span class="line"><span class="comment"> * (2)字节缓冲输入流:BufferedInputStream(InputStream in)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 为什么构造方法需要的是字节流，而不是具体的文件或者路径呢?</span></span><br><span class="line"><span class="comment"> * 字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStream_Buffered</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">output();</span><br><span class="line">input();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">bos.write(<span class="string">&quot;Holle!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">bos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次提取一个字节</span></span><br><span class="line"><span class="comment">//int by;</span></span><br><span class="line"><span class="comment">//while((by = bis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println((char)by);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//一次读取一个字节数组的数据</span></span><br><span class="line"><span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = bis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p> 注意在字节缓冲流和字节流中都有一次读一个字节和一次读一个字节数组两种方法，那么他们的区别是什么呢？</p><p> 在字节流中是读取一个字节（或一个字节数组）就写入磁盘一次，而字节缓冲流中虽然也是一次读取一个字节（或一个字节数组），但是要读够缓冲区大小的字节数后才写入磁盘一次。</p><p>因此缓冲区减少了读写磁盘的次数，从而提高了效率。</p></blockquote><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p><a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81&spm=1001.2101.3001.7020">字符流</a>是什么</p><ul><li><p>字符流是可以直接读取字符的IO流</p></li><li><p>字符流读取字符，就要先读去到字节数据，然后转为字符，如果要写出字符，需要把字符转为字节再写出</p></li><li><p>一个汉字存储：</p><ul><li>如果是GBK编码，占用2个字节</li><li>如果是UTF-8编码，占用3个字节</li></ul></li><li><p>字节流读取字符数据会出现问题，比如使用UTF-8编码的汉字，一个汉字占用3个字节，如果字节一个一个读取，没有办法拼成汉字。</p></li><li><p>由于字节流操作中文不是特别方便，所以java提供了字符流。字符流 &#x3D; 字节流 + 编码表</p></li><li><p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，</p><p>原因是：最终底层操作会自动进行字节拼接成中文，如何识别是中文呢？汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数。</p></li></ul><p>以字符为单位获取数据的流，称为字符流，它们都继承于Reader&#x2F;Writer抽象类。<br>  常用的字符流有：</p><ul><li>FileReader&#x2F;FileWriter，文件字符流（节点流）</li><li>BufferedReader&#x2F;BufferedWriter，字符缓存流（处理流）</li><li>InputStreamReader&#x2F;OutputStreamWriter，转换流（处理流）</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/f01b783c32164c1d9f29aad9d50ea2f3.png" alt="img"></p><h2 id="字符流抽象基类"><a href="#字符流抽象基类" class="headerlink" title="字符流抽象基类"></a>字符流抽象基类</h2><h3 id="输入流-1"><a href="#输入流-1" class="headerlink" title="输入流"></a>输入流</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210412124715893.png" alt="在这里插入图片描述"></p><p>java.io.Reader抽象类是标识用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><p>用于读取字符流的抽象类。 子类必须实现的唯一方法是read（char []，int，int）和close（）。 然而，大多数子类将覆盖这里定义的一些方法，以便提供更高的效率，附加的功能或两者。</p><table><thead><tr><th align="left">返回类型</th><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>abstract void</code></td><td align="left"><code>close()</code></td><td>关闭流并释放与之相关联的任何系统资源。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read()</code></td><td>读一个字符</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read(char[] cbuf)</code></td><td>将字符读入数组。</td></tr><tr><td align="left"><code>abstract int</code></td><td align="left"><code>read(char[] cbuf, int off, int len)</code></td><td>将字符读入数组的一部分。</td></tr></tbody></table><h3 id="输出流-1"><a href="#输出流-1" class="headerlink" title="输出流"></a>输出流</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210412124757494.png" alt="在这里插入图片描述"></p><p> java.io.Writer抽象类时标识用于写出字符流的所有类的<a href="https://so.csdn.net/so/search?q=%E8%B6%85%E7%B1%BB&spm=1001.2101.3001.7020">超类</a>，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><p>用于写入字符流的抽象类。 子类必须实现的唯一方法是write（char []，int，int），flush（）和close（）。 然而，大多数子类将覆盖这里定义的一些方法，以便提供更高的效率，附加的功能或两者。</p><table><thead><tr><th align="left">返回类型</th><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>abstract void</code></td><td align="left"><code>close()</code></td><td>关闭流，先刷新。</td></tr><tr><td align="left"><code>abstract void</code></td><td align="left"><code>flush()</code></td><td>刷新流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(char[] cbuf)</code></td><td>写入一个字符数组。</td></tr><tr><td align="left"><code>abstract void</code></td><td align="left"><code>write(char[] cbuf, int off, int len)</code></td><td>写入字符数组的一部分。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(int c)</code></td><td>写一个字符</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(String str)</code></td><td>写一个字符串</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(String str, int off, int len)</code>。</td><td>写一个字符串的一部分</td></tr></tbody></table><h2 id="字符流写数据"><a href="#字符流写数据" class="headerlink" title="字符流写数据"></a>字符流写数据</h2><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><h4 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a><strong>FileReader类</strong></h4><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">java.lang.Object</a><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/Reader.html">java.io.Reader</a><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/InputStreamReader.html">java.io.InputStreamReader</a><ul><li>java.io.FileReader</li></ul></li></ul></li></ul></li></ul><p>java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><p>阅读字符文件的便利课。 该类的构造函数假定默认字符编码和默认字节缓冲区大小是适当的。 要自己指定这些值，请在FileInputStream上构造一个InputStreamReader。</p><p><code>FileReader</code>是用于读取字符流。 要读取原始字节流，请考虑使用<code>FileInputStream</code> 。</p><p>作用：把硬盘文件中的数据以字符的方式读取到内存中。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">构造方法和说明</th></tr></thead><tbody><tr><td align="left"><code>FileReader(File file)</code>创建一个新的 <code>FileReader</code> ，给出 <code>File</code>读取。</td></tr><tr><td align="left"><code>FileReader(FileDescriptor fd)</code>创建一个新的 <code>FileReader</code> ，给定 <code>FileDescriptor</code>读取。</td></tr><tr><td align="left"><code>FileReader(String fileName)</code>创建一个新的 <code>FileReader</code> ，给定要读取的文件的名称。</td></tr></tbody></table><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>从 java.io.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/InputStreamReader.html">InputStreamReader</a> 类继承的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close, getEncoding, read, read, ready</span><br></pre></td></tr></table></figure><p>从 java.io.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/Reader.html">Reader</a> 类继承的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mark, markSupported, read, read, reset, skip</span><br></pre></td></tr></table></figure><p>从 java.lang.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">Object</a> 类继承的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</span><br></pre></td></tr></table></figure><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unfall04.File.Reader_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filereader01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        new Filereader01().fileread01();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Filereader01</span>().fileread02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileread01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="string">&quot;D:\\code File\\showIO\\Hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="keyword">while</span> ((data = fileReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileread02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="string">&quot;D:\\code File\\showIO\\a.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readleg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="keyword">while</span> ((readleg = fileReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print( <span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,readleg) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><h4 id="FileWrite"><a href="#FileWrite" class="headerlink" title="FileWrite"></a>FileWrite</h4><p>java.io.<a href="https://so.csdn.net/so/search?q=FileWriter&spm=1001.2101.3001.7020">FileWriter</a>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><p>作用：把内存中的字符数据写入到文件中</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">构造方法 和 说明</th></tr></thead><tbody><tr><td align="left"><code>FileWriter(File file)</code>给一个File对象构造一个FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(File file, boolean append)</code>给一个File对象构造一个FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(FileDescriptor fd)</code>构造与文件描述符关联的FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(String fileName)</code>构造一个给定文件名的FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(String fileName, boolean append)</code>构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。</td></tr></tbody></table><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><p>从 java.io.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/OutputStreamWriter.html">OutputStreamWriter</a> 类继承的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close, flush, getEncoding, write, write, write</span><br></pre></td></tr></table></figure><p>从 Methods inherited from class java.io.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/Writer.html">Writer</a> 类继承的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append, append, append, write, write</span><br></pre></td></tr></table></figure><p>从 java.lang.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">Object</a> 类继承的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</span><br></pre></td></tr></table></figure><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test4;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/c.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!f2.exists())&#123;</span><br><span class="line">            f2.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//定义一个字符输出流，向f2文件写入内容</span></span><br><span class="line">        Writer out=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(f2);</span><br><span class="line"> </span><br><span class="line">        out.write(<span class="number">97</span>);</span><br><span class="line"> </span><br><span class="line">        out.write((<span class="type">int</span>)<span class="string">&#x27;中&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">char</span>[] ch=&#123;<span class="string">&#x27;天&#x27;</span>,<span class="string">&#x27;上&#x27;</span>,<span class="string">&#x27;空&#x27;</span>,<span class="string">&#x27;气&#x27;</span>,<span class="string">&#x27;好&#x27;</span>,<span class="string">&#x27;呢&#x27;</span>&#125;;</span><br><span class="line">        out.write(ch,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        out.write(<span class="string">&quot;飞天肉饼&quot;</span>);</span><br><span class="line">        out.write(<span class="string">&quot;abcdef&quot;</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        out.flush();<span class="comment">//字符输出流有缓冲区的概念，需要刷新缓冲区才更新到硬盘</span></span><br><span class="line"> </span><br><span class="line">        out.close();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>  字符缓冲流和字节缓冲流一样，都是在原有基础上内部封装了一个缓冲区数组，以此提高流的读写速率。</p><h4 id="字符缓冲输入流"><a href="#字符缓冲输入流" class="headerlink" title="字符缓冲输入流"></a>字符缓冲输入流</h4><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">java.lang.Object</a><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/Reader.html">java.io.Reader</a><ul><li>java.io.BufferedReader</li></ul></li></ul></li></ul><p>BufferedReader : 从字符输出流读取文本，缓冲字符，以提供字符，数组，和行的高效读取，可以指定缓冲区大小，或者可以使用默认的大小。默认值足够大，可用于大多数用途</p><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><table><thead><tr><th align="left">构造方法名,说明</th></tr></thead><tbody><tr><td align="left"><code>BufferedReader(Reader in)</code>创建使用默认大小的输入缓冲区的缓冲字符输入流。</td></tr><tr><td align="left"><code>BufferedReader(Reader in, int sz)</code>创建使用指定大小的输入缓冲区的缓冲字符输入流。</td></tr></tbody></table><h5 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th align="left">返回类型</th><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>void</code></td><td align="left"><code>close()</code></td><td>关闭流并释放与之相关联的任何系统资源。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read()</code></td><td>读一个字符</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>read(char[] cbuf, int off, int len)</code></td><td>将字符读入数组的一部分。</td></tr><tr><td align="left"><code>String</code></td><td align="left"><code>readLine()</code></td><td>读一行文字。</td></tr></tbody></table><h5 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">/*        BufferedWriter rw = new BufferedWriter(new FileWriter(&quot;.\\rw.txt&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        rw.write(&quot;sciens\r\n&quot;);</span></span><br><span class="line"><span class="comment">        rw.write(&quot;technology\r\n&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        rw.close();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;.\\rw.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次读写一个字符</span></span><br><span class="line"><span class="comment">/*        int ch;</span></span><br><span class="line"><span class="comment">        while((ch = br.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.print((char)ch);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一次读取一个字符数组</span></span><br><span class="line">        <span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = br.read(chs)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chs,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符缓冲输出流"><a href="#字符缓冲输出流" class="headerlink" title="字符缓冲输出流"></a>字符缓冲输出流</h4><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">java.lang.Object</a><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/Writer.html">java.io.Writer</a><ul><li>java.io.BufferedWriter</li></ul></li></ul></li></ul><p>BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数字和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5><table><thead><tr><th align="left">构造方法和说明</th></tr></thead><tbody><tr><td align="left"><code>FileWriter(File file)</code>给一个File对象构造一个FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(File file, boolean append)</code>给一个File对象构造一个FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(FileDescriptor fd)</code>构造与文件描述符关联的FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(String fileName)</code>构造一个给定文件名的FileWriter对象。</td></tr><tr><td align="left"><code>FileWriter(String fileName, boolean append)</code>构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。</td></tr></tbody></table><h5 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th align="left">返回类型</th><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>void</code></td><td align="left"><code>close()</code></td><td>关闭流，先刷新。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>flush()</code></td><td>刷新流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>newLine()</code></td><td>写一行行分隔符。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(char[] cbuf, int off, int len)</code></td><td>写入字符数组的一部分。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(int c)</code></td><td>写一个字符</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>write(String s, int off, int len)</code></td><td>写一个字符串的一部分。</td></tr></tbody></table><h5 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h5><p>复制java文件（字符缓冲流改进版）</p><p>需求：把模块目录下的“xxx”复制到模块目录下的“xxx”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;.\\Demo5.java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;.\\copy.java&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        int ch;</span></span><br><span class="line"><span class="comment">        while((ch = br.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">            bw.write((char)ch);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = br.read(chs)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bw.write(chs,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流特有功能"><a href="#字符缓冲流特有功能" class="headerlink" title="字符缓冲流特有功能"></a>字符缓冲流特有功能</h3><table><thead><tr><th>所属类</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>BufferedWriter</td><td>void newLine（）</td><td>写一行 行分隔符，行分割符字符串由系统属性定义</td></tr><tr><td>BufferedReader</td><td>public String readLine（）</td><td>读一行文字，结果包含行的内容的字符串，不包含任何行终止字符，如果流的结尾已经到达，则为null<br/>感觉这个属性是为了配合OutputStreamWriter类中的Writer的写字符串的方法</td></tr></tbody></table><h4 id="使用字符缓冲流写数据特殊功能的步骤："><a href="#使用字符缓冲流写数据特殊功能的步骤：" class="headerlink" title="使用字符缓冲流写数据特殊功能的步骤："></a><strong>使用字符缓冲流写数据特殊功能的步骤：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 创建字符缓冲输入流对象</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">fileReader</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line"><span class="comment">//2 创建字符缓冲输出流对象</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">fileWriter</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line"><span class="comment">//3 使用readLine读取一行文字，并写入字符输出流对象。</span></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readline())!= <span class="literal">null</span>) &#123;</span><br><span class="line">bw.write(line);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注意:单独使用readLine方法读取数据 不会读入换行符之类的内容，换行需要执行newLine方法</p></blockquote><h1 id="IO特殊操作流"><a href="#IO特殊操作流" class="headerlink" title="IO特殊操作流"></a>IO特殊操作流</h1><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在整个IO包中，打印流是输出信息做方便的类，主要包含<strong>字节打印流</strong>（<a href="https://so.csdn.net/so/search?q=PrintStream&spm=1001.2101.3001.7020">PrintStream</a>）和<strong>字符打印流</strong>（<a href="https://so.csdn.net/so/search?q=PrintWriter&spm=1001.2101.3001.7020">PrintWriter</a>）。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串、布尔类型等等。</p><h3 id="PrintStream字节打印流"><a href="#PrintStream字节打印流" class="headerlink" title="PrintStream字节打印流"></a>PrintStream字节打印流</h3><p> 为什么要有PrintStream类？</p><p>之前在打印信息的时候需要使用OutputStream，但是这样一来，所有的数据输出的时候会非常的麻烦，String——&gt;byte[]，但是字节打印流中可以方便的进行输出。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>PrintStream在OutputStream基础之上提供了增强的功能，可以方便的输出各种类型的数据（不仅限于byte型）的格式化表示形式。</p><p> <code>PrintStream</code>为另一个输出流添加了功能，即能够方便地打印各种数据值的表示。 还提供了另外两个功能。 与其他输出流不同， <code>PrintStream</code>从不抛出<code>IOException</code> ; 相反，异常情况只是设置一个可以通过<code>checkError</code>方法测试的内部标志。 可以选择一个<code>PrintStream</code> ，以便自动刷新; 这意味着<code>flush</code>字节数组写入方法后自动调用，所述一个<code>println</code>方法被调用时，或者一个新行字符或字节（ <code>&#39;\n&#39;</code> ）被写入。</p><p>由印刷的所有字符<code>PrintStream</code>被转换成使用平台的默认字符编码字节。 在需要编写字符而不是字节的情况下，应使用<code>PrintWriter</code>类。</p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221216150512770.png" alt="image-20221216150512770"></p><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">构造方法和说明</th></tr></thead><tbody><tr><td align="left"><code>PrintStream(File file)</code>使用指定的文件创建一个新的打印流，而不需要自动换行。</td></tr><tr><td align="left"><code>PrintStream(File file, String csn)</code>使用指定的文件和字符集创建新的打印流，而不需要自动换行。</td></tr><tr><td align="left"><code>PrintStream(OutputStream out)</code>创建一个新的打印流。</td></tr><tr><td align="left"><code>PrintStream(OutputStream out, boolean autoFlush)</code>创建一个新的打印流。</td></tr><tr><td align="left"><code>PrintStream(OutputStream out, boolean autoFlush, String encoding)</code>创建一个新的打印流。</td></tr><tr><td align="left"><code>PrintStream(String fileName)</code>使用指定的文件名创建新的打印流，无需自动换行。</td></tr><tr><td align="left"><code>PrintStream(String fileName, String csn)</code>创建一个新的打印流，不需要自动换行，具有指定的文件名和字符集。</td></tr></tbody></table><p>在PrintStream中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收OutputStream类的实例，这是因为与OutputStream相比起来，PrintStream可以更加方便的输出数据，这就好比将OutputStream重新包装了一下，使之输出更加方便。</p><table><thead><tr><th>返回类型</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭流。</td></tr><tr><td><code>void</code></td><td><code>flush()</code></td><td>刷新流。</td></tr><tr><td><code>void</code></td><td><code>print(Type x)</code></td><td>该方法被重载很多次，可以输出任意数据</td></tr><tr><td><code>void</code></td><td><code>println(Type x)</code></td><td>该方法被重载很多次，可以输出任意数据后换行</td></tr></tbody></table><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>把指定的数据，写入到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">      <span class="comment">// 创建一个字符打印流对象</span></span><br><span class="line">      <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 把数组中的元素值输入到文件中</span></span><br><span class="line">      Object[] arr = &#123;<span class="literal">true</span>, <span class="number">123</span>, <span class="string">&quot;powernode&quot;</span>, <span class="number">123.45</span>&#125;;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="comment">// 打印数据</span></span><br><span class="line">         ps.println(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      ps.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>在JDK1.5之后，JAVA又对PrintStream类进行了扩充，增加了格式化的输出方式，直接使用printf()方法就可以完成操作，但是在进行格式化输出的时候需要指定其输出的数据类型。</p><table><thead><tr><th><em><strong>*字符*</strong></em></th><th><em><strong>*描述*</strong></em></th></tr></thead><tbody><tr><td>%s</td><td>表示内容为字符串</td></tr><tr><td>%d</td><td>表示内容为整数</td></tr><tr><td>%f</td><td>表示内容为小数</td></tr><tr><td>%c</td><td>表示内容为字符</td></tr></tbody></table><p>格式化输出后示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">      <span class="comment">// 创建一个字符打印流对象</span></span><br><span class="line">      <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 格式化输出</span></span><br><span class="line">      ps.printf(<span class="string">&quot;姓名:%s 年龄:%d 成绩:%f 性别:%c&quot;</span>,<span class="string">&quot;小明&quot;</span>, <span class="number">8</span>, <span class="number">97.5</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">      ps.close();</span><br><span class="line">      <span class="comment">// System.out的格式化输出</span></span><br><span class="line">      System.out.printf(<span class="string">&quot;姓名:%s 年龄:%d 成绩:%f 性别:%c&quot;</span>, <span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="number">97.5</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrintWriter字符打印流"><a href="#PrintWriter字符打印流" class="headerlink" title="PrintWriter字符打印流"></a>PrintWriter字符打印流</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>PrintWriter提供了PrintStream的所有打印方法，其方法也从不抛出IOException。</p><p>PrintWriter与PrintStream的区别：</p><p>作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream类型的字节流，还能够封装Writer类型的字符输出流并增强其功能。</p><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">构造方法和说明</th></tr></thead><tbody><tr><td align="left"><code>PrintWriter(File file)</code>使用指定的文件创建一个新的PrintWriter，而不需要自动的线路刷新。</td></tr><tr><td align="left"><code>PrintWriter(File file, String csn)</code>使用指定的文件和字符集创建一个新的PrintWriter，而不需要自动进行线条刷新。</td></tr><tr><td align="left"><code>PrintWriter(OutputStream out)</code>从现有的OutputStream创建一个新的PrintWriter，而不需要自动线路刷新。</td></tr><tr><td align="left"><code>PrintWriter(OutputStream out, boolean autoFlush)</code>从现有的OutputStream创建一个新的PrintWriter。</td></tr><tr><td align="left"><code>PrintWriter(String fileName)</code>使用指定的文件名创建一个新的PrintWriter，而不需要自动执行行刷新。</td></tr><tr><td align="left"><code>PrintWriter(String fileName, String csn)</code>使用指定的文件名和字符集创建一个新的PrintWriter，而不需要自动线路刷新。</td></tr><tr><td align="left"><code>PrintWriter(Writer out)</code>创建一个新的PrintWriter，没有自动线冲洗。</td></tr><tr><td align="left"><code>PrintWriter(Writer out, boolean autoFlush)</code>创建一个新的PrintWriter。</td></tr></tbody></table><p><em><strong>*注意：设置了自动刷新，那么只有在换行的时候才会提现效果！*</strong></em></p><h4 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>返回类型</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭流并释放与之相关联的任何系统资源。</td></tr><tr><td><code>void</code></td><td><code>flush()</code></td><td>刷新流。</td></tr><tr><td><code>void</code></td><td><code>print(Type x)</code></td><td>该方法被重载很多次，可以输出任意数据</td></tr><tr><td><code>void</code></td><td><code>print(Typr x)</code></td><td>该方法被重载很多次，可以输出任意数据后换行</td></tr></tbody></table><h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><p>把指定的数据，写入到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriterDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 创建字符打印流对象,并设置为自定刷新</span></span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(writer, <span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 存储数据</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         pw.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pw.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​    System.in:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System类的静态属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>该流的编译类型为InputStream，运行类型为BufferedInputStream</p><p>属于是字节流，默认关联的设备为键盘，即数据源为键盘<br>              使用转换流可以包装成字符流,使用BufferedReader可以包装成缓冲流<br>              通过System.setIn(InputStream in),可以更改标准输入流关联的设备<br>              该流对象不需要关闭</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>1.我们可以自己实现键盘录入输入。<br>        BufferedReader(InputStreamReader(System.in));<br>        调用readtLine()方法接收数据。</p><p>2.但是上面的方式太麻烦了，所以我们直接使用键盘输入的类<br>        Scanner sc &#x3D; new Scanner(System.in);</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fuxi;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">        <span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardInputOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = in.read()) != -<span class="number">1</span>)</span><br><span class="line">            <span class="comment">//一开始是打印int类型的,用char进行强制转换</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>System.out</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System类中的 静态属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><p>该流的类型为PrintStream，属于字节流，是打印流。<br>               默认关联的设置是控制台，即可以将数据直接写到控制台显示<br>               通过System.setOut(OutputStream out),可以更改标准输出流关联的设备</p><h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>​          输出语句本质就是一个标准输出流<br>​          创建标准输出流对象：PrintStream ps &#x3D; System.out;<br>​          调用print()方法可以输出不带换行效果的数据<br>​          调用println()方法可以输出带换行效果的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fuxi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardInputOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        out.print(<span class="literal">true</span>);</span><br><span class="line">        out.print(<span class="number">99</span>);</span><br><span class="line">        out.print(<span class="string">&quot;Hello,world&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        out.println(<span class="number">99</span>);</span><br><span class="line">        out.close();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">true99Hello,world------</span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure><h3 id="标准输入输出的重定向"><a href="#标准输入输出的重定向" class="headerlink" title="标准输入输出的重定向"></a>标准输入输出的重定向</h3><p>标准输入输出的重定向：</p><p>System中提供对应的重定向的方法,改变标准输入输出的方向为其它形式如从文件中输入或输出到文件中。<br>方法：利用System类中的3个static 方法可以实现。System.out 把数据输出到控制台，通过重定向可以改变输出的目的地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOut</span><span class="params">(PrintStream out)</span> ：重新分配“标准”输出流，标准输出流：输出到指定的输出流。 </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setErr</span><span class="params">(PrintStream err)</span>： 重新分配“标准”错误输出流，标准错误流：将输出到指定的输出流。 </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setIn</span><span class="params">(InputStream in)</span> ：重新分配“标准”输入流，标准输入流：原来在后台输入，现在根据指定的输入流，输入。</span><br></pre></td></tr></table></figure><p>注意：重定向的方法调用代码必须写在打印或者输入的前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重定向标准输入输出流以及标准错误输出流的重定向：（ex：System.out 把数据输出到控制台，通过重定向可以改变输出的目的地）</span></span><br><span class="line"><span class="comment"> * System中提供对应的重定向的方法：</span></span><br><span class="line"><span class="comment"> * static void setOut(PrintStream out) 重新分配“标准”输出流，标准输出流：输出到指定的输出流。 </span></span><br><span class="line"><span class="comment"> * static void setErr(PrintStream err) 重新分配“标准”错误输出流，标准错误流：将输出到指定的输出流。 </span></span><br><span class="line"><span class="comment"> * static void setIn(InputStream in) 重新分配“标准”输入流，标准输入流：原来在后台输入，现在根据指定的输入流，输入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">byte</span>[] b  = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> in.read();</span><br><span class="line"><span class="comment">//nio非阻塞式IO流</span></span><br><span class="line"><span class="comment">//此处： 因为in流持续在，检测后台的数据，只要有了就能读取出来，没有就在该处阻塞</span></span><br><span class="line"><span class="comment">/*while((len = in.read(b)) != -1)&#123;//阻塞了执行流程: 阻塞式IO流</span></span><br><span class="line"><span class="comment">System.out.println(new String(b,0,len));</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的标准输入流可能存在阻塞</span></span><br><span class="line"><span class="comment">//原来输出到后台显示，现在通过重定向之后，以指定流的方式：输出到指定的位置D:1/1/1.doc</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:1/1/1.doc&quot;</span>));</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">out.println(<span class="string">&quot;重定向之后的信息&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//========================================================================================</span></span><br><span class="line"><span class="comment">//如果操作系统已经打开了1.doc文件 ，代码执行会报错，文件已经处于被使用状态，代码不能操作该文件</span></span><br><span class="line">System.setErr(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:1/1/1.txt&quot;</span>));</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">err</span> <span class="operator">=</span> System.err;</span><br><span class="line">err.println(<span class="string">&quot;重定向之后的错误信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.setIn(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:1/1/1.txt&quot;</span>));</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in;</span><br><span class="line"><span class="type">int</span> len2;</span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len2 =is.read(b2)) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b2,<span class="number">0</span>,len2));<span class="comment">//注意上面标准输出流是否已经重定向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象流-序列化流"><a href="#对象流-序列化流" class="headerlink" title="对象流(序列化流)"></a>对象流(序列化流)</h2><h3 id="对象流作用"><a href="#对象流作用" class="headerlink" title="对象流作用"></a>对象流作用</h3><p>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到文件源中（序列化），也能把对象从文件源中还原回来（反序列化）</p><h3 id="序列化机制理解"><a href="#序列化机制理解" class="headerlink" title="序列化机制理解"></a>序列化机制理解</h3><p>首先我们要了解什么是序列化机制？<br>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从<br>而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传<br>输到另一个网络节点。<br>当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</span><br><span class="line">反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</span><br><span class="line"></span><br><span class="line">注意：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</span><br></pre></td></tr></table></figure><h3 id="序列化机制的好处"><a href="#序列化机制的好处" class="headerlink" title="序列化机制的好处"></a>序列化机制的好处</h3><p>可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</p><h3 id="序列化注意事项"><a href="#序列化注意事项" class="headerlink" title="序列化注意事项"></a>序列化注意事项</h3><p>首先，如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可<br>序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。</p><ol><li>Serializable（主要实现这个接口）</li><li>Externalizable</li></ol><p>否则，会抛出NotSerializableException异常</p><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用来表明类的不同版本间的兼容性。</span></span><br><span class="line"><span class="comment">简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</span></span><br><span class="line"><span class="comment">如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自</span></span><br><span class="line"><span class="comment">动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，</span></span><br><span class="line"><span class="comment">显式声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h3><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">java.lang.Object</a><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/InputStream.html">java.io.InputStream</a><ul><li>java.io.ObjectInputStream</li></ul></li></ul></li></ul><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">修饰器</th><th align="left">构造方法和说明</th></tr></thead><tbody><tr><td align="left"><code>protected</code></td><td align="left"><code>ObjectInputStream()</code>为完全重新实现ObjectInputStream的子类提供一种方法，不必分配刚刚被ObjectInputStream实现使用的私有数据。</td></tr><tr><td align="left"><code> </code></td><td align="left"><code>ObjectInputStream(InputStream in)</code>创建从指定的InputStream读取的ObjectInputStream。</td></tr></tbody></table><h4 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>返回类型</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭输入流。</td></tr><tr><td><code>int</code></td><td><code>read()</code></td><td>读取一个字节的数据。</td></tr><tr><td><code>int</code></td><td><code>read(byte[] buf, int off, int len)</code></td><td>读入一个字节数组。</td></tr><tr><td><code>boolean</code></td><td><code>readBoolean()</code></td><td>读取布尔值。</td></tr><tr><td><code>byte</code></td><td><code>readByte()</code>。</td><td>读取一个8位字节</td></tr><tr><td><code>char</code></td><td><code>readChar()</code></td><td>读一个16位字符。</td></tr><tr><td><code>double</code></td><td><code>readDouble()</code></td><td>读64位双倍。</td></tr><tr><td><code>ObjectInputStream.GetField</code></td><td><code>readFields()</code></td><td>从流中读取持久性字段，并通过名称获取它们。</td></tr><tr><td><code>float</code></td><td><code>readFloat()</code></td><td>读32位浮点数。</td></tr><tr><td><code>void</code></td><td><code>readFully(byte[] buf)</code></td><td>读取字节，阻塞直到读取所有字节。</td></tr><tr><td><code>void</code></td><td><code>readFully(byte[] buf, int off, int len)</code></td><td>读取字节，阻塞直到读取所有字节。</td></tr><tr><td><code>int</code></td><td><code>readInt()</code></td><td>读取一个32位int。</td></tr><tr><td><code>long</code></td><td><code>readLong()</code></td><td>读64位长。</td></tr><tr><td><code>Object</code></td><td><code>readObject()</code></td><td>从ObjectInputStream读取一个对象。</td></tr><tr><td><code>short</code></td><td><code>readShort()</code>短。</td><td>读取16位</td></tr><tr><td><code>String</code></td><td><code>readUTF()</code></td><td>以 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/DataInput.html#modified-utf-8">modified UTF-8</a>格式读取字符串。</td></tr></tbody></table><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 创建节点输出流（FileOutputStream）</span><br><span class="line">2. 创建对象流（ObjectOutputStream）</span><br><span class="line">3. 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</span><br><span class="line">4. 注意写出一次，操作flush()一次</span><br><span class="line">5. 关闭流</span><br><span class="line"></span><br><span class="line">注意：输出序列化对象后，需要进行反序列化操作才能得到内容！否则就是乱码！</span><br></pre></td></tr></table></figure><h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建节点流(文件流)</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建对象流,实现序列化操作</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            <span class="comment">//3.调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</span></span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;对象流很简单！&quot;</span>));</span><br><span class="line">            <span class="comment">//4.注意写出一次，操作flush()一次</span></span><br><span class="line">            oos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭流</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象反序列化流"><a href="#对象反序列化流" class="headerlink" title="对象反序列化流"></a>对象反序列化流</h3><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">java.lang.Object</a><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/OutputStream.html">java.io.OutputStream</a><ul><li>java.io.ObjectOutputStream</li></ul></li></ul></li></ul><h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">修饰器</th><th align="left">方法名和说明</th></tr></thead><tbody><tr><td align="left"><code>protected</code></td><td align="left"><code>ObjectOutputStream()</code>为完全重新实现ObjectOutputStream的子类提供一种方法，不必分配刚刚被ObjectOutputStream实现使用的私有数据。</td></tr><tr><td align="left"><code> </code></td><td align="left"><code>ObjectOutputStream(OutputStream out)</code>创建一个写入指定的OutputStream的ObjectOutputStream。</td></tr></tbody></table><h4 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>返回类型</th><th>方法名</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code>关闭流。</td></tr><tr><td><code>void</code></td><td><code>flush()</code>刷新流。</td></tr><tr><td><code>ObjectOutputStream.PutField</code></td><td><code>putFields()</code>检索用于缓冲要写入流的持久性字段的对象。</td></tr><tr><td><code>void</code></td><td><code>useProtocolVersion(int version)</code>指定在编写流时使用的流协议版本。</td></tr><tr><td><code>void</code></td><td><code>write(byte[] buf)</code>写入一个字节数组。</td></tr><tr><td><code>void</code></td><td><code>write(byte[] buf, int off, int len)</code>写入一个子字节数组。</td></tr><tr><td><code>void</code></td><td><code>write(int val)</code>写一个字节。</td></tr><tr><td><code>void</code></td><td><code>writeBoolean(boolean val)</code>写一个布尔值。</td></tr><tr><td><code>void</code></td><td><code>writeByte(int val)</code>写入一个8位字节。</td></tr><tr><td><code>void</code></td><td><code>writeBytes(String str)</code>写一个字符串作为字节序列。</td></tr><tr><td><code>void</code></td><td><code>writeChar(int val)</code>写一个16位的字符。</td></tr><tr><td><code>void</code></td><td><code>writeChars(String str)</code>写一个字符串作为一系列的字符。</td></tr><tr><td><code>void</code></td><td><code>writeDouble(double val)</code>写一个64位的双倍。</td></tr><tr><td><code>void</code></td><td><code>writeFields()</code>将缓冲的字段写入流。</td></tr><tr><td><code>void</code></td><td><code>writeFloat(float val)</code>写一个32位浮点数。</td></tr><tr><td><code>void</code></td><td><code>writeInt(int val)</code>写一个32位int。</td></tr><tr><td><code>void</code></td><td><code>writeLong(long val)</code>写一个64位长</td></tr><tr><td><code>void</code></td><td><code>writeObject(Object obj)</code>将指定的对象写入ObjectOutputStream。</td></tr><tr><td><code>void</code></td><td><code>writeShort(int val)</code>写一个16位短。</td></tr><tr><td><code>void</code></td><td><code>writeUTF(String str)</code>此字符串的原始数据写入格式为 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/io/DataInput.html#modified-utf-8">modified UTF-8</a> 。</td></tr></tbody></table><h4 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol><li>创建节点输出流（FileInputStream）</li><li>创建对象流（ObjectInputStream）</li><li>调用 ObjectOutputStream 对象的 readObject() 方法输出可序列化对象</li><li>关闭流</li></ol><h4 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建节点输入流(FileInputStream)</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 创建对象流（ObjectInputStream）</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="comment">//3.调用 ObjectOutputStream 对象的 readObject() 方法输出可序列化对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强调</strong>：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型<strong>必须是可序列化的</strong>，否则拥有该类型的Field 的类也不能序列化</p><h3 id="通过对象流输出自定义对象-person"><a href="#通过对象流输出自定义对象-person" class="headerlink" title="通过对象流输出自定义对象(person)"></a>通过对象流输出自定义对象(person)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们必须将自定义的对象，实现Serializable接口，</span></span><br><span class="line"><span class="comment">否则该对象不能进行序列化操作！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>  <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="comment">//序列化版本标识符的静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">12321312331231L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">============================================================================</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建节点流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Person.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建对象流</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            <span class="comment">//3.调用方法，进行序列化操作</span></span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xuzhibin&quot;</span>,<span class="number">20</span>));</span><br><span class="line">            <span class="comment">//4.刷新</span></span><br><span class="line">            oos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建节点流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Person.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建对象流</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="comment">//3.调用方法进行反序列化操作</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="集合（Properties集合）"><a href="#集合（Properties集合）" class="headerlink" title="集合（Properties集合）"></a>集合（Properties集合）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>是一个Map体系的集合类</li><li>Properties可以保存到流中或从流中加载</li><li>属性列表中的每个键及其对应的值都是一个字符串</li></ul><h3 id="Properties作为Map集合的特有方法"><a href="#Properties作为Map集合的特有方法" class="headerlink" title="Properties作为Map集合的特有方法"></a>Properties作为Map集合的特有方法</h3><p>1、Object   setProperty(String key, String value)<br>设置集合的键和值，都是String类型，底层调用   Hashtable方法 put<br>2、String   getProperty(String key)<br>使用此属性列表中指定的键搜索属性<br>3、Set<String>   stringPropertyNames()<br>从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</p><h3 id="Properties和IO流相结合的方法"><a href="#Properties和IO流相结合的方法" class="headerlink" title="Properties和IO流相结合的方法"></a>Properties和IO流相结合的方法</h3><p>1、void   load(InputStream inStream)<br>    从输入字节流读取属性列表（键和元素对）<br>2、void   load(Reader reader)<br>    从输入字符流读取属性列表（键和元素对）<br>3、void   store(OutputStream out, String comments)<br>    将此属性列表（键和元素对）写入此   Properties表中，以适合于使用   load(InputStream)方法的格式写入输出字节流<br>4、void   store(Writer writer, String comments)<br>    将此属性列表（键和元素对）写入此   Properties表中，以适合使用   load(Reader)方法的格式写入输出字符流</p><h3 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//把集合中的数据保存到文件</span></span><br><span class="line"><span class="comment">//        myStore();</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//把文件中的数据加载到集合</span></span><br><span class="line">        myLoad();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myLoad</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//void load(Reader reader)：</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myOtherStream\\fw.txt&quot;</span>);</span><br><span class="line">        prop.load(fr);</span><br><span class="line">        fr.close();</span><br><span class="line"> </span><br><span class="line">        System.out.println(prop);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myStore</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"> </span><br><span class="line">        prop.setProperty(<span class="string">&quot;itheima001&quot;</span>,<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;itheima002&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;itheima003&quot;</span>,<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//void store(Writer writer, String comments)：</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;myOtherStream\\fw.txt&quot;</span>);</span><br><span class="line">        prop.store(fw,<span class="literal">null</span>);</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2><h3 id="什么是字符集"><a href="#什么是字符集" class="headerlink" title="什么是字符集"></a>什么是字符集</h3><p>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p><p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等。</p><h3 id="常见的字符集"><a href="#常见的字符集" class="headerlink" title="常见的字符集"></a>常见的字符集</h3><h4 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h4><p>ASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 。</p><p>基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p><h4 id="GBXXX字符集"><a href="#GBXXX字符集" class="headerlink" title="GBXXX字符集"></a>GBXXX字符集</h4><p>GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</p><h4 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h4><p>UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码。</p><h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><p> 128个US-ASCII字符，只需一个字节编码<br>  拉丁文等字符，需要二个字节编码<br>  大部分常用字（含中文），使用三个字节编码<br>  其他极少使用的Unicode辅助字符，使用四字节编码</p><h2 id="flush方法和close方法的区别："><a href="#flush方法和close方法的区别：" class="headerlink" title="flush方法和close方法的区别："></a><strong>flush方法和close方法的区别：</strong></h2><ul><li>close释放资源前进行一次刷新流，</li><li>close执行后不能在写内容；而flush是刷新流，执行完毕依旧可以写内容；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_集合</title>
      <link href="/2022/11/15/Java_%E9%9B%86%E5%90%88/"/>
      <url>/2022/11/15/Java_%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><strong>为什么要有集合</strong><br>提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行添加、修改、删除操作，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为Collection和Map两种体系。</p><p><strong>在java中，集合分为两大类</strong></p><ul><li>单个方式存储元素，这一类集合的超级父接口为：java.util.Collection</li><li>以键值对的方式存储元素，这一类集合的超级父接口为：java.util.Map</li></ul><p><strong>集合和数组</strong></p><ul><li><p>长度区别</p><ul><li>数组固定</li><li>集合可变</li></ul></li><li><p>内容区别</p><ul><li>数组可以是基本类型，也可以是引用类型</li><li>集合只能是引用类型</li></ul></li><li><p>元素内容</p><ul><li>数组只能存储同一种类型</li><li>集合可以存储不同类型（其实集合一般存储的也是同一种类型）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1010726-20170621004734695-988542448.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1010726-20170621004756882-1379253225.gif" alt="img"> </p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025110431438.png" alt="image-20221025110431438"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025110453481.png" alt="image-20221025110453481"></p><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>迭代器的介绍</p><p>迭代器，集合的专用遍历方式</p><p>Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</p><p>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</p><p>Collection集合的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用while循环改进元素的判断和获取</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二次遍历需要重置迭代器</span></span><br><span class="line">        it = c.iterator();</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强for循环遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Object o : c)&#123;</span><br><span class="line">        System.out.println( o );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h4><p>Collection 接口有 3 种子类型集合: List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、ArrayBlockingQueue等，下面是Collection的所有方法。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025161938824.png" alt="image-20221025161938824"></p><p>这些方法即可以操作Set集合，也可以操作Queue和List集合,下面分别使用<code>Collection</code>集合接口的方法说明</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>向集合添加元素e，若指定集合元素改变了则返回true</td></tr><tr><td>boolean addAll(Collection&lt;? extends E&gt; c)</td><td>把集合C中的元素全部添加到集合中，若指定集合元素改变返回true</td></tr><tr><td>void clear()</td><td>清空所有集合元素</td></tr><tr><td>boolean contains(Object o)</td><td>判断指定集合是否包含对象o</td></tr><tr><td>boolean containsAll(Collection&lt;?&gt; c)</td><td>判断指定集合是否包含集合c的所有元素</td></tr><tr><td>boolean isEmpty()</td><td>判断指定集合的元素size是否为0</td></tr><tr><td>boolean remove(Object o)</td><td>删除集合中的元素对象o,若集合有多个o元素，则只会删除第一个元素</td></tr><tr><td>boolean removeAll(Collection&lt;?&gt; c）</td><td>删除指定集合包含集合c的元素</td></tr><tr><td>boolean retainAll(Collection&lt;?&gt; c)</td><td>从指定集合中保留包含集合c的元素,其他元素则删除</td></tr><tr><td>int size()</td><td>集合的元素个数</td></tr><tr><td>T[] toArray(T[] a)</td><td>将集合转换为T类型的数组</td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 创建Collection接口的实现</span></span><br><span class="line">      <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 添加元素</span></span><br><span class="line">      collection.add(<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;????&quot;</span>;</span><br><span class="line">      collection.add(src);</span><br><span class="line">      System.out.println(collection);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建Collection的实现</span></span><br><span class="line">      Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      System.out.println(coll);</span><br><span class="line">      <span class="comment">// 添加一个集合数据</span></span><br><span class="line">      collection.addAll(coll);</span><br><span class="line">      <span class="comment">// 输出集合的长度</span></span><br><span class="line">      System.out.println(collection);</span><br><span class="line">      <span class="comment">// 判断是否包含</span></span><br><span class="line">      System.out.println(collection.contains(<span class="string">&quot;?&quot;</span>));</span><br><span class="line">      <span class="comment">// 移除元素</span></span><br><span class="line">      collection.remove(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      <span class="comment">// 添加对象</span></span><br><span class="line">      collection.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">5000d</span>));</span><br><span class="line">      <span class="comment">// 当认为两个对象属性一致，相等时候，需重写hashCode 和 equals方法</span></span><br><span class="line">      System.out.println(collection.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">5000d</span>)));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">      collection.add(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">      Collection&lt;String&gt; collection1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      collection1.add(<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">      collection1.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      <span class="comment">// 求两个集合的交集(只保留collection1存在的元素)</span></span><br><span class="line">      collection.retainAll(collection1);</span><br><span class="line">      System.out.println(collection);</span><br><span class="line">      <span class="comment">// 清空元素</span></span><br><span class="line">      collection.clear();</span><br><span class="line">      System.out.println(collection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ol><li>List集合类中元素有序（即添加顺序和取出顺序一致），且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以更具序号存取容器中的元素</li><li>JDK  API中List接口的实现类非常多，常用的有ArrayList、LinkedList、Vectors<ol><li>ArrayList：底层由数组结构实现Object[]，可以存储任何Object类型的对象，是非线程安全的</li><li>LinkedList：List和Deque接口的双向链表实现。实现所有可选列表操作，并允许所有元素（包括null ）。所有操作都按照双向链表的预期执行。索引到列表中的操作将从开头或结尾遍历列表，以更接近指定索引的为准。</li><li>Vector：底层实现是动态数组的方式存放数据，是线程安全的，Vector源码当中每个方法都被synchronized关键字进行修饰，保证了Vector的线程安全，所以效率很低，尽量少使用</li></ol></li></ol><h5 id="List的继承、实现关系"><a href="#List的继承、实现关系" class="headerlink" title="List的继承、实现关系"></a>List的继承、实现关系</h5><p>其继承了Collection接口并由AbstractList来实现，Collection又继承了Iterable接口</p><p>Collection：集合层次结构中的根接口。一个集合表示一组对象，称为它的元素。一些集合允许重复元素，而另一些则不允许。有些是有序的，有些是无序的。<br>Iterable：实现此接口允许对象成为“for-each 循环”语句的目标。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2022020709121614.png" alt="img"></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        </span><br><span class="line">List&lt;Object&gt; list1= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Map&gt; list2= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Student&gt; list3= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index, Object ele)</td><td>在index位置插入ele元素</td></tr><tr><td>boolean addAll(int index, Collection eles)</td><td>从index位置开始将eles中的所有元素添加进来</td></tr><tr><td>Object get(int index)</td><td>获取指定index位置的元素</td></tr><tr><td>int indexOf(Object obj</td><td>返回obj在集合中首次出现的位置</td></tr><tr><td>int lastIndexOf(Object obj)</td><td>返回obj在当前集合中末次出现的位置</td></tr><tr><td>Object remove(int index)</td><td>移除指定index位置的元素，并返回此元素</td></tr><tr><td>Object set(int index, Object ele)</td><td>设置指定index位置的元素为ele , 相当于是替换.</td></tr><tr><td>List subList(int fromIndex, int toIndex)</td><td>返回从fromIndex到toIndex位置的子集合</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line"><span class="comment">//        void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">//在index = 1的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        Object get(int index):获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"><span class="comment">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line"><span class="comment">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;玛丽&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list=[张三丰, 韩顺平, 贾宝玉]</span><br><span class="line">list=[张三丰, jack, tom, 韩顺平, 贾宝玉]</span><br><span class="line">jack</span><br><span class="line"><span class="number">2</span></span><br><span class="line">list=[张三丰, jack, tom, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">list=[jack, tom, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line">list=[jack, 玛丽, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line">returnlist=[jack, 玛丽]</span><br></pre></td></tr></table></figure><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p> ArrayList实现了<a href="https://so.csdn.net/so/search?q=List%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">List接口</a>它是一个可调整大小的数组可以用来存放各种形式的数据。并提供了包括CRUD在内的多种方法可以对数据进行操作但是它不是线程安全的，外ArrayList按照插入的顺序来存放数据。</p><h6 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//数组默认初始容量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空的数组实例以供其他需要用到空数组的地方调用 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空数组，跟前面的区别就是这个空数组是用来判断ArrayList第一添加数据的时候要扩容多少。默认的构造器情况下返回这个空数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//数据存的地方它的容量就是这个数组的长度，同时只要是使用默认构造器（DEFAULTCAPACITY_EMPTY_ELEMENTDATA ）第一次添加数据的时候容量扩容为DEFAULT_CAPACITY = 10 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//当前数组的长度</span></span><br></pre></td></tr></table></figure><h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20180530205624808" alt="img"></p><ol><li>第一个构造方法用来返回一个初始容量为10的数组（具体过程后面会提到）</li><li>第二个用来生成一个带数据的ArrayList这边不再赘述</li><li>第三个构造方法就是自定义初始容量。下面我将根据默认的构造方法来展开下文。</li></ol><p>可以看到默认的构造器就是用了参数DEFAULTCAPACITY_EMPTY_ELEMENTDATA返回了一个空的数组，所以这边我们可以了解到ArrayList在创建的时候如果没有指定初始容量的话就会返回一个长度为0的空数组。下面我想从ArrayList的扩容机制开始解析，因为在所有添加数据的操作上面都要需要判断当前数组容量是否足以容纳新的数据，如果不够的话就需要进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><h6 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h6><p>​    ArrayList扩容的核心从ensureCapacityInternal方法说起。可以看到前面介绍成员变量的提到的ArrayList有两个默认的空数组：</p><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA：是用来使用默认构造方法时候返回的空数组。如果第一次添加数据的话那么数组扩容长度为DEFAULT_CAPACITY&#x3D;10。</p><p>EMPTY_ELEMENTDATA：出现在需要用到空数组的地方，其中一处就是使用自定义初始容量构造方法时候如果你指定初始容量为0的时候就会返回。</p><p>从下面可以看到如果是使用了空数组EMPTY_ELEMENTDATA话，那么不会返回默认的初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前数组是否是默认构造方法生成的空数组，如果是的话minCapacity=10反之则根据原来的值传入下一个方法去完成下一步的扩容判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//minCapacitt表示修改后的数组容量，minCapacity = size + 1 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//判断看看是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面谈谈ensureExplicitCapacity方法（modCount设计到Java的快速报错机制后面会谈到），可以看到如果修改后的数组容量大于当前的数组长度那么就需要调用grow进行扩容，反之则不需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//判断当前ArrayList是否需要进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//快速报错机制</span></span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后看下ArrayList扩容的核心方法grow()，下面将针对三种情况对该方法进行解析：</p><ol><li><p>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</p></li><li><p>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList扩容的核心方法，此方法用来决定扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h6 id="Java容器的快速报错机制ConcurrentModificationException："><a href="#Java容器的快速报错机制ConcurrentModificationException：" class="headerlink" title="Java容器的快速报错机制ConcurrentModificationException："></a>Java容器的快速报错机制ConcurrentModificationException：</h6><p>Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容。如果你在迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或修改此容器的某个对象，就会立刻抛出ConcurrentModificationException。</p><p>前文提到的迭代遍历指的就是使用迭代器Iterator(ListIterator)或者forEach语法，实际上一个类要使用forEach就必须实现Iterable接口并且重写它的Iterator方法所以forEach本质上还是使用Iterator。</p><p><img src="https://img-blog.csdn.net/20180531101951612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>从下面方法可以看到在迭代遍历的过程中都调用了方法checkForComodification来判断当前ArrayList是否是同步的。现在来举一个栗子，假设你往一个Integer类型的ArrayList插入了10条数据，那么每操作一次modCount（继承自父类AbstractList）就加一所以就变成10，而当你对这个集合进行遍历的时候就把modCount传到expectedModCount这个变量里，然后ArrayList在checkForComodification中通过判断两个变量是否相等来确认当前集合是否是同步的，如果不同步就抛出ConcurrentModificationException。所谓的不同步指的就是，如果你在遍历的过程中对ArrayList集合本身进行add,remove等操作时候就会发生。当然如果你用的是Iterator那么使用它的remove是允许的因为此时你直接操作的不是ArrayList集合而是它的Iterator对象。在代码后面将贴出前面提到的三种情况。此外在多线程也会存在这种情况，但是如果你在多线程中使用CopyOnWriteArrayList就可以避免了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// 下一个要返回的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 返回最后一个元素的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//防止篇幅过长省去了其中代码</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="comment">//防止篇幅过长省去其中代码</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一种情况使用Iterator：</strong></p><p><img src="https://img-blog.csdn.net/20180531105735346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>第二种情况使用forEach：</strong></p><p><img src="https://img-blog.csdn.net/20180531105905747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>第三种情况使用Iterator自身删除数据：</strong></p><p><img src="https://img-blog.csdn.net/20180531110055360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTAzNTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h6 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h6><p>在ArrayList中，声明了三个常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//默认容量大小为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//一个空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//一个默认容量的空数组</span></span><br></pre></td></tr></table></figure><p>还声明了一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p>然后再看一下ArrayList的构造方法</p><p>这是无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是有参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若是调用ArrayList的无参构造方法，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，它将DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值给elementData，这个DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的Object数组，而elementData就是ArrayList实际存储数据的容器。</p><p>由此可知，ArrayList在调用无参构造方法时创建的是一个长度为0的空数组，当调用add()方法添加元素时，ArrayList才会触发扩容机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add()方法的第一行即是执行扩容流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法又会先计算扩容容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始elementData就是一个空数组，条件成立，它会从DEFAULT_CAPACITY和minCapacity中选择一个最大值返回，其中DEFAULT_CAPACITY表示默认的初始容量，它的值为10：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>而minCapacity是add()方法传递过来的，值为size + 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br></pre></td></tr></table></figure><p>所以calculateCapacity()方法将返回10，之后调用ensureExplicitCapacity()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先让modCount++，这是用来记录数组被修改次数的变量，我们先不管它，此时minCapacity的值为10，elementData.length的值为0，条件成立，执行grow()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>先将旧容量右移1位，再加上旧容量就得到了新容量，正数右移1位相当于除以2，在该基础上加旧容量，则等价于新容量 &#x3D; 旧容量 * 1.5，所以才有ArrayList每次扩容为旧容量的1.5倍的说法，最后调用Arrays.copyOf()方法进行拷贝，并将elementData指向新数组，而旧数组因为没有引用指向它，很快就会被垃圾收集器回收掉。</p><p>当第二次调用add()方法时，程序依然要走到扩容方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此时的elementData已经不是空数组了，所以直接返回当前size + 1，即：2，接着调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时minCapacity小于数组长度，所以if判断不会成立，也就不会发生扩容。</p><p>当添加第11个元素时，ArrayList应该会触发第二次扩容，来看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>minCapacity的值为11，紧接着调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时minCapacity的值大于elementData的长度，条件成立，触发扩容机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原容量10右移一位得到5，再加上原容量10得到15，所以新数组的容量为15，最后对数组进行拷贝扩容就完成了。</p><p>当ArrayList进行第三次扩容后容量会是多少呢？我们知道，新容量一定是旧容量的1.5倍，而15 * 1.5 &#x3D; 22.5，那么新容量到底是22还是23呢？所以，如果你只知道新容量是旧容量的1.5倍，这个问题你就无法知道。事实上，ArrayList底层是通过移位操作计算得到的新容量。所以新容量应该等于15 &gt;&gt; 1 + 15 &#x3D; 22，由此可得，ArrayList经过第三次扩容后容量为22。</p><p>然而在addAll()方法中，扩容机制会有一定的变化，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.addAll(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完addAll()方法后，ArrayList的容量应该是多少呢？是15吗？来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将调用ensureCapacityInternal()方法进行扩容，并传入 size + numNew &#x3D; 11：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为初始elementData是一个空数组，符合条件，所以它将返回DEFAULT_CAPACITY和minCapacity中较大的那个，结果是minCapacity较大，所以返回11，这就导致addAll()方法执行结果后ArrayList的容量为11。</p><blockquote><p>addAll()方法总是选择扩容一次后的容量与旧容量加上添加的元素个数的容量中取一个最大值作为新的容量，比如：当前ArrayList中有10个元素，而addAll()方法需要添加6个元素，当ArrayList触发扩容后的新容量应该为15，而旧容量加上需要添加的元素容量为16，从中取一个较大值为16，所以新容量应该为16。</p></blockquote><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h6><p>Vector是集合当中的一个重要知识点，它于ArrayList相比，最大的区别在于Vector是线程安全的，在源码当中的添加，删除等重要方法当中都加入了关键字 synchronized，实现了操作的线程安全，与ArrayList一样，Vector同样实现了 RandomAccess, Cloneable, Serializable接口。</p><h6 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector():构造一个空的Vector对象。</span><br><span class="line">Vector(<span class="type">int</span> initialCapacity):构造一个具有给定初始容量的空的Vector对象。</span><br><span class="line">Vector(<span class="type">int</span> initialCapacity,<span class="type">int</span> capacityIncrement):构造一个具有给定初始容量和容量增量的空的Vector对象。</span><br></pre></td></tr></table></figure><h6 id="Vector-扩容机制"><a href="#Vector-扩容机制" class="headerlink" title="Vector 扩容机制"></a>Vector 扩容机制</h6><p><strong>使用无参构造器跟进</strong></p><p><img src="https://img-blog.csdnimg.cn/20210617122819739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>Vector中三个重要的属性：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210617123051412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210617123125532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>step 1：</strong><img src="https://img-blog.csdnimg.cn/20210617123332468.png" alt="img"></p><p><strong>step 2：</strong><img src="https://img-blog.csdnimg.cn/20210617123501756.png" alt="img"></p><p><strong>step 3：</strong><img src="https://img-blog.csdnimg.cn/2021061712373943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p> 实例化完成：</p><p>往Vector集合中添加 11个元素，看第11个元素的扩容机制：</p><p><img src="https://img-blog.csdnimg.cn/20210617124717477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p>step 1：</p><p><img src="https://img-blog.csdnimg.cn/20210617124859168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p>step 2：</p><p><img src="https://img-blog.csdnimg.cn/20210617124941946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p>step 3：</p><p><img src="https://img-blog.csdnimg.cn/20210617125749832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p> step 4：方法弹栈消失。回到 add 方法中：</p><p><img src="https://img-blog.csdnimg.cn/20210617130253386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p> Vector 其他两个 构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        elementCount = a.length;</span><br><span class="line">        <span class="comment">// 1： 如果是 ArrayList 集合</span></span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            <span class="comment">// 2： 则把 ArrayList集合的 elementData 赋值给 当前 Vectory实例的elementData指向。</span></span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 3： 如果不是则 先数组拷贝。再赋值指向。</span></span><br><span class="line">            elementData = Arrays.copyOf(a, elementCount, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 如果用户给的 初始化长度是 小于 0 </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 初始化的elementData的数组的长度为 用户指定的长度。</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="comment">// 当前Vector实例的 容量增量是用户给的为准。</span></span><br><span class="line">        <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 如果使用此构造器实例化 Vector对象时。当集合中的元素的数量超过。elementData数组的容量时。则<br>&#x2F;&#x2F; Vector 底层的扩容的新数组的长度每次都是  ： 旧数组的容量 + 用户给定的容量增量。</p><h6 id="ArrayList和Vector比较"><a href="#ArrayList和Vector比较" class="headerlink" title="ArrayList和Vector比较"></a>ArrayList和Vector比较</h6><table><thead><tr><th></th><th>底层结构</th><th>版本</th><th>线程安全（同步）效率</th><th>库容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>jdk1.2</td><td>不安全，效率高</td><td>如果有参构造为1.5倍，<br />如果是无参，第一次为10，第二次则是第一次的1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组</td><td>jdk1.0</td><td>安全，效率不高</td><td>如果是无参，默认10.满后，就按2倍扩容，<br />如果指定大小，则每次直接按2倍扩容</td></tr></tbody></table><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><h6 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h6><p><a href="https://so.csdn.net/so/search?q=LinkedList&spm=1001.2101.3001.7020">LinkedList</a>类是List接口的实现类，它是一个集合，可以根据索引来随机的访问集合中的元素，还实现了Deque接口，它还是一个队列，可以被当成双端队列来使用。虽然LinkedList是一个List集合，但是它的实现方式和ArrayList是完全不同的，ArrayList的底层是通过一个动态的Object[]数组来实现的，而LinkedList的底层是通过链表来实现的，因此它的随机访问速度是比较差的，但是它的删除，插入操作会很快。</p><ul><li>LinkedList是基于双向链表实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</li><li>LinkedList同样是非线程安全的，只在单线程下适合使用。</li><li>LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221028163644521.png" alt="image-20221028163644521"></p><h6 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h6><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">    java.util.AbstractCollection&lt;E&gt; </span><br><span class="line">        java.util.AbstractList&lt;E&gt; </span><br><span class="line">            java.util.AbstractSequentialList&lt;E&gt; </span><br><span class="line">                java.util.LinkedList&lt;E&gt;</span><br></pre></td></tr></table></figure><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, Deque&lt;E&gt;, List&lt;E&gt;, Queue&lt;E&gt;</span><br></pre></td></tr></table></figure><p>基本属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;    <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;     <span class="comment">//尾节点</span></span><br></pre></td></tr></table></figure><p>LinkedList 继承了 AbstractSequentialList 类。</p><p>LinkedList 实现了 Queue 接口，可作为队列使用。</p><p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p><p>LinkedList 实现了 Deque 接口，可作为队列使用。</p><p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p><p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNi8yMDE5MDMyODE2NDczNy5wbmc?x-oss-process=image/format,png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20201224105911185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM4Nzk2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h6><blockquote><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>　　链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向&#x2F;双向链表又可以分为循环链表和非循环链表，下面简单就这四种链表进行图解说明。</p><h3 id="1-单向链表"><a href="#1-单向链表" class="headerlink" title="1.单向链表"></a>1.单向链表</h3><p>　　　　单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。</p><p><img src="https://static.oschina.net/uploads/space/2018/0227/193331_JljJ_2927759.png" alt="img"></p><h3 id="2-单向循环链表"><a href="#2-单向循环链表" class="headerlink" title="2.单向循环链表"></a>2.单向循环链表</h3><p>　　　　单向循环链表和单向列表的不同是，最后一个节点的next不是指向null，而是指向head节点，形成一个“环”。</p><p><img src="https://static.oschina.net/uploads/space/2018/0227/193412_xGR9_2927759.png" alt="img"></p><h3 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3.双向链表"></a>3.双向链表</h3><p>　　　　从名字就可以看出，双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。</p><p><img src="https://static.oschina.net/uploads/space/2018/0227/193440_9dt2_2927759.png" alt="img"></p><h3 id="4-双向循环链表"><a href="#4-双向循环链表" class="headerlink" title="4.双向循环链表"></a>4.双向循环链表</h3><p>　　　　双向循环链表和双向链表的不同在于，第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。<strong>而LinkedList就是基于双向循环链表设计的。</strong></p><p><img src="https://static.oschina.net/uploads/space/2018/0227/193526_9m6M_2927759.png" alt="img"></p></blockquote><h6 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h6><p>LinkedList是通过双向链表去实现的，既然是链表实现那么它的随机访问效率比ArrayList要低，顺序访问的效率要比较的高。每个节点都有一个前驱（之前前面节点的指针）和一个后继（指向后面节点的指针），效果如下图：</p><p><img src="https://static.oschina.net/uploads/space/2018/0227/193615_NxRG_2927759.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;<span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;   <span class="comment">//尾节点</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造方法，创建一个空的列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;  <span class="comment">//将头节点赋值给f节点</span></span><br><span class="line">        <span class="comment">//new 一个新的节点，此节点的data = e , pre = null , next - &gt; f </span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">        first = newNode; <span class="comment">//将新创建的节点地址复制给first</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)  <span class="comment">//f == null，表示此时LinkedList为空</span></span><br><span class="line">            last = newNode;  <span class="comment">//将新创建的节点赋值给last</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;  <span class="comment">//否则f.前驱指向newNode</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入尾节点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last; </span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在succ节点前插入e节点，并修改各个节点之间的前驱后继</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="literal">null</span>;</span><br><span class="line">        f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="literal">null</span>;</span><br><span class="line">        l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">            first = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定节点</span></span><br><span class="line">    E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;  <span class="comment">//获取指定节点的前驱</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;  <span class="comment">//获取指定节点的后继</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = next;   <span class="comment">//如果前驱为null, 说明此节点为头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;  <span class="comment">//前驱结点的后继节点指向当前节点的后继节点</span></span><br><span class="line">            x.prev = <span class="literal">null</span>;     <span class="comment">//当前节点的前驱置空</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;    <span class="comment">//如果当前节点的后继节点为null ,说明此节点为尾节点</span></span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;  <span class="comment">//当前节点的后继节点的前驱指向当前节点的前驱节点</span></span><br><span class="line">            x.next = <span class="literal">null</span>;     <span class="comment">//当前节点的后继置空</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        x.item = <span class="literal">null</span>;     <span class="comment">//当前节点的元素设置为null ,等待垃圾回收</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取LinkedList中的第一个节点信息</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取LinkedList中的最后一个节点信息</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将添加的元素设置为LinkedList的头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将添加的元素设置为LinkedList的尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断LinkedList是否包含指定的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回List中元素的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在LinkedList的尾部添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将集合中的元素添加到List中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将集合中的元素全部插入到List中，并从指定的位置开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"> </span><br><span class="line">        Object[] a = c.toArray();  <span class="comment">//将集合转化为数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;  <span class="comment">//获取集合中元素的数量</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)   <span class="comment">//集合中没有元素，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="literal">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index); <span class="comment">//获取位置为index的结点元素，并赋值给succ</span></span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;  <span class="comment">//遍历数组进行插入操作。修改节点的前驱后继</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除List中所有的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="literal">null</span>;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="literal">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取指定位置的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将节点防止在指定的位置</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将节点放置在指定的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定位置的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断索引是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断位置是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//索引溢出信息</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查节点是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查位置是否合法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回指定位置的节点信息</span></span><br><span class="line">    <span class="comment">//LinkedList无法随机访问，只能通过遍历的方式找到相应的节点</span></span><br><span class="line">    <span class="comment">//为了提高效率，当前位置首先和元素数量的中间位置开始判断，小于中间位置，</span></span><br><span class="line">    <span class="comment">//从头节点开始遍历，大于中间位置从尾节点开始遍历</span></span><br><span class="line">    Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回第一次出现指定元素的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回最后一次出现元素的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//弹出第一个元素的值</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//弹出第一元素，并删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//添加到尾部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//添加到头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入到最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列操作</span></span><br><span class="line">    <span class="comment">//尝试弹出第一个元素，但是不删除元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//队列操作</span></span><br><span class="line">    <span class="comment">//尝试弹出最后一个元素，不删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : l.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弹出第一个元素，并删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//弹出最后一个元素，并删除</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如队列，添加到头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//出队列删除第一个节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//删除指定元素第一次出现的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除指定元素最后一次出现的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类，实现ListIterator接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; lastReturned = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"> </span><br><span class="line">        ListItr(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">            next = (index == size) ? <span class="literal">null</span> : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"> </span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"> </span><br><span class="line">            lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">            nextIndex--;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"> </span><br><span class="line">            Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">            unlink(lastReturned);</span><br><span class="line">            <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">                next = lastNext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextIndex--;</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned.item = e;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                linkLast(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkBefore(e, next);</span><br><span class="line">            nextIndex++;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类，创建节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"> </span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DescendingIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adapter to provide descending iterators via ListItr.previous</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DescendingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ListItr</span> <span class="variable">itr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(size());</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itr.previous();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            itr.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title function_">superClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &#123;<span class="doctag">@code</span> LinkedList&#125;. (The elements</span></span><br><span class="line"><span class="comment">     * themselves are not cloned.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this &#123;<span class="doctag">@code</span> LinkedList&#125; instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Put clone into &quot;virgin&quot; state</span></span><br><span class="line">        clone.first = clone.last = <span class="literal">null</span>;</span><br><span class="line">        clone.size = <span class="number">0</span>;</span><br><span class="line">        clone.modCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                                a.getClass().getComponentType(), size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Object[] result = a;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将对象写入到输出流中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            s.writeObject(x.item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//从输入流中将对象读出</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Read in size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            linkLast((E)s.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h6><p>LinkedList 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">LinkedList() </span><br><span class="line">LinkedList(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;E&gt;();   <span class="comment">// 普通创建方法</span></span><br><span class="line">或者</span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c); <span class="comment">// 使用集合创建链表</span></span><br></pre></td></tr></table></figure><blockquote><p>LinkedList没有长度的概念，所以不存在容量不足的问题，因此不需要提供初始化大小的构造方法，因此值提供了两个方法，一个是无参构造方法，初始一个LinkedList对象，和将指定的<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>元素转化为LinkedList构造方法。</p></blockquote><p>创建一个简单的链表实例：</p><p>&#x2F;&#x2F; 引入 LinkedList 类</p><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">    System.out.println(sites);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上实例，执行输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google, Runoob, Taobao, Weibo]</span><br></pre></td></tr></table></figure><h6 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h6><p>在了解LinkedList的实现原理之前，我们首先需要明白LinkedList中的一个节点是什么以及他的具体数据结构。LinkedList每个节点是一个Node类型的实例，每个Node实例除了保存节点的真实值(真实数据)外，还保存了这个节点的前一个节点的引用和后一个节点的引用，这样就实现了双线链表的数据结构。Node数据结构如下：</p><p><img src="https://img-blog.csdnimg.cn/20181119130011320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FqMTUyMDE0MjY4OTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从代码中我们可以看到，当创建一个Node节点时，我们需要传入三个参数，第一个参数就是当前节点的前驱节点，第二个就是节点的真实数据，第三个就是节点的后续节点。<br>了解完一个元素的具体数据结构，那么下面我们看看常用方法的具体实现：<br>1.add(E e)方法：add(E e)方法实际上调用的是linkLast(E e)方法，意思是把方法加到链表的最后。下面看看linkLast(E e)方法的具体实现：</p><p><img src="https://img-blog.csdnimg.cn/20181119130059300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FqMTUyMDE0MjY4OTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从代码中我们可以看到，代码中使用了变量first和last，这两个变量分别保存了当前链表第一个节点和最后一个节点的引用。在新增一个节点之前，首先把指向最后一个节点的引用（即变量 last）保存起来（即变量 l），然后新建一个节点，指定前驱节点是原来链表的最后一个节点，然后把指向最后一个节点的引用（last）指向新建的节点。紧接着就设置新建节点的前驱节点的后继节点指向新增的节点，最后把整个链表的总数加1，完成了新增一个节点的操作。完成新增后的链表结构类似如下：</p><p><img src="https://img-blog.csdnimg.cn/20181119130115227.png" alt="在这里插入图片描述"></p><h6 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public boolean add(E e)</td><td>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public void add(int index, E element)</td><td>向指定位置插入元素。</td></tr><tr><td>public boolean addAll(Collection c)</td><td>将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public boolean addAll(int index, Collection c)</td><td>将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public void addFirst(E e)</td><td>元素添加到头部。</td></tr><tr><td>public void addLast(E e)</td><td>元素添加到尾部。</td></tr><tr><td>public boolean offer(E e)</td><td>向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public boolean offerFirst(E e)</td><td>头部插入元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public boolean offerLast(E e)</td><td>尾部插入元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public void clear()</td><td>清空链表。</td></tr><tr><td>public E removeFirst()</td><td>删除并返回第一个元素。</td></tr><tr><td>public E removeLast()</td><td>删除并返回最后一个元素。</td></tr><tr><td>public boolean remove(Object o)</td><td>删除某一元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td>public E remove(int index)</td><td>删除指定位置的元素。</td></tr><tr><td>public E poll()</td><td>删除并返回第一个元素。</td></tr><tr><td>public E remove()</td><td>删除并返回第一个元素。</td></tr><tr><td>public boolean contains(Object o)</td><td>判断是否含有某一元素。</td></tr><tr><td>public E get(int index)</td><td>返回指定位置的元素。</td></tr><tr><td>public E getFirst()</td><td>返回第一个元素。</td></tr><tr><td>public E getLast()</td><td>返回最后一个元素。</td></tr><tr><td>public int indexOf(Object o)</td><td>查找指定元素从前往后第一次出现的索引。</td></tr><tr><td>public int lastIndexOf(Object o)</td><td>查找指定元素最后一次出现的索引。</td></tr><tr><td>public E peek()</td><td>返回第一个元素。</td></tr><tr><td>public E element()</td><td>返回第一个元素。</td></tr><tr><td>public E peekFirst()</td><td>返回头部元素。</td></tr><tr><td>public E peekLast()</td><td>返回尾部元素。</td></tr><tr><td>public E set(int index, E element)</td><td>设置指定位置的元素。</td></tr><tr><td>public Object clone()</td><td>克隆该列表。</td></tr><tr><td>public Iterator descendingIterator()</td><td>返回倒序迭代器。</td></tr><tr><td>public int size()</td><td>返回链表元素个数。</td></tr><tr><td>public ListIterator listIterator(int index)</td><td>返回从指定位置开始到末尾的迭代器。</td></tr><tr><td>public Object[] toArray()</td><td>返回一个由链表元素组成的数组。</td></tr><tr><td>public T[] toArray(T[] a)</td><td>返回一个由链表元素转换类型而成的数组。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//引入LinkedList类</span></span><br><span class="line">        LinkedList&lt;String&gt; lList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        lList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        lList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        lList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        lList.add(<span class="string">&quot;LinkedList&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链表元素个数</span></span><br><span class="line">        System.out.println(lList.size());</span><br><span class="line">        <span class="comment">//getFirst()方法获取头部元素</span></span><br><span class="line">        System.out.println(lList.getFirst()); <span class="comment">//hello</span></span><br><span class="line">        <span class="comment">//addFirst() 在头部添加元素</span></span><br><span class="line">        lList.addFirst(<span class="string">&quot;the&quot;</span>);  <span class="comment">//[the, hello, world, java, LinkedList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">//addLast() 在尾部添加元素</span></span><br><span class="line">        lList.addLast(<span class="string">&quot;ArrayList&quot;</span>); <span class="comment">//[the, hello, world, java, LinkedList, ArrayList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">// removeFirst() 移除头部元素</span></span><br><span class="line">        lList.removeFirst();  <span class="comment">// [hello, world, java, LinkedList, ArrayList]</span></span><br><span class="line">        <span class="comment">// set(int index, E element) 指定元素替换指定位置的元素</span></span><br><span class="line">        lList.set(<span class="number">1</span>,<span class="string">&quot;the&quot;</span>); <span class="comment">//[hello, the, java, LinkedList, ArrayList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">// add( int index,E element) 指定位置插入元素</span></span><br><span class="line">        lList.add(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>); <span class="comment">//[hello, the, world, java, LinkedList, ArrayList]</span></span><br><span class="line">        System.out.println(lList);</span><br><span class="line">        <span class="comment">// for-each 迭代元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;for-each 迭代元素:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : lList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="重要方法解析"><a href="#重要方法解析" class="headerlink" title="重要方法解析"></a>重要方法解析</h6><p> 添加方法-add(E e)</p><table><thead><tr><th>返回类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean</td><td>add(E e)</td><td>将指定的元素追加到此列表的末尾。</td></tr><tr><td>void</td><td>add(int index,E element)</td><td>在此列表中的指定位置插入指定的元素。</td></tr></tbody></table><p>（1）add()添加第一个元素(element &#x3D; 1),下面是测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        objects.add(<span class="number">1</span>);</span><br><span class="line">        objects.add(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>（2）把debug断点放在LinkedList这里，此时元素个数size &#x3D; 0，首节点first和尾节点last为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = &#123;LinkedList@<span class="number">522</span>&#125; <span class="string">&quot;[]&quot;</span></span><br><span class="line"> size = <span class="number">0</span></span><br><span class="line"> first = <span class="type">null</span></span><br><span class="line"> <span class="variable">last</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line"> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>（3）当debug执行到objects.add(1)时，Force Step Into强行进入源码，这里是做了一个装箱(int -&gt; Integer)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（4）Step Out跳出再Force Step Into进入就是add()方法，此方法最重要的一步就是linkLast(e)，e是待添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（5）跳入linkLast(e)方法，已知last &#x3D; null,于是把l &#x3D; null传入Node构造器，执行第二行代码final Node newNode &#x3D; new Node&lt;&gt;(l, e, null);跳入Node()构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（6）Node(上一个节点的引用prev，元素element，下一个节点的引用next)，已知l &#x3D; null,即Node(null, 1, null)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b6519086b91d461880a3ce6a336328b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>（7）new一个新的节点，newNode &#x3D; new Node&lt;&gt;(null, 1, null)，新节点的引用为LinkedList$Node@531，再把newNode赋给尾节点last,进入if(l &#x3D;&#x3D; null) 最后把newNode赋给首节点first，于是newNode、first、last同时指向这个节点，所以当只存在一个节点时，首节点就是尾节点<br><img src="https://img-blog.csdnimg.cn/887136daa3b74d8cbf59452ef67d8ffd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7b27836fd0fd4f0f99f9dc4bd20893da.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>此时前后指向依然为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newNode (slot_3) = &#123;LinkedList$Node@<span class="number">531</span>&#125; </span><br><span class="line"> item = &#123;Integer@<span class="number">530</span>&#125; <span class="number">1</span></span><br><span class="line">  value = <span class="number">1</span></span><br><span class="line"> next = <span class="type">null</span></span><br><span class="line"> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>（8）第一个元素添加完成，此时只存在一个节点，如果添加第二个元素就会形成双向链表，因为添加第二个元素底层又会创建一个节点，然后，此时底层通过改变两个节点的前后指向就能使两个节点连接起来形成双向链表</p><p><img src="https://img-blog.csdnimg.cn/0fd4e9ef03534a369a4cd62ab63b59e1.png" alt="在这里插入图片描述"></p><p>Debug信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = &#123;LinkedList@<span class="number">522</span>&#125; <span class="string">&quot;[1]&quot;</span></span><br><span class="line"> size = <span class="number">1</span></span><br><span class="line"> first = &#123;LinkedList$Node@<span class="number">531</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">530</span>&#125; <span class="number">1</span></span><br><span class="line">  next = <span class="type">null</span></span><br><span class="line">  <span class="variable">prev</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line"> <span class="variable">last</span> <span class="operator">=</span> &#123;LinkedList$Node@<span class="number">531</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">530</span>&#125; <span class="number">1</span></span><br><span class="line">  next = <span class="type">null</span></span><br><span class="line">  <span class="variable">prev</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line"> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>（8）添加第二个元素(element &#x3D; 8)</p><p><img src="https://img-blog.csdnimg.cn/5fa313fb43184443ae5f74a1813d616e.png" alt="在这里插入图片描述"></p><p>（9）这里我们直接看linkLast()方法的执行流程，此时last指向第一个节点，把last赋给new的第二个节点的prev，第二个节点就会指向第一个节点，再通过if判断，此时l不为空，于是把第二个节点的引用赋给第一个节点的next，于是第一个节点通过next指向第二个节点，双向链表形成</p><p><img src="https://img-blog.csdnimg.cn/59a59366daa24c3081405c27f6fae6fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>debug信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = &#123;LinkedList@<span class="number">522</span>&#125; <span class="string">&quot;[1, 8]&quot;</span></span><br><span class="line"> size = <span class="number">2</span></span><br><span class="line"> first = &#123;LinkedList$Node@<span class="number">530</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">551</span>&#125; <span class="number">1</span></span><br><span class="line">  next = &#123;LinkedList$Node@<span class="number">539</span>&#125; </span><br><span class="line">  prev = <span class="type">null</span></span><br><span class="line"> <span class="variable">last</span> <span class="operator">=</span> &#123;LinkedList$Node@<span class="number">539</span>&#125; </span><br><span class="line">  item = &#123;Integer@<span class="number">535</span>&#125; <span class="number">8</span></span><br><span class="line">  next = <span class="type">null</span></span><br><span class="line">  <span class="variable">prev</span> <span class="operator">=</span> &#123;LinkedList$Node@<span class="number">530</span>&#125; </span><br><span class="line"> modCount = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>通过linkLast()方法可以看到第二个节点的引用为newNode&#x3D; {LinkedList$Node@539}，在通过debug展示的信息可以得知，存放元素1(item &#x3D; 1)的第一个节点的next也指向了这个引用，因为暂时只有两个节点，所以首节点first指向第一个Node对象，尾节点last指向第二个节点，根据程序可得，第一个节点的prev在创建时就没有赋值，而第二个节点的next也为空是因为在创建节点对象时Node newNode &#x3D; new Node&lt;&gt;(l, e, null);next是默认为null的，通俗的理解就是这两个节点的前后都没有节点对象，自然不需要指向，故首节点prev &#x3D; null同时尾节点next &#x3D; null<br><img src="https://img-blog.csdnimg.cn/81de6c0e14b84b559634f121d3b95e77.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZHVydW53dTEyMw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> 删除方法-remove()</p><table><thead><tr><th>返回类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E</td><td><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/LinkedList.html#remove--">remove</a></strong>()</td><td>检索并删除此列表的头（第一个元素）。</td></tr><tr><td>E</td><td><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/LinkedList.html#remove-int-">remove</a></strong>(int index)</td><td>删除该列表中指定位置的元素。</td></tr><tr><td>boolean</td><td>remove(Object o)</td><td>从列表中删除指定元素的第一个出现（如果存在）。</td></tr></tbody></table><p>remove()默认删除首节点<br>（1）这里用无参的remove()进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       objects.add(<span class="number">1</span>);</span><br><span class="line">       objects.add(<span class="number">8</span>);</span><br><span class="line">       </span><br><span class="line">       objects.remove();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）remove()调了removeFirst()，让对象f指向first首节点，所以remove()无参方法删除的是首节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（3）unlinkFirst(Node f)方法是remove()删除首节点的核心方法，先取出首节点存储的数据item，然后f.next指向下一个节点，把数据置空，如果没有下一个节点就直接回收，first &#x3D; next(也就是first &#x3D; first.next)让first首节点指向下一个节点，将下一个节点的prev置空，最后返回之前取出的item,这套流程简单理解为让frist指向下一个节点，然后把原首节点全部置空，移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="literal">null</span>;</span><br><span class="line">        f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除方法，先循环遍历列表，找到item &#x3D;&#x3D; o 的节点，在调用unlink()方法删除</p></blockquote><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul><li>LinkedList是一个功能很强大的类，可以被当作List集合，双端队列和栈来使用。</li><li>LinkedList底层使用链表来保存集合中的元素，因此随机访问的性能较差，但是插入删除时性能非常的出色。</li><li>LinkedList在1.8版本有添加了一点新的内容，添加了一个static final 修饰的内部类LLSpliterator 并实现了Spliterator ，为了实现并行遍历而新添加的功能，整体的变化并不是很大，感兴趣的可以自己去看一下。</li></ul><h6 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h6><ol><li>从源码中很明显可以看出，LinkedList的实现是基于双向链表的，且头结点中不存放数据。</li><li>注意两个不同的构造方法。无参构造方法直接建立一个仅包含head节点的空链表，包含Collection的构造方法，先调用无参构造方法建立一个空链表，而后将Collection中的数据加入到链表的尾部后面。</li><li>在查找和删除某元素时，源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。</li><li>LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。</li><li>注意源码中的Entry<E> entry(int index)方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将index与长度size的一半比较，如果index&lt;size&#x2F;2，就只从位置0往后遍历到位置index处，而如果index&gt;size&#x2F;2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。</li><li>注意链表类对应的数据结构Entry。</li><li>LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。</li><li>要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。</li></ol><h6 id="ArrayList和LinkerList比较"><a href="#ArrayList和LinkerList比较" class="headerlink" title="ArrayList和LinkerList比较"></a>ArrayList和LinkerList比较</h6><table><thead><tr><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低<br />数组扩容</td><td>较高</td></tr><tr><td>LinkerList</td><td>双向链表</td><td>较高，通过链表追加</td><td>较低</td></tr></tbody></table><p>如何选择</p><ol><li>如果改查的操作较多，选择ArrayList</li><li>如果增删的操作较多，选择LinkedList</li><li>一般来说，程序中，80%~90%都是查询，因此大部分情况下会选择ArrayList</li><li>在一个项目中，更具业务灵活选择，也可以这样，一个模块使用的是ArrayList，另一个模块使用的是LinkedList</li></ol><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>HashSet简单的理解就是HashSet对象中不能存储相同的数据，存储数据时是无序的。但是HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。存储是无序的这就和C++里的Set就不一样了C++里面的Set是有序的我认为这是在使用时候的主要区别。下面就是HashSet简单的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; hsahset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>括号里面的类型是随你的需要更改的。</p><h6 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line"></span><br><span class="line">  java.util.AbstractCollection&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    java.util.AbstractSet&lt;E&gt;</span><br><span class="line"></span><br><span class="line">     java.util.HashSet&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/98602324bd7a926fec1131f75eb9f312.png" alt="img"></p><p>(1) HashSet继承于AbstractSet，并且实现了Set接口。</p><p>(2) HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。</p><h6 id="HashSet底层机制说明"><a href="#HashSet底层机制说明" class="headerlink" title="HashSet底层机制说明"></a>HashSet底层机制说明</h6><ul><li>HashSet 底层是HashMap，HashMap底层是(数组+链表+红黑树)</li></ul><h6 id="模拟简单数组-链表结构"><a href="#模拟简单数组-链表结构" class="headerlink" title="模拟简单数组+链表结构"></a>模拟简单数组+链表结构</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101150619880.png" alt="image-20221101150619880"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;john&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        table[<span class="number">2</span>] = john;</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        john.next = jack;</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Rose&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        jack.next = rose;</span><br><span class="line">​</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lucy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;lucy&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        table[<span class="number">3</span>] = lucy;</span><br><span class="line">        System.out.println(<span class="string">&quot;table=&quot;</span>+table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Object item; <span class="comment">//存放数据</span></span><br><span class="line">    Node next; <span class="comment">//指向下一个节点</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行结果为</span></span><br><span class="line">table=[Lcom.unfall.Collection_.Node;@4554617c</span><br></pre></td></tr></table></figure><h6 id="分析HashSet的添加元素底层是如何实现-hash-equals"><a href="#分析HashSet的添加元素底层是如何实现-hash-equals" class="headerlink" title="分析HashSet的添加元素底层是如何实现(hash()+equals())"></a>分析HashSet的添加元素底层是如何实现(<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>()+equals())</h6><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101150911044.png" alt="image-20221101150911044"></p><ol><li><p>HashSet 的底层是 HashMap</p></li><li><p>添加一个元素时，先得到hash值，会转成 -&gt; 索引值</p></li><li><p>找到存储数据表table，看这个索引位置是否已经存放了元素</p></li><li><p>如果没有存放，则直接添加</p></li><li><p>如果存放了，调用 equals() 比较，如果相同，就放弃添加，如果不相同，则添加到最后</p></li><li><p>在java8中，如果一条 链表 的元素个数 大于 TREEIFY_THRESHOLD（默认是8）(链表准备添加第九个的时候) ，并且 table 的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认是64），就会进行树化(红黑树)</p></li></ol><h6 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h6><table><thead><tr><th>类型</th><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>boolena</td><td>add(E e)</td><td>如果当前列表中不存在e，则将e加入列表</td></tr><tr><td>void</td><td>clear()</td><td>从列表中删除所有元素</td></tr><tr><td>boolean</td><td>contains(Object j)</td><td>判断列表中是否有元素j</td></tr><tr><td>Iterator<E></td><td>iterator()</td><td>得到当前列表的遍历器</td></tr><tr><td>boolean</td><td>remove(Object j)</td><td>如果列表中存在元素j,则将其从列表中删除</td></tr><tr><td>int</td><td>size()</td><td>得到列表中元素的个数</td></tr></tbody></table><p>add(E e)方法详解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet=&quot;</span>+hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">hashSet=[java,php]</span><br></pre></td></tr></table></figure><ol><li><p>执行 HashSet hashSet &#x3D; new HashSet();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 hashSet.add(“java”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="comment">//e = &quot;java&quot;</span></span><br><span class="line">    <span class="comment">//PRESENT -&gt; private static final Object PRESENT = new Object();</span></span><br><span class="line">    <span class="comment">//PRESENT的目的是为了占位</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 return map.put(e, PRESENT)&#x3D;&#x3D;null;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123; <span class="comment">//key = &quot;java&quot; value = PRESENT 共享</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先执行 hash(key)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再执行 return putVal(hash(key), key, value, false, true);</p><ol><li><p>transient Node&lt;K,V&gt;[] table; 和 Node&lt;K,V&gt;[] tab;</p></li><li><p>if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</p></li><li><p>table和tab是引用赋值，所以两者的地址相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义了辅助变量</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i; </span><br><span class="line">    <span class="comment">//table 就是HashMap的一个数组，类型是Node[]</span></span><br><span class="line">    <span class="comment">//transient Node&lt;K,V&gt;[] table;</span></span><br><span class="line">    <span class="comment">//if语句表示如果当前table是null或者tab的大小为0，则执行下面的语句</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//执行 resize()，创建了大小为16的table数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(1)根据key得到的hash值去计算该key应该存放到tab表的哪个索引位置</span></span><br><span class="line">    <span class="comment">//并且把这个位置的对象，赋给p</span></span><br><span class="line">    <span class="comment">//(2)判断p是否为null</span></span><br><span class="line">    <span class="comment">//(2.1)如果p为null，表示还没有存放元素，就创建一个Node(key=&quot;java&quot;,value=&quot;PRESENT&quot;)</span></span><br><span class="line">    <span class="comment">//(2.2)就放在该位置 tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/df371fb454db4f7c9bfbbec4359120eb.png"></p></li></ol></li><li><p>执行 hashSet.add(“php”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 return map.put(e, PRESENT)&#x3D;&#x3D;null;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先执行 hash(key)</p><ol><li>得到对应的hash值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再执行 return putVal(hash(key), key, value, false, true);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/d5eab1bf46e34aec824be1b0b427eac0.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56iL5bqP54y_6L-b5YyW54mI,size_20,color_FFFFFF,t_70,g_se,x_16"></p></li><li><p>执行 hashSet.add(“java”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 return map.put(e, PRESENT)&#x3D;&#x3D;null;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先执行 hash(key)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再执行 return putVal(hash(key), key, value, false, true);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果当前索引位置对应的链表的第一个元素的hash值和准备添加的key的hash值一样</span></span><br><span class="line">        <span class="comment">//并且满足下面两个条件之一：</span></span><br><span class="line">        <span class="comment">//(1)准备加入的key和p指向的Node节点的key是同一个对象</span></span><br><span class="line">        <span class="comment">//(2)p指向的Node节点的key的equals()方法和准备加入的key比较后相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; </span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//再判断p是不是一颗红黑树</span></span><br><span class="line">        <span class="comment">//如果是一颗红黑树，就调用putTreeVal，来进行添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果table对应的索引位置，已经是一个链表，就使用for循环比较</span></span><br><span class="line">               <span class="comment">//(1)依次和该链表的每一个元素比较后(从链表的第二个元素开始比较)，都不相同，则 </span></span><br><span class="line">               <span class="comment">//     加入到该链表的最后</span></span><br><span class="line">               <span class="comment">//   注意：在把元素添加到链表后，立即判断该链表是否已经到达8个节点,</span></span><br><span class="line">               <span class="comment">//   如果到达了8个节点，就调用 treeifyBin(tab, hash); 如果满足</span></span><br><span class="line">               <span class="comment">//   if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //64</span></span><br><span class="line">               <span class="comment">//       resize();，</span></span><br><span class="line">               <span class="comment">//   则先对table扩容；如果该if语句不满足，则对当前这个链表进行树化(转成红黑树)</span></span><br><span class="line">               <span class="comment">//(2)依次和该链表的每一个元素的比较过程中，如果有相同的情况，则直接break</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//TREEIFY_THRESHOLD = 8;</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="分析HashSet的扩容和转成红黑树的机制"><a href="#分析HashSet的扩容和转成红黑树的机制" class="headerlink" title="分析HashSet的扩容和转成红黑树的机制"></a>分析HashSet的扩容和转成红黑树的机制</h6><ol><li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值(threshold)是 16*加载因子(loadFactor)是0.75 &#x3D; 12</li><li>如果table数组使用到了临界值12，就会扩容到 16 * 2 &#x3D; 32，新的临界值就是 32 * 0.75 &#x3D; 24</li><li>在java8中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8)，并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认是64），就会进行树化(转成红黑树)，否则仍然采用数组扩容机制。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">A</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet=&quot;</span>+hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line">hashSet=[demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>, demo.A<span class="meta">@c8</span>]</span><br></pre></td></tr></table></figure><ul><li><p>执行 hashSet.add(new A(1)); 时，数组的大小扩容到16</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164024174.png" alt="image-20221101164024174"></p></li><li><p>执行 hashSet.add(new A(9)); 时，数组的大小扩容到32</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164052223.png" alt="image-20221101164052223"></p></li><li><p>执行 hashSet.add(new A(10)); 时，数组的大小扩容到64</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164131906.png" alt="image-20221101164131906"></p></li><li><p>执行 hashSet.add(new A(11)); 时，将该链表进行树化(转成红黑树)</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164152038.png" alt="image-20221101164152038"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">A</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">B</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无论是在table数组上还是在链表上加入元素，size都会加1，size(元素的个数)的大小大于临界值后，就会对数组进行扩容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><ul><li><p>执行到 hashSet.add(new A(1)); 时，数组的大小扩容到16</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164713998.png" alt="image-20221101164713998"></p></li><li><p>执行到 hashSet.add(new B(6)); 时，数组的大小扩容到32</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221101164735506.png" alt="image-20221101164735506"></p></li></ul><h6 id="实现总结"><a href="#实现总结" class="headerlink" title="实现总结"></a>实现总结</h6><p>HashSet实现原理进行一个总结：<br>（1）基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p><p>（2）当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。</p><p>（3）HashSet的其他操作都是基于HashMap的。</p><h6 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的无参构造器，构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定collection中的元素的新set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层使用默认的加载因子0.75和足以包含指定</span></span><br><span class="line"><span class="comment">     * collection中所有元素的初始容量来创建一个HashMap。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数构造一个空的HashMap。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</span></span><br><span class="line"><span class="comment">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy 标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用底层HashMap的keySet来返回所有的key。</span></span><br><span class="line"><span class="comment">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上，</span></span><br><span class="line"><span class="comment">     * value使用一个static final的Object对象标识。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对此set中元素进行迭代的Iterator。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此set中的元素的数量（set的容量）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e))</span></span><br><span class="line"><span class="comment">     * 的e元素时，返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的containsKey判断是否包含指定key。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set中尚未包含指定元素，则添加指定元素。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2))</span></span><br><span class="line"><span class="comment">     * 的元素e2，则向此set 添加指定的元素e。</span></span><br><span class="line"><span class="comment">     * 如果此set已包含该元素，则该调用不更改set并返回false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际将将该元素作为key放入HashMap。</span></span><br><span class="line"><span class="comment">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key</span></span><br><span class="line"><span class="comment">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true），</span></span><br><span class="line"><span class="comment">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变，</span></span><br><span class="line"><span class="comment">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中，</span></span><br><span class="line"><span class="comment">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 将添加到此set中的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果指定元素存在于此set中，则将其移除。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e，</span></span><br><span class="line"><span class="comment">     * 则将其移除。如果此set已包含该元素，则返回true</span></span><br><span class="line"><span class="comment">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的remove方法删除指定Entry。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此set中移除所有元素。此调用返回后，该set将为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h6><ol><li><p>用Iterator来遍历</p><ol><li>&#96;&#96;&#96;java1<br>Iterao<String> iterator &#x3D; hashSet.iterator();<br>while(iterator.hasNext()){<br>System.out.println(iterator.next()+” “);<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 这是比较常用的方法， 但是这种方法在使用的时候HashSet修改一次之后如果想再次遍历，必须重新申请Iterator,否则        无法遍历，但是把Itetator放在一个函数里， 那么就省去多次申请Iterator了。</span><br><span class="line"></span><br><span class="line">2. 增强for循环遍历</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      for(Objrct o : hashset)&#123;</span><br><span class="line">      System.out.println(o);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><p>简单试用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.java.text.Main;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main4</span> &#123;<span class="comment">//HashSet</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        String aString;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        aString = ip.next();</span><br><span class="line">        hashSet.add(aString);<span class="comment">//加入列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = hashSet.iterator();<span class="comment">//遍历器</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())System.out.print(iterator.next()+<span class="string">&quot; &quot;</span>);<span class="comment">//判断是否有，有就输出</span></span><br><span class="line">        String bString;</span><br><span class="line">        bString =  ip.next();</span><br><span class="line">        hashSet.remove(bString);<span class="comment">//删除</span></span><br><span class="line">        <span class="comment">/*Iterator iterator2 = hashSet.iterator();</span></span><br><span class="line"><span class="comment">        while(iterator2.hasNext()) &#123;//遍历器遍历</span></span><br><span class="line"><span class="comment">        System.out.print(iterator2.next()+&quot;  &quot;);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(String string: hashSet)System.out.print(string + <span class="string">&quot; &quot;</span>);<span class="comment">//for循环遍历</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>LinkedHashSet是一个 Set 的实现，它其中存的不是键值对，而是值。此实现与 HashSet 的不同之处在于，LinkedHashSet 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</p><ol><li>LinkedHashSet是HashSet的子类</li><li>LinkedHashSet底层是一个LinkedHashMap（hashmap的子类），底层维护了一个数组+双向链表</li><li>LinkedHashSet根据元素的hashcode值来决定元素的存储位置，同时使用链表维护元素的次序码，这使得元素看起来是以插入顺序保存的</li><li>LinkedHashSet不允许添加重复元素</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221103112727961.png" alt="image-20221103112727961"></p><p>说明：</p><ol><li>在linkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail)</li><li>每一个节点有before和after属性，这样可以形成双向链表</li><li>在添加一个元素时，先求hash值，再求索引，确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在(equals比较），不添加【原则和hashset一样])</li><li>这样的话，我们遍历linkedhashset也能确保插入顺序和遍历顺序一样</li><li>数组是hashMap[]类型 存放的元素&#x2F;数据是LinkedHashMap$Entry类型（数组多态）</li></ol><h6 id="LinkedHashSet实现"><a href="#LinkedHashSet实现" class="headerlink" title="LinkedHashSet实现"></a>LinkedHashSet实现</h6><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p><p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。LinkedHashSet 的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个带有指定初始容量和加载因子的新空链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个与指定collection中的元素相同的新链接哈希set。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层会调用父类的构造方法，构造一个足以包含指定collection</span></span><br><span class="line"><span class="comment">     * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上几乎就是 LinkedHashSet 的全部代码了，不是说 LinkedHashSet 是基于 LinkedHashMap 实现的吗？那为什么在源码中甚至都没有看到出现过 LinkedHashMap。</p><p>可以看到在 LinkedHashSet 的构造方法中，其调用了父类的构造方法。可以看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</span></span><br><span class="line"><span class="comment">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy 标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父类 HashSet 中，专为 LinkedHashSet 提供的构造方法如上，该方法为包访问权限，并未对外公开。</p><p>由上述源代码可见，LinkedHashSet 通过继承 HashSet，底层使用 LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能</p><h6 id="LinkedHashSet的源码解读"><a href="#LinkedHashSet的源码解读" class="headerlink" title="LinkedHashSet的源码解读"></a>LinkedHashSet的源码解读</h6><ul><li>LinkedHashSet 中维护了一个hash表和双向链表（LinkedHashSet 有 head 和 tail）</li><li>每一个节点都有 before 和 after 属性，这样可以形成双向链表</li><li>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和HashSet一样]）</li><li>这样的话，我们遍历LinkedHashSet 也能确保插入顺序和遍历顺序一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lhashset_</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">LinkedHashSet</span> <span class="variable">lhs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">13</span>));</span><br><span class="line">        lhs.add(<span class="keyword">new</span> <span class="title class_">cus</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">14</span>));</span><br><span class="line">        System.out.println( <span class="string">&quot;lhs =&quot;</span> + lhs );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cus</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">cus</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\ncus&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">cus</span> <span class="variable">cus</span> <span class="operator">=</span> (cus) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span>= cus.num &amp;&amp; Objects.equals(name, cus.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">lhs =[</span><br><span class="line">cus&#123;name=<span class="string">&#x27;张三&#x27;</span>, num=<span class="number">12</span>&#125;, </span><br><span class="line">cus&#123;name=<span class="string">&#x27;李四&#x27;</span>, num=<span class="number">13</span>&#125;, </span><br><span class="line">cus&#123;name=<span class="string">&#x27;王五&#x27;</span>, num=<span class="number">14</span>&#125;]</span><br></pre></td></tr></table></figure><blockquote><p>LinkedHashSet 集合添加和取出元素的顺序一致</p></blockquote><h6 id="LinkHashSet原理"><a href="#LinkHashSet原理" class="headerlink" title="LinkHashSet原理"></a>LinkHashSet原理</h6><ol><li>LinkedHashSet是HashSet的子类；</li><li>底层是节点数组加双向链表；</li><li>由于是双向链表，底层是LinkedHashMap，且底层机制是一个Entey后继是另一个Entey，所以导致输出是有序的；</li><li>同样不允许添加相同元素。</li><li>HashSet中 HashMap的元素数据类型是Node, 静态Node&lt;K,V&gt;类实现了Map接口，重写出属性Node&lt;K,V&gt; next(后继)，没有前驱；但由于LinkedHashSet类是双链表，所以这时候LinkedHashSet类构造自己的静态内部类Entry类，它继承于 HashMap的Node类，但是它有自己的属性before（前驱）和after（后继），数组类型仍然是节点Node，但是节点数组元素数据类型是LinkedHashSet类内部类Entry数据类型，相当于多态存储机制;</li><li>（LinkedHashMap的静态Entry内部类继承了HashMap的静态Node&lt;K,V&gt;类，并且重写加入自己的自己的属性before（前驱）和after（后继）</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221103151105260.png" alt="image-20221103151105260"></p><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><ul><li>LinkedHashSet 是 Set 的一个具体实现，其维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</li><li>LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的（具体的区别大家可以自己去思考一下）。</li><li>如果我们需要迭代的顺序为插入顺序或者访问顺序，那么 LinkedHashSet 是需要你首先考虑的。</li></ul><h6 id="说说你对-LinkedHashSet-的理解及其与-HashSet-的关系？"><a href="#说说你对-LinkedHashSet-的理解及其与-HashSet-的关系？" class="headerlink" title="说说你对 LinkedHashSet 的理解及其与 HashSet 的关系？"></a>说说你对 LinkedHashSet 的理解及其与 HashSet 的关系？</h6><p>答：<strong>LinkedHashSet 是可以按照插入顺序或者访问顺序进行迭代的非并发安全 Set，</strong>其继承自 HashSet，而 HashSet 又专门提供了一个包访问权限的构造方法给 LinkedHashSet 使用，这个构造方法内部基于 LinkedHashMap 来实现，而普通的 HashSet 则是基于 HashMap 来实现，所以可以说 <strong>LinkedHashSet 底层使用  LinkedHashMap 来保存所有元素，其所有的操作方法与 HashSet 相同，故而 LinkedHashSet 的实现源码非常简单，仅仅只是实现了构造操作等。</strong></p><p><strong>LinkedHashSet 与 HashSet 的不同之处在于 LinkedHashSet 依靠 LinkedHashMap 维护着一个顺序链表结构用来迭代，而 HashSet 依靠 HashMap 维持着一个简单的哈希表存储访问；此外 LinkedHashSet 与 HashSet 没有任何区别，都支持元素为 null，都是非并发安全 Set。</strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><p>TreeSet 是一个有序的集合，它的作用是提供有序的 Set 集合。它继承于 AbstractSet 抽象类，实现了 NavigableSet<E>, Cloneable, java.io.Serializable 接口。<br>TreeSet 继承于 AbstractSet，所以它是一个 Set 集合，具有 Set 的属性和方法。<br>TreeSet 实现了 NavigableSet 接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br>TreeSet 实现了 Cloneable 接口，意味着它能被克隆。<br>TreeSet 实现了 java.io.Serializable 接口，意味着它支持序列化。</p><p>TreeSet 是基于 TreeMap 实现的。TreeSet 中的元素支持 2 种排序方式：<strong>自然排序</strong> 或者 根据创建 TreeSet 时提供的 <strong>Comparator</strong> 进行排序。这取决于使用的构造方法。<br>TreeSet 为基本操作（add、remove 和 contains）提供受保证的 log (n) 时间开销。<br>另外，TreeSet 是非同步的。 它的 iterator 方法返回的迭代器是 fail-fast 的。</p><h5 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h5><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/dd5eefebe83a646310128ee7548862cc.png"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p> 有序，不重复；key不能为空，value可以为null（总结一点：凡是有Tree的集合，都是有序的，凡是有Set的就是不重复的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个TreeSet：</span></span><br><span class="line">        TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        ts.add(<span class="number">12</span>);</span><br><span class="line">        ts.add(<span class="number">89</span>);</span><br><span class="line">        ts.add(<span class="number">1</span>);</span><br><span class="line">        ts.add(<span class="number">33</span>);</span><br><span class="line">        ts.add(<span class="number">89</span>);</span><br><span class="line">        ts.add(<span class="number">33</span>);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">        System.out.println(ts);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*结果依旧具有：唯一性*/</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12</span>, <span class="number">33</span>, <span class="number">89</span>]<span class="comment">//升序排序</span></span><br></pre></td></tr></table></figure><p>由结果可以直观的发现TreeSet的结果仍然是唯一的，重复的数据不能再次放入集合中；<br>另外也不难发现，打印顺序也同样不按照添加顺序，但再仔细发现，和HashSet不一样的是，TreeSet的打印结果是升序排序的。<br>所以既可以说TreeSet无序（不按照输入顺序进行输出），也可以说其有序（按照升序顺序进行遍历）。</p><h5 id="TreeSet的有序的实现"><a href="#TreeSet的有序的实现" class="headerlink" title="TreeSet的有序的实现"></a>TreeSet的有序的实现</h5><p>TreeSet 底层的数据结构使用的是<strong>二叉树</strong></p><p>TreeSet 中的元素支持 2 种排序方式：<strong>自然排序</strong> 或者 根据创建 TreeSet 时提供的构造方法  <strong>Comparator</strong> 进行排序</p><h6 id="自然排序（Comparable）"><a href="#自然排序（Comparable）" class="headerlink" title="自然排序（Comparable）"></a>自然排序（Comparable）</h6><ul><li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li><li>调用对象的compareTo()方法和集合中的对象比较</li><li>根据compareTo()方法返回的结果进行存储</li></ul><h6 id="构造方法比较器排序（Comparator）"><a href="#构造方法比较器排序（Comparator）" class="headerlink" title="构造方法比较器排序（Comparator）"></a>构造方法比较器排序（Comparator）</h6><ul><li>创建TreeSet的时候可以制定 一个Comparator</li><li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li><li>add()方法内部会自动调用Comparator接口中compare()方法排序</li><li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li></ul><table><thead><tr><th align="left">构造方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">TreeSet （)</td><td>此构造函数构造空树集，将在根据其元素的自然顺序按升序排序。</td></tr><tr><td align="left">TreeSet (集合 c)</td><td>此构造函数生成树的集合，它包含的元素的集合 c。</td></tr><tr><td align="left">TreeSet (比较器 comp)</td><td>此构造函数构造一个空树集，将根据给定的比较器进行排序。</td></tr><tr><td align="left">TreeSet (SortedSet ss)</td><td>此构造函数生成包含给定 SortedSet 的元素 TreeSet</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个外部比较器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//return ((String) o1).length() - ((String)o2).length();</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).compareTo((String) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//利用外部比较器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        TreeSet treeSet = new TreeSet();</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">cmp</span>());</span><br><span class="line"></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;jck&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;ck&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;ck&quot;</span>);   </span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;Treeset =&quot;</span> + treeSet );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*结果出现唯一性和有序性了*/</span></span><br><span class="line"></span><br><span class="line">Treeset =[a, ck, jack, jck]</span><br></pre></td></tr></table></figure><h6 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h6><table><thead><tr><th align="left">修饰符和类型</th><th>方法和描述</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td><code>**add**(E e)</code>将指定的元素添加到这套，如果它已不存在。</td></tr><tr><td align="left"><code>E</code></td><td><code>**first**()</code>返回第一个 （最低） 元素当前在这一套。</td></tr><tr><td align="left"><code>E</code></td><td><code>**last**()</code>在这套目前返回的最后一个 （最高） 的元素</td></tr><tr><td align="left"><code>void</code></td><td><code>**clear**()</code>从这一组中移除所有元素。</td></tr><tr><td align="left"><code>**int**</code></td><td><code>**size**()</code>在这套 （其基数） 中返回的元素的数目。</td></tr></tbody></table><h4 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h4><ol><li>List集合存储的数据有序可以重复，Set集合存储的数据无序不可以重复。</li><li>List是一个有序的容器，可以保证每一个插入元素的顺序，输出顺序就是输入顺序。</li><li>List可以插入多个null值，而Set只能插入一个null值。</li></ol><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="map介绍"><a href="#map介绍" class="headerlink" title="map介绍"></a>map介绍</h4><p> Map集合和Collection集合没有任何关系。Collection集合是以单个方式存储元素的，而Map集合是以键值对的方式存储元素，所有Map集合的Key是无序不可重复的，key和value都是引用数据类型，存的都是内存的地址。</p><p> Map集合的实现类主要为HashMap、HashTable。子接口有一个SortedMap，SortedMap有一个TreeMap实现类。</p><h4 id="Map接口实现类的特点"><a href="#Map接口实现类的特点" class="headerlink" title="Map接口实现类的特点"></a>Map接口实现类的特点</h4><p>注意:<br>这里讲的是JDK8的Map接口特点</p><ol><li>Map 与 Collection 并列存在。用于保存具有映射关系的数据: Key-Value</li><li>Map 中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中</li><li>Map 中的 key 不允许重复，原因和 HashSet 一样，前面博文中分析过源码.</li><li>Map 中的 value 可以重复</li><li>Map 的 key 可以为 null , value 也可以为 null ,注意 key 为 null ,只能有一个，</li><li>value为null ,可以多个.</li><li>常用 String 类作为 Map 的 key</li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</li></ol><h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object put(Object key,Object value)</td><td>存放键值对。</td></tr><tr><td>Object get(Object key)</td><td>通过键对象查找得到值对象</td></tr><tr><td>Object remove(Object key)</td><td>删除键对象对应得键值对</td></tr><tr><td>boolean containsKey(Object key)</td><td>Map容器中是否包含键对象对应的键值对</td></tr><tr><td>boolean conrainsValue(Object value)</td><td>Mao容器中是否包含值对象对应得键值对</td></tr><tr><td>int size()</td><td>包含键值对得数量</td></tr><tr><td>boolean isEmpty()</td><td>Map是否为空</td></tr><tr><td>void putAll(Map t)</td><td>将t的所有键值对存放到本Map对象</td></tr><tr><td>void clear()</td><td>清空本Map对象所有的键值对</td></tr></tbody></table><h4 id="集合继承图"><a href="#集合继承图" class="headerlink" title="集合继承图"></a>集合继承图</h4><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/b35c014aebcc4b44be80d82df6706782.png" alt="在这里插入图片描述"></p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><blockquote><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>HashMap是Java程序员使用最频繁的的用于键值对(key value)数据处理的容器，在JDK1.7(Java Developmet Kit）时HashMap采取的是数组+链表的形式存储数据，JDK1.8对HashMap进行了存储结构上的优化，引入了红黑树数据结构，极大的增强了HashMap的存取性能！为什么会引入红黑树呢？因为HashMap存在一个问题，即使负载因子和Hash算法设计的再合理，也无法避免出现在链表上拉链过长的问题，如果极端情况下出现严重的Hash冲突，会严重影响HashMap的存取性能，于是HashMap在jdk1.8时，引入了红黑树，利用红黑树快速增删改查的特点来优化了HashMap的性能！</p></blockquote><h5 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a><strong>什么是哈希表</strong></h5><p>在讨论哈希表之前，我们先大概了解下其他<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>在新增，查找等基础操作执行性能</p><p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p><strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下（后面会探讨下哈希冲突的情况），仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p><strong>比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</strong><br>　　<br>这个函数可以简单描述为：<strong>存储位置 &#x3D; f(关键字)</strong> ，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：<br>插入过程如下图所示<br><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2018110221063296.png" alt="哈希表数据插入过程"></p><p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><h5 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h5><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="comment">//至于为什么这么做，后面会有详细分析。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>Entry是HashMap中的一个静态内部类。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="type">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102221702492.png" alt="在这里插入图片描述"></p><p>简单来说，<strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好。</strong></p><p>其他几个重要字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**实际存储的key-value键值对的个数*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，</span></span><br><span class="line"><span class="comment">threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到*/</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="comment">加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。</span></span><br><span class="line"><span class="comment">所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span></span><br><span class="line"><span class="comment">如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span></span><br><span class="line"><span class="comment">需要抛出异常ConcurrentModificationException*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>看下其中一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">　　　　　<span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();<span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），<strong>而是在执行put操作的时候才真正构建table数组</strong></p><h6 id="put操作的实现"><a href="#put操作的实现" class="headerlink" title="put操作的实现"></a>put操作的实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，</span></span><br><span class="line">        <span class="comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一步首先将k,v封装到Node对象当中（节点）。第二步它的底层会调用K的hashCode()方法得出hash值。第三步通过哈希表函数&#x2F;哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。</p><p>java1.8 中put 源码：put 中调用 putVal（）方法：</p><p>1.首先判断map中是否有数据，没有就执行resize方法</p><p>2.如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上即可</p><p>3.如果这个元素的key与要插入的一样，那么就替换一下。</p><p>4.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</p><p>5.遍历这条链子上的数据，完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法</p><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize&#x3D;13,则capacity&#x3D;16;to_size&#x3D;16,capacity&#x3D;16;to_size&#x3D;17,capacity&#x3D;32.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);<span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">        <span class="comment">/**此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span></span><br><span class="line"><span class="comment">        capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 */</span></span><br><span class="line">        threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">       <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="map-get-k-实现原理"><a href="#map-get-k-实现原理" class="headerlink" title="map.get(k)实现原理"></a>map.get(k)实现原理</h6><p>第一步：先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。第二步：通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。</p><h6 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a><a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**这是一个神奇的函数，用了很多的异或，移位等运算</span></span><br><span class="line"><span class="comment">对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1&#x3D;15，h&#x3D;18,转换成二进制计算为index&#x3D;2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p><p>所以最终存储位置的确定流程是这样的：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102214046362.png" alt="HashMap如何确定元素位置"></p><h6 id="addEntry的实现"><a href="#addEntry的实现" class="headerlink" title="addEntry的实现"></a>addEntry的实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上代码能够得知，<strong>当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</strong></p><h5 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h5><h6 id="什么时候才需要扩容"><a href="#什么时候才需要扩容" class="headerlink" title="什么时候才需要扩容"></a>什么时候才需要扩容</h6><ul><li>在首次调用put方法的时候，初始化数组table</li><li>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75&#x3D;12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</li><li>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</li></ul><h6 id="hashMap扩容"><a href="#hashMap扩容" class="headerlink" title="hashMap扩容"></a>hashMap扩容</h6><p>扩容就是重新计算容量，向hashMap不停的添加元素，当hashMap无法装载新的元素，对象将需要扩大数组容量，以便装入更多的元素。</p><p>haspMap扩容跟数据迁移具有很大的关联，我们先用图解的方式来说明数据迁移.</p><p>进行扩容前先介绍一些hahMap源码的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="literal">null</span>,  loTail = <span class="literal">null</span>;   <span class="comment">//低位链表的头尾结点</span></span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;    <span class="comment">//高位链表的头尾结点</span></span><br><span class="line">Node&lt;K,V&gt; next;  <span class="comment">//next指针 指向下一个元素</span></span><br></pre></td></tr></table></figure><p>迁移前: 这里将其设置为长度为 8，扩容临界点 8 * 0.75 &#x3D; 6 主要是为了画图 （hashMap默认容量是16）<br>以下讲解都是基于数组容量为 8 讲解的，流程都是一样的.</p><p>从图可知，发生了扩容并且是2的次方，并且 A，B,C两元素新的位置刚好是原数组位置的索引位置，D,E，F刚好在原数组位置索引 + 8 即原数组位置索引+数组容量。是不是真的是这样呢？？，这时需要看源码分析一波</p><p>流程讲解<br>刚开始进行第一次扩容的时候，得到A的index索引为4，put进数组中，hashMap先会将A的hash进行 &amp; oldCap（8） 运算，判断是否 &#x3D;&#x3D;0，如果为true,则代表为低位链表，这里涉及到二进制运算，比如A的index &#x3D;4 (二进制 &#x3D; 0000 0100) oldCap &#x3D; 8(二进制&#x3D;0000 1000) &amp;运算之后 &#x3D;0，后4位为低位，当然hash肯定不是8个bit位，hashCode得到索引值为int类型，一个int类型占4个字节，一个字节占8个bit位，所以hash二进制所占bit为 32，后4位为低位，高位远远多于低位，所以这也是put操作的时候需要将高位参与进来，减少hasp冲突。（这是put流程，put详情操作请看我另一篇博客）</p><p>言归正传，当A进行判断后,会将 loHead和loTail赋值给A，此时链表只有A元素，当循环到第二次迁移后，也就是将B元素进行迁移 B进行 &amp;运算之后，同样为true，所以加入低位链表，而此时链表中有A元素，所以讲A链表的尾结点.next指向B元素即可，同理C也是一样，添加到B尾结点下面，直到添加完所有元素，当添加D元素时，因为D元素的hash为12, 进行 &amp; 运算时为false ，则代表添加到高位链表，此时 hiHead和 hiTail指向D 之后流程都是一样的。当结束循环之后，低位链表的元素将会以原数组下标索引添加到新数组中，但是高位链表的元素会将原数组的下标索引 + oldCap添加到新数组，并且低位高位都会讲原先的数组设置为null ,方便gc</p><p>源码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;  <span class="comment">//数组容量（旧）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold; <span class="comment">//扩容临界点(旧)</span></span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//数组容量（新）、扩容临界点(新)</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧容量大于等于了最大的容量 2^30</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">//将临界值设置为Integer.MAX_VALUE</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扩容2倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 新阈值设置2倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// HashMap(int initialCapacity, float loadFactor)调用</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 第一次put操作的时候，因为jdk1.8hashMap先添加元素再扩容</span></span><br><span class="line">        <span class="comment">//构造函数将jdk1.7的扩容移动到这</span></span><br><span class="line">                    newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//默认容量 16</span></span><br><span class="line">                    <span class="comment">//临界值 16 *0.75 =12</span></span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新阈值为0，根据负载因子设置新阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;如果旧的数组中有数据，循环</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123; </span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>; <span class="comment">//gc处理</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//只有一个节点，赋值，返回</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是否为红黑树结点</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">//低位链表</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;  <span class="comment">//高位链表</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next; <span class="comment">//指向下个元素结点，做为while循环的条件</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//判断是否为低位链表</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)  <span class="comment">//链表没有元素，则将该元素作为头结点</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e; <span class="comment">//加在链表的下方</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123; &#123;<span class="comment">//不为0，元素位置在扩容后数组中的位置发生了改变，新的下</span></span><br><span class="line"><span class="comment">//标位置是（原下标位置+原数组长）</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//遍历完成后，进行数据迁移</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//链表最后</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将元素原位置迁移到新数组中，位置一样</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//高位链表迁移 + 旧数组容量</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结（扩容与迁移）：<br>1、扩容就是将旧表的数据迁移到新表<br>2、迁移过去的值需要重新计算hashCode，也就是他的存储位置<br>3、关于位置可以这样理解：比如旧表的长度8、新表长度16<br>旧表位置4有6个数据，假如前三个hashCode是一样的，后面的三个hashCode是一样的迁移的时候；就需要计算这6个值的存储位置<br>4、如何计算位置？采用低位链表和高位链表；如果位置4下面的数据e.hash &amp; oldCap等于0，那么它对应的就是低位链表，也就是数据位置不变,e.hash &amp; oldCap不等于0呢?就要重写计算他的位置也就是j + oldCap（4+8）；这个12，就是高位链表位置（新数组12位置）</p><h5 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a><strong>为何HashMap的数组长度一定是2的次幂？</strong></h5><p>HashMap的扩容公式：initailCapacity * loadFactor &#x3D; HashMap</p><p>其中initailCapacity是初始容量：默认值为16（懒加载机制，只有当第一次put的时候才创建）</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210708153056800.png" alt="在这里插入图片描述"><br>其中loadFactor是负载因子：默认值为0.75</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210708153021614.png" alt="在这里插入图片描述"></p><p>我们来继续看上面提到的resize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果数组进行扩容，数组长度发生变化，而存储位置 index &#x3D; h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">　　　　　<span class="comment">//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102223343298.png" alt="在这里插入图片描述"></p><p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181102223421180.png" alt="在这里插入图片描述"><br>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index&#x3D;21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。<br><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2018110222343145.png" alt="在这里插入图片描述"><br>如果不是2的次幂，也就是低位不是全为1此时，要使得index&#x3D;21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><p><strong>get方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">　　　　 <span class="comment">//如果key为null,则直接去table[0]处去检索即可。</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       <span class="type">return</span> <span class="variable">null</span> <span class="operator">=</span>= entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="literal">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash &#x3D;&#x3D; hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><h5 id="重写equals方法需同时重写hashCode方法"><a href="#重写equals方法需同时重写hashCode方法" class="headerlink" title="重写equals方法需同时重写hashCode方法"></a><strong>重写equals方法需同时重写hashCode方法</strong></h5><p>最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="type">int</span> idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> idCard, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.idCard = idCard;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="comment">//两个对象是否等值，通过idCard来确定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Person, String&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1234</span>,<span class="string">&quot;乔峰&quot;</span>);</span><br><span class="line">        <span class="comment">//put到hashmap中去</span></span><br><span class="line">        map.put(person,<span class="string">&quot;天龙八部&quot;</span>);</span><br><span class="line">        <span class="comment">//get取出，从逻辑上讲应该能输出“天龙八部”</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果:&quot;</span>+map.get(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1234</span>,<span class="string">&quot;萧峰&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际输出结果：<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p><h5 id="JDK1-8中HashMap的性能优化"><a href="#JDK1-8中HashMap的性能优化" class="headerlink" title="JDK1.8中HashMap的性能优化"></a><strong>JDK1.8中HashMap的性能优化</strong></h5><p>假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？<br>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。<br>关于这方面的探讨我们以后的文章再做说明。<br><strong>附：HashMap put方法逻辑图（JDK1.8）</strong><br><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20181105181728652.png" alt="在这里插入图片描述"></p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>HashTable类中，保存实际数据的，依然是Entry对象。其数据结构与HashMap是相同的。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20190313104521294.png" alt="在这里插入图片描述"></p><p>HashTable类继承自Dictionary类，实现了三个接口，分别是Map，Cloneable和java.io.Serializable，如下图所示。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20190313104529714.png" alt="在这里插入图片描述"></p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。</p><p>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。</p><p>Hashtable中的映射不是有序的。</p><p>Hashtable采用”拉链法”实现哈希表。</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表</span></span><br><span class="line"><span class="comment"> * 的&quot;key-value键值对&quot;都是存储在Entry数组中的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，容量为11，加载因子为0.75。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定初始容量和指定加载因子构造一个新的空哈希表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个与给定的 Map 具有相同映射关系的新哈希表。</span></span><br><span class="line"><span class="comment"> * 设置table容器大小，其值==t.size * 2 + 1   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h6><p>put方法的主要逻辑如下：<br>先获取synchronized锁。<br>put方法不允许null值，如果发现是null，则直接抛出异常。<br>计算key的哈希值和index<br>遍历对应位置的链表，如果发现已经存在相同的hash和key，则更新value，并返回旧值。<br>如果不存在相同的key的Entry节点，则调用addEntry方法增加节点。<br>addEntry方法中，如果需要则进行扩容，之后添加新节点到链表头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">​</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            rehash();</span><br><span class="line">​</span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h6><p>get方法的主要逻辑如下<br>先获取synchronized锁。<br>计算key的哈希值和index。<br>在对应位置的链表中寻找具有相同hash和key的节点，返回节点的value。<br>如果遍历结束都没有找到节点，则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="rehash扩容方法"><a href="#rehash扩容方法" class="headerlink" title="rehash扩容方法"></a><strong>rehash扩容方法</strong></h6><p>rehash扩容方法主要逻辑如下：<br>数组长度增加一倍（如果超过上限，则设置成上限值）。<br>更新哈希表的扩容门限值。<br>遍历旧表中的节点，计算在新表中的index，插入到对应位置链表的头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line">​</span><br><span class="line">        modCount++;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        table = newMap;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line">​</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h6><p>remove方法主要逻辑如下：<br>先获取synchronized锁。<br>计算key的哈希值和index。<br>遍历对应位置的链表，寻找待删除节点，如果存在，用e表示待删除节点，pre表示前驱节点。如果不存在，返回null。<br>更新前驱节点的next，指向e的next。返回待删除节点的value值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="literal">null</span> ; e != <span class="literal">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">//        hashtable.put(null,1);  //NullPointerException</span></span><br><span class="line"><span class="comment">//        hashtable.put(1,null); //NullPointerException</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack1&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack2&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack3&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack4&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack5&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack6&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;Jack7&quot;</span>,<span class="number">2</span>);  <span class="comment">//替换</span></span><br><span class="line">​</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.底层有数组 Hashtable$Entry[] 初始化大小为 11</span></span><br><span class="line"><span class="comment">2.临界值 threshold 8 = 11 * 0.75</span></span><br><span class="line"><span class="comment">3.扩容： 按照自己的扩容机制来进行即可</span></span><br><span class="line"><span class="comment">4.执行方法 addEntry(hash, key, value, index);添加 K-V 封装到Entry</span></span><br><span class="line"><span class="comment">5.满足if (count &gt;= threshold) 时，就进行扩容</span></span><br><span class="line"><span class="comment">6.int newCapacity = (oldCapacity &lt;&lt; 1) + 1; //两倍加一的大小扩容</span></span><br><span class="line"><span class="comment">​</span></span><br><span class="line"><span class="comment">底层解读：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">    public synchronized V put(K key, V value) &#123;</span></span><br><span class="line"><span class="comment">        // Make sure the value is not null</span></span><br><span class="line"><span class="comment">        if (value == null) &#123;</span></span><br><span class="line"><span class="comment">            throw new NullPointerException();</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">5.满足if (count &gt;= threshold) &#123; 扩容机制</span></span><br><span class="line"><span class="comment">int newCapacity = (oldCapacity &lt;&lt; 1) + 1; //两倍加一</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h5><ol><li><p>HashMap是非同步的，没有对读写等操作进行锁保护，所以是线程不安全的，在多线程场景下会出现数据不一致的问题。而HashTable是同步的，所有的读写等操作都进行了锁（synchronized）保护，在多线程环境下没有安全问题。但是锁保护也是有代价的，会对读写的效率产生较大影响。</p></li><li><p>HashMap的key可以使用null（但只能有一个），value可以为null，而HashTable都不允许存储key和value值为空的元素</p></li><li><p>HashMap继承了AbstractMap，HashTable继承了Dictionary抽象类，两者都实现了Map接口</p></li><li><p>HashMap的初始容量为16，HashTable的初始容量为11</p></li><li><p>HashMap的扩容机制为扩容两倍，而HashTable的扩容机制为两倍+1</p><ol><li>&#96;&#96;&#96;<br>int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. HashTable不会转换为红黑树</span><br><span class="line"></span><br><span class="line">7. HashMap的迭代器（Iterator）是fail-fast迭代器，但是Hashtable的迭代器（enumerator）不是fail-fast的。如果有其它线程对HashMap进行的添加/删除元素，将会抛出ConcurrentModificationException，但迭代器本身的remove方法移除元素则不会抛出异常。这条同样也是Enumeration和Iterator的区别。</span><br><span class="line"></span><br><span class="line">|           | 版本 | 线程安全（同步） | 效率 | 允许null键null值 |</span><br><span class="line">| :-------- | :--- | :--------------- | :--- | :--------------- |</span><br><span class="line">| HashMap   | 1.2  | 不安全           | 高   | 允许             |</span><br><span class="line">| Hashtable | 1.0  | 安全             | 较低 | 不允许           |</span><br><span class="line"></span><br><span class="line">#### porperties</span><br><span class="line"></span><br><span class="line">##### porperties介绍</span><br><span class="line"></span><br><span class="line">Properties（Java.util.Properties）是Java中一个比较重要的类，主要用于读取Java的配置文件。各种语言都有自己所支持的配置文件，配置文件中很多变量是经常改变的，这样做也是为了方便用户，让用户能够脱离程序本身去修改相关的变量设置。在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”或者“键 值”的格式，文本注释信息可以用&quot;#&quot;来注释。</span><br><span class="line"></span><br><span class="line">在做Java项目开发过程中，涉及到一些数据库服务连接配置、缓存服务器连接配置等，通常情况下我们会将这些不太变动的配置信息存储在以 .properties 结尾的配置文件中。当对应的服务器地址或者账号密码信息有所变动时，我们只需要修改一下配置文件中的信息即可。</span><br><span class="line"></span><br><span class="line"> Properties是一个Map体系集合类，因为其继承于Hashtable，而Hashtable继承于Dictionary类，实现了Map接口，所以Properties也保留了其相关特性。</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Unfalll/picgo/main/img/20201229131713135.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`Properties`继承于`Hashtable`，表示一个持久的属性集，属性列表中每个键及其对应值都是一个[字符串](https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020)。`Properties`类被许多`Java`类使用，例如在获取[环境变量](https://so.csdn.net/so/search?q=环境变量&amp;spm=1001.2101.3001.7020)时，它就作为`System.getProperties`方法的返回值。</span><br><span class="line"></span><br><span class="line">![properties汉化](https://raw.githubusercontent.com/Unfalll/picgo/main/img/2665b4ea840d9b588862a54c26c67274.png)</span><br><span class="line"></span><br><span class="line">##### Properties特点</span><br><span class="line"></span><br><span class="line">1. Properties是Hashtable&lt;Object,Object&gt;的子类；</span><br><span class="line">2. Properties类表示了一个可持久的属性集；</span><br><span class="line">3. Properties可以保存在流中或从流中加载；</span><br><span class="line">4. Properties中每个键和对应的值都是一个字符串（String类型）；</span><br><span class="line">5. Properties有一个特殊的作用：专门用来加载xxx.properties配置文件。</span><br><span class="line"></span><br><span class="line">##### Properties作为Map集合的使用</span><br><span class="line"></span><br><span class="line">&gt; ​      Properties作为Map集合使用时各种方法都与map集合一致（虽然可以但是不建议将Properties作为Map集合使用），但是有一点不同，就是在创建对象时不需要也不能给出泛型，否则会报错，默认所有的键值对类型都是Object类型。下面进行简单的添加和遍历演示。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//Properties作为map集合的使用</span><br><span class="line">private static void PropertiesMap() &#123;</span><br><span class="line">Properties pro = new Properties();//不需要加泛型，所有的键值都是object类型</span><br><span class="line"></span><br><span class="line">//存储元素</span><br><span class="line">pro.put(001, &quot;张三&quot;);</span><br><span class="line">pro.put(002, &quot;李四&quot;);</span><br><span class="line">pro.put(003, &quot;王五&quot;);</span><br><span class="line"></span><br><span class="line">//遍历集合</span><br><span class="line">for(Object key : pro.keySet()) &#123;</span><br><span class="line">System.out.println(key + &quot;:&quot; + pro.get(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p>注意：不要使用Hashtable里面定义的方法添加键值对！因为它们可以插入不是String 类型的数据。如果一个Properties中含有非String的键值对，那么这样的Properties是“不安全”的。调用 store 或者 save 方法将失败。</p></blockquote><h5 id="Properties作为集合的特有方法"><a href="#Properties作为集合的特有方法" class="headerlink" title="Properties作为集合的特有方法"></a>Properties作为集合的特有方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setPorperty(String key,String value)</td><td>设置集合的键和值，都是String类型，底层调用Hashtable方法put</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set<String> stringPropertyNames()</td><td>从该属性中返回一个不可修改的键集，其中键及其对应的值是字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Properties作为集合的特有方法</span></span><br><span class="line"><span class="comment"> * 0bject setProperty(String key,String value):设置类合的链和值，都是String类型，底层调用Hashtable方法put</span></span><br><span class="line"><span class="comment"> * string getProperty ( String key):使用此属性列表中指定的性搜索属性</span></span><br><span class="line"><span class="comment"> * Set&lt;String&gt; stringPropert yNames():从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SpecialMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">pro.setProperty(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;张三&quot;</span>);<span class="comment">//键值都是String类型</span></span><br><span class="line">pro.setProperty(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">pro.setProperty(<span class="string">&quot;003&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(pro.getProperty(<span class="string">&quot;001&quot;</span>));<span class="comment">//根据键搜索属性</span></span><br><span class="line">System.out.println(pro.getProperty(<span class="string">&quot;0011&quot;</span>));<span class="comment">//没有时返回null</span></span><br><span class="line"></span><br><span class="line">System.out.println(pro);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s = pro.stringPropertyNames();<span class="comment">//返回一个不可修改的键集，其中键及其对应的值是字符串</span></span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="keyword">for</span>(String key : s) &#123;</span><br><span class="line">System.out.println(key + <span class="string">&quot;:&quot;</span> + pro.getProperty(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221128225120730.png" alt="image-20221128225120730"></p><p>Properties文件处理<br>我们要处理properties文件就要用到Properties类，要用到一个类首先要干嘛？</p><p>我们需要至少一个Properties对象：</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个Properties对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br></pre></td></tr></table></figure><p>现在我们已经有了一个Properties对象，那么我们该如何用该对象往properties文件写数据呢？</p><p>不过在此之前，我们还得先想想现在有properties文件吗，好像并没有，所有我们还需要创建properties文件</p><p>在这里我们需要用到IO流跟异常的相关基础知识</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个test1.properties文件并通过文件输出流写入</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.properties&quot;</span>);</span><br><span class="line"><span class="comment">//引入Writer,可以明确该输出流的字符集,确保写入配置文件的中文编码正确（utf-8格式）</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">ops</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>好，现在我们已经有了一个名为test1的properties文件，现在我们要往里面写数据了，在这里我们需要用到Properties类中的setProperty方法</p><p>该方法API如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/586060fddb20963d96bec63a7613a13e.png" alt="setProperty"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将需要写入的属性内容通过set方法,存入properties对象中</span></span><br><span class="line">pros.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;一呆&quot;</span>);</span><br><span class="line">pros.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">pros.setProperty(<span class="string">&quot;money&quot;</span>,<span class="string">&quot;0&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在我们已经往里面写数据了，但这个数据只是临时数据，所以我们还需要保存数据，在这里我们需要用到Properties类中的store方法</p><p>该方法API如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/4309eca83af192cd9ecdc5f79630785c.png" alt="store"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用properties的存储方法</span></span><br><span class="line">pros.store(ops,<span class="string">&quot;测试数据&quot;</span>);</span><br></pre></td></tr></table></figure><p>在最后，我们需要释放使用的资源，换句话说，我们需要关闭资源</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">ops.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>我们现在总结一下要对properties文件进行处理都要干些啥：</p><ol><li>需要Properties对象</li><li>需要创建properties文件（通过IO流）</li><li>需要进行异常处理</li><li>需要通过Properties类中的setProperty方法往properties文件里写数据</li><li>需要通过Properties类中的store方法保存写入properties文件的数据</li><li>需要关闭资源</li></ol><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">propertiesTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先实例化一个Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建一个输出流对象</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//3.引入Writer,可以明确该输出流的字符集,确保写入配置文件的中文编码正确</span></span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">ops</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//4.将需要写入的属性内容通过set方法,存入properties对象中</span></span><br><span class="line">            pros.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;一呆&quot;</span>);</span><br><span class="line">            pros.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">            pros.setProperty(<span class="string">&quot;money&quot;</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">//5.调用properties的存储方法</span></span><br><span class="line">            pros.store(ops,<span class="string">&quot;测试数据&quot;</span>);</span><br><span class="line">            <span class="comment">//6.关闭资源</span></span><br><span class="line">            ops.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的properties文件如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/7dc0cd7e0f26eab96a851432dbbfc671.png" alt="properties文件"></p><h5 id="所有方法"><a href="#所有方法" class="headerlink" title="所有方法"></a>所有方法</h5><table><thead><tr><th align="left">返回类型</th><th align="left">方法名和说明</th></tr></thead><tbody><tr><td align="left"><code>String</code></td><td align="left"><code>getProperty(String key)</code>使用此属性列表中指定的键搜索属性。</td></tr><tr><td align="left"><code>String</code></td><td align="left"><code>getProperty(String key, String defaultValue)</code>使用此属性列表中指定的键搜索属性。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>list(PrintStream out)</code>将此属性列表打印到指定的输出流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>list(PrintWriter out)</code>将此属性列表打印到指定的输出流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>load(InputStream inStream)</code>从输入字节流读取属性列表（键和元素对）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>load(Reader reader)</code>以简单的线性格式从输入字符流读取属性列表（关键字和元素对）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>loadFromXML(InputStream in)</code>将指定输入流中的XML文档表示的所有属性加载到此属性表中。</td></tr><tr><td align="left"><code>Enumeration&lt;?&gt;</code></td><td align="left"><code>propertyNames()</code>返回此属性列表中所有键的枚举，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>save(OutputStream out, String comments)</code><strong>已弃用</strong>如果在保存属性列表时发生I &#x2F; O错误，此方法不会抛出IOException。 保存属性列表的<code>store(OutputStream out, String comments)</code>方法是通过<code>store(OutputStream out, String comments)</code>方法或<code>storeToXML(OutputStream os, String comment)</code>方法。</td></tr><tr><td align="left"><code>Object</code></td><td align="left"><code>setProperty(String key, String value)</code>致电 <code>Hashtable</code>方法 <code>put</code> 。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>store(OutputStream out, String comments)</code>将此属性列表（键和元素对）写入此 <code>Properties</code>表中，以适合于使用 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Properties.html#load-java.io.InputStream-"><code>load(InputStream)</code></a>方法加载到 <code>Properties</code>表中的格式输出流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>store(Writer writer, String comments)</code>将此属性列表（键和元素对）写入此 <code>Properties</code>表中，以适合使用 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Properties.html#load-java.io.Reader-"><code>load(Reader)</code></a>方法的格式输出到输出字符流。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>storeToXML(OutputStream os, String comment)</code>发出表示此表中包含的所有属性的XML文档。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>storeToXML(OutputStream os, String comment, String encoding)</code>使用指定的编码发出表示此表中包含的所有属性的XML文档。</td></tr><tr><td align="left"><code>Set&lt;String&gt;</code></td><td align="left"><code>stringPropertyNames()</code>返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。</td></tr></tbody></table><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>TreeMap是一个基于key有序的key value散列表。</p><ul><li>map根据其键的自然顺序排序，或者根据map创建时提供的Comparator排序</li><li>不是线程安全的</li><li>key 不可以存入null</li><li>底层是基于红黑树实现的</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/26231590053a6617afad4b9e92747996.webp" alt="img"></p><p>以上是TreeMap的类结构图：</p><ol><li>实现了NavigableMap接口，NavigableMap又实现了Map接口，提供了导航相关的方法。</li><li>继承了AbstractMap，该方法实现Map操作的骨干逻辑。</li><li>实现了Cloneable接口，标记该类支持clone方法复制</li><li>实现了Serializable接口，标记该类支持序列化</li></ol><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>TreeMap()</td><td>使用键的自然排序构造一个新的空树映射。</td></tr><tr><td>TreeMap(Comparator&lt;? super K&gt; comparator)</td><td>构造一个新的空树映射，根据给定的比较器排序</td></tr><tr><td>TreeMap(Map&lt;? extends K,? extends V&gt; m)</td><td>构造一个新的树映射，包含与给定映射相同的映射，按照键的自然顺序排序。</td></tr><tr><td>TreeMap(Map&lt;? extends K,? extends V&gt; m)</td><td>构造一个新的树映射，包含相同的映射，并使用与指定排序映射相同的顺序。</td></tr></tbody></table><h5 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h5><h6 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个比较器，方便插入查找元素等操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//红黑树的根节点：每个节点是一个Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//集合元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//集合修改的记录</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>comparator是一个排序器，作为key的排序规则</li><li>root是红黑树的根节点，说明的确底层用的红黑树作为数据结构。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">     <span class="comment">//左子树</span></span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">     <span class="comment">//右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">     <span class="comment">//父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">     <span class="comment">//每个节点的颜色：红黑树属性。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> (key==<span class="literal">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">            <span class="type">int</span> <span class="variable">valueHash</span> <span class="operator">=</span> (value==<span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">            <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="查找get方法"><a href="#查找get方法" class="headerlink" title="查找get方法"></a>查找get方法</h6><p>TreeMap基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以 TreeMap 的查找操作流程和二叉查找树一致。二叉树的查找流程是这样的，先将目标值和根节点的值进行比较，如果目标值小于根节点的值，则再和根节点的左孩子进行比较。如果目标值大于根节点的值，则继续和根节点的右孩子比较。在查找过程中，如果目标值和二叉树中的某个节点值相等，则返回 true，否则返回 false。TreeMap 查找和此类似，只不过在 TreeMap 中，节点（Entry）存储的是键值对&lt;k,v&gt;。在查找过程中，比较的是键的大小，返回的是值，如果没找到，则返回null。TreeMap 中的查找方法是get。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">//调用 getEntry方法查找</span></span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p. value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    / 如果比较器为空，只是用key作为比较器查询</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    <span class="comment">// 取得root节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">   <span class="comment">//核心来了：从root节点开始查找，根据比较器判断是在左子树还是右子树</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key );</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p. left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p. right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="插入put方法"><a href="#插入put方法" class="headerlink" title="插入put方法"></a>插入put方法</h6><p>我们来看下关键的插入方法，在插入时候是如何维护key的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">       <span class="comment">// 1.如果根节点为 null，将新节点设为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"> </span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果root不为null，说明已存在元素 </span></span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">//如果比较器不为null 则使用比较器</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//找到元素的插入位置</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                 <span class="comment">//当前key小于节点key 向左子树查找</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                    <span class="comment">//当前key大于节点key 向右子树查找</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//相等的情况下 直接更新节点值</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//如果比较器为null 则使用默认比较器</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果key为null  则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">             <span class="comment">//找到元素的插入位置</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">      <span class="comment">//根据比较结果决定插入到左子树还是右子树</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">    <span class="comment">//保持红黑树性质，进行红黑树的旋转等操作</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是fixAfterInsertion方法， 看懂这个方法需要你对红黑树的机制比较了解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新插入节点的颜色设置为红色</span></span><br><span class="line">    x. color = RED;</span><br><span class="line">    <span class="comment">// while循环，保证新插入节点x不是根节点或者新插入节点x的父节点不是红色（这两种情况不需要调整）</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x. parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">// 如果新插入节点x的父节点是祖父节点的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf (parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// 取得新插入节点x的叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf (parentOf(x)));</span><br><span class="line">            <span class="comment">// 如果新插入x的父节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                <span class="comment">// 将x的叔叔节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环</span></span><br><span class="line">                x = parentOf(parentOf (x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf( parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// 左旋父节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子</span></span><br><span class="line">                <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 右旋x的祖父节点</span></span><br><span class="line">                rotateRight( parentOf(parentOf (x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果新插入节点x的父节点是祖父节点的右孩子和上面的相似</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf (parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf (x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf( parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf (x), BLACK);</span><br><span class="line">                setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                rotateLeft( parentOf(parentOf (x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将根节点设置为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除remove方法"><a href="#删除remove方法" class="headerlink" title="删除remove方法"></a>删除remove方法</h6><p>删除remove是最复杂的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据key查找到对应的节点对象</span></span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 记录key对应的value，供返回使用</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p. value;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//元素个数减一</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 如果被删除的节点p的左孩子和右孩子都不为空，则查找其替代节</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="literal">null</span> &amp;&amp; p. right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找p的替代节点</span></span><br><span class="line">            Entry&lt;K,V&gt; s = successor (p);</span><br><span class="line">            p. key = s.key ;</span><br><span class="line">            p. value = s.value ;</span><br><span class="line">            p = s;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; replacement = (p. left != <span class="literal">null</span> ? p.left : p. right);</span><br><span class="line">        <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 将p的父节点拷贝给替代节点</span></span><br><span class="line">            replacement. parent = p.parent ;</span><br><span class="line">            <span class="comment">// 如果替代节点p的父节点为空，也就是p为跟节点，则将replacement设置为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="comment">// 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent. left)</span><br><span class="line">                p. parent.left   = replacement;</span><br><span class="line">            <span class="comment">// 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的右孩子</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p. parent.right = replacement;</span><br><span class="line">            <span class="comment">// 将替代节点p的left、right、parent的指针都指向空</span></span><br><span class="line">            p. left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 如果替代节点p的颜色是黑色，则需要调整红黑树以保持其平衡</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">            <span class="comment">// 如果要替代节点p没有父节点，代表p为根节点，直接删除即可</span></span><br><span class="line">            root = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果p的颜色是黑色，则调整红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(p);</span><br><span class="line">            <span class="comment">// 下面删除替代节点p</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 解除p的父节点对p的引用</span></span><br><span class="line">                <span class="keyword">if</span> (p == p.parent .left)</span><br><span class="line">                    p. parent.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent. right)</span><br><span class="line">                    p. parent.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 解除p对p父节点的引用</span></span><br><span class="line">                p. parent = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>TreeMap底层是红黑树，能够实现该Map集合有序~</p><p>如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较。否则，则使用Comparable的<code>compareTo(T o)</code>方法来比较。</p><ul><li>值得说明的是：如果使用的是<code>compareTo(T o)</code>方法来比较，<strong>key一定是不能为null</strong>，并且得实现了Comparable接口的。</li><li>即使是传入了Comparator对象，不用<code>compareTo(T o)</code>方法来比较，key<strong>也是</strong>不能为null的</li></ul><ol><li>由于底层是红黑树，那么时间复杂度可以保证为log(n)</li><li>key不能为null，为null为抛出NullPointException的</li><li>想要自定义比较，在构造方法中传入Comparator对象，否则使用key的自然排序来进行比较</li><li>TreeMap非同步的，想要同步可以使用Collections来进行封装</li></ol><h3 id="集合类如何选择"><a href="#集合类如何选择" class="headerlink" title="集合类如何选择"></a>集合类如何选择</h3><ol><li>先判断存储的类型（一组对象【单列】或一组键值对【双列】）</li><li>一组对象【单列】：collection接口<ol><li>允许重复：list    <ol><li>增删多：ListedList[底层维护了一个双向列表]</li><li>改查多：ArrayList[底层维护Object类型的可变数组]</li></ol></li><li>不允许重复：Set<ol><li>无序：HashSet[底层是HashMap，维护了一个哈希表，即（数组+链表+红黑树）]</li><li>排序：TreeSet</li><li>插入和取出顺序一致的；LinkedHashSet，维护数组+双向链表</li></ol></li></ol></li><li>一组键值对[双列]：Map<ol><li>键无序；HashMap[底层是哈希表，数组+链表+红黑树]</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致，LinkedHashMap</li><li>读取文件 Porperties</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合中常见的数据结构</title>
      <link href="/2022/11/10/%E9%9B%86%E5%90%88%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/10/%E9%9B%86%E5%90%88%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>常见的数据结构</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出–&gt;装子弹</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821221902384.png" alt="在这里插入图片描述"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出–&gt;过安检</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821221935320.png" alt="在这里插入图片描述"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素。</p></li><li><p>增删元素慢:–&gt;数组定长,改变数组长度的话,需要创建新的数组。</p></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li>单向链表：前面的记录后面的地址，后面的不记录前面的地址</li><li>双向链表：前面的记录后面的，后面也记录前面的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222010587.png" alt="在这里插入图片描述"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><ul><li>二叉树中,任意一个节点的度要小于等于2<ul><li>节点: 在树结构中,每一个元素称之为节点</li><li>度: 每一个节点的子节点数量称之为度</li></ul></li></ul><p>二叉树结构图</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222044325.png" alt="在这里插入图片描述"></p><h2 id="二叉查找树-二叉搜索树"><a href="#二叉查找树-二叉搜索树" class="headerlink" title="二叉查找树(二叉搜索树)"></a>二叉查找树(二叉搜索树)</h2><ul><li><p>二叉查找树的特点</p><ul><li><p>二叉查找树,又称二叉排序树或者二叉搜索树</p></li><li><p>每一个节点上最多有两个子节点</p></li><li><p>左子树上所有节点的值都小于根节点的值</p></li><li><p>右子树上所有节点的值都大于根节点的值</p></li></ul></li><li><p>二叉查找树结构图</p></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/202008212221133.png" alt="在这里插入图片描述"></p><ul><li>二叉查找树和二叉树对比结构图</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222126293.png" alt="在这里插入图片描述"></p><ul><li>二叉查找树添加节点规则<ul><li>小的存左边</li><li>大的存右边</li><li>一样的不存</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222144284.png" alt="在这里插入图片描述"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="平衡二叉树的特点"><a href="#平衡二叉树的特点" class="headerlink" title="平衡二叉树的特点"></a>平衡二叉树的特点</h3><ul><li>二叉树左右两个子树的高度差不超过1</li><li>任意节点的左右两个子树都是一颗平衡二叉树</li></ul><h3 id="平衡二叉树旋转"><a href="#平衡二叉树旋转" class="headerlink" title="平衡二叉树旋转"></a>平衡二叉树旋转</h3><h4 id="旋转触发时机"><a href="#旋转触发时机" class="headerlink" title="旋转触发时机"></a>旋转触发时机</h4><p>当添加一个节点之后,该树不再是一颗平衡二叉树</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222218944.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222228994.png" alt="在这里插入图片描述"></p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222252125.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2020082122230627.png" alt="在这里插入图片描述"></p><h3 id="平衡二叉树和二叉查找树对比结构图"><a href="#平衡二叉树和二叉查找树对比结构图" class="headerlink" title="平衡二叉树和二叉查找树对比结构图"></a>平衡二叉树和二叉查找树对比结构图</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222332320.png" alt="在这里插入图片描述"></p><h3 id="平衡二叉树旋转的四种情况"><a href="#平衡二叉树旋转的四种情况" class="headerlink" title="平衡二叉树旋转的四种情况"></a>平衡二叉树旋转的四种情况</h3><h4 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h4><p>左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡</p><p>如何旋转: 直接对整体进行右旋即可</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222518983.png" alt="在这里插入图片描述"></p><h4 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h4><p>左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡</p><p>如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222545659.png" alt="在这里插入图片描述"></p><h4 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h4><p>右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡</p><p>如何旋转: 直接对整体进行左旋即可</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222630511.png" alt="在这里插入图片描述"></p><h4 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h4><p>右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡</p><p>如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222645356.png" alt="在这里插入图片描述"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h3><ul><li><p>平衡二叉B树</p></li><li><p>每一个节点可以是红或者黑</p></li><li><p>红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的</p></li></ul><h3 id="红黑树的红黑规则有哪些"><a href="#红黑树的红黑规则有哪些" class="headerlink" title="红黑树的红黑规则有哪些"></a>红黑树的红黑规则有哪些</h3><ol><li>每一个节点或是红色的,或者是黑色的</li><li>根节点必须是黑色</li><li>如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的</li><li>如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)</li><li>对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222736358.png" alt="在这里插入图片描述"></p><h3 id="红黑树添加节点的默认颜色"><a href="#红黑树添加节点的默认颜色" class="headerlink" title="红黑树添加节点的默认颜色"></a>红黑树添加节点的默认颜色</h3><p>添加节点时,默认为红色,效率高</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222801908.png" alt="在这里插入图片描述"></p><h3 id="红黑树添加节点后如何保持红黑规则"><a href="#红黑树添加节点后如何保持红黑规则" class="headerlink" title="红黑树添加节点后如何保持红黑规则"></a>红黑树添加节点后如何保持红黑规则</h3><ol><li>根节点位置<ol><li>直接变为黑色</li></ol></li><li>非根节点位置<ol><li>父节点为黑色<ol><li>不需要任何操作,默认红色即可</li></ol></li><li>父节点为红色<ol><li>叔叔节点为红色<ol><li>将”父节点”设为黑色,将”叔叔节点”设为黑色</li><li>将”祖父节点”设为红色</li><li>如果”祖父节点”为根节点,则将根节点再次变成黑色</li></ol></li><li>叔叔节点为黑色<ol><li>将”父节点”设为黑色</li><li>将”祖父节点”设为红色</li><li>以”祖父节点”为支点进行旋转</li></ol></li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222855827.bmp" alt="在这里插入图片描述"></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="哈希值简介"><a href="#哈希值简介" class="headerlink" title="哈希值简介"></a>哈希值简介</h3><ol><li><p>是由计算机算出来的一个十进制,理解为对象的地址值(逻辑地址)</p><p>内存中分配给对象的地址值和哈希值没啥关系</p></li><li><p>是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p></li></ol><h3 id="哈希表介绍"><a href="#哈希表介绍" class="headerlink" title="哈希表介绍"></a>哈希表介绍</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222928901.png" alt="在这里插入图片描述"></p><h3 id="如何获取哈希值"><a href="#如何获取哈希值" class="headerlink" title="如何获取哈希值"></a>如何获取哈希值</h3><p> Object类中的public int hashCode()：返回对象的哈希码值</p><h3 id="哈希值的特点"><a href="#哈希值的特点" class="headerlink" title="哈希值的特点"></a>哈希值的特点</h3><p>同一个对象多次调用hashCode()方法返回的哈希值是相同的<br>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</p><h3 id="哈希表的存储过程"><a href="#哈希表的存储过程" class="headerlink" title="哈希表的存储过程"></a>哈希表的存储过程</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821222958360.png" alt="在这里插入图片描述"></p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ul><li>String中的hashCode方法,获取的是字符串内容的哈希值</li><li>内容一样(equals),哈希值(hashCode)一定一样</li><li>内容不一样,哈希值也有可能一样</li></ul><h4 id="JDK1-8以前"><a href="#JDK1-8以前" class="headerlink" title="JDK1.8以前"></a>JDK1.8以前</h4><p> 数组 + 链表</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821223050887.png" alt="在这里插入图片描述"></p><h4 id="JDK1-8以后"><a href="#JDK1-8以后" class="headerlink" title="JDK1.8以后"></a>JDK1.8以后</h4><ul><li>节点个数少于等于8个<ul><li>数组 + 链表</li></ul></li><li>节点个数多于8个<ul><li>数组 + 红黑树</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20200821223118800.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA如何进行debug调式</title>
      <link href="/2022/10/27/idea%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Cdebug%E8%B0%83%E5%BC%8F/"/>
      <url>/2022/10/27/idea%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Cdebug%E8%B0%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>🍃第一步，设断点，打开debug<br>        设断点是什么意思，其实就是暂定，等待的意思。当程序执行到用户设置的断点时，程序暂定执行，等待下一步命令的执行。在IDEA中只需在代码注释行旁边单击鼠标左键即可。</p><p><img src="https://img-blog.csdnimg.cn/20210313160439567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 在IDEA中，我们不光可以设置断点，还可以为该断点添加条件，比如在如下实例中，设置条件为i &#x3D; 5。此时断点样式右下角会有一个疑问符号，表示该断点是被赋予条件的。意思是程序直接执行到i &#x3D; 5 时才暂定执行，等待下一步命令执行。</p><p><img src="https://img-blog.csdnimg.cn/20210313160701862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210313160744697.png" alt="在这里插入图片描述"></p><p> 给断点添加条件有快捷键（shift + ctrl + F8)。在使用快捷键时，有一个小细节，你的鼠标一定要放在断点红色代码这一行中，否者快捷键按的就不是给断点添加条件，而是查看所有断点，如下，因为他们的快捷键是一样的，区别在于鼠标的光标的位置，在断点处所在行就是给断点添加条件，在非断点处所在行就是查看所有断点。</p><p><img src="https://img-blog.csdnimg.cn/20210313162623826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 当你已经把断点设置好了，便可以打开debug调试了。打开的方式有很多，在IDEA中，我们可以在最上面的工具栏中选择Run中的Debug打开；也可以选择右上角的Debug图标打开；还可以在代码里面单击鼠标右键选择Debug调试。</p><p>🌱方式一</p><p><img src="https://img-blog.csdnimg.cn/20210313161605916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>🌱方式二</p><p><img src="https://img-blog.csdnimg.cn/20210313161640701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>🌱方式三</p><p><img src="https://img-blog.csdnimg.cn/20210313161716855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>🍃第二步，使用Debug调试的功能键<br>我们先来了解Debug栏中位于左侧的主要的5个功能键。</p><p><img src="https://img-blog.csdnimg.cn/20210313163238903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e0b3c08643674757a04c87313645118d.png" alt="在这里插入图片描述"> 第一个，<strong>有返回箭头的按钮</strong>，功能是重新执行Debug，当你在执行Debug一半时，发行并不能解决你的问题，这时你不需要重新关闭并打开Debug，按下此按钮，Debug调试会重新执行。</p><p><img src="https://img-blog.csdnimg.cn/4b1e05dddc884bc081691603b040b2e8.png" alt="在这里插入图片描述">第二个，一个竖杠加向右的三角形的按钮，功能是跳到下一次断点执行，两个断点之间的代码都被加载执行过了。<br>        但是当一个断点在一个for循环中，如果循环有n（n&gt;&#x3D;1)次，for循环外有一个断点，此时该功能是跳过一次for循环，并不是跳过所有循环而直接到下一个断点，那么如果先要跳过所有循环可以将断点暂时不启用，也就是将enabled去掉，因为enable是启用断点的意思。</p><p><img src="https://img-blog.csdnimg.cn/7ccaad02a56547b397c77e4e8787e096.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/70d5f59e1b064cbb94ad855926b2376c.png" alt="在这里插入图片描述">第三个，<strong>一个红色的正方块的按钮</strong>，功能是结束Debug 的执行。按下之后，整个Debug调试都会将结束并停止执行。</p><p><img src="https://img-blog.csdnimg.cn/2182e49f429042e999bc5c61ee86085f.png" alt="在这里插入图片描述">第四个，<strong>两个重叠的红色圆圈的按钮</strong>，功能是查看所有的断点。快捷键是（<code>shift + ctrl + F8</code>)，至于它的用法在上面将给断点添加条件时已讲述</p><p><img src="https://img-blog.csdnimg.cn/99c886098c424fda8ddeb9fd8fd27464.png" alt="在这里插入图片描述">第五个，<strong>一个红色的圆圈中有一个灰色的斜杠的按钮</strong>，功能是隐藏所有的Debug断点。用途就是，当你在Debug调试时，你觉得此时已经没有问题了，这时可以暂时隐藏所有Debug断点，无障碍运行一次，如果有问题还要取消隐藏，不至于重新打开Debug。</p><hr><p><img src="https://img-blog.csdnimg.cn/20210313165959224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7896c70e72ee4970b577880b6e42e445.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是将你的光标移动到当前代码所执行处，不管此刻你的鼠标光标的位置在哪里。</p><p><img src="https://img-blog.csdnimg.cn/d6560aba1d724a49bfe146d014d2b275.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是单步跳入。Debug调试是一行一行的执行下去，但是如果遇到调用方法时，是不会进入方法里面的。</p><p><img src="https://img-blog.csdnimg.cn/24370a73d82748c09b78aae3e18b119d.png" alt="在这里插入图片描述"><strong>按钮</strong> 与<img src="https://img-blog.csdnimg.cn/2b3dde9fd1754f4694014ed23a644ed4.png" alt="在这里插入图片描述"><strong>按钮</strong>，因为功能相似，放在一起讲。两个的功能都是单步进入的执行，但唯一的区别是，<strong>蓝色向下箭头</strong>的按钮遇到方法时，只有当经过的方法时用户自定义的方法才会跳进去，如果是系统自定的方法则不会跳进去。而<strong>红色向下箭头</strong>的按钮，不管是系统自定义的方法还是用户自定义的方法都会跳入到方法里面去执行</p><p><img src="https://img-blog.csdnimg.cn/5db0e6408e7740b7b454e8c9408bf910.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是单步跳出。可以跳出进入的方法。</p><p><img src="https://img-blog.csdnimg.cn/e0b04dcb721049499a52cf9e82d15675.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是将当前执行的位置直接执行到用户指定鼠标光标的位置。</p><hr><p>接下来就是最后一个功能区，如下图片，详细解释。</p><p><img src="https://img-blog.csdnimg.cn/202103131719500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_oop_PLUS</title>
      <link href="/2022/10/10/Java-oop-PLUS/"/>
      <url>/2022/10/10/Java-oop-PLUS/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="枚举类-1"><a href="#枚举类-1" class="headerlink" title="枚举类"></a>枚举类</h3><p>实例（也叫对象）有限且固定不变的类，在Java里被称为枚举类。</p><p>枚举类是一种特殊的类，它一样可以有自己的成员变量、方法，可以实现一个或多个接口，也可以有自己的构造器。</p><p>枚举类的对象只能是有有限个且是确定的。比如说星期类：星期一到星期日；性别类：男女</p><p><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>枚举类对象的属性不应允许被改动，所以应该使用private，final修饰</li><li>枚举类的使用private final修饰的属性应该在构造器中为其赋值</li><li>若枚举类显式的定义了带参数的构造器，则在列出枚举值时，也必须对应的传入参数</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li><p>枚举类默认继承 java.lang.Enum 类，而不是 Object 类，因此枚举类不能显示继承其他父类。</p></li><li><p>使用 enum 定义的非抽象的枚举类默认会使用 final 修饰，因此非抽象枚举类不能派生子类（即不能被继承) </p><blockquote><p>final关键字回顾：final修饰的类不能被继承、修饰的方法不能被重写、修饰的属性其值不能改变。</p></blockquote></li><li><p>枚举类的构造器只能使用 private 访问控制符，如果忽略访问控制符的话，则默认使用 private 修饰；如果强制指定其他的访问控制符（例如public、procted等）,则会报错。</p></li><li><p>枚举类的所有实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不可能产生实例。列出的这些实例，系统会自动给它们加上 public static final 修饰。枚举类的实例以逗号分隔，分号结束，这些列出的枚举值代表了该枚举类的所有可能的实例。</p></li></ol><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><p>自定义枚举类的步骤</p><ol><li>私有化类的构造器，保证无法在类的外部创建对象；</li><li>类内部创建枚举类的实例，声明为<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a> static final</li><li>对象若有实例变量，声明为private final，并在构造器中初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name,String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = name;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enum定义枚举类"><a href="#enum定义枚举类" class="headerlink" title="enum定义枚举类"></a>enum定义枚举类</h3><ol><li>使用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li><li>枚举类的构造器只能使用private权限修饰符</li><li>枚举类的所有实例必须再枚举类中显式列出（, 分隔  ;  结尾）列出的实例系统会自动添加public static final 修饰</li><li>必须在枚举类的第一行声明枚举类对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SeasonEnum</span> <span class="variable">seasonEnum</span> <span class="operator">=</span> SeasonEnum.SPRING;</span><br><span class="line">        System.out.println(seasonEnum);</span><br><span class="line">        System.out.println(seasonEnum.getClass().getSuperclass());<span class="comment">//class java.lang.Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SeasonEnum</span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象，对象之间使用，分开，最后一个使用：</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String name,String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = name;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSEASONDESC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONDESC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSEASONNAME</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONNAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SeasonEnum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li><li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</li><li>toString()：返回当前枚举类对象常量的名称</li><li>ordinal();  得到当前枚举常量的次序</li><li></li></ul><p>以上enum定义枚举类为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSeason</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//没有重写枚举类里的.toString()，直接打印的是枚举对象的名称，不是地址值，因为枚举类的父类不是Object</span></span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN);</span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getSEASONNAME());</span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getSEASONDESC());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取AUTUMN的对象代表的类</span></span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getClass());</span><br><span class="line">        <span class="comment">//获取AUTUMN的对象代表的枚举类父类【父类是Enum类，而非Object】</span></span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getClass().getSuperclass());</span><br><span class="line">        <span class="comment">//ordinal得到当前枚举常量的次序</span></span><br><span class="line">        System.out.println( SeasonEnum.AUTUMN.ordinal() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取枚举类里所有的对象</span></span><br><span class="line">        SeasonEnum[] values = SeasonEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (SeasonEnum season : values) &#123;</span><br><span class="line">            System.out.println(season);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将字符串AUTUMN转化为枚举类里的对象</span></span><br><span class="line">        <span class="type">SeasonEnum</span> <span class="variable">autumn</span> <span class="operator">=</span> SeasonEnum.valueOf(<span class="string">&quot;AUTUMN&quot;</span>);</span><br><span class="line">        System.out.println(autumn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报错</span></span><br><span class="line">        <span class="type">SeasonEnum</span> <span class="variable">autumn2</span> <span class="operator">=</span> SeasonEnum.valueOf(<span class="string">&quot;autumn&quot;</span>);</span><br><span class="line">        System.out.println(autumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;秋天&#x27;</span>, SEASONDESC=<span class="string">&#x27;秋高气爽&#x27;</span>&#125;</span><br><span class="line">秋天</span><br><span class="line">秋高气爽</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.unfall.Enum.SeasonEnum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Enum</span><br><span class="line"><span class="number">2</span></span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;春天&#x27;</span>, SEASONDESC=<span class="string">&#x27;春暖花开&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;夏天&#x27;</span>, SEASONDESC=<span class="string">&#x27;夏日炎炎&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;秋天&#x27;</span>, SEASONDESC=<span class="string">&#x27;秋高气爽&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;冬天&#x27;</span>, SEASONDESC=<span class="string">&#x27;白雪皑皑&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;秋天&#x27;</span>, SEASONDESC=<span class="string">&#x27;秋高气爽&#x27;</span>&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: No <span class="keyword">enum</span> <span class="title class_">constant</span> com.unfall.Enum.SeasonEnum.autumn</span><br><span class="line">at java.lang.Enum.valueOf(Enum.java:<span class="number">238</span>)</span><br><span class="line">at com.unfall.Enum.SeasonEnum.valueOf(Enumerstion02.java:<span class="number">19</span>)</span><br><span class="line">at com.unfall.Enum.TestSeason.main(TestSeason.java:<span class="number">33</span>)</span><br></pre></td></tr></table></figure><h3 id="实现接口枚举类"><a href="#实现接口枚举类" class="headerlink" title="实现接口枚举类"></a>实现接口枚举类</h3><ul><li>和普通Java类一样，枚举类可以实现一个或多个接口</li><li>若每个枚举类在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li></ul><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></blockquote><p>注解(Annotation):对代码的描述, 作为代码形式保留下来,</p><p>Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>注释: 类似超市商品下面的标签, 描述商品 方便给顾客查看的</p><p>注解: 类似商品的条形码, 描述商品, 方便后期商品结算</p><p>注解的本质: 特殊的接口</p><p>声明注解: 创建了一个特殊接口</p><p>使用注解: @注解名(创建注解的一个对象)</p><ol><li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等 </li><li>跟踪代码依赖性，实现替代配置文件功能。比如Spring的注入，未来java开发，将大量注解配置，具有很大用处; 后期学习框架大量使用, 基于注解的开发 </li><li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>提供信息给编译器：编译器可直接通过注解探测错误和警告信息，例如：@Override，@Deprecated</li><li>编译阶段时的处理：软件工具可以用来利用注解信息生成代码、html文档或者做其他相应处理，例如：@Param，@Return，@See，@Author用于生成javadoc文档</li><li>运行时的处理：某些注解可以在程序运行时接收代码的提取，但注解本身不是代码的一部分</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><p>内置注解：jdk定义好这个注解的声明，开发者直接使用，语法检查</p><ol><li><p>@Override 检测重写</p></li><li><p>@Deprecated 已过时, 只是一个标志, 还是能够使用</p></li><li><p>@SuppressWarnings(“all”) 抑制编译器生成警告信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">        demo2.fun1(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//2022 - 1970 = 52  1900 ~ 1999</span></span><br><span class="line">        System.out.println(d.getYear()); <span class="comment">//2022  122</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> <span class="keyword">extends</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    <span class="comment">//重写Demo1的</span></span><br><span class="line">   <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a  声明了方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  声明方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元注解:jdk定义好这个注解的声明, 在注解上使用</p><ol><li><p>@Documented-注解是否将包含在JavaDoc中</p><p>一个简单的Annotations标记注解，表示是否将注解信息添加在javadoc文档中</p></li><li><p>@Retention –什么时候使用该注解</p><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间</p></li><li><p>@Target–注解用于什么地方</p><p>默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括 ● ElementType.CONSTRUCTOR:用于描述构造器 ● ElementType.FIELD:成员变量、对象、属性（包括enum实例） ● ElementType.LOCAL_VARIABLE:用于描述局部变量 ● ElementType.METHOD:用于描述方法 ● ElementType.PACKAGE:用于描述包 ● ElementType.PARAMETER:用于描述参数 ● ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p></li><li><p>@Inherited – 定义该注释和子类的关系</p><p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个注解接口</span></span><br><span class="line"><span class="comment"> *  使用元注解对自定义的注解进行一些声明,说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">//表示该MyAnnotation1注解将会在生成doc文档上出现</span></span><br><span class="line"><span class="comment">//跟注解的参数赋值: 如果数组类型</span></span><br><span class="line"><span class="meta">@Target(value=&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span>    <span class="comment">//目标: 表示这个MyAnnotation1注解在那些地方使用</span></span><br><span class="line">            <span class="comment">// 如果没有写, 表示这个注解在任意的地方使用</span></span><br><span class="line"><span class="meta">@Retention(value= RetentionPolicy.RUNTIME)</span> <span class="comment">//自定义注解,保留期一定是Runtime</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 表示这个MyAnnotation1这个注解标记的类, 这个类的子类是否继承父类该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation1</span>  <span class="comment">//创建了MyAnnotation1的一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> stuno;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@MyAnnotation1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">( <span class="type">int</span> stuno, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuno = stuno;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStuno</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stuno;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStuno</span><span class="params">(<span class="type">int</span> stuno)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuno = stuno;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">SubStudent</span> <span class="keyword">extends</span>  <span class="title class_">Student</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ol><li>自定义注解: 关键字@interface , 默认继承Annotation接口, 本质就是一个接口</li><li>参数成员访问修饰符: public 或者是缺省的(还是public), 参数名后面必须是()</li></ol><p>参数本质就是一个抽象方法</p><p>但是我们可以使用注解的时候,给参数赋值, 在声明的时候, 设置默认值</p><p>参数名() default 值;</p><p>如果一个参数没有设置default默认值, 使用这个注解的时候, 一定要给参数赋值,</p><p>如果使用default, 使用注解的时候, 可以给参数赋值,也可以不赋值(使用默认值)</p><ol><li>参数的数据类型: 八大基本数据类型,String, 枚举,Class,注解类型,或者12种的数组类型</li><li>自定义的注解,可以有参数,也可以没有参数, 如果没有参数,这个注解没有意义</li><li>自定义注解,它的功能, 必须写代码解析注解,并给它赋予功能,自定义注解保留期: 一定为RUNTIME, 获取该注解的对象, 只能使用反射来获取</li></ol><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>声明注解的语法: @interface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line"><span class="comment">//成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用注解:</p><p>在方法,类型,包,构造方法,属性,参数… 使用注解</p><p>@注解名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(value=&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Annotation1 &#123;</span><br><span class="line"> <span class="comment">//成员参数</span></span><br><span class="line"> <span class="comment">// value参数有一个默认值, 这个方法默认返回值</span></span><br><span class="line"> <span class="comment">//给这个参数赋值, 就是设置这个方法的返回值</span></span><br><span class="line"> String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"> SexEnum <span class="title function_">sex</span><span class="params">()</span> <span class="keyword">default</span> SexEnum.MAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line"> MAN,WOMAN</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Annotation1(value=&quot;lisi&quot;,sex=SexEnum.WOMAN)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池</p><p>　这个运行时生成的动态代理对象是可以导出到文件的，方法有两种</p><ul><li>在代码中加入System.setProperty(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);</li><li>在运行时加入jvm 参数 -Dsun.misc.ProxyGenerator.saveGeneratedFiles&#x3D;true</li></ul><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>什么是异常：程序执行过程中的<strong>不正常</strong>情况。</li><li>异常的作用：增强程序的 **<code>健壮性</code>**。</li></ul><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException(&quot;/ by zero&quot;);</span></span><br><span class="line">        <span class="comment">// 并且JVM将new的异常对象抛出，打印输出信息到控制台了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;/&quot;</span> + b + <span class="string">&quot;=&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处运行也会创建一个：ArithmeticException类型的异常对象。</span></span><br><span class="line">        System.out.println(<span class="number">100</span> / <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的捕获和处理"><a href="#异常的捕获和处理" class="headerlink" title="异常的捕获和处理"></a>异常的捕获和处理</h3><p>设计时如果已经预测到某部分代码在执行时可能会产生异常就应当对这块代码进行异常的捕获及相应的处理。<br>如果异常未被捕获，那么程序执行到此就结束了，对于用户来讲就感到莫名其妙。<br>捕获和处理异常的语句是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Try&#123;</span><br><span class="line">       可能会出异常的语句块;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型参数 参数名)&#123;<span class="comment">//异常类型要与产生的异常类型匹配，匹配是指符合向上转型的条件，catch可以有多个</span></span><br><span class="line">   处理异常的语句块</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   释放资源;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>,b = <span class="number">0</span>;</span><br><span class="line">    cal(a, b);<span class="comment">//接受cal方法抛出的异常，后面的代码不执行，把异常抛给jvm，异常信息是jvm打印的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main方法产生异常后&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法会产生异常</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a/b;<span class="comment">//此处抛异常，直接抛给main，后面的代码不执行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;cal方法产生异常后&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上try语句</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = a/b;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>异常分为 <strong><code>编译时异常</code></strong> 和 **<code>运行时异常</code>**。</p><p>所有异常都是在 <strong><code>运行阶段</code></strong> 发生的。因为只有程序运行阶段才可以 <strong>new</strong>对象。</p><p>因为异常的发生就是 **<code>new异常对象</code>**。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221011160943919.png" alt="image-20221011160943919"></p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210503143543377.png" alt="在这里插入图片描述"></p><ul><li>Exception的直接子类：<strong>编译时异常</strong>（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</li><li>RuntimeException：<strong>运行时异常</strong>。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</li></ul><h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><ol><li>catch后面的小括号中的类型可以是 **<code>具体的异常类型</code>**，也可以是该异常类型的 **<code>父类型</code>**。</li><li>catch可以写<strong>多个</strong>。建议catch的时候，<strong>精确的一个一个处理</strong>。这样有利于程序的调试。</li><li>catch写多个的时候，<strong>从上到下</strong>，必须遵守 **<code>从小到大</code>**。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Download\\Javabean-addperson案例解析.docx&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Download\\Javabean-addperson案例解析.docx&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;<span class="comment">// 多态：Exception e = new FileNotFoundException();</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Download\\Javabean-addperson案例解析.docx&quot;</span>);</span><br><span class="line">    fis.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;读文件报错了！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String <strong>getMessage</strong>()</td><td>返回异常的详细详细信息</td></tr><tr><td>void <strong>printStackTrace</strong>()</td><td>追踪堆栈异常信息(采用异步线程)</td></tr></tbody></table><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>在finally子句中的代码是最后执行的，并且是 <strong><code>一定会执行</code></strong> 的，即使try语句块中的代码出现了异常。</p><p><strong>finally</strong>子句必须和<strong>try</strong>一起出现，不能单独编写。</p><p>通常在finally语句块中完成 **<code>资源的释放/关闭</code>**。</p><h3 id="try-catch-finally之间的关系"><a href="#try-catch-finally之间的关系" class="headerlink" title="try catch finally之间的关系"></a>try catch finally之间的关系</h3><ol><li>try 可以与catch或finally搭配使用，try{}catch{} try{}finally{}</li><li>Catch 不能没有try，它不能单独有。try没有发生异常，catch不会执行</li><li>Finally 也不能没有try，它也不能单独用。</li><li>如果有finally，无论异常是否被catch处理，finally中的语句都会执行，哪怕在catch中有return，finally都会执行</li></ol><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li>如果没有发生异常，则执行try中的语句，不执行catch中的语句，如果有finally，最后还需要执行finally中的语句</li><li>如果出现异常，则try中异常发生后，try块剩下的语句不再执行，将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。因此需要自定义异常</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>编写一个类<strong>继承</strong> <strong><code>Exception</code></strong> 或者 <strong><code>RuntimeException</code></strong>.</li><li>提供两个 <strong><code>构造方法</code><strong>，一个</strong>无参数</strong>的，一个<strong>带有String参数</strong>的。</li></ol><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="comment">//自定义的异常类    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewException</span> <span class="params">(msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种用法：直接在一个判断语句下throw该异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NewException</span>(<span class="string">&quot;我是抛出的新异常！&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种：throws之后，再try——catch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span><span class="keyword">throws</span> NewException&#123;</span><br><span class="line">    <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NewException</span>(<span class="string">&quot;我是抛出的新异常！&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NewException e)&#123;</span><br><span class="line">            System.out,println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="throw-amp-thorows"><a href="#throw-amp-thorows" class="headerlink" title="throw &amp; thorows"></a>throw &amp; thorows</h3><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法生命处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><hr><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p> java是一门面向对象的语言，但是8中基本数据类型不具备面向对象的特征，所以实际使用中很不便所以为java八种基本数据类型提供了对应的包装类。</p><table><thead><tr><th>基本数据类型</th><th>对应包装类</th><th>包装类的父类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr></tbody></table><ol><li>对应包装类比较特殊的就是int对应的Integer和char对应的Character；</li><li>对应包装类的直接父类：前6个由于是数，直接父类为Number，而后两个的直接父类就是Object类；</li></ol><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p>静态方法 valueOf()</p><ul><li><p>参数为基本数据类型，返回包装类对象；</p></li><li><p>参数为String字符串（Character类没有以String为 参数的该方法）,返回包装类对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*1.参数为基本数据类型</span></span><br><span class="line"><span class="comment"> * 作用：将基本数据类型转换为对应包装类 * */</span></span><br><span class="line">Integer i=Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">System.out.println(i);<span class="comment">//输出10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.参数为String字符串时，</span></span><br><span class="line"><span class="comment"> * 作用：返回指定字符串值的包装类对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">Integer a=Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">Integer b=Integer.valueOf(<span class="string">&quot;100a&quot;</span>)为</span><br><span class="line">System.out.println(b);<span class="comment">//运行错误，字符串的值不少一个int类型的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态方法parseXXX(String str)</p><ul><li><p>Character类没有该方法；</p></li><li><p>作用：将字符串装换为对应的基本数据类型（注意此处和上面的valueOf方法返回值的不同）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*作用：将给定字符串装换为对应的基本数据类型</span></span><br><span class="line"><span class="comment"> * 前提是该字符串必须正确描述该基本数据类型表示的值*/</span></span><br><span class="line"><span class="type">int</span> a=Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b=Integer.parseInt(<span class="string">&quot;100a&quot;</span>);</span><br><span class="line">System.out.println(b);<span class="comment">//运行错误，字符串的值不为int类型</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>非静态方法XXXValue()</p><ul><li><p>因为是非静态方法，所以不能像上面两个方法用类名调用了；</p></li><li><p>数字类的包装类（八种包装类中父类是Number的的六个类）才有该方法；</p></li><li><p>作用：将当前包装类对象转换为对应的基本数据类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*作用：将包装类对象转换为对应的基本数据类型*/</span></span><br><span class="line"></span><br><span class="line">Integer a=Integer.valueOf(<span class="number">100</span>);<span class="comment">//将基本数据类型转换为包装类对象</span></span><br><span class="line"><span class="type">int</span> b=a.intValue();<span class="comment">//将包装类对象转换为对应的基本数据类型</span></span><br><span class="line">System.out.println(b);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">Double c=Double.valueOf(<span class="number">2.33</span>);</span><br><span class="line"><span class="type">double</span> d=c.doubleValue();</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>jdk1.5之后的新特性。该特性是编译器认可的，是在编译器自动将基本数据类型和包装类相互转换，节省了麻烦。</p><ol><li><strong>自动拆箱 包装类——&gt;基本数据类型</strong> (原理是调用了xxxValue方法)  </li><li><strong>自动装箱</strong> <strong>基本数据类型——&gt;包装类</strong> (原理是调用了valueOf方法)</li></ol><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*自动装箱：valueOf*/</span></span><br><span class="line">Integer i=<span class="number">123</span>;<span class="comment">//原理是 Integer i=Integer.valueOf(123);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*自动拆箱*/</span></span><br><span class="line"><span class="type">int</span> i1=i+<span class="number">1</span>;<span class="comment">//原理是int i1=i.intValue()+1;</span></span><br><span class="line"></span><br><span class="line">Integer a=<span class="number">123</span>;</span><br><span class="line">Integer b=<span class="number">123</span>;</span><br><span class="line">Integer c=a+b;</span><br><span class="line"><span class="comment">/*原理为Integer c=Integer.valueOf(a.intValue()+b.intValue());*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueOf-源码"><a href="#valueOf-源码" class="headerlink" title="valueOf()源码"></a>valueOf()源码</h3><ul><li>通过按住Ctrl键，鼠标点击该方法即可查看源码，以Integer类的valueOf(int i)的源码为例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>*<em>关于源码的理解：Integer类的valueOf(int i)方法首先会判断i是否在*</em>-128~127**之间，如果在的话，就返回的对象是Integer类中*<em>静态数组*</em>*<em>cache*<em>中的对象，如果不是在这之间，就会重写创建一个新的对象。</em></em></li></ul><p><strong>通过查看其它类的该方法的源码之后，可以得到该表：</strong></p><table><thead><tr><th>包装类</th><th>valueOf（X i）返回对象的原则</th></tr></thead><tbody><tr><td>byte</td><td>直接取，数组范围内（-128，127），且byte值的范围也是（-128，127）</td></tr><tr><td>Shout</td><td>（-128，127）之间在数组中取，否则new</td></tr><tr><td>Integer</td><td>（-128，127）之间在数组中取，否则new</td></tr><tr><td>Long</td><td>（-128，127）之间在数组中取，否则new</td></tr><tr><td>Folut</td><td>直接new</td></tr><tr><td>Double</td><td>直接new</td></tr><tr><td>Boolean</td><td>直接返回，不new</td></tr><tr><td>Character</td><td>0-127之间从数组中取，否则new</td></tr></tbody></table><hr><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><p>String表示<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>类型，属于 **<code>引用数据类型</code>**，不属于基本数据类型。</p></li><li><p>在java中随便使用 <strong><code>双引号括起来</code></strong> 的都是String对象。</p></li><li><p>String对象用于保存字符串，也就是一组字符序列</p></li><li><p>“jack”字符串常量，双引号括起的字符序列</p></li><li><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p></li><li><p>java中规定，双引号括起来的字符串，是 不可变 的，也就是说”abc”自出生到最终死亡，不可变，不能变成”abcd”，也不能变成”ab”</p></li><li><p>在JDK当中双引号括起来的字符串，例如：“abc” “def”都是直接存储在“方法区”的“字符串常量池”当中的。</p></li><li><p>String类有很多构造器，构造器的重载</p></li><li><p>String类实现了</p><ol><li>接口Serializable【String可以串行化：可以在网络传输】</li><li>接口Comparable 【String 对象可以比较大小】</li></ol></li><li><p>String 是final类，不能被其他类继承</p></li><li><p>String 有属性private final char value[]; 用于存放字符串内容</p></li><li><p>value是一个final类型，不可以修改：即value不能指向新的地址，但是单个字符内容是可以变化的</p></li><li><p>为什么SUN公司把字符串存储在一个“字符串常量池”当中呢？</p><p>因为字符串在实际的开发中使用太频繁。为了执行效率，所以把字符串放到了方法区的字符串常量池当中。</p></li></ol><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span> + <span class="string">&quot;xy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析：这是使用new的方式创建的字符串对象。这个代码中的&quot;xy&quot;是从哪里来的？</span></span><br><span class="line">        <span class="comment">// 凡是双引号括起来的都在字符串常量池中有一份。</span></span><br><span class="line">        <span class="comment">// new对象的时候一定在堆内存当中开辟空间。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221013151915385.png" alt="image-20221013151915385"></p><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// &quot;hello&quot;是存储在方法区的字符串常量池当中</span></span><br><span class="line">        <span class="comment">// 所以这个&quot;hello&quot;不会新建。（因为这个对象已经存在了！）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// == 双等号比较的是变量中保存的内存地址</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// == 双等号比较的是变量中保存的内存地址</span></span><br><span class="line">        System.out.println(x == y); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221013152046138.png" alt="image-20221013152046138"></p><h3 id="实例化两种方式"><a href="#实例化两种方式" class="headerlink" title="实例化两种方式"></a>实例化两种方式</h3><ol><li><p>通过字面量定义的方式</p><ol><li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;通过字面量定义的方式:此时数据abc声明在方法区中的字符串常量池中<br>    String s1&#x3D;”abc”;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 通过new + 构造器() 的方式</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      //通过new+构造器的方式: 此时s1保存的地址值，是数据在堆空间中开辟以后对应的地址值</span><br><span class="line">              String s1 = new String(&quot;abc&quot;);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221018155302762.png" alt="image-20221018155302762"></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th>构造方法名</th><th>eg。</th></tr></thead><tbody><tr><td>String s &#x3D; “xxx”</td><td>最常用</td></tr><tr><td>String(String original)</td><td>String(“xxx”)</td></tr><tr><td>String(char数组)</td><td></td></tr><tr><td>String(char数组，起始下标，长度)</td><td></td></tr><tr><td>String(byte数组)</td><td></td></tr><tr><td>String(byte数组，起始下标，长度)</td><td></td></tr><tr><td>String(StringBuffer buffer)</td><td></td></tr><tr><td>String(StringBuilder builder)</td><td></td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//最常用的方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;我是中国人&quot;</span>;</span><br><span class="line">        System.out.println(s1);<span class="comment">//我是中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我是中国人&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">//我是中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;我&#x27;</span> , <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;果&#x27;</span>, <span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        System.out.println(s3);<span class="comment">//我是中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s4);<span class="comment">//中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = &#123;<span class="number">65</span>, <span class="number">66</span> ,<span class="number">67</span>, <span class="number">68</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">        System.out.println(s5);<span class="comment">//ABCD</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(s6);<span class="comment">//BC</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我是福建人&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);</span><br><span class="line">        System.out.println(s7);<span class="comment">//我是福建人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;我是厦门人&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb2);</span><br><span class="line">        System.out.println(s8);<span class="comment">//我是厦门人</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>char charAt(int index)</td><td>返回指定位置的字符</td></tr><tr><td>int compareTo(String anotherString)</td><td>比较两个字符串，相等返回0，前大后小返回1，前小后大返回-1</td></tr><tr><td>boolean contains(CharSequence s)</td><td>判断字符串是否包含s</td></tr><tr><td>boolean endsWith(String suffix)</td><td>判断字符串是否以suffix结尾</td></tr><tr><td>boolean equals(Object anObject)</td><td>判断两个串是否相等</td></tr><tr><td>boolean equalsIgnoreCase(String anotherString)</td><td>忽略大小写判断两个串是否相等</td></tr><tr><td>byte[] getBytes()</td><td>将字符串串变成字节数组返回</td></tr><tr><td>int indexOf(String str)</td><td>返回str在字符串第一次出现的位置</td></tr><tr><td>boolean isEmpty()</td><td>字符串是否为空</td></tr><tr><td>int length()</td><td>字符串长度</td></tr><tr><td>int lastIndexOf(String str)</td><td>返回str最后一次出现的位置</td></tr><tr><td>String replace(CharSequence target, CharSequence replacement)</td><td>用replacement替换字符串target的字符</td></tr><tr><td>String[] split(String regex)</td><td>将字符串以regex分割</td></tr><tr><td>boolean startsWith(String prefix)</td><td>判断字符串是否以prefix开始</td></tr><tr><td>String substring(int beginIndex)</td><td>从beginIndex开始截取字串</td></tr><tr><td>String substring(int beginIndex, int endIndex)</td><td>截取beginIndex到endIndex - 1的字符串</td></tr><tr><td>char[] toCharArray()</td><td>将字符串转换乘char数组</td></tr><tr><td>String toLowerCase()</td><td>字符串转小写</td></tr><tr><td>String toUpperCase()</td><td>字符串转大写</td></tr><tr><td>String trim()</td><td>去除字符串两边空格</td></tr><tr><td>静态方法</td><td></td></tr><tr><td>static String valueOf(int i)</td><td>将 i 转换成字符串</td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.charAt(<span class="number">6</span>));<span class="comment">//w</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">        System.out.println(s2.compareTo(s3));<span class="comment">//-23</span></span><br><span class="line">        System.out.println(s3.compareTo(s4));<span class="comment">//0</span></span><br><span class="line">        System.out.println(s4.compareTo(s1));<span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2.equals(s3));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;world&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;t&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;HELLO worLD&quot;</span>;</span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s5));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = s1.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(b));<span class="comment">//[104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;world&quot;</span>));<span class="comment">//6</span></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;h&quot;</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.length());<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javapythonc++cphpjavapython&quot;</span>;</span><br><span class="line">        System.out.println(s6.lastIndexOf(<span class="string">&quot;java&quot;</span>));<span class="comment">//17</span></span><br><span class="line">        System.out.println(s6.lastIndexOf(<span class="string">&quot;h&quot;</span>));<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;name=zhangsan&amp;age=18&amp;sex=男&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newS7</span> <span class="operator">=</span> s7.replace(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        System.out.println(newS7);<span class="comment">//name=zhangsan;age=18;sex=男</span></span><br><span class="line"></span><br><span class="line">        String[] splitS7 = s7.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(splitS7));<span class="comment">//[name=zhangsan, age=18, sex=男]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s6.startsWith(<span class="string">&quot;java&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s6.startsWith(<span class="string">&quot;python&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s6.substring(<span class="number">10</span>));<span class="comment">//c++cphpjavapython</span></span><br><span class="line">        System.out.println(s6.substring(<span class="number">10</span>, <span class="number">13</span>));<span class="comment">//c++</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charS6 = s6.toCharArray();</span><br><span class="line">        System.out.println(Arrays.toString(charS6));<span class="comment">//[j, a, v, a, p, y, t, h, o, n, c, +, +, c, p, h, p, j, a, v, a, p, y, t, h, o, n]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s6.toUpperCase());<span class="comment">//JAVAPYTHONC++CPHPJAVAPYTHON</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s5.toLowerCase());<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;           你 好 世 界                   &quot;</span>;</span><br><span class="line">        System.out.println(s8.trim());<span class="comment">//你 好 世 界</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.valueOf(<span class="number">123</span>));<span class="comment">//123</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="number">3.14</span>));<span class="comment">//3.14</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="literal">true</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()));<span class="comment">//java.lang.Object@4554617c</span></span><br><span class="line">        <span class="comment">//valueOf会自动调用toString()方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>在JAVA中，字符串使用String类进行表示，虽然针对String直接操作很方便，但是由于字符串变量声明后不可改变，能改变的只是字符串对象的指向。换言之，不同的字符串常量会占用不同的内存空间，而在频繁修改的字符串操作上，不适用String类型，此时可以使用StringBuffer类型。也就是说该类型方便用户进行内容的修改</p><p>基本介绍</p><ol><li><p>StringBuffer的直接父类是AbstractStringBuilder</p></li><li><p>StringBuffer实现了Serializable 即StringBuffer的对象可以串行化</p></li><li><p>在父类中 AbstractStringBuilder 有属性 char[] value,不是final</p><p>在该value数组存放字符串内容,引出存放在堆中的</p></li><li><p>StringBuffer 是一个final类 不能被继承</p></li><li><p>StringBuffer是存放在 char[] value ,所有的变化 不用每次创建新对象,更换地址所以效率高于String</p></li></ol><h4 id="StringBuffer与String的区别："><a href="#StringBuffer与String的区别：" class="headerlink" title="StringBuffer与String的区别："></a>StringBuffer与String的区别：</h4><ol><li>StringBuffer的内容和长度都是可以改变的，String却不可以。</li><li>String创建每一个字符串都会在常量池开辟一个新的空间。而StringBuffer会提前给出容量，可以重新进行字符串拼接，而不会重新开辟空间。</li></ol><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>public StringBuffer();构造一个没有字符的字符串缓冲区，初始容量为16字符。</p><p>public StringBuffer(int capacity);构造一个没有字符的字符串缓冲区和指定的初始容量。</p><p>public StringBuffer(String str);构造一个初始化为指定内容的字符串缓冲区。</p><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.one;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public StringBuffer()  构造一个没有字符的字符串缓冲区，初始容量为16个字符。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;sb1:&quot;</span> + sb1); <span class="comment">//StringBuffer重写了toString方法</span></span><br><span class="line">        <span class="comment">//如何获取StringBuffer的容量</span></span><br><span class="line">        <span class="comment">//public int capacity()返回当前容量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前StringBuffer的容量为：&quot;</span> + sb1.capacity());</span><br><span class="line">        <span class="comment">//public int length()返回长度（字符数）。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb1.length());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line">        <span class="comment">//public StringBuffer(int capacity)  构造一个没有字符的字符串缓冲区和指定的初始容量。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span> + sb2); <span class="comment">//StringBuffer重写了toString方法</span></span><br><span class="line">        <span class="comment">//如何获取StringBuffer的容量</span></span><br><span class="line">        <span class="comment">//public int capacity()返回当前容量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前StringBuffer的容量为：&quot;</span> + sb2.capacity());</span><br><span class="line">        <span class="comment">//public int length()返回长度（字符数）。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb2.length());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line">        <span class="comment">//public StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb3:&quot;</span> + sb3); <span class="comment">//StringBuffer重写了toString方法</span></span><br><span class="line">        <span class="comment">//如何获取StringBuffer的容量</span></span><br><span class="line">        <span class="comment">//public int capacity()返回当前容量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前StringBuffer的容量为：&quot;</span> + sb3.capacity()); <span class="comment">// 21 = 16 + 5</span></span><br><span class="line">        <span class="comment">//public int length()返回长度（字符数）。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb3.length()); <span class="comment">// 5</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><blockquote><p>首先我们需要创建一个StringBuffer对象</p><p>可以有初始值</p><p>添加语法:StringBuffer对象.append(插入的string值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello,&quot;</span>)</span><br><span class="line">string.append(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="comment">//输出为  hello,world</span></span><br><span class="line"><span class="comment">//添加多个可以直接 append.append.append</span></span><br><span class="line">string.append(<span class="string">&quot;good&quot;</span>).append(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="comment">//输出  hello,worldgoodtrue</span></span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><blockquote><p>删除是删除开始索引到结束索引位置的 注意不包含结束索引值</p><p>语法:StringBuffer对象.delete(开始索引,结束索引)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.delete(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出为 ho,worldgoodtrue    </span></span><br></pre></td></tr></table></figure><blockquote><p>在hello中的o是第四个索引位置 并没有删除这里可以看出删除并不包含结束索引值 这是一个典型的左闭右开原则</p></blockquote><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><blockquote><p>替换也是一个典型的左闭右开原则</p><p>语法: StringBuffer对象.replace(开始索引,结束索引,替换掉的新值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&quot;java&quot;</span>)</span><br><span class="line"><span class="comment">//输出结果  javaworldgoodtrue</span></span><br></pre></td></tr></table></figure><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><blockquote><p>插入可以在指定位置索引插入内容,比如说有一个String 内容为abcd 但是我们想变成aocd 是不是很麻烦这时候发现还是StringBuffer类好用</p><p>语法:StringBuffer对象.inert(要插入的索引位置,插入的值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.inert(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//结果为hellojavaworldgoodtrue</span></span><br></pre></td></tr></table></figure><blockquote><p>上面我们在索引为0的位置插入了hello但是小伙伴们会发现j是索引为0的位置并没有被替换掉这是因为字符在插入时会自动向后移并不会消失</p></blockquote><h5 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h5><blockquote><p>StringBuffer对象.length()</p><p>返回一个StringBuffer对象内字符长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string在上面结果为hellojavaworldgoodtrue</span></span><br><span class="line">string.length()</span><br><span class="line"><span class="comment">//打印结果为22</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</strong></p><p>此类提供一个与StringBuffer兼容的API，但不保证同步，该类被设计用作，StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用，建议优先采用该类，因为在大多数实现中，他比StringBuffer更快</p><h3 id="StringBuffer实现线程安全方式："><a href="#StringBuffer实现线程安全方式：" class="headerlink" title="StringBuffer实现线程安全方式："></a>StringBuffer实现线程安全方式：</h3><p>StringBuffer类中实现的方法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019112232577.png" alt="StringBuffer类中实现的方法"></p><p>StringBuilder类中实现的方法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019112307896.png" alt="StringBuilder类中实现的方法"></p><p>由此可见，StringBuffer类中的方法都添加了<strong>synchronized关键字</strong>，也就是给这个方法添加了一个锁，用来保证线程安全。</p><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><p>当<strong>对字符串进行修改</strong>的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且<strong>不产生新的未使用对象</strong>。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><p><strong>三者的继承结构</strong></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019112954081.png" alt="image-20221019112954081"></p><ul><li>String：不可变字符序列</li><li>StringBuffer：可变字符序列，效率低，线程安全</li><li>StringBuilder：可变字符序列，效率高，线程不安全</li></ul><h3 id="String-StringBuffer-StringBuilder的选择"><a href="#String-StringBuffer-StringBuilder的选择" class="headerlink" title="String,StringBuffer,StringBuilder的选择"></a>String,StringBuffer,StringBuilder的选择</h3><ol><li>如果字符串存在大量的修改操作，一般使用StringBuffer和StringBuilder</li><li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li><li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li><li>如果字符串很少修改，被多个对象引用，使用String，比如配置信息等</li></ol><hr><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p><a href="http://c.biancheng.net/java/">Java</a> 中的 +、-、*、&#x2F; 和 % 等基本算术运算符不能进行更复杂的数学运算，例如，三角函数、对数运算、指数运算等。于是 Java 提供了 Math 工具类来完成这些复杂的运算。</p><p>在 Java 中 Math 类封装了常用的数学运算，提供了基本的数学操作，如指数、对数、平方根和三角函数等。Math 类位于 java.lang 包，它的构造方法是 private 的，因此无法创建 Math 类的对象，并且 Math 类中的所有方法都是类方法，可以直接通过类名来调用它们。</p><h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>Math 类中包含 E 和 PI 两个静态常量，正如它们名字所暗示的，它们的值分别等于 e（自然对数）和 π（圆周率）。</p><h4 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h4><p>调用 Math 类的 E 和 PI 两个常量，并将结果输出。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;E 常量的值：&quot;</span> + Math.E);System.out.println(<span class="string">&quot;PI 常量的值：&quot;</span> + Math.PI);</span><br></pre></td></tr></table></figure><p>执行上述代码，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E 常量的值：<span class="number">2.718281828459045</span></span><br><span class="line">PI 常量的值：<span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><h3 id="求最大值、最小值和绝对值"><a href="#求最大值、最小值和绝对值" class="headerlink" title="求最大值、最小值和绝对值"></a>求最大值、最小值和绝对值</h3><p>在程序中常见的就是求最大值、最小值和绝对值问题，如果使用 Math 类提供的方法可以很容易实现。这些方法的说明如下所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static int abs(int a)</td><td>返回 a 的绝对值</td></tr><tr><td>static long abs(long a)</td><td>返回 a 的绝对值</td></tr><tr><td>static float abs(float a)</td><td>返回 a 的绝对值</td></tr><tr><td>static double abs(double a)</td><td>返回 a 的绝对值</td></tr><tr><td>static int max(int x,int y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static double max(double x,double y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static long max(long x,long y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static float max(float x,float y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static int min(int x,int y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static long min(long x,long y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static double min(double x,double y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static float min(float x,float y)</td><td>返回 x 和 y 中的最小值</td></tr></tbody></table><h4 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h4><p>求 10 和 20 的较大值、15.6 和 15 的较小值、-12 的绝对值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test02 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;10 和 20 的较大值：&quot; + Math.max(10, 20));        System.out.println(&quot;15.6 和 15 的较小值：&quot; + Math.min(15.6, 15));        System.out.println(&quot;-12 的绝对值：&quot; + Math.abs(-12));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10和20的较大值：20</span><br><span class="line">15.6和15的较小值：15.0</span><br><span class="line">-12的绝对值：12</span><br></pre></td></tr></table></figure><h3 id="求整运算"><a href="#求整运算" class="headerlink" title="求整运算"></a>求整运算</h3><p>Math 类的求整方法有很多，详细说明如表 2 所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double ceil(double a)</td><td>返回大于或等于 a 的最小整数</td></tr><tr><td>static double floor(double a)</td><td>返回小于或等于 a 的最大整数</td></tr><tr><td>static double rint(double a)</td><td>返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数</td></tr><tr><td>static int round(float a)</td><td>将参数加上 1&#x2F;2 后返回与参数最近的整数</td></tr><tr><td>static long round(double a)</td><td>将参数加上 1&#x2F;2 后返回与参数最近的整数，然后强制转换为长整型</td></tr></tbody></table><h4 id="eg-2"><a href="#eg-2" class="headerlink" title="eg"></a>eg</h4><p>下面的实例演示了 Math 类中取整函数方法的应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;public class Test03 &#123;    public static void main(String[] args) &#123;        Scanner input = new Scanner(System.in);        System.outprintln(&quot;请输入一个数字：&quot;);        double num = input.nextDouble();        System.out.println(&quot;大于或等于 &quot;+ num +&quot; 的最小整数：&quot; + Math.ceil(num));        System.out.println(&quot;小于或等于 &quot;+ num +&quot; 的最大整数：&quot; + Math.floor(num));        System.out.println(&quot;将 &quot;+ num +&quot; 加上 0.5 之后最接近的整数：&quot; + Math.round(num));        System.out.println(&quot;最接近 &quot;+num+&quot; 的整数：&quot; + Math.rint(num));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入一个数字：</span><br><span class="line">99.01</span><br><span class="line">大于或等于 99.01 的最小整数：100.0</span><br><span class="line">小于或等于 99.01 的最大整数：99.0</span><br><span class="line">将 99.01 加上 0.5 之后最接近的整数：100</span><br><span class="line">最接近 99.01 的整数：99.0</span><br></pre></td></tr></table></figure><h3 id="三角函数运算"><a href="#三角函数运算" class="headerlink" title="三角函数运算"></a>三角函数运算</h3><p>Math 类中包含的三角函数方法及其说明如表 3 所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double sin(double a)</td><td>返回角的三角正弦值，参数以孤度为单位</td></tr><tr><td>static double cos(double a)</td><td>返回角的三角余弦值，参数以孤度为单位</td></tr><tr><td>static double asin(double a)</td><td>返回一个值的反正弦值，参数域在 [-1,1]，值域在 [-PI&#x2F;2,PI&#x2F;2]</td></tr><tr><td>static double acos(double a)</td><td>返回一个值的反余弦值，参数域在 [-1,1]，值域在 [0.0,PI]</td></tr><tr><td>static double tan(double a)</td><td>返回角的三角正切值，参数以弧度为单位</td></tr><tr><td>static double atan(double a)</td><td>返回一个值的反正切值，值域在 [-PI&#x2F;2,PI&#x2F;2]</td></tr><tr><td>static double toDegrees(double angrad)</td><td>将用孤度表示的角转换为近似相等的用角度表示的角</td></tr><tr><td>staticdouble toRadians(double angdeg)</td><td>将用角度表示的角转换为近似相等的用弧度表示的角</td></tr></tbody></table><p>在表 3 中，每个方法的参数和返回值都是 double 类型，参数以弧度代替角度来实现，其中 1 度等于 π&#x2F;180 弧度，因此平角就是 π 弧度。</p><h4 id="eg-3"><a href="#eg-3" class="headerlink" title="eg"></a>eg</h4><p>计算 90 度的正弦值、0 度的余弦值、1 的反正切值、120 度的弧度值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test04 &#123;    public static void main(String[] args) &#123;        System.out.println&#123;&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));        System.out.println(&quot;0 度的余弦值：&quot; + Math.cos(0));        System.out.println(&quot;1 的反正切值：&quot; + Math.atan(l));        System.out.println(&quot;120 度的弧度值：&quot; + Math.toRadians(120.0));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，因为 Math.sin() 中的参数的单位是弧度，而 90 度表示的是角度，因此需要将 90 度转换为弧度，即 Math.PI&#x2F;180*90，故转换后的弧度为 Math.PI&#x2F;2，然后调用 Math 类中的 sin() 方法计算其正弦值。</p><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">90 度的正弦值：1.0</span><br><span class="line">0 的余弦值：1.0</span><br><span class="line">1 的反正切值：0.7853981633974483</span><br><span class="line">120 度的弧度值：2.0943951023931953</span><br></pre></td></tr></table></figure><h3 id="指数运算"><a href="#指数运算" class="headerlink" title="指数运算"></a>指数运算</h3><p>指数的运算包括求方根、取对数及其求 n 次方的运算。在 Math 类中定义的指数运算方法及其说明如表 4 所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double exp(double a)</td><td>返回 e 的 a 次幂</td></tr><tr><td>static double pow(double a,double b)</td><td>返回以 a 为底数，以 b 为指数的幂值</td></tr><tr><td>static double sqrt(double a)</td><td>返回 a 的平方根</td></tr><tr><td>static double cbrt(double a)</td><td>返回 a 的立方根</td></tr><tr><td>static double log(double a)</td><td>返回 a 的自然对数，即 lna 的值</td></tr><tr><td>static double log10(double a)</td><td>返回以 10 为底 a 的对数</td></tr></tbody></table><h4 id="eg-4"><a href="#eg-4" class="headerlink" title="eg"></a>eg</h4><p>使用 Math 类中的方法实现指数的运算，main() 方法中的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test05 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;4 的立方值：&quot; + Math.pow(4, 3));        System.out.println(&quot;16 的平方根：&quot; + Math.sqrt(16));        System.out.println(&quot;10 为底 2 的对数：&quot; + Math.log1O(2));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 的立方值：64.0</span><br><span class="line">16 的平方根：4.0</span><br><span class="line">10 为底 2 的对数：0.3010299956639812</span><br></pre></td></tr></table></figure><hr><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays的常用方法那肯定是在Arrays类内了，所以导包：java.util.Arrays;</p><p>Arrays是针对<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>的工具类，可以进行复制、排序、查找等功能，大大提高了开发人员的工作效率</p><table><thead><tr><th>返回类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>toString(array)</td><td>将数组array转换成字符串</td></tr><tr><td>void</td><td>sort(array)</td><td>对数组进行排序，</td></tr><tr><td>void</td><td>fill(arr,val)</td><td>将数组arr全部元素赋值为val</td></tr><tr><td>boolean</td><td>equals(arr1,arr2)</td><td>判断两个数组是否相等</td></tr><tr><td>与arr类型相同</td><td>copyOf(arr,length)</td><td>将数组arr复制成一个长度为length的新数组</td></tr><tr><td>int</td><td>binarySearch(ary,val)</td><td>查询元素val在arr中的下标值</td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[]=&#123;<span class="number">12</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>,<span class="number">72</span>,<span class="number">26</span>,<span class="number">35</span>,<span class="number">10</span>,<span class="number">46</span>,<span class="number">26</span>,<span class="number">53</span>&#125;;</span><br><span class="line">        <span class="type">int</span> b[]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> c[]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        String str=Arrays.toString(a);       <span class="comment">//将特定数组转换成字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串：&quot;</span>+str);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(a);                      <span class="comment">//对数组array的元素进行升序排列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>+Arrays.toString(a)); </span><br><span class="line">        </span><br><span class="line">        Arrays.fill(a,<span class="number">10</span>);                   <span class="comment">//所以元素都赋值成特定值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;赋值后：&quot;</span>+Arrays.toString(a)); </span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> boo=Arrays.equals(a,b);      <span class="comment">//判断两个数组是否相等(对应位置上的元素是否相等)</span></span><br><span class="line">        <span class="type">boolean</span> boo2=Arrays.equals(b, c);</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span>+b);</span><br><span class="line">        System.out.println(<span class="string">&quot;c:&quot;</span>+c);</span><br><span class="line">        System.out.println(<span class="string">&quot;ab相等？&quot;</span>+boo);</span><br><span class="line">        System.out.println(<span class="string">&quot;bc相等？&quot;</span>+boo2);</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> d[]=Arrays.copyOf(b,b.length);   <span class="comment">//把数组复制成特定长度的数组,与直接赋值（引用传递）不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:&quot;</span>+Arrays.toString(d));</span><br><span class="line">        System.out.println(<span class="string">&quot;d:&quot;</span>+d);</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span>+b);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i=Arrays.binarySearch(b, <span class="number">5</span>);     <span class="comment">//查询特定因素在数组中的下标</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下标是：&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019163526751.png" alt="image-20221019163526751"></p><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>System类位于java.lang包，代表当前Java程序的运行平台，系统级的很多属性和控制方法都放置在该类的内部。</p><p>  由于该类的<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">构造方法</a>是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员方法和成员变量都是static（静态）的，所以也可以很方便的调用他。</p><p>  system中包含了in、out和err三个成员变量，分别代表标准输入流（键盘输入）、标准输出流（显示器）和标准错误输出流（显示器）</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>System类有3个静态成员变量，分别是PrintStream out，InputStream in 和 PrintStream err。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in;</span><br><span class="line"><span class="comment">//标准输入流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out;</span><br><span class="line"><span class="comment">//标准输出流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err;</span><br><span class="line"><span class="comment">//标准错误流</span></span><br></pre></td></tr></table></figure><h4 id="PrintStream-out"><a href="#PrintStream-out" class="headerlink" title="PrintStream out"></a>PrintStream out</h4><p>标准输出流。此流已打开并准备接收输出数据。通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。</p><p>例如，编写一行输出数据的典型方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(data);</span><br></pre></td></tr></table></figure><p>其中，println 方法是属于流类 PrintStream 的方法，而不是 System 中的方法。</p><h4 id="InputStream-in"><a href="#InputStream-in" class="headerlink" title="InputStream in"></a>InputStream in</h4><p>标准输入流。此流已打开并准备提供输入数据。通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。</p><h4 id="PrintStream-err"><a href="#PrintStream-err" class="headerlink" title="PrintStream err"></a>PrintStream err</h4><p>标准的错误输出流。其语法与 System.out 类似，不需要提供参数就可输出错误信息。也可以用来输出用户指定的其他信息，包括变量的值。</p><h3 id="System-类的成员方法"><a href="#System-类的成员方法" class="headerlink" title="System 类的成员方法"></a>System 类的成员方法</h3><p>System 类中提供了一些系统级的操作方法，常用的方法有 arraycopy()、currentTimeMillis()、exit()、gc() 和 getProperty()。</p><h4 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy()"></a>arraycopy()</h4><p>该方法的作用是数组复制，即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。该方法的具体定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,<span class="type">int</span> srcPos,Object dest,<span class="type">int</span> destPos,<span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure><p>其中，src 表示源数组，srcPos 表示从源数组中复制的起始位置，dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。</p><p>下面的示例代码演示了 arraycopy() 方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_arrayCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] srcArray = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[] destArray = &#123;<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">        System.arraycopy(srcArray,<span class="number">1</span>,destArray,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;源数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; srcArray.length;i++) &#123;</span><br><span class="line">            System.out.println(srcArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; destArray.length;j++) &#123;</span><br><span class="line">            System.out.println(destArray[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，将数组 srcArray 中，从下标 1 开始的数据复制到数组 destArray 从下标 1 开始的位置，总共复制两个。也就是将 srcArray[1] 复制给 destArray[1]，将 srcArray[2] 复制给 destArray[2]。这样经过复制之后，数组 srcArray 中的元素不发生变化，而数组 destArray 中的元素将变为 E、B、C、 H，下面为输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源数组：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">//D</span></span><br><span class="line"><span class="comment">//目标数组：</span></span><br><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">//H</span></span><br></pre></td></tr></table></figure><h4 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h4><p>该方法的作用是返回当前的计算机时间，时间的格式为当前计算机时间与 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒所差的毫秒数。一般用它来测试程序的执行时间。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure><p>上述语句将获得一个长整型的数字，该数字就是以差值表达的当前时间。</p><p>使用 currentTimeMillis() 方法来显示时间不够直观，但是可以很方便地进行时间计算。例如，计算程序运行需要的时间就可以使用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_currentTimeMillis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000000</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行时间&quot;</span> + time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的变量 time 的值表示代码中 for 循环执行所需要的毫秒数，使用这种方法可以测试不同算法的程序的执行效率高低，也可以用于后期线程控制时的精确延时实现。</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h4><p> 退出虚拟机。exit(int)方法是终止当前正在运行的java虚拟机。参数是状态码。根据惯例，非0的状态码表示异常终止，0表是终止。而且，该方法永远不会正常返回。具体的定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure><p>其中，status 的值为 0 时表示正常退出，非零时表示异常退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is try&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是唯一一个能够退出程序并不执行finally的情况。说明：退出虚拟机会直接终止整个程序，这时的程序已经不是从代码的层面来终止程序，所以finally不会被执行。</p><h4 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h4><p>该方法的作用是请求系统进行垃圾回收，完成内存中的垃圾清除。至于系统是否立刻回收，取决于系统中垃圾回收算法的实现以及系统执行时的情况。定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="getProperty"><a href="#getProperty" class="headerlink" title="getProperty()"></a>getProperty()</h4><p>该方法的作用是获得系统中属性名为 key 的属性对应的值，具体的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure><p>系统中常见的属性名以及属性的说明如表所示</p><table><thead><tr><th>属性名</th><th>属性说明</th></tr></thead><tbody><tr><td>java.version</td><td>Java 运行时环境版本</td></tr><tr><td>java.home</td><td>Java 安装目录</td></tr><tr><td>os.name</td><td>操作系统的名称</td></tr><tr><td>os.version</td><td>操作系统的版本</td></tr><tr><td>user.name</td><td>用户的账户名称</td></tr><tr><td>user.home</td><td>用户的主目录</td></tr><tr><td>user.dir</td><td>用户的当前工作目录</td></tr></tbody></table><p>下面的示例演示了 getProperty() 方法的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_getProperty</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jversion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">oName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Java 运行时环境版本：&quot;</span>+jversion);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前操作系统是：&quot;</span>+oName);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前用户是：&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，输出结果如下（结果为我自己的运行环境）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 运行时环境版本：<span class="number">1.8</span><span class="number">.0_121</span></span><br><span class="line">当前操作系统是：Windows <span class="number">10</span></span><br><span class="line">当前用户是：Unfall</span><br></pre></td></tr></table></figure><h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>在 Java 中，有许多数字处理的类，比如 Integer类，但是Integer类有一定的局限性。</p><p>我们都知道 Integer 是 Int 的包装类，int 的最大值为 2^31-1。若希望描述更大的整数数据时，使用Integer 数据类型就无法实现了，所以Java中提供了BigInteger 类。</p><p>BigInteger类型的数字范围较Integer，Long类型的数字范围要大得多，它支持任意精度的整数，也就是说在运算中 BigInteger 类型可以准确地表示任何大小的整数值而不会丢失任何信息。</p><h3 id="读入方法"><a href="#读入方法" class="headerlink" title="读入方法"></a>读入方法</h3><p>nextBigInteger()：控制台读入一个BigInteger型数据，类似于int型的nextInt()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读入方法：nextBigInteger()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">// 读入</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt(); <span class="comment">// 读入一个int;</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextBigInteger();<span class="comment">// 读入一个BigInteger;</span></span><br><span class="line"><span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;scan.hasNext()=&quot;</span> + scan.hasNext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p>默认为十进制，也是我们最常用的，同时也支持自定义进制类型（已存在的）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进制转换</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScale</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//在构造将函数时，把radix进制的字符串转化为BigInteger</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1011100111&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">interNum1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(str,radix);<span class="comment">//743</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通常不写，则是默认成10进制转换，如下：</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">interNum2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(str);<span class="comment">//1011100111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>返回值为BigInteger类型：add()，subtract()，multiply()，divide()，mod()，remainder()，pow()，abs()，negate()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本运算:add(),subtract(),multiply(),divide(),mod(),remainder(),pow(),abs(),negate()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBasic</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.加</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> a.add(b);<span class="comment">//17</span></span><br><span class="line"><span class="comment">//2.减</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> a.subtract(b);<span class="comment">//9</span></span><br><span class="line"><span class="comment">//3.乘</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum3</span> <span class="operator">=</span> a.multiply(b);<span class="comment">//52</span></span><br><span class="line"><span class="comment">//4.除</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum4</span> <span class="operator">=</span> a.divide(b);<span class="comment">//3</span></span><br><span class="line"><span class="comment">//5.取模(需 b &gt; 0，否则出现异常：ArithmeticException(&quot;BigInteger: modulus not positive&quot;))</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum5</span> <span class="operator">=</span> a.mod(b);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//6.求余</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum6</span> <span class="operator">=</span> a.remainder(b);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//7.平方(需 n &gt;= 0，否则出现异常：ArithmeticException(&quot;Negative exponent&quot;))</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum7</span> <span class="operator">=</span> a.pow(n);<span class="comment">//2197</span></span><br><span class="line"><span class="comment">//8.取绝对值</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum8</span> <span class="operator">=</span> a.abs();<span class="comment">//13</span></span><br><span class="line"><span class="comment">//9.取相反数</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum9</span> <span class="operator">=</span> a.negate();<span class="comment">//-13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><p>compareTo()返回一个int型数据：1 大于； 0 等于； -1 小于；<br>max()，min()：分别返回大的（小的）那个BigInteger数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较大小:compareTo(),max(),min()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;52&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;27&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.compareTo()：返回一个int型数据（1 大于； 0 等于； -1 小于）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> bigNum1.compareTo(bigNum2);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.max()：直接返回大的那个数，类型为BigInteger</span></span><br><span class="line"><span class="comment">//原理：return (compareTo(val) &gt; 0 ? this : val);</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">compareMax</span> <span class="operator">=</span> bigNum1.max(bigNum2);<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.min()：直接返回小的那个数，类型为BigInteger</span></span><br><span class="line"><span class="comment">//原理：return (compareTo(val) &lt; 0 ? this : val);</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">compareMin</span> <span class="operator">=</span> bigNum1.min(bigNum2);<span class="comment">//27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量<br>ZERO，ONE，TEN 返回值为BigInteger类型：有朋友提到的-1，2，源码注释里面已表明不再输出(Not exported.)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量(返回BigInteger类型)</span></span><br><span class="line"><span class="comment">//有朋友提到的-1和2，源码注释里面已表明不再输出(Not exported.)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFinalNum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">zero</span> <span class="operator">=</span> BigInteger.ZERO;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">one</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">ten</span> <span class="operator">=</span> BigInteger.TEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型转换<br>将BigInteger数据转换成基本数据类型，还可以转换成radix进制的字符串形式；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型转换(返回类型如下)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToAnother</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;52&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.转换为bigNum的二进制补码形式</span></span><br><span class="line"><span class="type">byte</span>[] num1 = bigNum.toByteArray();</span><br><span class="line"><span class="comment">//2.转换为bigNum的十进制字符串形式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">num2</span> <span class="operator">=</span> bigNum.toString();<span class="comment">//52</span></span><br><span class="line"><span class="comment">//3.转换为bigNum的radix进制字符串形式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">num3</span> <span class="operator">=</span> bigNum.toString(radix);<span class="comment">//110100</span></span><br><span class="line"><span class="comment">//4.将bigNum转换为int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> bigNum.intValue();</span><br><span class="line"><span class="comment">//5.将bigNum转换为long</span></span><br><span class="line"><span class="type">long</span> <span class="variable">num5</span> <span class="operator">=</span> bigNum.longValue();</span><br><span class="line"><span class="comment">//6.将bigNum转换为float</span></span><br><span class="line"><span class="type">float</span> <span class="variable">num6</span> <span class="operator">=</span> bigNum.floatValue();</span><br><span class="line"><span class="comment">//7.将bigNum转换为double</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num7</span> <span class="operator">=</span> bigNum.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制运算<br>返回值为BigInteger类型，此类方法不常用，有备无患；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制运算(返回类型都为BigInteger，不常用，但有备无患)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBinaryOperation</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.与：a&amp;b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> a.and(b);<span class="comment">//0</span></span><br><span class="line"><span class="comment">//2.或：a|b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> a.or(b);<span class="comment">//15</span></span><br><span class="line"><span class="comment">//3.异或：a^b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum3</span> <span class="operator">=</span> a.xor(b);<span class="comment">//15</span></span><br><span class="line"><span class="comment">//4.取反：~a</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum4</span> <span class="operator">=</span> a.not();<span class="comment">//-14</span></span><br><span class="line"><span class="comment">//5.左移n位： (a &lt;&lt; n)</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum5</span> <span class="operator">=</span> a.shiftLeft(n);<span class="comment">//26</span></span><br><span class="line"><span class="comment">//6.右移n位： (a &gt;&gt; n)</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum6</span> <span class="operator">=</span> a.shiftRight(n);<span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限控制<br>setBit()，testBit()：可用于菜单的权限控制，非常好用，原理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//权限控制：setBit(),testBit()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetAndTest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//1.封装数据(setBit的值需 &gt;= 0，否则出现异常：ArithmeticException(&quot;Negative bit address&quot;))</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">permission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">numBig</span> <span class="operator">=</span> permission.setBit(<span class="number">2</span>);</span><br><span class="line">numBig = numBig.setBit(<span class="number">5</span>);</span><br><span class="line">numBig = numBig.setBit(<span class="number">13</span>);</span><br><span class="line">numBig = numBig.setBit(<span class="number">66</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原理：&quot;</span> + numBig);</span><br><span class="line"><span class="comment">// 原理：73786976294838214692 = 2^2+2^5+2^13+2^66 次方的和；</span></span><br><span class="line"><span class="comment">// 看！！即使这么大的数也不会溢出，而int最大值只有2147483647；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.取值验证（返回Boolean型）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> numBig.testBit(<span class="number">2</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> numBig.testBit(<span class="number">5</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag3</span> <span class="operator">=</span> numBig.testBit(<span class="number">13</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag4</span> <span class="operator">=</span> numBig.testBit(<span class="number">66</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag5</span> <span class="operator">=</span> numBig.testBit(<span class="number">27</span>);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析<br>setBit()：将set进去变量作为二进制数，计算它们的和，并以十进制显示；<br>testBit()：与setBit()相反，验证this的二进制组成元素中是否包含传入的变量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//权限控制源码分析：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.setBit()原理：计算this与2的n次方的和</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">setBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Negative bit address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">intNum</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[Math.max(intLength(), intNum+<span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; result.length; i++)</span><br><span class="line">result[result.length-i-<span class="number">1</span>] = getInt(i);</span><br><span class="line"></span><br><span class="line">result[result.length-intNum-<span class="number">1</span>] |= (<span class="number">1</span> &lt;&lt; (n &amp; <span class="number">31</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> valueOf(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.testBit()原理：计算this的值中是否包含2的n次方</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">testBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Negative bit address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (getInt(n &gt;&gt;&gt; <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; (n &amp; <span class="number">31</span>))) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><ol><li>BigInteger也是不可变的，在进行每一步运算时，都会产生一个新的对象。都会产生一个新的对象。发生异常算术条件时，会抛出ArithmeticException异常。例如，一个整数除以“0”，会抛出一个这个类的实例；</li><li>假设计算一个int数据平方与另一个大小的问题，很可能会内存溢出。除了使用二分法外，利用BigInteger的compareTo方法也是一个好选择，简单易懂，而且不需要算法支持；</li><li>本章作为笔记使用，内容比较全面，但常用的只有：构造函数，基本运算以及compareTo()，intValue()，setBit()，testBit()方法；</li><li>setBit()和testBit()方法可用于菜单的权限控制</li></ol><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p><a href="https://so.csdn.net/so/search?q=BigDecimal&spm=1001.2101.3001.7020">BigDecimal</a> 是java小数操作的一个专有类,在电商、金融行业 存储跟金额有关的字段</p><p>接下来看一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoubleSimple</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出:<code>0.3</code></p><p>在小数操作中,我们通常希望能有多种自由的定义方式。</p><blockquote><p>例如在不同的场景可能需要返回: 0.3, 0.4, 0.333 不同精度,在不同的精度进位时希望能自主控制</p></blockquote><p>这个时候,就轮到BigDecimal出场了</p><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p>首先来一段最简单的加减乘除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDecimalSimple</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5</span>);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">40</span>);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">add</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">subtract</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">multiply</span> <span class="operator">=</span> a.multiply(b);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> a.divide(b);</span><br><span class="line">     System.out.println(<span class="string">&quot;add:&quot;</span> + add);</span><br><span class="line">     System.out.println(<span class="string">&quot;subtract:&quot;</span> + subtract);</span><br><span class="line">     System.out.println(<span class="string">&quot;multiply:&quot;</span> + multiply);</span><br><span class="line">     System.out.println(<span class="string">&quot;divide:&quot;</span> + divide);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>控制台输出内容如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add:<span class="number">45</span></span><br><span class="line">subtract:-<span class="number">35</span></span><br><span class="line">multiply:<span class="number">200</span></span><br><span class="line">divide:<span class="number">0.125</span></span><br></pre></td></tr></table></figure><p>在了解了BigDecimal基本内容后,在去深入的去使用它的精度<br>精度控制<br>精度有7种模式，举例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRound</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 正无穷大方向取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;celling:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.CEILING)));</span><br><span class="line">     <span class="comment">// 负无穷大方向取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;floor:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.FLOOR)));</span><br><span class="line">     <span class="comment">//向 0 的方向取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;down a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.121</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.DOWN)));</span><br><span class="line">     System.out.println(<span class="string">&quot;down b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(-<span class="number">0.129</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.DOWN)));</span><br><span class="line">     <span class="comment">// 正数向正无穷大取整，负数向负无穷大取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;up a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.121</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.UP)));</span><br><span class="line">     System.out.println(<span class="string">&quot;up b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(-<span class="number">0.129</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.UP)));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 5,6,7,8,9 向上取整</span></span><br><span class="line"><span class="comment">      * 1,2,3,4 向下取整</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 常用的4舍5入</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;half up:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.HALF_UP)));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *  6,7,8,9 向上取整</span></span><br><span class="line"><span class="comment">      *  1,2,3,4,5 向下取整</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *  5 向下取整</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;half down:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.HALF_DOWN)));</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 小数位是5时，判断整数部分是奇数就进位</span></span><br><span class="line"><span class="comment">      * 1,2,3,4,  舍弃</span></span><br><span class="line"><span class="comment">      * 6,7,8,9,  进位</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;odd a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.4</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line">     System.out.println(<span class="string">&quot;odd b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.5</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 小数位是5时，判断整数部分是偶数就舍弃</span></span><br><span class="line"><span class="comment">      * 1,2,3,4,  舍弃</span></span><br><span class="line"><span class="comment">      * 6,7,8,9,  进位</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;even a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">6.5</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line">     System.out.println(<span class="string">&quot;even b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">6.6</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>控制台输出内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">celling:<span class="number">0.13</span></span><br><span class="line">floor:<span class="number">0.12</span></span><br><span class="line">down a:<span class="number">0.12</span></span><br><span class="line">down b:-<span class="number">0.12</span></span><br><span class="line">up a:<span class="number">0.13</span></span><br><span class="line">up b:-<span class="number">0.13</span></span><br><span class="line">half up:<span class="number">0.13</span></span><br><span class="line">half down:<span class="number">0.12</span></span><br><span class="line">odd a:<span class="number">5</span></span><br><span class="line">odd b:<span class="number">6</span></span><br><span class="line">even a:<span class="number">6</span></span><br><span class="line">even b:<span class="number">7</span></span><br></pre></td></tr></table></figure><p>在 RoundingMode.XXXXX 类型的源码注释上面，有更加详细的例子，可以看到是怎么舍入的</p><h3 id="除法特写"><a href="#除法特写" class="headerlink" title="除法特写"></a>除法特写</h3><p>我认为在电商，金融领域中，用BigDecimal最重要的原因有两个：</p><ol><li>精度准确</li><li>除法运算支持好</li></ol><p>所以一定要对除法做深入的了解,做项目的时候，才能不会对这些类型感到疑惑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDecimalDivide</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.4</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">3.1</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> a.divide(b);</span><br><span class="line">    System.out.println(<span class="string">&quot;divide:&quot;</span> + divide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现异常:<br><strong>java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</strong></p><p>明明刚刚还好好的，怎么现在出了事?</p><p>那是因为 5.4、3.1都是double类型转换的 BigDecimal。</p><p>实际上5.4在内存中可能是 5.40000003321546546 的内容。导致BigDecimal内部精度计算的时候，发生错误</p><p>这个错误是因为没有指定精度导致的，我们只要指定了结果的精度，就可以避免这个问题。</p><p>推荐做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDecimalStandDivide</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.4</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">3.1</span>);</span><br><span class="line">    <span class="comment">// 保留几位小数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 重点:务必是3个参数</span></span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> a.divide(b,scale,RoundingMode.HALF_UP);</span><br><span class="line">    System.out.println(<span class="string">&quot;divide:&quot;</span> + divide);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出:<strong>divide:1.74</strong></p><p>我们额外传入第二个参数:保留的小数,指定了结果的精度,就可以避免出现这种问题。</p><p>所以我们日常用BigDecimal做除法运算的时候，务必写成推荐的形式。避免出现了异常，自己还莫名其妙</p><h3 id="默认除法精度"><a href="#默认除法精度" class="headerlink" title="默认除法精度"></a>默认除法精度</h3><p>在文章的开头的除法，是用整数转成BigDecimal， 保留的3为小数。 那默认情况下会精确到几位呢？</p><p>在跟进到divide函数内部时，发现了构造MathContext的部分内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MathContext</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathContext</span>( (<span class="type">int</span>)Math.min(<span class="built_in">this</span>.precision() +</span><br><span class="line">                                                           (<span class="type">long</span>)Math.ceil(<span class="number">10.0</span>*divisor.precision()/<span class="number">3.0</span>),</span><br><span class="line">                                                           Integer.MAX_VALUE),</span><br><span class="line">                                             RoundingMode.UNNECESSARY);</span><br></pre></td></tr></table></figure><blockquote><p>整数 12345 的precision 是5<br>整数 332 的precision 是 3<br>小数5.4 的precision可能是 5.40000065464698656565454454555 的长度。 值不固定</p></blockquote><p>根据MathContext的第一个参数的计算方式得到默认除法精度:</p><ol><li>当被除数为:0x1 最低精度5</li><li>当被除数为:0xFFFFFFFF 最高精度36</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>BigDecimal精度描述</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>ceiling</td><td>正无穷大方向取整数</td></tr><tr><td>floor</td><td>负无穷大方向取整</td></tr><tr><td>fown</td><td>向0的方向取整</td></tr><tr><td>up</td><td>正数向无穷大取整，负数向无穷大取整</td></tr><tr><td>half_up</td><td>5，6，7，8向上取整，1，2，3，4向下取整，常用的四舍五入</td></tr><tr><td>half_down</td><td>6,7,8,9 向上取整 1,2,3,4,5 向下取整</td></tr><tr><td>half_even</td><td>小数位是5时，判断整数部分是奇数就进位、 小数位是5时，判断整数部分是偶数就舍弃、 1,2,3,4, 舍弃、 6,7,8,9, 进位</td></tr></tbody></table><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p><p>第一个构造函数使用当前日期和时间来初始化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date( )</span><br></pre></td></tr></table></figure><p>第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date(<span class="type">long</span> millisec)</span><br></pre></td></tr></table></figure><p>Date 对象创建以后，可以调用下面的方法</p><table><thead><tr><th>1</th><th><strong>boolean after(Date date)</strong> 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</th></tr></thead><tbody><tr><td>2</td><td><strong>boolean before(Date date)</strong> 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</td></tr><tr><td>3</td><td><strong>Object clone( )</strong> 返回此对象的副本。</td></tr><tr><td>4</td><td><strong>int compareTo(Date date)</strong> 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</td></tr><tr><td>5</td><td><strong>int compareTo(Object obj)</strong> 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</td></tr><tr><td>6</td><td><strong>boolean equals(Object date)</strong> 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</td></tr><tr><td>7</td><td><strong>long getTime( )</strong> 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td></tr><tr><td>8</td><td><strong>int hashCode( )</strong>  返回此对象的哈希码值。</td></tr><tr><td>9</td><td><strong>void setTime(long time)</strong>   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</td></tr><tr><td>10</td><td><strong>String toString( )</strong> 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)</td></tr></tbody></table><h4 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h4><p>Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// 初始化 Date 对象</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 使用 toString() 函数显示日期时间</span></span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mon May <span class="number">04</span> 09:<span class="number">51</span>:<span class="number">52</span> CDT <span class="number">2013</span></span><br></pre></td></tr></table></figure><h4 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h4><p>Java使用以下三种方法来比较两个日期：</p><ul><li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li><li>使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。</li><li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</li></ul><h4 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h4><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="type">Date</span> <span class="variable">dNow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>( );</span><br><span class="line">      <span class="type">SimpleDateFormat</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> (<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间为: &quot;</span> + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> (<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure><p>这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。</p><p><strong>注意</strong>:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。</p><p>以上实例编译运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时间为: <span class="number">2018</span>-09-<span class="number">06</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure><h4 id="日期和时间的格式化编码"><a href="#日期和时间的格式化编码" class="headerlink" title="日期和时间的格式化编码"></a>日期和时间的格式化编码</h4><p>时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：</p><table><thead><tr><th align="left"><strong>字母</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">G</td><td align="left">纪元标记</td><td align="left">AD</td></tr><tr><td align="left">y</td><td align="left">四位年份</td><td align="left">2001</td></tr><tr><td align="left">M</td><td align="left">月份</td><td align="left">July or 07</td></tr><tr><td align="left">d</td><td align="left">一个月的日期</td><td align="left">10</td></tr><tr><td align="left">h</td><td align="left">A.M.&#x2F;P.M. (1~12)格式小时</td><td align="left">12</td></tr><tr><td align="left">H</td><td align="left">一天中的小时 (0~23)</td><td align="left">22</td></tr><tr><td align="left">m</td><td align="left">分钟数</td><td align="left">30</td></tr><tr><td align="left">s</td><td align="left">秒数</td><td align="left">55</td></tr><tr><td align="left">S</td><td align="left">毫秒数</td><td align="left">234</td></tr><tr><td align="left">E</td><td align="left">星期几</td><td align="left">Tuesday</td></tr><tr><td align="left">D</td><td align="left">一年中的日子</td><td align="left">360</td></tr><tr><td align="left">F</td><td align="left">一个月中第几周的周几</td><td align="left">2 (second Wed. in July)</td></tr><tr><td align="left">w</td><td align="left">一年中第几周</td><td align="left">40</td></tr><tr><td align="left">W</td><td align="left">一个月中第几周</td><td align="left">1</td></tr><tr><td align="left">a</td><td align="left">A.M.&#x2F;P.M. 标记</td><td align="left">PM</td></tr><tr><td align="left">k</td><td align="left">一天中的小时(1~24)</td><td align="left">24</td></tr><tr><td align="left">K</td><td align="left">A.M.&#x2F;P.M. (0~11)格式小时</td><td align="left">10</td></tr><tr><td align="left">z</td><td align="left">时区</td><td align="left">Eastern Standard Time</td></tr><tr><td align="left">‘</td><td align="left">文字定界符</td><td align="left">Delimiter</td></tr><tr><td align="left">“</td><td align="left">单引号</td><td align="left">&#96;</td></tr></tbody></table><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>在java.util包下</p><p>Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>使用Calendar的静态方法<code>getInstance()</code>实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p> Calendar类的一些静态属性如年，月，日，星期并不是表示的是2022-3-8 12:12:12。 而是用于指代set,get方法到底是取什么类型的值。<strong>作为set,get方法的第一个参数，用来指定设置获取年月日。</strong><br> <strong>不能通过静态属性来获取时间!</strong></p><table><thead><tr><th align="left">常量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Calendar.YEAR</td><td align="left">年份</td></tr><tr><td align="left">Calendar.MONTH</td><td align="left">月份</td></tr><tr><td align="left">Calendar.DATE</td><td align="left">日期</td></tr><tr><td align="left">Calendar.DAY_OF_MONTH</td><td align="left">日期，和上面的字段意义完全相同</td></tr><tr><td align="left">Calendar.HOUR</td><td align="left">12小时制的小时</td></tr><tr><td align="left">Calendar.HOUR_OF_DAY</td><td align="left">24小时制的小时</td></tr><tr><td align="left">Calendar.MINUTE</td><td align="left">分钟</td></tr><tr><td align="left">Calendar.SECOND</td><td align="left">秒</td></tr><tr><td align="left">Calendar.DAY_OF_WEEK</td><td align="left">星期几</td></tr></tbody></table><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.YEAR : &quot;</span>+Calendar.YEAR); <span class="comment">// Calendar.YEAR : 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.MONTH : &quot;</span>+Calendar.MONTH); <span class="comment">// Calendar.MONTH : 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.DAY_OF_MONTH : &quot;</span>+Calendar.DAY_OF_MONTH ); <span class="comment">//Calendar.DAY_OF_MONTH : 5</span></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.DAY_OF_WEEK : &quot;</span>+Calendar.DAY_OF_WEEK); <span class="comment">//Calendar.DAY_OF_WEEK : 7</span></span><br><span class="line">System.out.println(Calendar.HOUR);  <span class="comment">// 十二小时制的小时</span></span><br><span class="line">System.out.println(Calendar.HOUR_OF_DAY); <span class="comment">//二十四小时制的小时</span></span><br><span class="line">System.out.println(Calendar.MINUTE); <span class="comment">//分</span></span><br><span class="line">System.out.println(Calendar.SECOND); <span class="comment">//秒</span></span><br><span class="line">System.out.println(Calendar.MILLISECOND); <span class="comment">//毫秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置时间set-int-field-int-value"><a href="#设置时间set-int-field-int-value" class="headerlink" title="设置时间set(int field , int value)"></a>设置时间set(int field , int value)</h4><p>  set(int field , int value)方法通过传入上述的静态属性（第一个参数）来设置对应的值（第二个参数）。<br> 在设置年月日星期中，月是从0开始算的，星期中星期天认为是1，以此类推。<br> 直接举例子。<br> 代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">c.set(Calendar.YEAR, <span class="number">1999</span>); <span class="comment">//将年设置为1999年</span></span><br><span class="line">c.set(Calendar.MONTH,<span class="number">11</span>);   <span class="comment">//将月设置为12月    传入0为1月</span></span><br><span class="line">c.set(Calendar.DAY_OF_MONTH,<span class="number">18</span>); <span class="comment">//将日设置为18日。</span></span><br><span class="line">c.set(Calendar.DAY_OF_WEEK,<span class="number">1</span>);  <span class="comment">//将星期设置为星期天</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取时间get-int-field"><a href="#获取时间get-int-field" class="headerlink" title="获取时间get(int field)"></a>获取时间get(int field)</h4><p> get(int field)通过传入上述的静态属性可以获取对应的年月日星期。<br> 根据上述set的例子来获取时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">1999</span>); <span class="comment">//将年设置为1999年</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">11</span>);   <span class="comment">//将月设置为12月    传入0为1月</span></span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">18</span>); <span class="comment">//将日设置为18日。</span></span><br><span class="line">        <span class="comment">//c.set(Calendar.DAY_OF_WEEK, 1);  //将星期设置为星期天</span></span><br><span class="line">        System.out.println(c.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line">        System.out.println(c.get(Calendar.YEAR)); <span class="comment">//输出 1999</span></span><br><span class="line">        System.out.println(c.get(Calendar.MONTH));   <span class="comment">//输出 11</span></span><br><span class="line">        System.out.println(c.get(Calendar.DAY_OF_MONTH));<span class="comment">//输出 18</span></span><br><span class="line">        System.out.println(c.get(Calendar.DAY_OF_WEEK)); <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>java.time.LocalDate -&gt;只对年月日做出处理</p><p>java.time.LocalTime -&gt;只对时分秒纳秒做出处理</p><p>java.time.LocalDateTime -&gt;同时可以处理年月日和时分秒</p><h4 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h4><p>LocalDate:默认返回一个日期格式为yyyy-MM-dd格式的日期</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalDate now()</td><td>获取默认时区的当前日期,默认返回格式yyyy-MM-dd</td></tr><tr><td>static LocalDate now(Clock clock)</td><td>从指定时钟获取当前日期</td></tr><tr><td>static LocalDate now(ZoneId zone)</td><td>获取指定时区的当前日期</td></tr><tr><td>static LocalDate of(int year, int month, int dayOfMonth)</td><td>根据指定的年、月、日获取LocalDate 实例</td></tr><tr><td>static LocalDate of(int year, Month month, int dayOfMonth)</td><td>根据指定的年、月、日获取LocalDate 实例</td></tr><tr><td>static LocalDate ofYearDay(int year,int dayOfYear)</td><td>根据指定的年，年中的第xx天获取LocalDate实例</td></tr><tr><td>static LocalDate ofEpochDay(long epochDay)</td><td>从1970-01-01开始获取指定天数的LocalDate实例</td></tr><tr><td>static LocalDate parse(CharSequence text)</td><td>将字符串转换为LocalDate,字符串的格式必须为yyyy-MM-dd 10位长度的日期格式，否则会报错</td></tr><tr><td>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)</td><td>将text字符串转换为formatter格式，<code>text的格式必须与formatter格式一致</code>，如text为yyyyMMdd格式,则formatter也应该为yyyyMMdd格式,否则会报错</td></tr></tbody></table><h5 id="创建LocalDate"><a href="#创建LocalDate" class="headerlink" title="创建LocalDate"></a>创建LocalDate</h5><h6 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h6><blockquote><p>从默认时区的系统时钟中获取当前日期。默认输出格式为yyyy-MM-dd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//2021-11-29</span></span><br></pre></td></tr></table></figure><h6 id="now-Clock-clock"><a href="#now-Clock-clock" class="headerlink" title="now(Clock clock)"></a>now(Clock clock)</h6><blockquote><p>从指定时钟获取当前日期。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.now(Clock.systemDefaultZone());</span><br><span class="line">System.out.println(l);</span><br><span class="line"></span><br><span class="line">System.out.println(Clock.systemDefaultZone());<span class="comment">//方法返回带有系统默认时区的Clock实例。</span></span><br><span class="line">System.out.println(Clock.systemUTC());<span class="comment">//此方法返回带有UTC时区的Clock实例。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br><span class="line"></span><br><span class="line">SystemClock[Asia/Shanghai]</span><br><span class="line">SystemClock[Z]</span><br></pre></td></tr></table></figure><h6 id="now-Zoneld-zone"><a href="#now-Zoneld-zone" class="headerlink" title="now(Zoneld zone)"></a>now(Zoneld zone)</h6><blockquote><p> 从指定时区的系统时钟中获取当前日期。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.now(ZoneId.of(<span class="string">&quot;UTC+1&quot;</span>));</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure><p>时区是用ZoneId类表示的，你可以使用ZoneId.now()或ZoneId.of(“xxx”)来实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;UTC+1&quot;</span>);</span><br></pre></td></tr></table></figure><p>传给of()方法的参数是时区的ID，如“UTC+1”指距离UTC（格林威治时间）有一小时的时差，你可以使用你想要的时差来表示ZoneId（如+1与-5等等）</p><p>你也可以使用另一种方式表示zone id，即使用地区名字，也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId2</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Copenhagen&quot;</span>);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId3</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Paris&quot;</span>);</span><br></pre></td></tr></table></figure><h6 id="of-int-year-int-month-int-dayOfMonth"><a href="#of-int-year-int-month-int-dayOfMonth" class="headerlink" title="of(int year, int month, int dayOfMonth)"></a>of(int year, int month, int dayOfMonth)</h6><blockquote><p>从年、月和日获取LocalDate实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">11</span>, <span class="number">29</span>);</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure><h6 id="ofYearDay-int-year-int-dayOfYear"><a href="#ofYearDay-int-year-int-dayOfYear" class="headerlink" title="ofYearDay(int year,int dayOfYear)"></a>ofYearDay(int year,int dayOfYear)</h6><blockquote><p>从指定年的指定天获取LocalDate实例 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取2021年第230天的日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.ofYearDay(<span class="number">2021</span>, <span class="number">230</span>);</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-08-<span class="number">18</span></span><br></pre></td></tr></table></figure><p>1</p><h6 id="ofEpochDay-long-epochDay"><a href="#ofEpochDay-long-epochDay" class="headerlink" title="ofEpochDay(long epochDay)"></a>ofEpochDay(long epochDay)</h6><blockquote><p>从1970-01-01开始获取指定天数的LocalDate实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.ofEpochDay(<span class="number">0</span>);<span class="comment">//1970-01-01</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l1</span> <span class="operator">=</span> LocalDate.ofEpochDay(-<span class="number">10</span>);<span class="comment">//1969-12-22</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l2</span> <span class="operator">=</span> LocalDate.ofEpochDay(<span class="number">10</span>);<span class="comment">//1970-01-11</span></span><br></pre></td></tr></table></figure><h6 id="parse-CharSequence-text"><a href="#parse-CharSequence-text" class="headerlink" title="parse(CharSequence text)"></a>parse(CharSequence text)</h6><blockquote><p>将字符串转换为LocalDate,字符串的格式必须为yyyy-MM-dd 10位长度的日期格式，否则会报错,字符串必须是一个合法的日期，否则会报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-01-29&quot;</span>);</span><br><span class="line">System.out.println(l); <span class="comment">//2021-01-29</span></span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期格式非yyyy-MM-dd</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-1-29&quot;</span>);</span><br><span class="line"><span class="comment">//日期格式非yyyy-MM-dd</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021/01/29&quot;</span>);</span><br><span class="line"><span class="comment">//字符串不是一个合法的日期，2月没有30号</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-02-30&quot;</span>);</span><br></pre></td></tr></table></figure><p>若parse(CharSequence text)中传入的格式非yyyy-MM-dd或不合法，会抛出异常，且长度需要是10位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.time.format.DateTimeParseException: Text <span class="string">&#x27;2021/11/29&#x27;</span> could not be parsed at index <span class="number">4</span></span><br><span class="line">at java.base/java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:<span class="number">2046</span>)</span><br><span class="line">at java.base/java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:<span class="number">1948</span>)</span><br><span class="line">at java.base/java.time.LocalDate.parse(LocalDate.java:<span class="number">428</span>)</span><br><span class="line">at java.base/java.time.LocalDate.parse(LocalDate.java:<span class="number">413</span>)</span><br><span class="line">at com.aexpec.mic.merchant.controller.Test.main(Test.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure><h6 id="parse-CharSequence-text-DateTimeFormatter-formatter"><a href="#parse-CharSequence-text-DateTimeFormatter-formatter" class="headerlink" title="parse(CharSequence text, DateTimeFormatter formatter)"></a>parse(CharSequence text, DateTimeFormatter formatter)</h6><blockquote><p>将text字符串转换为formatter格式，text的格式必须与formatter格式一致，如text为yyyyMMdd格式,则formatter也应该为yyyyMMdd格式,否则会报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20211129&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line">System.out.println(l);</span><br><span class="line">System.out.println(localDate1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure><p> 为什么localDate1输出后格式为yyyy-MM-dd?<br>虽然入参格式为yyyyMMdd,但是转换为LocalDate后，格式默认为yyyy-MM-dd, LocalDate返回的格式默认为yyyy-MM-dd，下面会讲如何转换为其他格式。<br>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例：text与formatter格式不一致，会抛出异常</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20211129&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="LocalDate日期比较"><a href="#LocalDate日期比较" class="headerlink" title="LocalDate日期比较"></a>LocalDate日期比较</h5><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>boolean isBefore(ChronoLocalDate other)</td><td>检查日期是否在指定日期之前</td></tr><tr><td>boolean isAfter(ChronoLocalDate other)</td><td>检查日期是否在指定日期之后</td></tr><tr><td>boolean isEqual(ChronoLocalDate other)</td><td>比较日期是否相同</td></tr><tr><td>int compareTo(ChronoLocalDate other)</td><td>日期比较localDateA.compareTo(localDateB)，若相等返回0；若A&gt;B，返回1 ；若A&lt;B返回-1</td></tr></tbody></table><h6 id="boolean-isBefore-ChronoLocalDate-other"><a href="#boolean-isBefore-ChronoLocalDate-other" class="headerlink" title="boolean isBefore(ChronoLocalDate other)"></a>boolean isBefore(ChronoLocalDate other)</h6><blockquote><p>用于检查此LocalDate值是否在给定的ChronoLocalDate(other)之前</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.isBefore(LocalDate.parse(&quot;2021-11-28&quot;))); //false</span><br><span class="line">System.out.println(l.isBefore(LocalDate.parse(&quot;2021-11-30&quot;))); //true</span><br></pre></td></tr></table></figure><h6 id="boolean-isAfter-ChronoLocalDate-other"><a href="#boolean-isAfter-ChronoLocalDate-other" class="headerlink" title="boolean isAfter(ChronoLocalDate other)"></a>boolean isAfter(ChronoLocalDate other)</h6><blockquote><p>用于检查此LocalDate值是否在给定的ChronoLocalDate(other)之后</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.isAfter(LocalDate.parse(&quot;2021-11-28&quot;))); //true</span><br><span class="line">System.out.println(l.isAfter(LocalDate.parse(&quot;2021-11-30&quot;))); //false</span><br></pre></td></tr></table></figure><h6 id="boolean-isEqual-ChronoLocalDate-other"><a href="#boolean-isEqual-ChronoLocalDate-other" class="headerlink" title="boolean isEqual(ChronoLocalDate other)"></a>boolean isEqual(ChronoLocalDate other)</h6><blockquote><p>用于检查此LocalDate值是否与给定的ChronoLocalDate(other)相等</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.isEqual(LocalDate.parse(&quot;2021-11-28&quot;))); //false</span><br><span class="line">System.out.println(l.isEqual(LocalDate.parse(&quot;2021-11-30&quot;))); //false</span><br><span class="line">System.out.println(l.isEqual(l)); //true</span><br></pre></td></tr></table></figure><h6 id="int-compareTo-ChronoLocalDate-other"><a href="#int-compareTo-ChronoLocalDate-other" class="headerlink" title="int compareTo(ChronoLocalDate other)"></a>int compareTo(ChronoLocalDate other)</h6><blockquote><p>比较两个日期A.compareTo(B)，若日期相同则返回0；<br>若A&gt;B，则返回1；<br>若A&lt;B，则返回-1；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.compareTo(LocalDate.parse(&quot;2021-11-28&quot;))); //1</span><br><span class="line">System.out.println(l.compareTo(LocalDate.parse(&quot;2021-11-30&quot;))); //-1</span><br><span class="line">System.out.println(l.compareTo(l)); //0</span><br></pre></td></tr></table></figure><h5 id="获取年、月、日"><a href="#获取年、月、日" class="headerlink" title="获取年、月、日"></a>获取年、月、日</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getYear()</td><td>获取年份</td></tr><tr><td>Month getMonth()</td><td>使用月枚举类型获取月份</td></tr><tr><td>int getMonthValue()</td><td>返回数字月份 1-12月</td></tr><tr><td>int getDayOfMonth()</td><td>获取日期在该月是第几天</td></tr><tr><td>DayOfWeek getDayOfWeek()</td><td>获取日期是星期几</td></tr><tr><td>int getDayOfYear()</td><td>获取日期在该年是第几天</td></tr><tr><td>boolean isLeapYear()</td><td>检查是否闰年</td></tr><tr><td>int lengthOfMonth()</td><td>返回日期所在月份共有几天</td></tr><tr><td>int lengthOfYear()</td><td>返回日期所在年份共有几天</td></tr><tr><td>long toEpochDay()</td><td>返回当前日期距离1970年1月1日的天数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(localDate); <span class="comment">// 2021-11-29</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;年 : &quot;</span> + localDate.getYear()); <span class="comment">// 2021</span></span><br><span class="line">System.out.println(<span class="string">&quot;月（英文） : &quot;</span> + localDate.getMonth()); <span class="comment">// NOVEMBER</span></span><br><span class="line">System.out.println(<span class="string">&quot;月（数字英文）: &quot;</span> + localDate.getMonth().getValue()); <span class="comment">// 11</span></span><br><span class="line">System.out.println(<span class="string">&quot;月（数字英文）: &quot;</span> + localDate.getMonthValue()); <span class="comment">// 11</span></span><br><span class="line">System.out.println(<span class="string">&quot;本月第几天 : &quot;</span> + localDate.getDayOfMonth()); <span class="comment">// 29</span></span><br><span class="line">System.out.println(<span class="string">&quot;星期几（英文） : &quot;</span> + localDate.getDayOfWeek()); <span class="comment">// MONDAY</span></span><br><span class="line">System.out.println(<span class="string">&quot;星期几（数字英文） : &quot;</span> + localDate.getDayOfWeek().getValue()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年的第几天 : &quot;</span> + localDate.getDayOfYear()); <span class="comment">// 333</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否润年 : &quot;</span> + localDate.isLeapYear()); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;本月天数 : &quot;</span> + localDate.lengthOfMonth()); <span class="comment">// 30</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年天数 : &quot;</span> + localDate.lengthOfYear()); <span class="comment">// 365</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="日期计算，加-x2F-减年、月、周、日"><a href="#日期计算，加-x2F-减年、月、周、日" class="headerlink" title="日期计算，加&#x2F;减年、月、周、日"></a>日期计算，加&#x2F;减年、月、周、日</h5><h6 id="加-x2F-减年、月、周、日"><a href="#加-x2F-减年、月、周、日" class="headerlink" title="加&#x2F;减年、月、周、日"></a>加&#x2F;减年、月、周、日</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDate plus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制增加天、周、月、年</td></tr><tr><td>LocalDate plusDays(long daysToAdd)</td><td>返回增加了*天的LocalDate副本</td></tr><tr><td>LocalDate plusWeeks(long weeksToAdd)</td><td>返回增加了*周的LocalDate副本</td></tr><tr><td>LocalDate plusMonths(long monthsToAdd)</td><td>返回增加了*月的LocalDate副本</td></tr><tr><td>LocalDate plusYears(long yearsToAdd)</td><td>返回增加了*年的LocalDate副本</td></tr><tr><td>LocalDate minus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制减少天、周、月、年</td></tr><tr><td>LocalDate minusDays(long daysToSubtract)</td><td>返回减少了*天的LocalDate副本</td></tr><tr><td>LocalDate minusWeeks(long weeksToSubtract)</td><td>返回减少了*周的LocalDate副本</td></tr><tr><td>LocalDate minusMonths(long monthsToSubtract)</td><td>返回减少了*月的LocalDate副本</td></tr><tr><td>LocalDate minusYears(long yearsToSubtract)</td><td>返回减少了*年的LocalDate副本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">localDate1 = LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>);</span><br><span class="line">System.out.println(localDate1); <span class="comment">// 2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加 : &quot;</span> + localDate1.plus(<span class="number">1</span>, ChronoUnit.DAYS));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;增加天数 : &quot;</span> + localDate1.plusDays(<span class="number">1</span>)); <span class="comment">// 2021-11-30</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加周数 : &quot;</span> + localDate1.plusWeeks(<span class="number">1</span>)); <span class="comment">// 2021-12-06</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加月数 : &quot;</span> + localDate1.plusMonths(<span class="number">1</span>)); <span class="comment">// 2021-12-29</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加年数 : &quot;</span> + localDate1.plusYears(<span class="number">1</span>)); <span class="comment">// 2022-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少 : &quot;</span> + localDate1.minus(<span class="number">1</span>, ChronoUnit.DAYS));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;减少天数 : &quot;</span> + localDate1.minusDays(<span class="number">1</span>)); <span class="comment">// 2021-11-28</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少月数 : &quot;</span> + localDate1.minusMonths(<span class="number">1</span>)); <span class="comment">// 2021-10-29</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少周数 : &quot;</span> + localDate1.minusWeeks(<span class="number">1</span>)); <span class="comment">// 2021-11-22</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少年数 : &quot;</span> + localDate1.minusYears(<span class="number">1</span>)); <span class="comment">// 2020-11-29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上方法返回的都是LocalDate实例的副本，即源对象localDate1变量的值不变</p><h6 id="计算两个日期的间隔"><a href="#计算两个日期的间隔" class="headerlink" title="计算两个日期的间隔"></a>计算两个日期的间隔</h6><ol><li><p><strong>方法一</strong>：计算两个日期相差的天数</p><blockquote><p>调用LocalDate类的toEpochDay方法，返回距离1970年1月1日的long值<br>此方法只能计算两个日期相差的天数，不能计算月数，年数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">28</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间之间的相差的天数: &quot;</span>+(end.toEpochDay()-start.toEpochDay())); <span class="comment">//644</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong>计算两个日期相差的天数、月数、年数</p><blockquote><p>ChronoUnit也可以计算两个单元之间的天数、月数或年数。<br>我们使用ChronoUnit类的between() 方法来执行相同的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">28</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">long</span> days= ChronoUnit.DAYS.between(start , end );</span><br><span class="line">结果：<span class="number">644</span></span><br><span class="line"><span class="type">long</span> month= ChronoUnit.MONTHS.between(start , end );</span><br><span class="line">结果<span class="number">21</span></span><br><span class="line"><span class="type">long</span> year= ChronoUnit.YEARS.between(start , end );</span><br><span class="line">结果 <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>方法三</strong>: 计算两个日期相差的年月日</p><blockquote><p>此方法主要是计算两个日期相差的年月日，不能计算出具体相差了多少天</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">28</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(start,end);</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间之间的差值  年：&quot;</span>+period.getYears()+<span class="string">&quot;，月：&quot;</span>+period.getMonths()+<span class="string">&quot;，日：&quot;</span>+period.getDays());</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个时间之间的差值  年：1，月：9，日：5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String format(DateTimeFormatter formatter)</td><td>使用特定格式化形式将LocalDate转为字符串</td></tr><tr><td>static LocalDate parse(CharSequence text)</td><td>从文本字符串获取LocalDate实例，text必须是yyyy-MM-dd格式</td></tr><tr><td>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)</td><td>使用特定格式化形式从文本字符串获取LocalDate实例，<code>text的格式必须与formatter格式一致</code>，如text为yyyyMMdd格式,则formatter也应该为yyyyMMdd格式,否则会报错</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-01-29&quot;</span>);</span><br><span class="line">System.out.println(l); <span class="comment">//2021-01-29</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">System.out.println(l1); <span class="comment">//2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20211129&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line">System.out.println(localDate1); <span class="comment">//2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">System.out.println(l.format(dtf));<span class="comment">// 2021-01-29 十位转八位 ==&gt; 20210129</span></span><br><span class="line"></span><br><span class="line">dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">System.out.println(l.format(dtf));<span class="comment">// 2021-01-29  ==&gt; 2021年01月29日</span></span><br><span class="line"></span><br><span class="line">dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">System.out.println(l.format(dtf));<span class="comment">// 2021-01-29  ==&gt; 2021/01/29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LocalDate进阶-获取月末、月首、本周一、下周五、每个月的周一"><a href="#LocalDate进阶-获取月末、月首、本周一、下周五、每个月的周一" class="headerlink" title="LocalDate进阶,获取月末、月首、本周一、下周五、每个月的周一"></a>LocalDate进阶,获取月末、月首、本周一、下周五、每个月的周一</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDate with(TemporalAdjuster adjuster)</td><td>使用传递的TemporalAdjuster作为参数来调整此日期时间，并在调整后返回调整后的日期时间的副本</td></tr><tr><td>LocalDate with(TemporalField field, long newValue)</td><td>用于将LocalDate的指定字段设置为新值并返回新的日期时间的副本。此方法可用于更改任何受支持的字段，例如年，月或day-of-month。如果由于不支持该字段或其他原因而无法设置新值，则会引发异常。</td></tr><tr><td>LocalDate withMonth(int month)</td><td>修改LocalDate变量的月份，如LocalDate.parse(“2021-10-30”).withMonth(3)则为2021-03-30<br/>month:从1到12</td></tr><tr><td>LocalDate withDayOfMonth(int dayOfMonth)</td><td>修改LocalDate变量的日，如LocalDate.parse(“2021-10-30”).withDayOfMonth(3)则为2021-10-03 dayOfMonth：从1到28-31</td></tr><tr><td>LocalDate withDayOfYear(int dayOfYear)</td><td>返回当年第几天的日期，如当年第300天是几月几号，dayOfYear从1到365-366</td></tr><tr><td>LocalDate withYear(int year)</td><td>修改LocalDate变量的年份，如LocalDate.parse(“2021-10-30”).withYear(2000)则为2000-10-30 year:从MIN_YEAR到MAX_YEAR</td></tr></tbody></table><h6 id="LocalDate-with-TemporalAdjuster-adjuster"><a href="#LocalDate-with-TemporalAdjuster-adjuster" class="headerlink" title="LocalDate with(TemporalAdjuster adjuster)"></a>LocalDate with(TemporalAdjuster adjuster)</h6><blockquote><p>该方法用于使用传递的TemporalAdjuster作为参数来调整此日期时间，并在调整后返回调整后的日期时间的副本。使用指定的调整器策略对象进行调整。该LocalDate实例是不可变的，不受此方法调用的影响。</p></blockquote><p>参数：该方法接受调节器作为要使用的调节器的参数。</p><p>返回值：该方法将基于此方法返回LocalDate并进行调整。</p><p>异常：此方法引发以下异常：</p><ul><li>DateTimeException–如果无法进行调整。</li><li>ArithmeticException–如果发生数字溢出。</li></ul><p>TemporalAdjuster：时间调节器<br>有的时候，你需要进行一些更加灵活复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。这时，就需要时间调节器 TemporalAdjuster，可以更加灵活地处理日期。TemporalAdjusters 工具提供了一些通用的功能，并且你还可以新增你自己的功能。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static TemporalAdjuster firstDayOfMonth()</td><td>当前月的第一天</td></tr><tr><td>static TemporalAdjuster firstDayOfNextMonth()</td><td>下一个月的第一天</td></tr><tr><td>static TemporalAdjuster firstDayOfNextYear()</td><td>下一年的第一天</td></tr><tr><td>static TemporalAdjuster firstDayOfYear()</td><td>当年的第一天</td></tr><tr><td>static TemporalAdjuster lastDayOfYear()</td><td>当年的最后一天</td></tr><tr><td>static TemporalAdjuster lastDayOfMonth()</td><td>当月的最后一天</td></tr><tr><td>static TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)</td><td>某月的第一个星期几</td></tr><tr><td>static TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)</td><td>某月的最后一个星期几</td></tr><tr><td>static TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</td><td>某月的第几个星期几，例如，三月中第二个星期二</td></tr><tr><td>static TemporalAdjuster next(DayOfWeek dayOfWeek)</td><td>(往后不包括当天)下一个星期几是几月几号。若当前为周三，那么next(DayOfWeek.WEDNESDAY)指下一个周三即下周三；next(DayOfWeek.SUNDAY) 指下一个周日即本周日(此时并不是下周日)</td></tr><tr><td>static TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)</td><td>(往后包括当天)最近星期几的日期。如最近星期五的日期，如果今天是星期五，则返回今天日期，如果今天不是星期五，则返回下周五的日期</td></tr><tr><td>static TemporalAdjuster previous(DayOfWeek dayOfWeek)</td><td>(往前不包括当天)上一个星期几是几月几号。若当前为周三，那么previous(DayOfWeek.WEDNESDAY)指上一个周三即上周三；previous(DayOfWeek.TUESDAY) 指上一个周二即昨天(此时并不是上周二)</td></tr><tr><td>static TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)</td><td>(往前包括当天)最近星期几的日期。如最近星期五的日期，如果今天是星期五，则返回今天日期，如果今天不是星期五，则返回上周五的日期</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间：&quot;</span>+now); <span class="comment">//2021-11-30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当月第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfMonth()));<span class="comment">// 2021-11-01</span></span><br><span class="line"><span class="comment">//获取本月第2天：</span></span><br><span class="line">System.out.println(<span class="string">&quot;本月第2天：&quot;</span>+now.withDayOfMonth(<span class="number">2</span>)); <span class="comment">//2021-11-02</span></span><br><span class="line"><span class="comment">//获取下月第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;下月第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfNextMonth())); <span class="comment">//2021-12-01</span></span><br><span class="line"><span class="comment">//获取明年第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;明年第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfNextYear())); <span class="comment">//2022-01-01</span></span><br><span class="line"><span class="comment">//获取本年第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfYear()));<span class="comment">//2021-01-01</span></span><br><span class="line"><span class="comment">//获取当月最后一天，再也不用计算是28，29，30还是31：</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月最后一天：&quot;</span>+now.with(TemporalAdjusters.lastDayOfMonth())); <span class="comment">//2021-11-30</span></span><br><span class="line"><span class="comment">//获取本年最后一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年最后一天：&quot;</span>+now.with(TemporalAdjusters.lastDayOfYear())); <span class="comment">//2021-12-31</span></span><br><span class="line"><span class="comment">//获取当月的第一个星期一</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月的第一个星期一：&quot;</span>+now.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY))); <span class="comment">//2021-11-01</span></span><br><span class="line"><span class="comment">//获取当月的最后一个星期一</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月的最后一个星期一：&quot;</span>+now.with(TemporalAdjusters.lastInMonth(DayOfWeek.MONDAY))); <span class="comment">//2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当月第三周星期五</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月第三周星期五：&quot;</span>+now.with(TemporalAdjusters.dayOfWeekInMonth(<span class="number">3</span>, DayOfWeek.FRIDAY))); <span class="comment">//2021-11-19</span></span><br><span class="line"><span class="comment">//获取本周一</span></span><br><span class="line">System.out.println(<span class="string">&quot;本周一：&quot;</span>+now.with(DayOfWeek.MONDAY)); <span class="comment">//2021-11-29</span></span><br><span class="line"><span class="comment">//获取上周二</span></span><br><span class="line">System.out.println(<span class="string">&quot;上周二：&quot;</span>+now.minusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)); <span class="comment">//2021-11-23</span></span><br><span class="line"><span class="comment">//(往前不包括当天)获取当前日期的上一个周一  如果今天是周一，则返回上周一</span></span><br><span class="line">System.out.println(<span class="string">&quot;上一个周一(不包括当天)：&quot;</span>+now.with(TemporalAdjusters.previous(DayOfWeek.MONDAY))); <span class="comment">//2021-11-29</span></span><br><span class="line"><span class="comment">//(往前包括当天)最近星期五的日期  如果今天是星期五，则返回今天日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;上一个周一(包括当天)：&quot;</span>+now.with(TemporalAdjusters.previousOrSame(DayOfWeek.FRIDAY))); <span class="comment">//2021-11-26</span></span><br><span class="line"><span class="comment">//获取下周二</span></span><br><span class="line">System.out.println(<span class="string">&quot;下周二：&quot;</span>+now.plusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)); <span class="comment">//2021-12-07</span></span><br><span class="line"><span class="comment">//(往后不包括当天)获取当前日期的下一个周日 如果今天是周日，则返回下周日的时间  如果今天是星期一，则返回本周日的时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;下一个周日(不包括当天)：&quot;</span>+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY))); <span class="comment">//2021-12-05</span></span><br><span class="line"><span class="comment">//(往后包括当天)最近星期五的日期  如果今天是星期五，则返回今天日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;下一个周日(包括当天)：&quot;</span>+now.with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY))); <span class="comment">//2021-12-03</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LocalDateTime与Date的互转"><a href="#LocalDateTime与Date的互转" class="headerlink" title="LocalDateTime与Date的互转"></a>LocalDateTime与Date的互转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Date转LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> date Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> LocalDateTime</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">dateToLocalDateTime</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">     <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="keyword">return</span> instant.atZone(zoneId).toLocalDateTime();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LocalDateTime转Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> localDateTime LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Date</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">localDateTimeToDate</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> localDateTime.atZone(zoneId);</span><br><span class="line">     <span class="keyword">return</span> Date.from(zdt.toInstant());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="LocalTime类"><a href="#LocalTime类" class="headerlink" title="LocalTime类"></a>LocalTime类</h4><p>java.time.LocalTime -&gt;只对时分秒纳秒做出处理</p><blockquote><p>默认格式：HH:mm:ss.SSSSSSSSS 例如：11:23:40.051942200。<br><code>当纳秒&lt;=0时，不显示纳秒</code><br><code>当秒&lt;=0且纳秒&lt;=0时，默认只显示时:分 如11：23</code></p></blockquote><h5 id="创建LocalTime"><a href="#创建LocalTime" class="headerlink" title="创建LocalTime"></a>创建LocalTime</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalTime now()</td><td>返回当前时间时分秒纳秒，默认格式：HH:mm:ss.SSSSSSSSS</td></tr><tr><td>static LocalTime now(ZoneId zone)</td><td>通过指定时区创建LocalTime实例</td></tr><tr><td>static LocalTime now(Clock clock)</td><td>通过指定时钟创建LocalTime实例</td></tr><tr><td>static LocalTime of(int hour, int minute)</td><td>通过时、分创建LocalTime实例， 输出格式为HH:mm,此时默认不输出秒、纳秒</td></tr><tr><td>static LocalTime of(int hour, int minute, int second)</td><td>通过时、分、秒创建LocalTime实例，默认输出格式为HH:mm:ss</td></tr><tr><td>static LocalTime of(int hour, int minute, int second, int nanoOfSecond)</td><td>通过时、分、秒、纳秒创建LocalTime实例，当纳秒&gt;0时显示纳秒，否则不显示纳秒</td></tr><tr><td>static LocalTime ofSecondOfDay(long secondOfDay)</td><td>通过一天的秒数创建LocalTime实例 secondOfDay：从0到24 * 60 * 60 – 1</td></tr><tr><td>static LocalTime ofNanoOfDay(long nanoOfDay)</td><td>通过一天的纳秒数创建LocalTime实例 nanoOfDay：从0到24 * 60 * 60 * 1,000,000,000 - 1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时分秒纳秒</span></span><br><span class="line">System.out.println(LocalTime.now()); <span class="comment">//15:51:01.167526700</span></span><br><span class="line"><span class="comment">//获取指定闹钟的时间</span></span><br><span class="line">System.out.println(LocalTime.now(Clock.systemUTC()));<span class="comment">//07:51:01.168523900 备注：utc时间与当前时间相差8小时</span></span><br><span class="line"><span class="comment">//获取指定时区的时间</span></span><br><span class="line">System.out.println(LocalTime.now(ZoneId.systemDefault())); <span class="comment">//15:51:01.168523900</span></span><br><span class="line"><span class="comment">//获取时、分</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>));<span class="comment">//13:23</span></span><br><span class="line"><span class="comment">//获取时、分、秒</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">23</span>));<span class="comment">//13:23:23</span></span><br><span class="line"><span class="comment">//获取时、分、秒(当秒=0时，默认不显示秒，只有HH:mm)</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">0</span>));<span class="comment">//13:23</span></span><br><span class="line"><span class="comment">//获取时、分、秒、纳秒</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">33</span>,<span class="number">1</span>));<span class="comment">//13:23:33.000000001</span></span><br><span class="line"><span class="comment">//获取时、分、秒、纳秒(当纳秒=0时，默认不显示纳秒)</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//13:23</span></span><br><span class="line"><span class="comment">//通过一天内的秒创建LocalTime</span></span><br><span class="line">System.out.println(LocalTime.ofSecondOfDay(<span class="number">24</span>*<span class="number">60</span>));<span class="comment">//00:24</span></span><br><span class="line"><span class="comment">//通过一天内的纳秒创建LocalTime</span></span><br><span class="line">System.out.println(LocalTime.ofNanoOfDay(<span class="number">24</span>*<span class="number">60</span>));<span class="comment">//00:00:00.000001440</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LocalTime时间比较"><a href="#LocalTime时间比较" class="headerlink" title="LocalTime时间比较"></a>LocalTime时间比较</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean isAfter(LocalTime other)</td><td>比较时间是否在other之后</td></tr><tr><td>boolean isBefore(LocalTime other)</td><td>比较时间是否在other之前</td></tr><tr><td>int compareTo(LocalTime other)</td><td>时间比较localTimeA.compareTo(localTimeB)，若相等返回0；若A&gt;B，返回1 ；若A&lt;B返回-1</td></tr><tr><td><strong>说明</strong></td><td></td></tr><tr><td>isAfter、isBefore只能比较之前之后，当值相等的时候，需要用compareTo比较</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">before</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">after</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前时分秒纳秒</span></span><br><span class="line">System.out.println(before.isAfter(after)); <span class="comment">//false</span></span><br><span class="line">System.out.println(before.isBefore(after)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(before.compareTo(after)); <span class="comment">//-1</span></span><br><span class="line">System.out.println(after.compareTo(before)); <span class="comment">//1</span></span><br><span class="line">System.out.println(before.compareTo(before)); <span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获取时、分、秒、纳秒"><a href="#获取时、分、秒、纳秒" class="headerlink" title="获取时、分、秒、纳秒"></a>获取时、分、秒、纳秒</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getHour()</td><td>获取小时 ，返回0到23</td></tr><tr><td>int getMinute()</td><td>获取分钟，返回0到59</td></tr><tr><td>int getSecond()</td><td>获取秒，返回0到59</td></tr><tr><td>int getNano()</td><td>获取纳秒，返回0到999,999,999</td></tr><tr><td>int get(TemporalField field)</td><td>通用方法，通过传入TemporalField对象可以获取时、分、秒、毫秒、纳秒 …</td></tr><tr><td>long getLong(TemporalField field)</td><td>通用方法，通过传入TemporalField对象可以获取时、分、秒、毫秒、纳秒…</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:51:01.167526700&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取小时</span></span><br><span class="line">System.out.println(now.getHour()); <span class="comment">//15</span></span><br><span class="line"><span class="comment">//获取分钟</span></span><br><span class="line">System.out.println(now.getMinute()); <span class="comment">//51</span></span><br><span class="line"><span class="comment">//获取秒</span></span><br><span class="line">System.out.println(now.getSecond()); <span class="comment">//1</span></span><br><span class="line"><span class="comment">//获取纳秒</span></span><br><span class="line">System.out.println(now.getNano()); <span class="comment">//167526700</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用获取，通过传入TemporalField对象，获取时、分、秒、纳秒等值</span></span><br><span class="line">System.out.println(now.get(ChronoField.HOUR_OF_DAY)); <span class="comment">//15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="时间计算，加-x2F-减时、分、秒、纳秒…"><a href="#时间计算，加-x2F-减时、分、秒、纳秒…" class="headerlink" title="时间计算，加&#x2F;减时、分、秒、纳秒…"></a>时间计算，加&#x2F;减时、分、秒、纳秒…</h5><h6 id="加-x2F-减时、分、秒、纳秒"><a href="#加-x2F-减时、分、秒、纳秒" class="headerlink" title="加&#x2F;减时、分、秒、纳秒"></a>加&#x2F;减时、分、秒、纳秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalTime plus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制增加纳秒、微秒、毫秒、秒、分、时</td></tr><tr><td>LocalTime plusHours(long hoursToAdd)</td><td>返回增加了*小时的LocalTime副本</td></tr><tr><td>LocalTime plusMinutes(long minutesToAdd)</td><td>返回增加了*分钟的LocalTime副本</td></tr><tr><td>LocalTime plusSeconds(long secondstoAdd)</td><td>返回增加了*秒的LocalTime副本</td></tr><tr><td>LocalTime plusNanos(long nanosToAdd)</td><td>返回增加了*纳秒的LocalTime副本</td></tr><tr><td>LocalTime minus(long amountToSubtract, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制减少纳秒、微秒、毫秒、秒、分、时</td></tr><tr><td>LocalTime minusHours(long hoursToSubtract)</td><td>返回减少了*小时的LocalTime副本</td></tr><tr><td>LocalTime minusMinutes(long minutesToSubtract)</td><td>返回减少了*分钟的LocalTime副本</td></tr><tr><td>LocalTime minusSeconds(long secondsToSubtract)</td><td>返回减少了*秒的LocalTime副本</td></tr><tr><td>LocalTime minusNanos(long nanosToSubtract)</td><td>返回减少了*纳秒的LocalTime副本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="comment">//LocalTime plus(long amountToAdd, TemporalUnit unit)  </span></span><br><span class="line"><span class="comment">//当前api中unit可以用的有NANOS、MICROS、MILLIS、SECONDS、MINUTES、HOURS、HALF_DAYS。其他单元不可用</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1小时：&quot;</span>+now.plus(<span class="number">1</span>, ChronoUnit.HOURS)); <span class="comment">//11:51:01.167526700</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;增加1小时：&quot;</span>+now.plusHours(<span class="number">1</span>));<span class="comment">//11:51:01.167526700</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1分钟：&quot;</span>+now.plusMinutes(<span class="number">1</span>));<span class="comment">//10:52:01.167526700</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1秒：&quot;</span>+now.plusSeconds(<span class="number">1</span>));<span class="comment">//10:51:02.167526700</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1纳秒：&quot;</span>+now.plusNanos(<span class="number">1</span>));<span class="comment">//10:51:01.167526701</span></span><br></pre></td></tr></table></figure><h6 id="计算两个时间的间隔"><a href="#计算两个时间的间隔" class="headerlink" title="计算两个时间的间隔"></a>计算两个时间的间隔</h6><ol><li><p>方法一：</p><blockquote><p>通过Duration计算两个LocalTime相差的时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:52:03.167526701&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//between的用法是end-start的时间，若start的时间大于end的时间，则所有的值是负的</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+duration.toSeconds()+<span class="string">&quot;秒，相差：&quot;</span>+duration.toHours()+<span class="string">&quot;小时，相差：&quot;</span>+duration.toMinutes()+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">18062</span>秒，相差：<span class="number">5</span>小时，相差：<span class="number">301</span>分钟</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><blockquote><p>ChronoUnit也可以计算两个单元之间的差值。<br>我们使用ChronoUnit类的between() 方法来执行相同的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:52:03.167526701&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> ChronoUnit.SECONDS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">hour</span> <span class="operator">=</span> ChronoUnit.HOURS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">minute</span> <span class="operator">=</span> ChronoUnit.MINUTES.between(start , end );</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+seconds+<span class="string">&quot;秒，相差：&quot;</span>+hour+<span class="string">&quot;小时，相差：&quot;</span>+minute+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">18062</span>秒，相差：<span class="number">5</span>小时，相差：<span class="number">301</span>分钟</span><br></pre></td></tr></table></figure></li><li><p>方法三：</p><blockquote><p>通过LocalTime类的toSecondOfDay()方法，返回时间对应的秒数，然后计算出两个时间相差的间隔</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:52:03.167526701&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> end.toSecondOfDay() - start.toSecondOfDay();</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+time+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">18062</span>秒</span><br></pre></td></tr></table></figure></li></ol><h5 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalTime parse(CharSequence text)</td><td>从文本字符串获取LocalTime实例，text格式一般是10:15或者10:15:30</td></tr><tr><td>static LocalTime parse(CharSequence text, DateTimeFormatter formatter)</td><td>使用特定格式化形式从文本字符串获取LocalTime实例，text的格式一般与formatter格式一致，如text为HH:mm格式,则formatter也应该为HH:mm格式,否则可能会报错</td></tr><tr><td>String format(DateTimeFormatter formatter)</td><td>将LocalTime转为特定格式的字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line">System.out.println(time); <span class="comment">//10:51:01.167526700</span></span><br><span class="line"></span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;10:51&quot;</span>);</span><br><span class="line">System.out.println(time);<span class="comment">//10:51</span></span><br><span class="line"></span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;10:51:01&quot;</span>);</span><br><span class="line">System.out.println(time);<span class="comment">//10:51:01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若使用parse(CharSequence text, DateTimeFormatter formatter)，text格式需与formatter格式一致，否则可能会报错</span></span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;10:51:01&quot;</span>,DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>));</span><br><span class="line">System.out.println(time);<span class="comment">//10:51:01</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;HH-mm-ss&quot;</span>));</span><br><span class="line">System.out.println(time1); <span class="comment">//10-51-01</span></span><br></pre></td></tr></table></figure><h5 id="LocalTime进阶"><a href="#LocalTime进阶" class="headerlink" title="LocalTime进阶"></a>LocalTime进阶</h5><h6 id="修改LocalTime的时、分、秒、纳秒"><a href="#修改LocalTime的时、分、秒、纳秒" class="headerlink" title="修改LocalTime的时、分、秒、纳秒"></a>修改LocalTime的时、分、秒、纳秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalTime with(TemporalAdjuster adjuster)</td><td>使用传递的TemporalAdjuster时间调节器作为参数来调整此日期时间，并在调整后返回调整后的时间的副本</td></tr><tr><td>LocalTime with(TemporalField field, long newValue)</td><td>用于将LocalTime的指定字段设置为新值并返回新的时间的副本。此方法可用于更改任何受支持的字段，例如时、分、秒…。如果由于不支持该字段或其他原因而无法设置新值，则会引发异常。</td></tr><tr><td>LocalTime withHour(int hour)</td><td>修改LocalTime变量的小时，hour:从0到23</td></tr><tr><td>LocalTime withMinute(int minute)</td><td>修改LocalTime变量的分钟，minute:从0到59</td></tr><tr><td>LocalTime withSecond(int second)</td><td>修改LocalTime变量的秒，second:从0到59</td></tr><tr><td>LocalTime withNano(int nanoOfSecond)</td><td>修改LocalTime变量的纳秒，nanoOfSecond:从0到999,999,999</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:03.167526700&quot;</span>);</span><br><span class="line"><span class="comment">//修改LocalTime变量的小时</span></span><br><span class="line">System.out.println(time.withHour(<span class="number">1</span>)); <span class="comment">//01:51:03.167526700</span></span><br><span class="line"><span class="comment">//修改LocalTime变量的分钟</span></span><br><span class="line">System.out.println(time.withMinute(<span class="number">1</span>)); <span class="comment">//10:01:03.167526700</span></span><br><span class="line"><span class="comment">//修改LocalTime变量的秒</span></span><br><span class="line">System.out.println(time.withSecond(<span class="number">1</span>)); <span class="comment">//10:51:01.167526700</span></span><br><span class="line"><span class="comment">//修改LocalTime变量的纳秒</span></span><br><span class="line">System.out.println(time.withNano(<span class="number">1</span>)); <span class="comment">//10:51:03.000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改LocalTime变量的秒</span></span><br><span class="line">System.out.println(time.with(ChronoField.SECOND_OF_MINUTE, <span class="number">1</span>)); <span class="comment">//10:51:01.167526700</span></span><br></pre></td></tr></table></figure><h5 id="LocalTime的注意事项"><a href="#LocalTime的注意事项" class="headerlink" title="LocalTime的注意事项"></a>LocalTime的注意事项</h5><p>java.time.LocalTime -&gt;只对时分秒纳秒做出处理</p><blockquote><p>默认格式：HH:mm:ss.SSSSSSSSS 例如：11:23:40.051942200。<br><code>当纳秒&lt;=0时，不显示纳秒</code><br><code>当秒&lt;=0且纳秒&lt;=0时，默认只显示时:分 如11：23</code></p></blockquote><h6 id="LocalTime有时候不显示秒？"><a href="#LocalTime有时候不显示秒？" class="headerlink" title="LocalTime有时候不显示秒？"></a>LocalTime有时候不显示秒？</h6><blockquote><p>LocalTime有时候会不显示秒，有时候我们需要把时间转化为HH:mm:ss格式时，这可能就是个坑，那么如果让LocalTime输出指定的格式呢？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">t1</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:00:00&quot;</span>);</span><br><span class="line"><span class="comment">//不显示秒示例</span></span><br><span class="line">System.out.println(t1);<span class="comment">//10:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(dtf.format(t1)); <span class="comment">//10:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">LocalTime t2= LocalTime.parse(<span class="string">&quot;10:00:00&quot;</span>, dtf);</span><br><span class="line">System.out.println(t2.format(DateTimeFormatter.ISO_LOCAL_TIME));<span class="comment">//10:00:00</span></span><br></pre></td></tr></table></figure><h4 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h4><p>java.time.LocalDateTime -&gt;同时可以处理年月日和时分秒</p><blockquote><p>默认格式：yyyy-MM-ddTHH:mm:ss.SSSSSSSSS 例如：2021-12-01T11:27:22.598224900</p></blockquote><h5 id="创建LocalDateTime"><a href="#创建LocalDateTime" class="headerlink" title="创建LocalDateTime"></a>创建LocalDateTime</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalDateTime now()</td><td>获取默认时区的当前日期时间，默认格式yyyy-MM-ddTHH:mm:ss.SSSSSSSSS</td></tr><tr><td>static LocalDateTime now(ZoneId zone)</td><td>从指定时区获取日期时间</td></tr><tr><td>static LocalDateTime now(Clock clock)</td><td>从指定闹钟获取日期时间</td></tr><tr><td>static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)</td><td>根据年月日时分秒创建日期时间</td></tr><tr><td>static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</td><td>根据年月日时分秒纳秒创建日期时间</td></tr><tr><td>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)</td><td>根据年月日时分秒创建日期时间</td></tr><tr><td>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</td><td>根据年月日时分秒纳秒创建日期时间</td></tr><tr><td>static LocalDateTime of(LocalDate date, LocalTime time)</td><td>根据LocalDate与LocalTime创建时间</td></tr><tr><td>static LocalDateTime ofInstant(Instant instant, ZoneId zone)</td><td>通过Instant实例与时区创建时间</td></tr><tr><td>static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)</td><td>通过毫秒数、纳秒数及时区创建时间epochSecond：从1970-01-01T00:00:00到指定时间的秒数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;当前默认时间：&quot;</span>+LocalDateTime.now());</span><br><span class="line">System.out.println(<span class="string">&quot;当前指定时区时间：&quot;</span>+LocalDateTime.now(ZoneId.systemDefault()));</span><br><span class="line">System.out.println(<span class="string">&quot;当前指定闹钟时间：&quot;</span>+LocalDateTime.now(Clock.systemUTC()));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, Month.DECEMBER, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">23</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒纳秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, Month.DECEMBER, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>,<span class="number">23</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒纳秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>,<span class="number">23</span>,<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;localDate、LocalTime时间：&quot;</span>+LocalDateTime.of(LocalDate.now(),LocalTime.now()));</span><br><span class="line">System.out.println(<span class="string">&quot;创建Instant实例时间：&quot;</span>+LocalDateTime.ofInstant(Instant.now(), ZoneId.of(<span class="string">&quot;UTC&quot;</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;通过秒、毫秒创建时间：&quot;</span>+LocalDateTime.ofEpochSecond(Instant.now().getEpochSecond(), <span class="number">222</span>, ZoneOffset.UTC));</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前默认时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">33</span>:<span class="number">08.769938300</span></span><br><span class="line">当前指定时区时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">33</span>:<span class="number">08.805841900</span></span><br><span class="line">当前指定闹钟时间：<span class="number">2021</span>-<span class="number">12</span>-06T02:<span class="number">33</span>:<span class="number">08.805841900</span></span><br><span class="line">指定时分秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">指定时分秒纳秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23.000000001</span></span><br><span class="line">指定时分秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">指定时分秒纳秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23.000000001</span></span><br><span class="line">localDate、LocalTime时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">33</span>:<span class="number">08.809832100</span></span><br><span class="line">创建Instant实例时间：<span class="number">2021</span>-<span class="number">12</span>-06T02:<span class="number">33</span>:<span class="number">08.810829400</span></span><br><span class="line">通过秒、毫秒创建时间：<span class="number">2021</span>-<span class="number">12</span>-06T02:<span class="number">33</span>:<span class="number">08.000000222</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获取年月日时分秒纳秒"><a href="#获取年月日时分秒纳秒" class="headerlink" title="获取年月日时分秒纳秒"></a>获取年月日时分秒纳秒</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getYear()</td><td>获取年份</td></tr><tr><td>Month getMonth()</td><td>使用月枚举类型获取月份</td></tr><tr><td>int getMonthValue()</td><td>返回数字月份 1-12月</td></tr><tr><td>int getDayOfMonth()</td><td>获取日期在该月是第几天</td></tr><tr><td>DayOfWeek getDayOfWeek()</td><td>获取日期是星期几</td></tr><tr><td>int getDayOfYear()</td><td>获取日期在该年是第几天</td></tr><tr><td>int getHour()</td><td>获取小时， 返回0到23</td></tr><tr><td>int getMinute()</td><td>获取分钟， 返回0到59</td></tr><tr><td>int getSecond()</td><td>获取秒，返回0到59</td></tr><tr><td>int getNano()</td><td>获取纳秒，返回0到999,999,999</td></tr></tbody></table><p>使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前默认时间：&quot;</span>+now);</span><br><span class="line"><span class="comment">//获取年份</span></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span>+now.getYear());</span><br><span class="line"><span class="comment">//获取月份</span></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+now.getMonth().getValue());</span><br><span class="line"><span class="comment">//获取当前日期是当月的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+now.getDayOfMonth());</span><br><span class="line"><span class="comment">//获取当前日期是星期几</span></span><br><span class="line">System.out.println(<span class="string">&quot;星期几：&quot;</span>+now.getDayOfWeek());</span><br><span class="line"><span class="comment">//获取当前日期是当年的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+now.getDayOfYear());</span><br><span class="line"><span class="comment">//获取小时、分钟、秒、纳秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前时间：&quot;</span>+now.getHour()+<span class="string">&quot;小时，&quot;</span>+now.getMinute()+<span class="string">&quot;分钟，&quot;</span>+now.getSecond()+<span class="string">&quot;秒，&quot;</span>+now.getNano()+<span class="string">&quot;纳秒&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用获取日期时间方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前时间：&quot;</span>+now.get(ChronoField.HOUR_OF_DAY)+<span class="string">&quot;小时，&quot;</span>+now.get(ChronoField.MINUTE_OF_HOUR)+<span class="string">&quot;分钟，&quot;</span>+now.get(ChronoField.SECOND_OF_MINUTE)+<span class="string">&quot;秒&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前默认时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">57</span>:<span class="number">14.833390300</span></span><br><span class="line">年：<span class="number">2021</span></span><br><span class="line">月：<span class="number">12</span></span><br><span class="line">日：<span class="number">6</span></span><br><span class="line">星期几：MONDAY</span><br><span class="line">日：<span class="number">340</span></span><br><span class="line">当前时间：<span class="number">10</span>小时，<span class="number">57</span>分钟，<span class="number">14</span>秒，<span class="number">833390300</span>纳秒</span><br><span class="line">当前时间：<span class="number">10</span>小时，<span class="number">57</span>分钟，<span class="number">14</span>秒</span><br></pre></td></tr></table></figure><h5 id="LocalDateTime日期比较"><a href="#LocalDateTime日期比较" class="headerlink" title="LocalDateTime日期比较"></a>LocalDateTime日期比较</h5><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>boolean isBefore(ChronoLocalDateTime&lt;?&gt; other)</td><td>检查日期是否在指定日期之前</td></tr><tr><td>boolean isAfter(ChronoLocalDateTime&lt;?&gt; other)</td><td>检查日期是否在指定日期之后</td></tr><tr><td>boolean isEqual(ChronoLocalDateTime&lt;?&gt; other)</td><td>比较日期是否相同</td></tr><tr><td>int compareTo(ChronoLocalDateTime&lt;?&gt; other)</td><td>日期比较localDateTimeA.compareTo(localDateTimeB)，若相等返回0；若A&gt;B，返回1 ；若A&lt;B返回-1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">before</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:57:14.833390300&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">after</span>  <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T21:57:14.833390300&quot;</span>);</span><br><span class="line">System.out.println(before.isBefore(after));<span class="comment">//true</span></span><br><span class="line">System.out.println(before.isAfter(after));<span class="comment">//false</span></span><br><span class="line">System.out.println(before.isEqual(before)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(before.compareTo(after));<span class="comment">//-1</span></span><br><span class="line">System.out.println(after.compareTo(before));<span class="comment">//1</span></span><br><span class="line">System.out.println(after.compareTo(after));<span class="comment">//0</span></span><br></pre></td></tr></table></figure><h5 id="日期计算，加-x2F-减年、月、周、日、时、分、秒"><a href="#日期计算，加-x2F-减年、月、周、日、时、分、秒" class="headerlink" title="日期计算，加&#x2F;减年、月、周、日、时、分、秒"></a>日期计算，加&#x2F;减年、月、周、日、时、分、秒</h5><h6 id="加-x2F-减年、月、周、日、时、分、秒"><a href="#加-x2F-减年、月、周、日、时、分、秒" class="headerlink" title="加&#x2F;减年、月、周、日、时、分、秒"></a>加&#x2F;减年、月、周、日、时、分、秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDateTime plus(TemporalAmount amountToAdd)</td><td>通过TemporalAmount对象增加指定日期时间，TemporalAmount的实现一般是Period,Duration对象</td></tr><tr><td>LocalDateTime plus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制增加天、周、月、年</td></tr><tr><td>LocalDateTime plusDays(long daysToAdd)</td><td>返回增加了*天的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusWeeks(long weeksToAdd)</td><td>返回增加了*周的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusMonths(long monthsToAdd)</td><td>返回增加了*月的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusYears(long yearsToAdd)</td><td>返回增加了*年的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusHours(long hours)</td><td>返回增加了*小时的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusMinutes(long minutes)</td><td>返回增加了*分钟的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusSeconds(long seconds)</td><td>返回增加了*秒的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusNanos(long nanos)</td><td>返回增加了*纳秒的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minus(TemporalAmount amountToAdd)</td><td>通过TemporalAmount对象减少指定日期时间，TemporalAmount的实现一般是Period,Duration对象</td></tr><tr><td>LocalDateTime minus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制减少天、周、月、年</td></tr><tr><td>LocalDateTime minusDays(long daysToSubtract)</td><td>返回减少了*天的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusWeeks(long weeksToSubtract)</td><td>返回减少了*周的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusMonths(long monthsToSubtract)</td><td>返回减少了*月的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusYears(long yearsToSubtract)</td><td>返回减少了*年的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusHours(long hours)</td><td>返回减少了*小时的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusMinutes(long minutes)</td><td>返回减少了*分钟的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusSeconds(long seconds)</td><td>返回减少了*秒的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusNanos(long nanos)</td><td>返回减少了*纳秒的LocalDateTime 副本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;增加1年：&quot;</span>+now.plusYears(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;增加1月：&quot;</span>+now.plusMonths(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;增加1天：&quot;</span>+now.plusDays(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;减少1小时：&quot;</span>+now.minusHours(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;减少1分钟：&quot;</span>+now.minusMinutes(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;减少1秒：&quot;</span>+now.minusSeconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime plus(TemporalAmount amountToAdd)</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加2个月：&quot;</span>+now.plus(Period.ofMonths(<span class="number">2</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;增加2天：&quot;</span>+now.plus(Duration.ofDays(<span class="number">2</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;增加1纳秒：&quot;</span>+now.plus(<span class="number">1</span>, ChronoUnit.NANOS));</span><br><span class="line">System.out.println(<span class="string">&quot;减少1分钟：&quot;</span>+now.minus(<span class="number">1</span>, ChronoUnit.MINUTES));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">增加<span class="number">1</span>年：<span class="number">2022</span>-<span class="number">12</span>-06T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">1</span>月：<span class="number">2022</span>-<span class="number">01</span>-06T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">1</span>天：<span class="number">2021</span>-<span class="number">12</span>-07T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">减少<span class="number">1</span>小时：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">减少<span class="number">1</span>分钟：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line">减少<span class="number">1</span>秒：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">01</span></span><br><span class="line">增加<span class="number">2</span>个月：<span class="number">2022</span>-<span class="number">02</span>-06T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">2</span>天：<span class="number">2021</span>-<span class="number">12</span>-08T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">1</span>纳秒：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">01</span>:<span class="number">01.000000001</span></span><br><span class="line">减少<span class="number">1</span>分钟：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">00</span>:<span class="number">01</span></span><br></pre></td></tr></table></figure><h6 id="计算两个日期时间的间隔"><a href="#计算两个日期时间的间隔" class="headerlink" title="计算两个日期时间的间隔"></a>计算两个日期时间的间隔</h6><p>方法一：</p><blockquote><p>通过Duration计算两个LocalTime相差的时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span>   <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-07T11:06:01&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//between的用法是end-start的时间，若start的时间大于end的时间，则所有的值是负的</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+duration.toDays()+<span class="string">&quot;天，相差&quot;</span>+duration.toSeconds()+<span class="string">&quot;秒，相差：&quot;</span>+duration.toHours()+<span class="string">&quot;小时，相差：&quot;</span>+duration.toMinutes()+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">1</span>天，相差<span class="number">86700</span>秒，相差：<span class="number">24</span>小时，相差：<span class="number">1445</span>分钟</span><br></pre></td></tr></table></figure><p>方法二：</p><blockquote><p>ChronoUnit也可以计算两个单元之间的差值。<br>我们使用ChronoUnit类的between() 方法来执行相同的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span>   <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-07T11:06:01&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> ChronoUnit.DAYS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> ChronoUnit.SECONDS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">hour</span> <span class="operator">=</span> ChronoUnit.HOURS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">minute</span> <span class="operator">=</span> ChronoUnit.MINUTES.between(start , end );</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+day + <span class="string">&quot;天，相差&quot;</span>+seconds+<span class="string">&quot;秒，相差：&quot;</span>+hour+<span class="string">&quot;小时，相差：&quot;</span>+minute+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">1</span>天，相差<span class="number">86700</span>秒，相差：<span class="number">24</span>小时，相差：<span class="number">1445</span>分钟</span><br></pre></td></tr></table></figure><p>方法三：</p><blockquote><p>通过LocalDateTime类的toEpochSecond()方法，返回时间对应的秒数，然后计算出两个时间相差的间隔</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span>   <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-07T11:06:01&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+ (end.toEpochSecond(ZoneOffset.UTC) - start.toEpochSecond(ZoneOffset.UTC)) +<span class="string">&quot;秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">86700</span>秒</span><br></pre></td></tr></table></figure><h5 id="时间格式化-1"><a href="#时间格式化-1" class="headerlink" title="时间格式化"></a>时间格式化</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalDateTime parse(CharSequence text)</td><td>从文本字符串获取LocalDateTime实例，text格式一般是2007-12-03T10:15:30</td></tr><tr><td>static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)</td><td>使用特定格式化形式从文本字符串获取LocalDateTime实例，text的格式一般与formatter格式一致</td></tr><tr><td>String format(DateTimeFormatter formatter)</td><td>将LocalTime转为特定格式的字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line">System.out.println(time); <span class="comment">//2021-12-06T11:01:01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若使用parse(CharSequence text, DateTimeFormatter formatter)，text格式需与formatter格式一致，否则可能会报错</span></span><br><span class="line">time = LocalDateTime.parse(<span class="string">&quot;2021-12-06 11:01:01&quot;</span>,DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">System.out.println(time);<span class="comment">//2021-12-06T11:01:01</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH-mm-ss&quot;</span>));</span><br><span class="line">System.out.println(time1); <span class="comment">//2021-12-06 11-01-01</span></span><br></pre></td></tr></table></figure><p>注意：<br>parse(CharSequence text, DateTimeFormatter formatter)与format(DateTimeFormatter formatter)两个方法表现不一样，parse后输出格式为yyyy-MM-ddTHH:mm:ss.SSSSSSSSS，format后输出格式为formatter样式。</p><h6 id="LocalDateTime进阶"><a href="#LocalDateTime进阶" class="headerlink" title="LocalDateTime进阶"></a>LocalDateTime进阶</h6><h6 id="修改年、月、日、时、分、秒、纳秒"><a href="#修改年、月、日、时、分、秒、纳秒" class="headerlink" title="修改年、月、日、时、分、秒、纳秒"></a>修改年、月、日、时、分、秒、纳秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDateTime with(TemporalAdjuster adjuster)</td><td>使用传递的TemporalAdjuster时间调节器作为参数来调整此日期时间，并在调整后返回调整后的时间的副本</td></tr><tr><td>LocalDateTime with(TemporalField field, long newValue)</td><td>用于将LocalTime的指定字段设置为新值并返回新的时间的副本。此方法可用于更改任何受支持的字段，例如时、分、秒…。如果由于不支持该字段或其他原因而无法设置新值，则会引发异常。</td></tr><tr><td>LocalDateTime withYear(int year)</td><td>修改LocalTime变量的年</td></tr><tr><td>LocalDateTime withMonth(int month)</td><td>修改LocalTime变量的月份</td></tr><tr><td>LocalDateTime withDayOfMonth(int dayOfMonth)</td><td>修改LocalTime变量的日</td></tr><tr><td>LocalDateTime withHour(int hour)</td><td>修改LocalTime变量的小时，hour:从0到23</td></tr><tr><td>LocalDateTime withMinute(int minute)</td><td>修改LocalDateTime变量的分钟，minute:从0到59</td></tr><tr><td>LocalDateTime withSecond(int second)</td><td>修改LocalDateTime变量的秒，second:从0到59</td></tr><tr><td>LocalDateTime withNano(int nanoOfSecond)</td><td>修改LocalDateTime变量的纳秒，nanoOfSecond:从0到999,999,999</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:11:11&quot;</span>);</span><br><span class="line"><span class="comment">//修改LocalDateTime变量的年</span></span><br><span class="line">System.out.println(time.withYear(<span class="number">2020</span>)); <span class="comment">//2020-12-06T10:11:11</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的月</span></span><br><span class="line">System.out.println(time.withMonth(<span class="number">11</span>)); <span class="comment">//2021-11-06T10:11:11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的小时</span></span><br><span class="line">System.out.println(time.withHour(<span class="number">1</span>)); <span class="comment">//2021-12-06T01:11:11</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的分钟</span></span><br><span class="line">System.out.println(time.withMinute(<span class="number">3</span>)); <span class="comment">//2021-12-06T10:03:11</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的秒</span></span><br><span class="line">System.out.println(time.withSecond(<span class="number">1</span>)); <span class="comment">//2021-12-06T10:11:01</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的纳秒</span></span><br><span class="line">System.out.println(time.withNano(<span class="number">1</span>)); <span class="comment">//2021-12-06T10:11:11.000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法，修改LocalDateTime变量的日</span></span><br><span class="line">System.out.println(time.with(ChronoField.DAY_OF_MONTH, <span class="number">12</span>)); <span class="comment">//2021-12-12T10:11:11</span></span><br></pre></td></tr></table></figure><p><strong>获取下周二上午10点的日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取下周二上午10点的日期</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">ldt = ldt.plusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)</span><br><span class="line">.with(ChronoField.MILLI_OF_DAY, <span class="number">0</span>).withHour(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>获取本月最后一天最后一刻</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span>   LocalDate.now()</span><br><span class="line">.with(TemporalAdjusters.lastDayOfMonth()).atTime(LocalTime.MAX);</span><br></pre></td></tr></table></figure><p><strong>下个月第一个周一的下午五点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span>   LocalDate.now()</span><br><span class="line">.with(TemporalAdjusters.lastDayOfMonth()).atTime(LocalTime.MAX);</span><br></pre></td></tr></table></figure><h6 id="LocalDateTime、LocalDate、LocalTime互转"><a href="#LocalDateTime、LocalDate、LocalTime互转" class="headerlink" title="LocalDateTime、LocalDate、LocalTime互转"></a>LocalDateTime、LocalDate、LocalTime互转</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:11:11&quot;</span>);</span><br><span class="line"><span class="comment">//1. LocalDateTime转LocalDate</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> localDateTime.toLocalDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. LocalDateTime转LocalTime</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> localDateTime.toLocalTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. LocalDate转LocalDateTime</span></span><br><span class="line"><span class="comment">//3.1 LocalDateTime atTime(LocalTime time)</span></span><br><span class="line">localDateTime = localDate.atTime(localTime);</span><br><span class="line"><span class="comment">//3.2 LocalDateTime atTime(int hour, int minute, int second)</span></span><br><span class="line">localDateTime = localDate.atTime(<span class="number">10</span>,<span class="number">11</span>,<span class="number">11</span>);</span><br><span class="line"><span class="comment">//3.3 LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond)</span></span><br><span class="line">localDateTime = localDate.atTime(<span class="number">10</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//3.4 获得一天的开始</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">beginningOfDay</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2016-06-12&quot;</span>).atStartOfDay(); <span class="comment">//2016-06-12T00：00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. LocalTime转LocalDateTime</span></span><br><span class="line"><span class="comment">//4.1 LocalDateTime atDate(LocalDate date)</span></span><br><span class="line">localDateTime = localTime.atDate(localDate);</span><br></pre></td></tr></table></figure><h6 id="LocalDateTime转为Instant、获取时间戳"><a href="#LocalDateTime转为Instant、获取时间戳" class="headerlink" title="LocalDateTime转为Instant、获取时间戳"></a>LocalDateTime转为Instant、获取<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020">时间戳</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:11:11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.LocalDateTime转Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> localDateTime.toInstant(ZoneOffset.UTC);</span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 获取距离1970-01-01T00:00:00Z的秒值</span></span><br><span class="line">System.out.println(instant.getEpochSecond());</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Instant获取时间戳  获取距离1970-01-01T00:00:00Z的毫秒值  与System.currentTimeMillis()一样，返回毫秒数</span></span><br><span class="line">System.out.println(instant.toEpochMilli());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. Date转LocalDateTime  static LocalDateTime ofInstant(Instant instant, ZoneId zone)</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(<span class="keyword">new</span> <span class="title class_">Date</span>().toInstant(),ZoneId.systemDefault());</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Date转LocalTime    static LocalTime ofInstant(Instant instant, ZoneId zone)</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.ofInstant(<span class="keyword">new</span> <span class="title class_">Date</span>().toInstant(),ZoneId.systemDefault());</span><br><span class="line">System.out.println(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. LocalDateTime/LocalTime转Date  static Date from(Instant instant)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(localDateTime.toInstant(ZoneId.systemDefault().getRules().getOffset(localDateTime)));</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.1 LocalDateTime/LocalTime转Date   Date(long date) date:毫秒值</span></span><br><span class="line">date = <span class="keyword">new</span> <span class="title class_">Date</span>(localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">12</span>-06T18:<span class="number">33</span>:<span class="number">17.965</span></span><br><span class="line"><span class="number">18</span>:<span class="number">33</span>:<span class="number">17.982</span></span><br><span class="line">Mon Dec <span class="number">06</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">17</span> CST <span class="number">2021</span></span><br><span class="line">Mon Dec <span class="number">06</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">17</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date转LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> date Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> LocalDateTime</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">dateToLocalDateTime</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">     <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="keyword">return</span> instant.atZone(zoneId).toLocalDateTime();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LocalDateTime转Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> localDateTime LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Date</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">localDateTimeToDate</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> localDateTime.atZone(zoneId);</span><br><span class="line">     <span class="keyword">return</span> Date.from(zdt.toInstant());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><code>Collections</code> 是一个操作<code>Set</code> <code>List</code> 和 <code>Map</code>等集合的工具类</li><li><code>Collections</code> 中提供一系静态的方法对集合元素进行排序 ， 查询和修改等操作</li></ol><h4 id="常用方法【均为static方法】"><a href="#常用方法【均为static方法】" class="headerlink" title="常用方法【均为static方法】"></a><strong>常用方法【均为<code>static</code>方法】</strong></h4><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>reverse(List)</td><td>反转List中元素的顺序</td></tr><tr><td>shuffle(List)</td><td>对List集合元素进行随机排序</td></tr><tr><td>ort(List)</td><td>根据元素的自然顺序对指定List集合元素按升序排序</td></tr><tr><td>sort(List,Comparator)</td><td>根据指定的Comparator产生的顺序对List集合元素进行排序</td></tr></tbody></table><h5 id="替换-和-查找操作"><a href="#替换-和-查找操作" class="headerlink" title="替换 和 查找操作"></a>替换 和 查找操作</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>swap(List, int ,int )</td><td>将指定List集合中的 i 处元素 和 j 处元素进行交换</td></tr><tr><td>Object max(Collection)</td><td>根据元素的自然顺序，返回给定集合中的最大元素</td></tr><tr><td>Object max(Collection, Comparator)</td><td>根据Comparator指定的顺序，返回给集合中的最大元素</td></tr><tr><td>Object min(Collection)</td><td>根据元素的自然顺序，返回给定集合中的最小元素</td></tr><tr><td>Object min(Collection, Comparator)</td><td>根据Comparator指定的顺序，返回给集合中的最大元素</td></tr><tr><td>int frequency(Collection,Object)</td><td>返回指定集合中指定元素的出现次数</td></tr><tr><td>void copy(List dest,List src)</td><td>将src中的内容复制到dest中<br/> 注意复制的目标集合的长度必须大于源集合，否则会抛出空指针异常</td></tr><tr><td>boolean replaceAll(List list,Object oldVal,Object newVal)</td><td>使用新值替换List对象的所有旧值</td></tr></tbody></table><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection_.collectionP.collection_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;湛江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;海康&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;南宁&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;佛山&quot;</span>);</span><br><span class="line">        <span class="comment">// reverse(List) 反转中元素的顺序 就是将原来的顺序反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shuffle(list) 对List集合元素进行随机排序</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort 根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;自然顺序排序&quot;</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// sort(list , Comparator) 根据指定的Comparator 产生的顺序对List集合元素进行排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Comparator制定排序&quot;</span>);</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                <span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// swap(List,int ,int) 将指定List集合中 i 处元素  和  j 处元素进行交换</span></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换后的位置=&quot;</span>+list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object max(Collection) 根据元素的自然顺序，返回给定集合中最大元素</span></span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;自然排序后的最大值max=&quot;</span>+max);</span><br><span class="line">        <span class="comment">// Object max(Collection,Comparator) 根据Comparator指定的顺序返回给定集合中的最大元素</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">max1</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((String) o1).compareTo((String) o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定排序规则的最大值=&quot;</span>+max1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object min(Collection) 根据元素的自然排序，返回给定集合的最小值</span></span><br><span class="line">        <span class="comment">// Object min(Collection , Comparator) 根据Comparator指定的顺序返回给定集合中的最小值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int frequency(Collection ,Object) 返回指定集合中指定元素的出现次数</span></span><br><span class="line">        <span class="comment">// Collection：集合  Object 该元素出现次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tom</span> <span class="operator">=</span> Collections.frequency(list, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;tom出现的次数=&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy(List dest ,List src)：将src中的内容复制到dest中【】</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            dest.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line">        <span class="comment">//注意复制的目标集合的长度必须大于源集合，否则会抛出空指针异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的集合=&quot;</span>+dest);</span><br><span class="line">        <span class="comment">/**   copy的源码剖析</span></span><br><span class="line"><span class="comment">         *     public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span></span><br><span class="line"><span class="comment">         *         int srcSize = src.size(); </span></span><br><span class="line"><span class="comment">         *         if (srcSize &gt; dest.size()) 如果目标集合的长度不大于源集合长度则会抛出空指针异常</span></span><br><span class="line"><span class="comment">         *             throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *        如果源集合的长度小于10或源集合和目标集合类型是RandomAccess，则执行if块代码，否则执行else代码</span></span><br><span class="line"><span class="comment">         *         if (srcSize &lt; COPY_THRESHOLD ||</span></span><br><span class="line"><span class="comment">         *             (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123;</span></span><br><span class="line"><span class="comment">         *             for (int i=0; i&lt;srcSize; i++)</span></span><br><span class="line"><span class="comment">         *                 dest.set(i, src.get(i));</span></span><br><span class="line"><span class="comment">         *         &#125; else &#123;</span></span><br><span class="line"><span class="comment">         *             ListIterator&lt;? super T&gt; di=dest.listIterator();</span></span><br><span class="line"><span class="comment">         *             ListIterator&lt;? extends T&gt; si=src.listIterator();</span></span><br><span class="line"><span class="comment">         *             for (int i=0; i&lt;srcSize; i++) &#123;</span></span><br><span class="line"><span class="comment">         *                 di.next();</span></span><br><span class="line"><span class="comment">         *                 di.set(si.next());</span></span><br><span class="line"><span class="comment">         *             &#125;</span></span><br><span class="line"><span class="comment">         *         &#125;</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// boolean replaceAll(List list,Object oldVal ,Object newVal)：使用新值替换List对象的所有旧值</span></span><br><span class="line">        Collections.replaceAll(list,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;汤姆&quot;</span>);<span class="comment">//将tom 替换成 汤姆</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><p>什么是泛型？为什么要使用泛型？</p><blockquote><p> 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;item = &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错</span></span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>泛型只在编译阶段有效。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">classStringArrayList</span> <span class="operator">=</span> stringArrayList.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">classIntegerArrayList</span> <span class="operator">=</span> integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：D&#x2F;泛型测试: 类型相同。</p><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最普通的泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;(<span class="string">&quot;key_vlaue&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + genericString.getKey());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">27</span> 09:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> 09:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p>看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Generic</span> <span class="variable">generic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line"><span class="type">Generic</span> <span class="variable">generic1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>(<span class="number">4444</span>);</span><br><span class="line"><span class="type">Generic</span> <span class="variable">generic2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>(<span class="number">55.55</span>);</span><br><span class="line"><span class="type">Generic</span> <span class="variable">generic3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic3.getKey());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>泛型的类型参数只能是类类型，不能是简单类型。<br>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，未传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">FruitGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">       <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<Ingeter>与Generic<Number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<Number>作为形参的方法中，能否使用Generic<Ingeter>的实例传入呢？在逻辑上类似于Generic<Number>和Generic<Ingeter>是否可以看成具有父子关系的泛型类型呢？</p><p>为了弄清楚这个问题，我们使用Generic<T>这个泛型类继续看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span></span><br><span class="line"><span class="comment">// cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line"><span class="comment">// showKeyValue(gInteger);</span></span><br></pre></td></tr></table></figure><p>通过提示信息我们可以看到Generic<Integer>不能被看作为&#96;Generic<Number>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<Integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<Integer>和Generic<Number>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p><p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span><br><span class="line">     IllegalAccessException&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> tClass.newInstance();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> genericMethod(Class.forName(<span class="string">&quot;com.test.test&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h5><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;container key :&quot;</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">test</span> <span class="operator">=</span> container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot;</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot;</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h5><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericFruit</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">GenerateTest</span>&lt;T&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show_1</span><span class="params">(T t)</span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show_3</span><span class="params">(E t)</span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show_2</span><span class="params">(T t)</span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    </span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> <span class="title class_">GenerateTest</span>&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h5><p>再看一个泛型方法和可变参数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printMsg</span><span class="params">( T... args)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;t is &quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">&quot;111&quot;</span>,<span class="number">222</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;2323.4&quot;</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h5 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h5><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p><p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticGenerator</span>&lt;T&gt; &#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">      即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">        * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h5><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p><blockquote><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p></blockquote><h4 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h4><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showKeyValue1</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Generic&lt;Float&gt; generic3 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Generic&lt;Double&gt; generic4 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Double&gt;(<span class="number">2.56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span></span><br><span class="line"><span class="comment">//showKeyValue1(generic1);</span></span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);</span><br></pre></td></tr></table></figure><p>如果我们把泛型类的定义也改一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这一行代码也会报错，因为String不是Number的子类</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;(<span class="string">&quot;11111&quot;</span>);</span><br></pre></td></tr></table></figure><p>再来一个泛型方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; T <span class="title function_">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;container key :&quot;</span> + container.getKey());</span><br><span class="line">    <span class="type">T</span> <span class="variable">test</span> <span class="operator">=</span> container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。</p><h4 id="关于泛型数组要提一下"><a href="#关于泛型数组要提一下" class="headerlink" title="关于泛型数组要提一下"></a>关于泛型数组要提一下</h4><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。</p><p>也就是说下面的这个例子是不可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>];  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>];  </span><br></pre></td></tr></table></figure><p>这样也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>下面使用Sun的一篇文档的一个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p><p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p><p>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> <span class="title class_">List</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK </span></span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。</p><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程or线程？"><a href="#进程or线程？" class="headerlink" title="进程or线程？"></a>进程or线程？</h3><p> 进程（Process）是计算机中的程序关于某<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020">数据集</a>合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>线程，有时被称为轻量级进程（Lightweight Process,LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立、可调度的执行单元，是系统独立调度和分派CPU的基本单位，也指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>。</p><p>注意：<strong>一个进程可以启动多个线程。</strong></p><p>eg.<br>对于java程序来说，当在DOS命令窗口中输入：<br>java HelloWorld 回车之后。会先启动JVM，而JVM就是一个进程。</p><p>JVM再启动一个主线程调用main方法（main方法就是主线程）。<br>同时再启动一个垃圾回收线程负责看护，回收垃圾。</p><p>最起码，现在的java程序中至少有两个线程并发，一个是 垃圾回收线程，一个是 执行main方法的主线程。</p><p>关系图</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20191031002556559.png" alt="img"></p><h3 id="进程和线程是什么关系？"><a href="#进程和线程是什么关系？" class="headerlink" title="进程和线程是什么关系？"></a>进程和线程是什么关系？</h3><p>进程：可以看做是现实生活当中的公司。</p><p>线程：可以看做是公司当中的某个员工。</p><p>注意：<br>进程A和进程B的 内存独立不共享。</p><p>eg.<br>魔兽游戏是一个进程<br>酷狗音乐是一个进程<br>这两个进程是独立的，不共享资源。</p><h4 id="线程A和线程B是什么关系？"><a href="#线程A和线程B是什么关系？" class="headerlink" title="线程A和线程B是什么关系？"></a>线程A和线程B是什么关系？</h4><p>在java语言中：</p><p>线程A和线程B，堆内存 和 方法区 内存共享。但是 栈内存 独立，一个线程一个栈。</p><p>eg.<br>假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。</p><p>eg.<br>火车站，可以看做是一个进程。<br>火车站中的每一个售票窗口可以看做是一个线程。<br>我在窗口1购票，你可以在窗口2购票，你不需要等我，我也不需要等你。所以多线程并发可以提高效率。</p><p>java中之所以有多线程机制，目的就是为了 提高程序的处理效率。</p><h3 id="并发，并行"><a href="#并发，并行" class="headerlink" title="并发，并行"></a>并发，并行</h3><p>A、B、C 代表处理器</p><p>并发:同一时刻，多个任务交替执行，造成一种”貌似同时”的错觉，简单的来说，就是单核cpu实现的多任务就是并发</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/77067d5e686a49e392d083a46d6c5aec.png" alt="img"></p><p>并行：同一时刻，多个任务同一时刻同时执行，多核cpu可以实现并行，</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/ccad6d5d901e4b7296e3ef7fe56cf28f.png" alt="img"></p><h3 id="线程创建与启动"><a href="#线程创建与启动" class="headerlink" title="线程创建与启动"></a>线程创建与启动</h3><h4 id="继承java-lang-Thread类"><a href="#继承java-lang-Thread类" class="headerlink" title="继承java.lang.Thread类"></a>继承java.lang.Thread类</h4><ol><li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MYThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="实现java-lang-Runnable接口"><a href="#实现java-lang-Runnable接口" class="headerlink" title="实现java.lang.Runnable接口"></a>实现java.lang.Runnable接口</h4><ol><li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread构造方法</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name, <span class="type">long</span> stackSize)</span><br></pre></td></tr></table></figure><p> String name：线程的名子。这个名子可以在建立Thread实例后通过Thread类的setName方法设置。默认线程名：Thread-N，N是线程建立的顺序，是一个不重复的正整数。</p><p>​    ThreadGroup group：当前建立的线程所属的线程组。如果不指定线程组，所有的线程都被加到一个默认的线程组中。</p><p>​    long stackSize：线程栈的大小，这个值一般是CPU页面的整数倍。如x86的页面大小是4KB.在x86平台下，默认的线程栈大小是12KB。</p><h4 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h4><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>总结：</p><p>实现Runnable接口比继承Thread类所具有的优势：</p><p>1）：适合多个相同的程序代码的线程去处理同一个资源</p><p>2）：可以避免java中的单继承的限制</p><p>3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</p><p>4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</p><h3 id="Start-和run-的区别"><a href="#Start-和run-的区别" class="headerlink" title="Start()和run()的区别"></a>Start()和run()的区别</h3><p>首先需要知道线程的几个状态以及多线程工作方式。</p><ul><li>new 一个Thread，线程进入了新建状态，调用start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到 时间片 后就可以开始运行了。start() 会执行线程的相应准备工作，然后自动执行run() 方法的内容，这是真正的多线程工作。</li><li>而直接执行run() 方法，会把run 方法当成一个main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><p>总的来说：调用start 方法方可启动线程并使线程进入就绪状态，而run 方法只是thread 的一个普通方法调用，还是在主线程里执行。</p><h4 id="深入理解start方法"><a href="#深入理解start方法" class="headerlink" title="深入理解start方法"></a>深入理解start方法</h4><p>start方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">         * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//=============start0方法，是一个本地方法，底层是c实现的===============</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从整个方法上的注释看，start()使得该线程开始执行，Java虚拟机调用这个线程的run()方法，结果是两个线程会并发的运行：当前线程(调用start()方法的”主线程”)与另一个线程(执行其run方法)</p><p>start()之后的代码的核心就是其中调用的start0()方法，下面看看start0()的定义：<br>private native void start0();<br>很明显这是一个只声明而未实现的方法，native表示调用本机的原⽣系统函数，native 方法往往意味着这个方法无法使用平台无关的手段来实现。所以，还是那句话，实际上线程的实现与 Java 无关，由平台所决定.</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>start()方法的具体流程：start方法（判断当前线程是不是首次创建，Java方法）-&gt;调用start0()方法（JVM）-&gt;通过JVM进行资源调度，系统分配-&gt;回调run()方法（Java方法）执行线程的具体操作任务。</li><li>由于start()方法调用了JVM进行系统调度、系统分配等一系列操作，因此创建一个线程只能由start()来完成，而若直接调用run()方法，相当于是在调用一个普通方法。</li></ol><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><h4 id="什么是线程的生命周期"><a href="#什么是线程的生命周期" class="headerlink" title="什么是线程的生命周期"></a>什么是线程的生命周期</h4><p><em>*<em>*线程的生命周期即是线程的生老病死，*</em>*<em>即线程的各个阶段状态*</em>*</em></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/23643e98d1f84de19ea6d40c2f21631c.png" alt="img"></p><h4 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h4><ol><li>NEW ：新建状态。</li><li>RUNNABLE：在JAVA虚拟机中执行的线程处于这个阶段</li><li>BLOCKED：线程阻塞状态，被阻塞等待监视器锁定的线程处于这个状态。</li><li>WAITING：正在等待另一个线程执行特定的动作的线程处于这个状态。</li><li>TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于这个状态。</li><li>TERMINATED：已退出的线程处于此状态。</li></ol><p>共就六个状态：新建、运行、阻塞、等待、在等待、终止。</p><h4 id="以下对各个状态进一步说明"><a href="#以下对各个状态进一步说明" class="headerlink" title="以下对各个状态进一步说明"></a>以下对各个状态进一步说明</h4><ul><li>NEW : 在调用 strat() 之前的状态。</li><li>RUNNABLE：可运行状态，是个复合状态，可分为两类：<ul><li>:READY：就绪状态。</li><li>RUNNING:表示该线程正在执行。</li><li>可通过上篇说到的 Thread.yield 方法，完成放弃CPU资源，使得该线程从 RUNNING状态转到 :READY。</li><li>然后如果在被程序调度器选中，又从 :READY状态转到 RUNNING状态。</li></ul></li><li>BLOCKED：阻塞状态，当线程发起阻塞的 I&#x2F;O 操作，或者申请其它线程独占的资源，线程会转换为 BLOCKED阻塞状态，处于阻塞状态的线程不占用 CPU 资源。当阻塞I&#x2F;O操作完成时，或者线程获得了其他资源，线程可以转换为 RUNNABLE 状态。</li><li>WAITING:等待状态，线程执行了Object.wait(),Thread.join，会把线程转换为 WAITING状态。执行了Object.notify()方法，或者加入的线程执行完毕，会把线程从等待状态转为 RUNNABLE状态。</li><li>TIMED_WAITING:和WAITING 状态类似，区别在于状态的线程不会无限等待，如果在指定时间内完成了指定的操作，就会转换为 RUNNABLE状态。</li><li>TERMINATED（终止）：线程结束处于的状态。</li></ul><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th align="left">构造器和描述</th></tr></thead><tbody><tr><td align="left"><code>Thread()</code>分配一个新的 <code>Thread</code>对象。</td></tr><tr><td align="left"><code>Thread(Runnable target)</code>分配一个新的 <code>Thread</code>对象。</td></tr><tr><td align="left"><code>Thread(Runnable target, String name)</code>分配一个新的 <code>Thread</code>对象。</td></tr><tr><td align="left"><code>Thread(String name)</code>分配一个新的 <code>Thread</code>对象。</td></tr><tr><td align="left"><code>Thread(ThreadGroup group, Runnable target)</code>分配一个新的 <code>Thread</code>对象。</td></tr><tr><td align="left"><code>Thread(ThreadGroup group, Runnable target, String name)</code>分配一个新的 <code>Thread</code>对象，使其具有 <code>target</code>作为其运行对象，具有指定的 <code>name</code>作为其名称，属于 <code>group</code>引用的线程组。</td></tr><tr><td align="left"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code>分配一个新的 <code>Thread</code>对象，以便它具有 <code>target</code>作为其运行对象，将指定的 <code>name</code>正如其名，以及属于该线程组由称作 <code>group</code> ，并具有指定的 <em>堆栈大小</em> 。</td></tr><tr><td align="left"><code>Thread(ThreadGroup group, String name)</code>分配一个新的 <code>Thread</code>对象。</td></tr></tbody></table><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>run()</code>。</td><td>如果这个线程使用单独的<code>Runnable</code>运行对象构造，则调用该<code>Runnable</code>对象的<code>run</code>方法; 否则，此方法不执行任何操作并返回</td></tr><tr><td><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.html#currentThread--">currentThread</a></strong>()</td><td>static <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.html">Thread</a></td><td>返回对当前正在执行的线程对象的引用。</td></tr><tr><td><code>String</code></td><td><code>getName()</code></td><td>返回此线程的名称</td></tr><tr><td><code>Thread.State</code></td><td><code>getState()</code></td><td>返回此线程的状态</td></tr><tr><td><code>void</code></td><td><code>setName(String name)</code></td><td>将此线程的名称更改为等于参数 <code>name</code> 。</td></tr><tr><td><code>static void</code></td><td><code>sleep(long millis)</code></td><td>使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</td></tr><tr><td><code>void</code></td><td><code>start()</code></td><td>导致此线程开始执行; Java虚拟机调用此线程的<code>run</code>方法。</td></tr><tr><td><code>void</code></td><td><code>join()</code></td><td>在当前线程中调用另一个线程的join方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当<br/>前线程再由阻塞转为可运行状态。如果调用此方法时，另一个线程已经运行完毕，那就接着运行当前线程。</td></tr><tr><td><code>void</code></td><td><code>setPriority(int newPriority)</code></td><td>更改此线程的优先级。</td></tr></tbody></table><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th align="left">返回值类型</th><th align="left">属性名和说明</th></tr></thead><tbody><tr><td align="left"><code>static int</code></td><td align="left"><code>MAX_PRIORITY</code>线程可以拥有的最大优先级。</td></tr><tr><td align="left"><code>static int</code></td><td align="left"><code>MIN_PRIORITY</code>线程可以拥有的最小优先级。</td></tr><tr><td align="left"><code>static int</code></td><td align="left"><code>NORM_PRIORITY</code>分配给线程的默认优先级。</td></tr></tbody></table><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><blockquote><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），<br>将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， 从而保证了该变量的唯一性和准确性。</p></blockquote><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul><li><strong>同步代码块</strong>： <code>synchronized</code> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ul><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步锁：</p><p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p><ul><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。</li></ul><blockquote><p>注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着 (BLOCKED)。</p></blockquote><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>同步方法：使用 synchronized 修饰的方法，就叫做同步方法，保证 A 线程执行该方法的时候，其他线程只能在方法外等着。<br>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同步锁是谁?</p><p>对于非 static 方法，同步锁就是 this。</p><p>对于 static 方法，我们使用当前方法所在类的字节码对象（类名.class）。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字和保留字</title>
      <link href="/2022/09/09/Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97/"/>
      <url>/2022/09/09/Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof是Java的一个保留关键字，左边是对象，右边是类，返回类型是Boolean类型。它的具体作用是测试左边的对象是否是右边类或者该类的子类创建的实例对象，是，则返回true，否则返回false。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>先有继承关系，再有instanceof的使用。</li><li>当该测试对象创建时右边的声明类型和左边的类其中的任意一个跟测试类必须得是继承树的同一分支或存在继承关系，否则编译器会报错。</li></ol><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object &gt; Person &gt; teacher</span></span><br><span class="line">    <span class="comment">// Object &gt; Person &gt; Student</span></span><br><span class="line">    <span class="comment">// Object &gt; String</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// 主要看这个对象是什么类型与实例化的类名</span></span><br><span class="line">    <span class="comment">// instanceof关键字可以判断左边对象是否是右边类或者子类的一个实例</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Student); <span class="comment">// o 是Student类的一个实例对象 所以判断右边类跟student有无关系 以及显示声明有无关系</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Object); <span class="comment">// true</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> String); <span class="comment">// false</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Teacher); <span class="comment">// 无关系</span></span><br><span class="line">    System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.println(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">    System.out.println(person <span class="keyword">instanceof</span> Object); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// System.out.println(person instanceof String); // 编译错误</span></span><br><span class="line">    System.out.println(person <span class="keyword">instanceof</span> Teacher); <span class="comment">// 无关系</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要用到对象的强制类型转换时，需要使用instanceof进行判断</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA使用记录（个人向）</title>
      <link href="/2022/09/01/IDEA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89/"/>
      <url>/2022/09/01/IDEA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><ol><li>删除当前行，自己配置CTRL + d</li><li>复制当前行，配置 CTRL + alt + 向下光标</li><li>ctrl + alt + T  常用快捷语句（if，for。。。）</li><li>补全代码 alt + &#x2F;</li><li>添加注释和取消注释 CTRL + &#x2F; 【第一次是添加注释，第二次是取消注释】</li><li>Diagrams下,选中类,ctrl + alt + B,创建子类</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220901112602360.png" alt="image-20220901112602360"></p><h3 id="模板-x2F-自定义模板"><a href="#模板-x2F-自定义模板" class="headerlink" title="模板&#x2F;自定义模板"></a>模板&#x2F;自定义模板</h3><p>file -&gt; settings -&gt; editor -&gt; Live templates -&gt; 查看有那些模板快捷键&#x2F;可以自己增加模板</p><h3 id="新建项目自动出现信息"><a href="#新建项目自动出现信息" class="headerlink" title="新建项目自动出现信息"></a>新建项目自动出现信息</h3><p>file -&gt; settings -&gt;editor -&gt;File and Code Templates-&gt;includes-&gt;新建项目信息</p><h3 id="更详细的debug界面"><a href="#更详细的debug界面" class="headerlink" title="更详细的debug界面"></a>更详细的debug界面</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221031200151600.png" alt="image-20221031200151600"></p><h3 id="Java监听和管理控制台"><a href="#Java监听和管理控制台" class="headerlink" title="Java监听和管理控制台"></a>Java监听和管理控制台</h3><p>在cmd界面输入jconsole</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221205153157652.png" alt="image-20221205153157652"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221205153229124.png" alt="image-20221205153229124"></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的与和或（||，|，&amp;&amp;，&amp;）</title>
      <link href="/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/"/>
      <url>/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关于与(&amp;&amp;:并且)、或(||:或者)</p><p>学术话语：<br>或(或者)：(满足单方面一个就好了），不挑食，你满足了，那就跟我走吧。<br>“||”(短路或): 如果左边计算后的操作数为true,右边则不再执行，返回true；</p><p>与&amp;&amp;类似，只要遇到一个条件为True，表达式返回True，不进行后续条件判断。</p><p>“|”：(逻辑或)前后两个操作数都会进行计算。也就是说：“|”不存在短路。</p><p>与（并且）：（满足双方两个才可以）为了约束双方值不越界，我得看看这两个有没有都满足我条件才能带走。<br>&amp;&amp;(短路与)，当第一个判断条件不满足要求时（返回false），第二个判断条件就不会执行；只有当两个判断条件都返回true时，整个逻辑运算才返回true。</p><p>从左到右，只要遇到一个条件为False，表达式返回False，不进行后续条件判断。</p><p>&amp;(逻辑与)，不论什么情况下，两边的判断条件都会执行，当两边都返回true时，按位与才返回true。</p><p>直观解释：</p><p>最直观解释就是||和&amp;&amp;左边有一个不通过就不去执行右边了，没必要浪费时间。而|和&amp;不管左边有没有通过，都要磨磨唧唧两边都要先执行一遍，效率低</p><p>||、&amp;&amp;会先进行左边判断通过与否，再进行右边判断，再执行有没有通过</p><p>|、&amp;：就是先两边都执行，再去同时判断有没有通过。相当于||的一个逆向思路</p><p>开发中一般使用&amp;&amp;和||比较好一点，因为效率高</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDK和API的区别（转)</title>
      <link href="/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="讲个小故事："><a href="#讲个小故事：" class="headerlink" title="讲个小故事："></a><strong>讲个小故事：</strong></h2><blockquote><p>研发人员A开发了软件A，研发人员B正在研发软件B。<br>有一天，研发人员B想要调用软件A的部分功能来用，但是他又不想从头看一遍软件A的源码和功能实现过程，怎么办呢？<br>研发人员A想了一个好主意： <strong>我把软件A里你需要的功能打包好，写成一个函数。你按照我说的流程，把这个函数放在软件B里，就能直接用我的功能了！</strong><br>其中，API就是研发人员A说的那个函数。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/5692a53d8119cf182034bdc59e92b0f6.png" alt="img"></p><p>这就是API的诞生。</p><h3 id="日常生活中，我们有很多类似API的场景，比如："><a href="#日常生活中，我们有很多类似API的场景，比如：" class="headerlink" title="日常生活中，我们有很多类似API的场景，比如："></a><strong>日常生活中，我们有很多类似API的场景，比如：</strong></h3><blockquote><p>电脑需要调用手机里面的信息，这时候你会拿一根数据线将电脑手机连接起来，电脑和手机上连接数据线的接口就相当于“API接口”。如图所示：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/81bf59a486bb1fe0961e6f6d9f67cd22.png" alt="img"></p><h2 id="那SDK又是什么？"><a href="#那SDK又是什么？" class="headerlink" title="那SDK又是什么？"></a><strong>那SDK又是什么？</strong></h2><p>SDK 就是 Software Development Kit 的缩写，翻译过来——软件开发工具包。这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。</p><p>SDK被开发出来是为了减少程序员工作量的。</p><p>比如——</p><blockquote><p>有公司开发出某种软件的某一功能，把它封装成SDK（比如数据分析SDK就是能够实现数据分析功能的SDK），出售给其他公司做开发用，其他公司如果想要给软件开发出某种功能，但又不想从头</p><h2 id="现在可以谈谈API和SDK的区别了。"><a href="#现在可以谈谈API和SDK的区别了。" class="headerlink" title="现在可以谈谈API和SDK的区别了。"></a><strong>现在可以谈谈API和SDK的区别了。</strong></h2><p>总的来说，两者没有值得比较的区别，因为是具有关联性的两种东西。</p><p>你可以把SDK想象成一个虚拟的<a href="https://www.zhihu.com/search?q=%E7%A8%8B%E5%BA%8F%E5%8C%85&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:770586138%7D">程序包</a>，在这个程序包中有一份做好的软件功能，这份程序包几乎是全封闭的，只有一个小小接口可以联通外界，这个接口就是API。</p><p>比如——</p><p>我们现在要在企业ERP系统中增加某个功能（比如自动备份、数据分析、云存储等），但又不想耗费大量时间、也没那么多研发亲自去做这个功能。这时我们可以选择使用这个“SDK”软件包，把ERP系统连接上API接口，就可以使用SDK软件包里的功能。</p><h3 id="举个实例辅助理解："><a href="#举个实例辅助理解：" class="headerlink" title="举个实例辅助理解："></a><strong>举个实例辅助理解：</strong></h3><p>【中铁大桥科研院】有一个自研的信息平台，用于管理业务数据。</p><p>但他们曾面临一个问题——尽管有信息平台，却因为系统的独立性，数据的上传和备份，需要依靠人工在excel里来回操作，效率很低。</p><p>由于系统的开发周期长、成本高，桥科院将目光聚焦到现成的功能软件上。</p><p>后来通过API将简道云直接插入公司数据库，数据可自动上传至信息平台上并统一展示；再通过webhook把数据推送到服务器，实现自动备份。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/da6c9f6f3d05fb3e1e789c8560fa8f44.png" alt="img"></p><p>API将信息平台与简道云相连</p><p>在这一过程中，简道云扮演的角色就是SDK，而简道云配备API接口，可以对接外部系统，让桥科院不用开发直接实现了数据自动上传、备份的功能。</p><p><strong>最后，贴近生活讲讲两者的关系：</strong></p><p><strong>有一杯密封饮料，它的名字叫做“SDK”。</strong></p><p><strong>饮料上插着吸管，吸管的名字叫“API”。</strong></p><p><strong>把你叫做“XX系统”。</strong></p><p><strong>如果你想喝到SDK里的饮料（让系统拥有SDK中的功能），你必须通过API这根吸管来实现（通过API连接你的系统和SDK工具包），否则你就喝不到饮料。</strong></p><p><strong>所以：</strong></p><p>SDK＝放着你想要的软件功能的软件包</p><p>API＝SDK上唯一的接口</p><p><strong>不知道你这次真的懂了没？</strong></p><hr><p><strong>这个问题好像又热起来了，既然如此，给大家推荐一个新“玩具”：前端事件。</strong></p><p><strong>理论上解释：</strong></p><blockquote><p>前端事件是一种全新的数据获取的方式，可以在数据提交或者表单填报时，主动调用外部接口，从而可以实现接口取数、数据验证、数据分析、触发事件等一系列的操作，用户可以基于现成的商业接口进行配置（无需编程），也可以根据自身需求封装接口，灵活地满足自身业务需求（需编程）</p></blockquote><p><strong>说人话解释：</strong></p><blockquote><p>用户填写快递单号，返回具体物流信息；<br>上传发票图片，返回发票金额；<br>上传身份证照片，获取身份证姓名、身份证号；<br>……等。</p></blockquote><p>例如，在发票报销场景中，根据前端事件配置，可在提交发票图片后自动获取发票中的开票金额、开票日期等基础信息。</p><p>开发，直接付钱省事。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本功|Java即时编译器原理解析及实践</title>
      <link href="/2022/08/18/%E5%9F%BA%E6%9C%AC%E5%8A%9F-Java%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/08/18/%E5%9F%BA%E6%9C%AC%E5%8A%9F-Java%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、导读"><a href="#一、导读" class="headerlink" title="一、导读"></a>一、导读</h2><p>常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。</p><p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p><p>即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</p><h2 id="二、Java的执行过程"><a href="#二、Java的执行过程" class="headerlink" title="二、Java的执行过程"></a>二、Java的执行过程</h2><p>Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。</p><p>怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/ba83857ecf9f344e4972fd551c4973d653952.png@648w_454h_80q" alt="img"></p><h3 id="1-JVM中的编译器"><a href="#1-JVM中的编译器" class="headerlink" title="1. JVM中的编译器"></a>1. JVM中的编译器</h3><p>JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。</p><p><strong>Client Compiler</strong></p><p>HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</p><ul><li>局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。</li><li>将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。</li><li>最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。</li></ul><p><strong>Server Compiler</strong></p><p>Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。</p><p><strong>C2 Compiler</strong></p><p>在Hotspot VM中，默认的Server Compiler是C2编译器。</p><p>C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。</p><p>Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。</p><p>无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/4c33853195a4e5e11951a6324a698b6c108881.png@823w_864h_80q" alt="img"></p><p><strong>Graal Compiler</strong></p><p>从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：</p><ul><li>前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。</li><li>使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。</li><li>更深层次的优化，比如虚函数的内联、部分逃逸分析等。</li></ul><p>Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。</p><h3 id="2-分层编译"><a href="#2-分层编译" class="headerlink" title="2. 分层编译"></a>2. 分层编译</h3><p>在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</p><ol><li>解释执行。</li><li>执行不带profiling的C1代码。</li><li>执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。</li><li>执行带所有profiling的C1代码。</li><li>执行C2代码。</li></ol><p>profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。</p><p>通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&gt;2层&gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：</p><p><img src="https://p0.meituan.net/travelcube/9dee40c45e1abb392243e07666ff6d5b79153.png@863w_680h_80q" alt="img"></p><ul><li>图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</li><li>如果方法比较小（比如Java服务中常见的getter&#x2F;setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</li><li>在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</li><li>前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</li><li>如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</li></ul><p>总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。</p><h3 id="3-即时编译的触发"><a href="#3-即时编译的触发" class="headerlink" title="3. 即时编译的触发"></a>3. 即时编译的触发</h3><p>Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：</p><p>循环回边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(Object obj) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</p><p>字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(java.lang.Object);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_0</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: sipush        200</span><br><span class="line">       8: if_icmpge     21</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: iload_2</span><br><span class="line">      13: iadd</span><br><span class="line">      14: istore_1</span><br><span class="line">      15: iinc          2, 1</span><br><span class="line">      18: goto          4</span><br><span class="line">      21: return</span><br></pre></td></tr></table></figure><p>在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。</p><p>当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</p><p>开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：</p><ul><li>方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</li><li>方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</li></ul><p>分层编译触发条件公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s) </span><br><span class="line">i为调用次数，b是循环回边次数</span><br></pre></td></tr></table></figure><p>上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。</p><h2 id="三、编译优化"><a href="#三、编译优化" class="headerlink" title="三、编译优化"></a>三、编译优化</h2><p>即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</p><h3 id="1-中间表达形式（Intermediate-Representation）"><a href="#1-中间表达形式（Intermediate-Representation）" class="headerlink" title="1. 中间表达形式（Intermediate Representation）"></a>1. 中间表达形式（Intermediate Representation）</h3><p>在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</p><p>Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：</p><p>SSA IR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a = 1;</span><br><span class="line">  a = 2;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以轻易地发现a &#x3D; 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</p><p>上面代码的SSA IR形式的伪代码可以表示为：</p><p>SSA IR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a_1 = 1;</span><br><span class="line">  a_2 = 2;</span><br><span class="line">  b_1 = a_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</p><p>除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a = 2;</span><br><span class="line">  int b = 0</span><br><span class="line">  if(2 &gt; 1)&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    b = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到SSA IR伪代码：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_1 = 2;</span><br><span class="line">b_1 = 0</span><br><span class="line">if true:</span><br><span class="line">  a_2 = 1;</span><br><span class="line">else</span><br><span class="line">  b_2 = 2;</span><br><span class="line">add(a,b)</span><br></pre></td></tr></table></figure><p>编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">  int b = 0;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</p><p><strong>C1中的中间表达形式</strong></p><p>前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</p><p>HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/ecc6e309ee4a8f36cab407a6b5989c9b21165.png@262w_611h_80q" alt="img"></p><p>其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</p><p>从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：</p><p>字节码构造HIR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  字节码                     Local Value             operand stack              HIR</span><br><span class="line">5: iload_1                  [i1,i2]                 [i1]</span><br><span class="line">6: iload_2                  [i1,i2]                 [i1,i2]   </span><br><span class="line">                            ................................................   i3: i1 * i2</span><br><span class="line">7: imul                                   </span><br><span class="line">8: istore_3                 [i1,i2，i3]              [i3]</span><br></pre></td></tr></table></figure><p>可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。</p><p>C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</p><p><strong>Sea-of-Nodes IR</strong></p><p>C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：</p><p>example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int foo(int count) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的IR图如下所示：</p><p><img src="https://p0.meituan.net/travelcube/42ae260309e69d543bfdc4e7c3e1ea9a164249.png@1368w_1260h_80q" alt="img"></p><p>图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</p><p>这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</p><p>依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</p><p><strong>Phi And Region Nodes</strong></p><p>Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。</p><p>example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">int a = 0;</span><br><span class="line">  if(x == 1) &#123;</span><br><span class="line">    a = 5;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：</p><p><img src="https://p0.meituan.net/travelcube/41c8d6188f478a93566c2573b8ce263150102.png@631w_930h_80q" alt="img"></p><p>Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</p><p>Phi Nodes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">  a_1 = 0;</span><br><span class="line">  if(x == 1)&#123;</span><br><span class="line">    a_2 = 5;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    a_3 = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  a_4 = Phi(a_2,a_3);</span><br><span class="line">  return a_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Global Value Numbering</strong></p><p>Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</p><p>GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：</p><p>GVN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b = 2;</span><br><span class="line">c = a + b;</span><br><span class="line">d = a + b;</span><br><span class="line">e = d;</span><br></pre></td></tr></table></figure><p>GVN会利用Hash算法编号，计算a &#x3D; 1时，得到编号1，计算b &#x3D; 2时得到编号2，计算c &#x3D; a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d &#x3D; a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e &#x3D; d也可以由Hash表中查到而进行复用。</p><p>可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</p><h3 id="2-方法内联"><a href="#2-方法内联" class="headerlink" title="2.方法内联"></a>2.方法内联</h3><p>方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</p><p>Java服务中存在大量getter&#x2F;setter方法，如果没有方法内联，在调用getter&#x2F;setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter&#x2F;setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter&#x2F;setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：</p><p>方法内联的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean flag = true;</span><br><span class="line">public static int value0 = 0;</span><br><span class="line">public static int value1 = 1;</span><br><span class="line"></span><br><span class="line">public static int foo(int value) &#123;</span><br><span class="line">    int result = bar(flag);</span><br><span class="line">    if (result != 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int bar(boolean flag) &#123;</span><br><span class="line">    return flag ? value0 : value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bar方法的IR图：</p><p><img src="https://p1.meituan.net/travelcube/857398429cf23f82f291a9cbaceecea122617.png@794w_480h_80q" alt="img"></p><p>内联后的IR图：</p><p><img src="https://p0.meituan.net/travelcube/524631fb0c1db243b5b1fd08b185c23f59399.png@802w_1202h_80q" alt="img"></p><p>内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</p><p>被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</p><p>调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号&#x3D;&#x3D;节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</p><p>如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</p><p><strong>方法内联的条件</strong></p><p>编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</p><p>可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：</p><p><img src="https://p0.meituan.net/travelcube/5edc4a89d148535e6e4ef659a61882fc128193.png@1350w_612h_80q" alt="img"></p><p><strong>虚函数内联</strong></p><p>内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</p><p>C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：</p><p>virtual call</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj = new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 = new VirtualInvoke1();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000113369d37: callq  0x00000001132950a0  ; OopMap&#123;off=476&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  //代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 18)</span><br><span class="line">                                               ;   &#123;optimized virtual_call&#125;  //虚调用已经被优化</span><br></pre></td></tr></table></figure><p>可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</p><p>比如下面这段代码，我们增加一个实现：</p><p>多实现的虚调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj = new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 = new VirtualInvoke1();</span><br><span class="line">        VirtualInvoke2 obj2 = new VirtualInvoke2();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        invokeMethod(obj2);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class VirtualInvoke2 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反编译得到下面的汇编代码：</p><p>代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000000011f5f0a37: callq  0x000000011f4fd2e0  ; OopMap&#123;off=28&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  //代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 20)</span><br><span class="line">                                               ;   &#123;virtual_call&#125;  //虚调用未被优化</span><br></pre></td></tr></table></figure><p>可以看到多个实现的虚调用未被优化，依然是virtual_call。</p><p>Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。</p><h3 id="3-逃逸分析"><a href="#3-逃逸分析" class="headerlink" title="3. 逃逸分析"></a>3. 逃逸分析</h3><p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：</p><ol><li>对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。</li><li>对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</li></ol><p>逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      example();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void example() &#123;</span><br><span class="line">      Foo foo = new Foo();</span><br><span class="line">      Bar bar = new Bar();</span><br><span class="line">      bar.setFoo(foo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Foo &#123;&#125;</span><br><span class="line"></span><br><span class="line">  class Bar &#123;</span><br><span class="line">    private Foo foo;</span><br><span class="line">    public void setFoo(Foo foo) &#123;</span><br><span class="line">      this.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</p><p><strong>锁消除</strong></p><p>在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</p><p>如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</p><p><strong>栈上分配</strong></p><p>我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：</p><p>标量替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    Cat cat = new Cat(1,10);</span><br><span class="line">    addAgeAndWeight(cat.age,Cat.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    int age = 1;</span><br><span class="line">    int weight = 10;</span><br><span class="line">    addAgeAndWeight(age,weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>部分逃逸分析</strong></p><p>部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</p><h3 id="4-Loop-Transformations"><a href="#4-Loop-Transformations" class="headerlink" title="4. Loop Transformations"></a>4. Loop Transformations</h3><p>在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。</p><p><strong>循环展开</strong></p><p>循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。</p><p>循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：</p><p>循环展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i = 0;i&lt;200;i++)&#123;</span><br><span class="line">    delete(i);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：</p><p>循环展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i = 0;i&lt;200;i+=5)&#123;</span><br><span class="line">    delete(i);</span><br><span class="line">    delete(i+1);</span><br><span class="line">    delete(i+2);</span><br><span class="line">    delete(i+3);</span><br><span class="line">    delete(i+4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</p><p><strong>循环分离</strong></p><p>循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：</p><p>循环分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] = x[i] + x[a];</span><br><span class="line">  a = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这段代码除了第一次循环a &#x3D; 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：</p><p>循环分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[0] = x[0] + 10;</span><br><span class="line">for(int i = 1;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] = x[i] + x[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</p><h3 id="5-窥孔优化与寄存器分配"><a href="#5-窥孔优化与寄存器分配" class="headerlink" title="5. 窥孔优化与寄存器分配"></a>5. 窥孔优化与寄存器分配</h3><p>前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：</p><p>强度削减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y1=x1*3  经过强度削减后得到  y1=(x1&lt;&lt;1)+x1</span><br></pre></td></tr></table></figure><p>编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</p><p>寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</p><p>寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><p>即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。</p><h3 id="1-编译相关的重-要参数"><a href="#1-编译相关的重-要参数" class="headerlink" title="1. 编译相关的重* 要参数"></a>1. 编译相关的重* 要参数</h3><ul><li>-XX:+TieredCompilation：开启分层编译，JDK8之后默认开启</li><li>-XX:+CICompilerCount&#x3D;N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 &#x3D; 1:2</li><li>-XX:TierXBackEdgeThreshold：OSR编译的阈值</li><li>-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</li><li>-XX:TierXCompileThreshold：开启分层编译后的编译阈值</li><li>-XX:ReservedCodeCacheSize：codeCache最大大小</li><li>-XX:InitialCodeCacheSize：codeCache初始大小</li></ul><p>-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。</p><p>由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。</p><h3 id="2-通过JITwatch分析编译日志"><a href="#2-通过JITwatch分析编译日志" class="headerlink" title="2. 通过JITwatch分析编译日志"></a>2. 通过JITwatch分析编译日志</h3><p>通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile&#x3D;LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/5d82c16cf7739e16b1de7e5f5fa53123555106.png%25403360w_2099h_80q" alt="img"><img src="https://p0.meituan.net/travelcube/1a2cb3082b79eb778360e79f5acd1e83545877.png@3360w_2033h_80q" alt="img"></p><p>如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：</p><p><img src="https://p0.meituan.net/travelcube/b089edabd2fa9bb1fc7f068df79c8c8361195.png@1920w_218h_80q" alt="img"></p><p>我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。</p><p>区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。</p><h3 id="3-使用Graal编译器"><a href="#3-使用Graal编译器" class="headerlink" title="3. 使用Graal编译器"></a>3. 使用Graal编译器</h3><p>由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。</p><p>为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。</p><p>前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</p><p>前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。</p><p>这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。</p><p><strong>使用Graal编译器后性能表现</strong></p><p>在我们的线上服务中，启用Graal编译后，TP9999从60ms -&gt; 50ms ，下降10ms，下降幅度达16.7%。</p><p>运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。</p><p><strong>Graal编译器的问题</strong></p><p>Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。</p><p>考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><ul><li>《深入理解Java虚拟机》</li><li>《Proceedings of the Java™ Virtual Machine Research and Technology Symposium》Monterey, California, USA April 23–24, 2001</li><li>《Visualization of Program Dependence Graphs》 Thomas Würthinger</li><li>《深入拆解Java虚拟机》 郑宇迪</li><li><a href="https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ">JIT的Profile神器JITWatch</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线工具+资源</title>
      <link href="/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/"/>
      <url>/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="在线工具-资源"><a href="#在线工具-资源" class="headerlink" title="在线工具+资源"></a>在线工具+资源</h1><h3 id="常用-x2F-未归类"><a href="#常用-x2F-未归类" class="headerlink" title="常用&#x2F;未归类"></a>常用&#x2F;未归类</h3><ul><li>有道翻译：<a href="https://fanyi.youdao.com/">https://fanyi.youdao.com</a></li><li>谷歌翻译：<a href="https://translate.google.cn/">https://translate.google.cn</a></li><li>蓝奏云盘：<a href="https://pc.woozooo.com/u">https://pc.woozooo.com/u</a></li><li>免费4k视频：<a href="https://www.4kdv.com/">https://www.4kdv.com</a></li><li>日本域名申请：<a href="https://www.value-domain.com/">https://www.value-domain.com</a></li><li><code>大量在线工具（网站内右上角搜索想要的工具）</code>：<a href="https://www.fly63.com/tool/home.html">https://www.fly63.com/tool/home.html</a></li><li>在线代码截图工具：<a href="https://carbon.now.sh/">https://carbon.now.sh/</a></li><li>在线短链接工具：<a href="https://urlify.cn/">https://urlify.cn/</a></li><li>0x3.me 短网址：<a href="https://0x3.me/">https://0x3.me</a></li></ul><h3 id="免费软件、资源下载"><a href="#免费软件、资源下载" class="headerlink" title="免费软件、资源下载"></a>免费软件、资源下载</h3><ul><li>吾爱破解论坛：<a href="https://52pojie.cn/">https://52pojie.cn/</a></li><li>免费正版Windows系统：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a></li><li>免费Mac软件：<a href="https://www.macwk.com/">https://www.macwk.com</a></li><li>小蚂蚁资源网：<a href="https://www.xmy7.com/">https://www.xmy7.com</a></li></ul><h3 id="视频、音频、图片、壁纸、二维码"><a href="#视频、音频、图片、壁纸、二维码" class="headerlink" title="视频、音频、图片、壁纸、二维码"></a>视频、音频、图片、壁纸、二维码</h3><ul><li>在线多媒体转换器合集：<a href="https://cn.office-converter.com/">https://cn.office-converter.com/</a></li><li>视频转GIF工具：<a href="http://www.fly63.com/tool/giftxt/">http://www.fly63.com/tool/giftxt/</a></li><li>在线音频剪辑：<a href="https://www.weixinsyt.com/">https://www.weixinsyt.com/</a></li><li>在线视频剪辑：<a href="https://www.kapwing.com/">https://www.kapwing.com/</a></li></ul><hr><ul><li>SVG转PNG工具：<a href="http://www.fly63.com/tool/svg2img/">http://www.fly63.com/tool/svg2img/</a></li><li>JPG 转换成WEBP：<a href="https://onlineconvertfree.com/zh/convert-format/jpg-to-webp/">https://onlineconvertfree.com/zh/convert-format/jpg-to-webp/</a></li><li>图片压缩：<a href="https://tinypng.com/">https://tinypng.com</a></li><li>图片智能放大工具：<a href="https://bigjpg.com/">https://bigjpg.com/</a></li></ul><hr><ul><li>在线抠图工具：<a href="https://www.remove.bg/zh">https://www.remove.bg/zh</a></li><li>在线PS：<a href="https://www.uupoop.com/#/old">https://www.uupoop.com/#/old</a></li><li>在线海报设计工具：<a href="https://www.designcap.com/">https://www.designcap.com/</a></li></ul><hr><ul><li>免费透明背景图片素材：<a href="http://pngimg.com/">http://pngimg.com/</a></li><li>免费PNG图片库：<a href="https://pluspng.com/">https://pluspng.com/</a></li><li>Pixabay图片素材库：<a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></li><li>Unsplash图片素材库：<a href="https://unsplash.com/">https://unsplash.com/</a></li><li>Pexels图片素材库：<a href="http://www.pexels.com/">http://www.pexels.com/</a></li><li>NASA图片视频素材库：<a href="https://images.nasa.gov/">https://images.nasa.gov/</a></li><li>千库网：<a href="https://588ku.com/">https://588ku.com</a></li><li>PngPix：<a href="https://www.pngpix.com/download/tag/fire">https://www.pngpix.com/download/tag/fire</a></li></ul><hr><ul><li>极简壁纸：<a href="https://bz.zzzmh.cn/">https://bz.zzzmh.cn/</a></li><li>Wallpaper Abyss壁纸：<a href="https://wall.alphacoders.com/">https://wall.alphacoders.com/</a></li><li>免费壁纸下载：<a href="https://wallhaven.cc/">https://wallhaven.cc</a></li></ul><hr><ul><li>二维码在线生成器：<a href="http://www.fly63.com/tool/ewm/">http://www.fly63.com/tool/ewm/</a></li><li>二维码在线解码：<a href="http://www.fly63.com/php/decoder/">http://www.fly63.com/php/decoder/</a></li><li>二维码美化器：<a href="https://mh.cli.im/">https://mh.cli.im/</a></li></ul><h3 id="图床、思维导图、流程图"><a href="#图床、思维导图、流程图" class="headerlink" title="图床、思维导图、流程图"></a>图床、思维导图、流程图</h3><ul><li>路过图床：<a href="https://imgtu.com/">https://imgtu.com</a></li><li>sm.ms图床：<a href="https://sm.ms/">https://sm.ms</a></li><li>图壳图床：<a href="https://imgkr.com/">https://imgkr.com/</a></li><li>图片上传 | PicX 图床神器：<a href="https://picx.xpoet.cn/">https://picx.xpoet.cn/</a></li></ul><hr><ul><li>在线画图工具ProcessOn：<a href="https://www.processon.com/">https://www.processon.com/</a></li><li>在线画图工具Draw.io：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a></li><li>在线思维导图工具MindLine：<a href="http://www.mindline.cn/webapp">http://www.mindline.cn/webapp</a></li></ul><h3 id="ICO、字体图标、logo、Emoji表情"><a href="#ICO、字体图标、logo、Emoji表情" class="headerlink" title="ICO、字体图标、logo、Emoji表情"></a>ICO、字体图标、logo、Emoji表情</h3><ul><li>ICO图标在线生成：<a href="http://www.fly63.com/php/ico/">http://www.fly63.com/php/ico/</a></li><li>ico图标包：[ICO_Sweet_Paranoia.rar：<a href="https://wws.lanzoub.com/ing8408aok7a">https://wws.lanzoub.com/ing8408aok7a</a></li><li>图标分享 | 30 个免费 icon 下载网站：<a href="https://zhuanlan.zhihu.com/p/431105940">https://zhuanlan.zhihu.com/p/431105940</a></li><li>Font Awesome-ico图标：<a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></li><li>Font Awesome 图标-菜鸟教程：<a href="https://www.runoob.com/font-awesome/fontawesome-tutorial.html">https://www.runoob.com/font-awesome/fontawesome-tutorial.html</a></li><li>免费logo在线制作：<a href="http://www.uugai.com/">http://www.uugai.com/</a></li><li>ICON图标在线下载：<a href="https://www.iconfinder.com/">https://www.iconfinder.com/</a></li><li>open source icons：<a href="https://feathericons.com/">https://feathericons.com/</a></li><li>阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></li><li>艺术字体在线生成：<a href="https://www.qt86.com/">https://www.qt86.com/</a></li></ul><hr><ul><li>Emoji表情搜索：<a href="https://emoji.svend.cc/">https://emoji.svend.cc/</a></li><li>Emoji表情包下载：<a href="https://emojiisland.com/">https://emojiisland.com/</a></li><li>表情包在线网站：<a href="https://fabiaoqing.com/">https://fabiaoqing.com/</a></li></ul><h3 id="文字、文本、PDF、表格、文件、RGB颜色"><a href="#文字、文本、PDF、表格、文件、RGB颜色" class="headerlink" title="文字、文本、PDF、表格、文件、RGB颜色"></a>文字、文本、PDF、表格、文件、RGB颜色</h3><ul><li>在线文字识别工具：<a href="https://ocr.wdku.net/">https://ocr.wdku.net/</a></li><li>在线字数统计：<a href="https://www.eteste.com/">https://www.eteste.com/</a></li><li>mdnice markdown排版工具：<a href="https://mdnice.com/">https://mdnice.com/</a></li><li>md2all markdown排版工具：<a href="http://md.aclickall.com/">http://md.aclickall.com/</a></li><li>在线文本代码对比工具：<a href="https://www.fly63.com/tool/textdiff/">https://www.fly63.com/tool/textdiff/</a></li><li>在线文本替换：<a href="http://www.fly63.com/tool/textreplace/">http://www.fly63.com/tool/textreplace/</a></li></ul><hr><ul><li>pdf在线处理套装1：<a href="https://tools.pdf24.org/zh/">https://tools.pdf24.org/zh/</a></li><li>pdf在线处理套装2：<a href="https://smallpdf.com/cn/pdf-tools">https://smallpdf.com/cn/pdf-tools</a></li><li>pdf转word在线工具：<a href="https://www.pdftoword.com/">https://www.pdftoword.com/</a></li><li>PDF to Markdown：<a href="https://pdf2md.morethan.io/">https://pdf2md.morethan.io</a></li><li>在线表格转换工具：<a href="https://tableconvert.com/">https://tableconvert.com/</a></li><li>在线文件压缩工具：<a href="https://docsmall.com/">https://docsmall.com/</a></li></ul><hr><ul><li>RGB颜色转换：<a href="https://www.zxgj.cn/g/yansezhi">https://www.zxgj.cn/g/yansezhi</a></li><li>RGB颜色对照表：<a href="https://bj.96weixin.com/tools/rgb">https://bj.96weixin.com/tools/rgb</a></li><li>貌似打开不了：<a href="http://xh.5156edu.com/page/z1015m9220j18754.html">http://xh.5156edu.com/page/z1015m9220j18754.html</a></li></ul><h3 id="json、xml、yaml、sql、css格式化"><a href="#json、xml、yaml、sql、css格式化" class="headerlink" title="json、xml、yaml、sql、css格式化"></a>json、xml、yaml、sql、css格式化</h3><ul><li>在线JSON解析：<a href="http://www.json.cn/">http://www.json.cn/</a></li><li>JSON&#x2F;YAML在线转换：<a href="http://www.fly63.com/tool/jsonyaml/">http://www.fly63.com/tool/jsonyaml/</a></li><li>JSON和XML在线转换：<a href="https://www.zxgj.cn/g/jsonxml">https://www.zxgj.cn/g/jsonxml</a></li><li>XML格式化工具：<a href="https://www.zxgj.cn/g/xmlformat">https://www.zxgj.cn/g/xmlformat</a></li><li>在线JS代码格式化工具：<a href="https://prettier.io/playground/">https://prettier.io/playground/</a></li><li>在线JSON解析：<a href="http://www.json.cn/">http://www.json.cn/</a></li><li>SQL压缩&#x2F;格式化工具：<a href="https://www.zxgj.cn/g/sqlformat">https://www.zxgj.cn/g/sqlformat</a></li><li>在线CSS代码可视化工具：<a href="https://enjoycss.com/">https://enjoycss.com/</a></li><li>在线数据可视化：<a href="https://flourish.studio/">https://flourish.studio/</a></li><li>在线前端编辑器：<a href="https://codepen.io/">https://codepen.io/</a></li></ul><h3 id="时间、进制、计量单位、人民币大小写转换"><a href="#时间、进制、计量单位、人民币大小写转换" class="headerlink" title="时间、进制、计量单位、人民币大小写转换"></a>时间、进制、计量单位、人民币大小写转换</h3><ul><li>时间戳转换工具：<a href="https://www.zxgj.cn/g/unix">https://www.zxgj.cn/g/unix</a></li><li>通用进制转换工具：<a href="https://www.zxgj.cn/g/jinzhi">https://www.zxgj.cn/g/jinzhi</a></li><li>在线浮点数十进制转换：<a href="http://www.binaryconvert.com/">http://www.binaryconvert.com/</a></li><li>计量单位换算工具：<a href="http://www.fly63.com/tool/unitable/">http://www.fly63.com/tool/unitable/</a></li><li>人民币大小写转换工具：<a href="http://www.fly63.com/tool/renmingbi/">http://www.fly63.com/tool/renmingbi/</a></li></ul><h3 id="随机数、正则表达式、接口测试"><a href="#随机数、正则表达式、接口测试" class="headerlink" title="随机数、正则表达式、接口测试"></a>随机数、正则表达式、接口测试</h3><ul><li>UUID在线生成器：<a href="https://www.zxgj.cn/g/uuid">https://www.zxgj.cn/g/uuid</a></li><li>随机数生成器：<a href="https://www.zxgj.cn/g/suijishu">https://www.zxgj.cn/g/suijishu</a></li></ul><hr><ul><li>正则表达式可视化工具：<a href="https://jex.im/regulex/#!flags=&amp;re=^">https://jex.im/regulex/#!flags=&amp;re=^</a>(a|b*%3F%24</li><li>正则表达式调试工具：<a href="https://regexr.com/">https://regexr.com/</a></li></ul><hr><ul><li>HTTP在线接口测试工具：<a href="http://www.fly63.com/php/http/">http://www.fly63.com/php/http/</a></li><li>在线接口文档管理工具：<a href="http://xiaoyaoji.cn/">http://xiaoyaoji.cn</a></li></ul><h3 id="Nginx、IP查询、CDN、谷歌插件、ASCII码"><a href="#Nginx、IP查询、CDN、谷歌插件、ASCII码" class="headerlink" title="Nginx、IP查询、CDN、谷歌插件、ASCII码"></a>Nginx、IP查询、CDN、谷歌插件、ASCII码</h3><ul><li>在线Nginx配置工具：<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN</a></li></ul><hr><ul><li>IP地址归属地查询：<a href="https://www.ip138.com/">https://www.ip138.com/</a></li><li>IP地址查询：<a href="https://www.ipip.net/ip.html">https://www.ipip.net/ip.html</a></li></ul><hr><ul><li>CDN查询：<a href="https://www.itdog.cn/">https://www.itdog.cn</a></li></ul><hr><ul><li>在线Chrome浏览器插件：<a href="https://www.crx4chrome.com/">https://www.crx4chrome.com</a></li></ul><hr><ul><li>在线ASCII码对照表：<a href="http://www.fly63.com/tool/ascii/">http://www.fly63.com/tool/ascii/</a></li></ul><h3 id="编译运行、编解码、加解密"><a href="#编译运行、编解码、加解密" class="headerlink" title="编译运行、编解码、加解密"></a>编译运行、编解码、加解密</h3><ul><li>C#在线编译运行：<a href="https://rextester.com/">https://rextester.com</a></li><li>C&#x2F;C++在线编译调试：<a href="https://www.onlinegdb.com/">https://www.onlinegdb.com</a></li><li>在线编译工具套装：<a href="https://c.runoob.com/">https://c.runoob.com</a></li></ul><hr><ul><li>BASE64编解码工具：<a href="https://base64.supfree.net/">https://base64.supfree.net/</a></li><li>MD5编码工具：<a href="https://www.zxgj.cn/g/md5">https://www.zxgj.cn/g/md5</a></li><li>JWT解码工具：<a href="http://jwt.calebb.net/">http://jwt.calebb.net/</a></li><li>ASCII编解码工具：<a href="https://www.matools.com/code-convert-ascii">https://www.matools.com/code-convert-ascii</a></li><li>Unicode编解码工具：<a href="https://www.zxgj.cn/g/unicode">https://www.zxgj.cn/g/unicode</a></li><li>UTF-8编解码工具：<a href="https://www.zxgj.cn/g/utf8">https://www.zxgj.cn/g/utf8</a></li><li>字符串编解码工具：<a href="https://www.zxgj.cn/g/enstring">https://www.zxgj.cn/g/enstring</a></li><li>URL编解码工具：<a href="http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1">http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1</a></li></ul><hr><ul><li>AES&#x2F;DES加解密：<a href="http://www.fly63.com/tool/cipher/">http://www.fly63.com/tool/cipher/</a></li></ul><h3 id="文档笔记工具"><a href="#文档笔记工具" class="headerlink" title="文档笔记工具"></a>文档笔记工具</h3><ul><li>onenote：<a href="https://www.onenote.com/">https://www.onenote.com</a></li><li>simplenote：<a href="https://simplenote.com/">https://simplenote.com</a></li><li>为知笔记：<a href="https://www.wiz.cn/zh-cn">https://www.wiz.cn/zh-cn</a></li><li>印象笔记：<a href="https://www.yinxiang.com/">https://www.yinxiang.com</a></li><li>幕布：<a href="https://mubu.com/home">https://mubu.com/home</a></li><li>有道笔记：<a href="https://note.youdao.com/">https://note.youdao.com</a></li><li>石墨：<a href="https://shimo.im/">https://shimo.im</a></li><li>语雀：<a href="https://www.yuque.com/">https://www.yuque.com</a></li></ul><h3 id="编程学习网"><a href="#编程学习网" class="headerlink" title="编程学习网"></a>编程学习网</h3><ul><li>哔哩哔哩：<a href="https://www.bilibili.com/">https://www.bilibili.com/</a></li><li>C语言网：<a href="https://www.dotcpp.com/">https://www.dotcpp.com/</a></li><li>cppreference：<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/首页</a></li><li>中国大学MOOC：<a href="https://www.icourse163.org/">https://www.icourse163.org/</a></li><li>网易公开课：<a href="https://open.163.com/">https://open.163.com/</a></li><li>CodeGym：<a href="https://codegym.cc/">https://codegym.cc/</a></li><li>BeginnersBook：<a href="https://beginnersbook.com/">https://beginnersbook.com/</a></li><li>codecademy：<a href="https://www.codecademy.com/">https://www.codecademy.com/</a></li><li>Coursera：<a href="https://www.coursera.org/">https://www.coursera.org/</a></li><li>StackOverFlow：<a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li><li>学破解论坛：<a href="https://www.52hb.com/">https://www.52hb.com</a></li><li>我要自学网：<a href="https://www.51zxw.net/">https://www.51zxw.net/</a></li><li>逆向未来：<a href="https://www.pd521.com/">https://www.pd521.com</a></li></ul><h3 id="在线教程和文档"><a href="#在线教程和文档" class="headerlink" title="在线教程和文档"></a>在线教程和文档</h3><ul><li>SVN中文手册：<a href="http://svnbook.red-bean.com/nightly/zh/index.html">http://svnbook.red-bean.com/nightly/zh/index.html</a></li><li>jQuery API中文文档：<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a></li><li>Nginx中文文档：<a href="https://www.nginx.cn/doc/index.html">https://www.nginx.cn/doc/index.html</a></li><li>Kafka中文文档：<a href="https://kafka.apachecn.org/">https://kafka.apachecn.org/</a></li><li>Mybatis中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li><li>微信小程序官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li><li>Nodejs中文教程文档：<a href="http://nodejs.cn/learn/">http://nodejs.cn/learn/</a></li><li>Apache Web Server文档：<a href="http://httpd.apache.org/docs/">http://httpd.apache.org/docs/</a></li><li>Golang标准库文档中文版：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></li><li>Tomcat 8官方文档：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></li><li>RabbitMQ官方文档：<a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></li><li>RocketMQ官方文档：<a href="http://rocketmq.apache.org/docs/quick-start/">http://rocketmq.apache.org/docs/quick-start/</a></li><li>Dubbo中文文档：<a href="https://dubbo.apache.org/zh/docs/">https://dubbo.apache.org/zh/docs/</a></li><li>Netty官方文档：<a href="https://netty.io/wiki/index.html">https://netty.io/wiki/index.html</a></li><li>Elasticsearch官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li>kubernetes中文文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a></li><li>thymeleaf官方文档：<a href="https://www.thymeleaf.org/documentation.html">https://www.thymeleaf.org/documentation.html</a></li><li>Vue.js中文文档：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></li><li>React.js官方文档：<a href="https://reactjs.org/docs/getting-started.html">https://reactjs.org/docs/getting-started.html</a></li><li>Jenkins中文文档：<a href="https://www.jenkins.io/zh/doc/">https://www.jenkins.io/zh/doc/</a></li><li>Oracle Help Center：<a href="https://docs.oracle.com/en/">https://docs.oracle.com/en/</a></li><li>敬伟PS教程全集：<a href="https://www.bilibili.com/video/av18792821?p=172&amp;vd_source=c57311942d38847adc4597a126bba185">https://www.bilibili.com/video/av18792821?p=172&amp;vd_source=c57311942d38847adc4597a126bba185</a></li></ul><h3 id="博主个人备忘书签"><a href="#博主个人备忘书签" class="headerlink" title="博主个人备忘书签"></a>博主个人备忘书签</h3><ul><li><a href="https://zx.js.cool/">https://zx.js.cool</a></li><li><a href="https://mail.qq.com/">https://mail.qq.com</a></li><li><a href="https://www.zhipin.com/">https://www.zhipin.com</a></li><li><a href="https://www.zhaopin.com/">https://www.zhaopin.com</a></li><li><a href="https://cloud.tencent.co蔰m(s忽泆hell瀄蚨root/">https://cloud.tencent.com（shell登录用户名root</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_oop</title>
      <link href="/2022/05/15/Java-oop/"/>
      <url>/2022/05/15/Java-oop/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p>它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。</p><p>在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p><p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。</p><p>当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。</p><p>在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称OOD）方面的知识。</p><p>许多流行的编程语言是面向对象的,它们的风格就是会透由对象来创出实例。</p><p>重要的面向对象编程语言包含Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP等。</p><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>属性：对象数据的描述<br>方法：对象的行为<br>构造方法：用于实例化对象<br>内部类：在类中声明的类（inner class）<br>块：分静态代码块与实例语句块。</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Java是一门面向对象的编程语言，理解Java，首先要理解类与对象这两个概念。</p><ul><li>类：类是一个模板，它描述一类对象的行为和状态。</li><li>对象：对象：对象是类的一个实例。</li></ul><p>综上所述，看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br>对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><p>类的定义：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220826114425837.png" alt="image-20220826114425837"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例说明：</p><ul><li>public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符会在面向对象—封装中详细介绍</li><li>class 是定义类的关键字</li><li>Admin 是类名称</li></ul><p>对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。<br>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p><p>声明：声明一个对象，包括对象名称和对象类型。<br>实例化：使用关键字new来创建一个对象。<br>初始化：使用new创建对象时，会调用构造方法初始化对象。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Admin admin=<span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br></pre></td></tr></table></figure><p>类和对象的内存分配机制</p><p>Java内存的结构分析</p><ol><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（Person p，数组）等</li><li>方法区：常量池（常量，比如字符串），类加载信息</li></ol><p>Java创建对象的流程简要分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = “jack”;</span><br><span class="line">p.age = <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>、先加载 Person 类信息(属性和方法信息, 只会加载一次)</span><br><span class="line"><span class="number">2</span>、在堆中分配空间, 进行默认初始化(看规则)</span><br><span class="line"><span class="number">3</span>、把地址赋给 p , p 就指向对象</span><br><span class="line"><span class="number">4</span>、进行指定初始化， 比如 p.name =”jack” p.age = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827132411595.png" alt="image-20220827132411595"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827132444738.png" alt="image-20220827132444738"></p><p>Java创建对象的流程简单分析</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827141004875.png" alt="image-20220827141004875"></p><ol><li>先加载person类信息（属性信息，方法信息，只会加载一次）</li><li>在堆中分配空间，执行默认初始化</li><li>在栈中分配一个空间存放对象，该对象指向堆空间</li><li>给属性赋初始值（如：p.name &#x3D; “jack”; p.age &#x3D; 10）</li></ol><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><p>1、类属性的定义</p><p>类的属性，是用来描述这一类的相关信息，例如管理员是一类人的总称，那么管理员就有自己的属性，大概包括姓名，年龄，用户名，密码等。定义类的属性通过声明变量的形式来完成。每个属性都有它对应的访问修饰符、数据类型、变量名。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String loginName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：定义类的属性可以不为变量赋初始化值，属性的初始值会在类对象被实例化时进行赋值</strong></p><p>2、类属性的分类：</p><p>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。<br>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种。</p><p>3、this关键字</p><p>当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是 this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this，并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。在本类中，方法内可以通过this访问累的非静态变量和方法。</p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>1、类方法的定义<br>Java语言中的“方法”（Method）在其他语言当中也可能被称为“函数”（Function）。对于一些复杂的代码逻辑，如果希望重复使用这些代码，并且做到“随时任意使用”，那么就可以将这些代码放在一个大括号“{}”当中，并且起一个名字。使用代码的时候，直接找到名字调用即可。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220826114941053.png" alt="image-20220826114941053"></p><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li>访问修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法会被谁访问到。</li><li>方法修饰符：用来修饰特殊方法的修饰符。</li><li>返回值类型：方法可能会返回值。return ValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。（构造方法除外）</li><li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li>方法参数：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li>方法体：方法体包含具体的语句，定义该方法的功能，使用大括号作为方法范围。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>方法：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li>程序开始执行的时候是先执行main方法。因为main方法是一个入口。</li><li>在java语言中所有的方法体中的代码都必须遵循自上而下的顺序依次逐行执行。</li><li>main方法不需要程序员手动调用，是由JVM调用的。但是除了main方法之外其他的方法，都需要程序员手动调用。</li><li>方法只有调用的时候才会执行，方法不调用是不会执行的。</li><li>方法定义在类体当中。方法定义的先后顺序没有关系</li><li>方法中的变量都属于局部变量。方法结束之后，局部变量占用的内存会自动释放</li></ol><h3 id="方法定义，语法机制"><a href="#方法定义，语法机制" class="headerlink" title="方法定义，语法机制"></a>方法定义，语法机制</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">方法体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>[] 符号叫做中括号，以上中括号[ ]里面的内容表示不是必须的，是<code>可选</code>的。</li><li>方法体由Java语句构成。</li><li>方法定义之后需要去调用，不调用是不会执行的。</li></ol><h4 id="修饰符列表"><a href="#修饰符列表" class="headerlink" title="修饰符列表"></a>修饰符列表</h4><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><ol><li>返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String…</li><li>什么是返回值？返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line"><span class="comment">// 调用a方法</span></span><br><span class="line">a();</span><br><span class="line">       <span class="comment">//如果a方法执行结束之后有返回值，这个返回值返回给main了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。</p><ol start="3"><li><p>当一个方法执行结束不返回任何值的时候，返回值 类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。</p></li><li><p>如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用”return 值;”这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句,那么编译器会报错。<br>return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。</p></li><li><p>只要有“return”关键字的语句执行，当前方法必然结束。<br>return只要执行，当前所在的方法结束，记住：不是整个程序结束。</p></li><li><p>如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前 方法的。</p></li><li><p>除了void之外，剩下的都必须有“return 值;”这样的语句。</p></li></ol><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名要见名知意。（<code>驼峰命名</code>方式）<br>方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。</p><h4 id="形式参数列表"><a href="#形式参数列表" class="headerlink" title="形式参数列表"></a>形式参数列表</h4><ol><li>简称：形参</li><li>注意：形式参数列表中的每一个参数都是“<code>局部变量</code>”，方法结束之后内存<code>释放</code>。</li><li>形参的个数是：<code>0 ~ N</code>个。</li><li>形参的数据类型起决定性作用，形参对应的变量名是随意的。（方法重载会涉及！）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> d, String s)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参有多个的话使用“逗号,”隔开。逗号是英文的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><p>由Java语句构成。java语句以“<code>;</code>”结尾。<br>方法体当中编写的是业务逻辑代码，完成某个特定功能。<br>在方法体中的代码遵循自上而下的顺序依次逐行执行。<br>在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参</p><hr><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名(实际参数列表);</span><br></pre></td></tr></table></figure><p><strong>实参和形参的类型必须一一对应，另外个数也要一一对应。</strong></p><ul><li>在方法调用的时候，什么时候“类名.”是可以省略的。什么时候不能省略？<ul><li>a()方法调用b()方法的时候，a和b方法都在<code>同一个类</code>中，“类名.”<code>可以省略</code>。<br>如果不在同一个类中“类名.”不能省略。</li></ul></li></ul><h4 id="调用方法的三种形式"><a href="#调用方法的三种形式" class="headerlink" title="调用方法的三种形式"></a>调用方法的三种形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赋值调用：</strong>调用方法，在方法前面定义变量，接收方法返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出语句调用：在输出语句中调用方法， System.out.println(方法名()) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能用输出语句调用void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</p><h3 id="方法的调用机制分析"><a href="#方法的调用机制分析" class="headerlink" title="方法的调用机制分析"></a>方法的调用机制分析</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827181717775.png" alt="image-20220827181717775"></p><p>方法调用：</p><ol><li>当程序执行到方法是时，就会开辟一个独立的空间（栈空间）</li><li>当方法执行完毕，或者执行到ruturn语句时，就会返回</li><li>返回到调用方法的地方</li><li>返回后，继续执行方法后面的代码</li><li>当main方法（栈）执行完毕，整个程序退出</li></ol><p>方法的注意事项</p><ol><li>方法不能定义在类中其他方法里面</li><li>方法名和变量名可以同名</li><li>方法要先定义后使用，方法要调用了才会执行</li><li>当方法有形参的时候,想调用该方法必须向其中传入相应的实际参数</li><li>形参和实际参数的变量名不需要相同,需要注意的是形参的个数,类型,类型顺序是否和实参一致</li><li>一个方法可以有多个return,但是只可能有一个return被执行</li></ol><h4 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h4><p>​            基本数据类型的传参机制</p><p>​            结论: 基本数据类型, 传递的是值(值拷贝) , 形参的任何改变不影响实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Hsp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 创建AA对象 名字叫obj</span></span><br><span class="line"><span class="type">AA</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">obj.swap(a,b); <span class="comment">//调用swap :交换</span></span><br><span class="line">System.out.println(“main方法: a=” + a + <span class="string">&quot; b= &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a和b交换前的值a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);</span><br><span class="line"><span class="comment">//完成了a和b的交换</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">System.out.println(<span class="string">&quot;a和b交换后的值a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>内存分析法：</li></ul><ol><li>堆 : 一般存放基本数据类型(局部变量)</li><li>栈 : 存放对象(Cat cat，数组，引用数据类型等)</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c31ef1ac7558489e8572a83446b3354c.png" alt="img"></p><ol start="3"><li>最后输出的 a,b的值是在main方法中，要找的是main方法中的a和b的值，而主函数中的a,b并没有发生交换，所以是 a &#x3D; 10,b &#x3D; 20</li><li>swap方法中发生交换，但并不影响主方法中的交换，因为mian栈和swap是两个独立的空间，而且a、b都是基本数据类型，不是引用数据类型，所以不会影响到主方法中的a、b的值</li></ol><p>引用数据类型的传参机制</p><ul><li><p>B 类中编写一个方法 test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？</p><p>答案：会变化</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">M2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">         <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">         b.test100(arr);    <span class="comment">//调用方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot; main的 arr数组 &quot;</span>);</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         System.out.print(arr[i] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//B类中编写一个方法test100，</span></span><br><span class="line">    <span class="comment">//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">200</span>;<span class="comment">//修改元素</span></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot; test100的 arr数组 &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内存分析法：</p><ol><li>只要是调用一个方法就会产生一个新的栈</li><li>引用类型传递的是一个地址</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2437149496074802b6a9720445bacb15.png" alt="img"></p><ol start="3"><li>B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？<strong>答案：会变化</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParameter02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;xdr630&quot;</span>;</span><br><span class="line">        p.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        b.test200(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age); <span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        person.age = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>结论:引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;xdr630&quot;</span>;</span><br><span class="line">        p.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        b.test200(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age); <span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>示意图</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/f9478134046c4381948fbc2d305c1e14.png" alt="img"></p><p>2、特殊的方法—-构造方法</p><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Admin</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Admin</span><span class="params">(String name,<span class="type">int</span> age,String loginName,String password)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.loginName=loginName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.password=password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>Java中方法的重载，就是在一个类中，有相同的方法名称，但形参不同的方法。</p><h4 id="方法重载的规则"><a href="#方法重载的规则" class="headerlink" title="方法重载的规则"></a>方法重载的规则</h4><ul><li>方法名称<strong>必须相同</strong></li><li>形参列表<strong>必须不同</strong>（参数个数不同、或参数类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同，不足以称为方法的重载。</li><li><strong>同一个类中，不允许两个方法的方法名称和参数列表都相同</strong></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>如下，代码中定义了三个<strong>max</strong>方法(即<strong>方法重载</strong>)，在调用它们时根据传入的实参类型和实参个数，分别调用了对应的 max 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mJane.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第一个max方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value1</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(max_value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第二个max方法，而不是第一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value2</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">25</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(max_value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为2个浮点数，匹配到第三个max方法</span></span><br><span class="line"><span class="comment">//int max_value3 = (int)max(10.0,30.0);   //返回值类型为double， 高--&gt;低 : 强制转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">max_value3</span> <span class="operator">=</span> max(<span class="number">10.0</span>,<span class="number">30.0</span>);</span><br><span class="line">        System.out.println(max_value3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> num3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt; num3 ? result:num3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>方法名相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法执行，如果匹配失败(未找到对应方法)，则编译器报错。</p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p><strong>重写（override）</strong>：也称覆盖。重写是子类对父类非静态，非private，非final方法的实现过程进行重新编写，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的）和形参都不能改变。即外壳不变，核心重写。</p><p><strong>【方法重写的规则】</strong>：<br>1.子类在重写父类的方法时，一般必须与父类方法原型一致：修饰符 返回值类型 方法名(参数列表) 要完全一致<br>2.JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的。<br>3.访问权限不能比父类中被重写的方法的访问权限更低。<br>4.父类被static、private 、final修饰的方法不能被重写。</p><p><strong>重写的作用</strong></p><p>重写是为了增强类的重用性和复用性，扩展性；</p><p>重写是对类中方法的扩充，因为继承用的是父类的东西，重写则不仅得到父类的东西，同时也加入了自己的东西，两全其美。</p><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>1.重载<br>重载的参数列表是必须修改的，而返回值类型，访问限定符是可以修改的</p><p>重载是静态绑定，即在编译时就根据实参类型确定了调用哪个方法。</p><p>2.重写<br>重写的参数列表，返回类型（可以是父子类），访问限定符（不能更严厉），一般是不能修改的。</p><p>重写是动态绑定，即在编译时不能确定具体的调用方法，而在程序运行时，才能确定具体的被调用的方法。</p><p>即：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现</p><table><thead><tr><th>名称</th><th>发生范围</th><th>方法名</th><th>形参列表</th><th>返回类型</th><th>修饰符</th></tr></thead><tbody><tr><td>重载(overload)</td><td>本类</td><td>必须一样</td><td>类型，个数或者顺序至少有一个不同</td><td>无要求</td><td>无要求</td></tr><tr><td>重写(override)</td><td>父子类</td><td>必须一样</td><td>相同</td><td>子类重写的方法，返回类和父类返回类型一样，或者是其子类</td><td>子类方法不能缩小父类方法的访问范围</td></tr></tbody></table><blockquote><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p></blockquote><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>可变参数(variable argument)允许你指定可以采用多个同类型参数的方法，而不需要事先确定参数的数目。</p><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可变参数语法：</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> … args)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>调用可变参数的方法时, 编译器将自动创建一个数组保存传递给方法的可变参数，因此，程序员可以在方法体中以数组的形式访问可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ... nums)</span>&#123; </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个方法参数中只能使用一个省略号；且省略号必须出现在方法中参数列表的最后一个位置。<br>&#x2F;&#x2F;要把可变参数放到参数列表的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String s,<span class="type">int</span> ... nums)</span>&#123; <span class="comment">//把可变参数当成数组</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">   sum += nums[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol><li>可变参数的实参可以为0个或者任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li>在java编程中，主要的变量就是属性（成员变量）和局部变量</li><li>我们说的局部变量一般是指在成员方法中定义的变量</li><li>java中作用域的分类<ol><li>全局变量：也就是属性</li><li>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</li></ol></li><li>全局变量（属性）可以不赋值，直接使用，因为他有默认值，局部变量必须赋值后，才能使用，因为没有默认值</li></ol><p>注意事项：</p><ol><li>属性和局部变量可以重名，访问时遵循就近原则</li><li>在同一个作用域中，比如在同一个成员方法中，两恶搞局部变量，不能重名</li><li>属性生命周期长，伴随着对象的创建而创建，伴随则会对象的销毁而销毁，局部变量，生命周期较短，伴随着他的代码块的执行而创建，伴随这代码块的结束而销毁，即在一次方法调用过程中</li><li>作用域范围不同<ol><li>全局变量&#x2F;属性：可以被本类使用，或其他类使用(通过对象调用)</li><li>局部变量：只能在本类中对应的方法中使用</li></ol></li><li>修饰符不同<ol><li>全局变量&#x2F;属性可以加修饰符</li><li>局部变量不可以加修饰符</li></ol></li></ol><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>一般是指在成员方法中定义的变量</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;<span class="comment">//这是一个方法cry()</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">10</span>;<span class="comment">//这就是局部变量</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>局部变量没有默认值<br>如果出现没有赋值，那么就会报出为初始化变量</p><pre><code>public static void main(String[] args)&#123;    Cat a1=new Cat();    a1.cry();&#125;&#125;class Cat&#123;    public void cry()&#123;//这是一个方法cry()        int n;//这就是局部变量        System.out.println(n);    &#125;&#125;</code></pre><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java: 可能尚未初始化变量n</span><br></pre></td></tr></table></figure><h4 id="全局变量（或者属性）"><a href="#全局变量（或者属性）" class="headerlink" title="全局变量（或者属性）"></a>全局变量（或者属性）</h4><p>可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.eat();<span class="comment">//调用eat方法</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">10</span>;<span class="comment">//全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;<span class="comment">//eat方法</span></span><br><span class="line">        System.out.println(age);<span class="comment">//输出全局变量age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>全局变量默认值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byet <span class="number">0</span></span><br><span class="line"><span class="type">short</span> <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0</span></span><br><span class="line"><span class="type">long</span> <span class="number">0</span></span><br><span class="line"><span class="type">float</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">double</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">char</span> \u0000</span><br><span class="line"><span class="type">boolean</span> <span class="literal">false</span></span><br><span class="line">String <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>全局变量默认值可以直接输出</p><p>举例 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.eat();<span class="comment">//调用eat方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> age;<span class="comment">//全局变量age</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(age);<span class="comment">//输出age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>构造方法也叫构造器（constructor）是类的一种特殊的方法，他的主要作用是完成对<strong>新对象的初始化</strong>，</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用类的构造器完成对对象的初始化。</li></ol><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名 (形参列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>构造器的修饰符可以默认，也可以是public、private、protected</li><li>构造器<strong>没有返回值</strong></li><li>方法名和类名字必须一样</li><li>参数列表和成员方法一样的规则</li><li>构造器的调用由系统完成</li></ol><h4 id="注意事项-x2F-使用细节"><a href="#注意事项-x2F-使用细节" class="headerlink" title="注意事项&#x2F;使用细节"></a>注意事项&#x2F;使用细节</h4><ol><li><p>一个类可以定义多个不同的构造器，构造器重载比如：可以给Person类顶一个构造器，用来创建对象的收，只指定人名，不需要指定年龄。</p><ol><li>&#96;&#96;&#96;java<br>class Person{<br>String name;<br>int age;<br>public Person(String PName,int PAge){<br>    naem &#x3D; PName;<br>    aeg &#x3D; PAge;<br>}<br>public Person(String PName){<br>    name &#x3D; PName;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 构造器名和类名要相同</span><br><span class="line"></span><br><span class="line">3. 构造器没有返回值</span><br><span class="line"></span><br><span class="line">4. 构造器是完成对象的初始化，并不是创建对象</span><br><span class="line"></span><br><span class="line">5. 在创建对象时，系统会自动的调用该类的构造方法</span><br><span class="line"></span><br><span class="line">6. 如果没有定义构造方法，系统会自动给类一个默认无参构造方法（也叫默认构造方法），比如Person()&#123;&#125;,可使用**javap指令** 反编译查看</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      class Person&#123;</span><br><span class="line">          Person()&#123;&#125;//隐藏构造器</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一旦定义了自己的构造器，默认的构造器就被覆盖，就不能再使用默认的无参构造器，除非显式的定义一下，即；Person(){}</p><ol><li>&#96;&#96;&#96;java<br>class Person{<br>String name;<br>&#x2F;&#x2F;手动定义的无参构造器<br>Person(){}<br>&#x2F;&#x2F;自己定义的有参构造器<br>public Person(String PNanme){<br>    name &#x3D; PName;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 访问修饰符</span><br><span class="line"></span><br><span class="line">有四种访问修饰符规定了定义的属性和方法能访问的区域</span><br><span class="line"></span><br><span class="line">1. private关键字</span><br><span class="line"></span><br><span class="line">   用private关键字修饰的属性和方法只能在该类的大括号内访问，出了这个类就不能被访问了。当一个子类继承一个父类的属性和方法时，若父类的属性或方法被private修饰，那么子类就不可以继承该属性或方法。</span><br><span class="line"></span><br><span class="line">2. default关键字（包访问权限）</span><br><span class="line"></span><br><span class="line">   default关键字修饰的属性或方法只能在同一个包中的所有类访问，且必须是同级的包，在一个包中的子包也不可以访问。但我们在定义属性和方法时不需要将default关键字写出来，没有关键字修饰的属性或方法就是包访问权限。</span><br><span class="line"></span><br><span class="line">3. protected关键字（继承访问权限）</span><br><span class="line"></span><br><span class="line">   被protected关键字修饰的属性或方法只能在同一个包中的所有类和不同包中的子类访问，出了一个包但不是该类的子类的话就不可以访问。</span><br><span class="line"></span><br><span class="line">4. public关键字</span><br><span class="line"></span><br><span class="line">   被public关键字修饰的属性或方法可以在任意位置被访问，没有使用的权限。</span><br><span class="line"></span><br><span class="line">&gt; 所以这四种访问修饰符使用的范围从小到大依次是</span><br><span class="line">&gt; [private](https://so.csdn.net/so/search?q=private&amp;spm=1001.2101.3001.7020) &lt; default &lt; protected &lt; public</span><br><span class="line"></span><br><span class="line">| 范围           | private    | Default(默认)     | Protected     | Public     |</span><br><span class="line">| :------------: | :--: | :--: | :--: | :--: |</span><br><span class="line">| 同一个类       |  √    |  √    |  √    |   √   |</span><br><span class="line">| 同一个包       |      |   √   |   √   |  √   |</span><br><span class="line">| 不同包的子类   |      |      |   √   |   √   |</span><br><span class="line">| 不同包的非子类 |      |      |      |   √   |</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line"></span><br><span class="line">1. 修饰符可以用来修饰类中的属性，成员方法以及类</span><br><span class="line">2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点</span><br><span class="line">3. 1</span><br><span class="line">4. 成员方法的访问规则和属性完全一样</span><br><span class="line"></span><br><span class="line">## This</span><br><span class="line"></span><br><span class="line">#### 注意事项，使用细节</span><br><span class="line"></span><br><span class="line">1. this关键字可以用来访问本类的属性、方法。构造器</span><br><span class="line">2. this用于区分当前类的属性和局部变量</span><br><span class="line">3. 访问成员方法的语法：this.方法名(参数列表)</span><br><span class="line">4. 访问构造器语法：this(参数列表);注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须位于第一行，而且只能出现一次）</span><br><span class="line">5. this不能在类定义的外部使用，只能在类定义的方法中使用</span><br><span class="line">6. 不能在一个类中的两个构造方法中使用this()互相调用</span><br><span class="line"></span><br><span class="line">this关键字的三种用法：</span><br><span class="line"></span><br><span class="line">- 通过this关键字可以明确的访问一个类的成员变量，解决成员变量与局部变量名称冲突问题。</span><br><span class="line">  实例：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class person&#123;</span><br><span class="line">        </span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">        </span><br><span class="line">        public person(String name,int age)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p> 上面代码中<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">构造方法</a>中定义的参数name，age等它是局部变量，在类中也定义了name，age等成员变量，在构造方法中使用age则是访问局部变量，如果想访问类中的成员变量，使用this.age则是访问成员变量。</p></li></ol><ul><li><p>通过this关键字调用成员方法</p><ul><li><p>&#96;&#96;&#96;java<br>class person{</p><pre><code>public void test()&#123;    System.out.println(“该方法被调用”);&#125;public void test1()&#123;    //调用test()方法    this.test();&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;在test2()方法中通过this.test1()访问test1()方法，注意此处的this关键字可以不写，效果是一样的。</p><p>class person{</p><pre><code>public void test()&#123;    System.out.println(“该方法被调用”);&#125;public void test1()&#123;    //调用test()方法    test();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在构造方法中访问构造方法使用this([参数1]，[参数2].。。)</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class person&#123;</span><br><span class="line">        </span><br><span class="line">        int age;</span><br><span class="line">        </span><br><span class="line">        public person()&#123;</span><br><span class="line">            //无参构造</span><br><span class="line">        &#125;</span><br><span class="line">        public person(int age)&#123;</span><br><span class="line">            this();</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误用法</p><ul><li><p>&#96;&#96;&#96;java<br>public class Student {<br>&#x2F;&#x2F;成员变量<br>String name;<br><br>public Student() {<br>    System.out.println(“无参构造方法…”);<br>    &#x2F;&#x2F;错误,必须位于第一行<br>    this(“张三”);<br>}<br><br>public Student(String name) {<br>    this.name &#x3D; name;<br>}<br>  }</p><p>public class Student {<br>String name;&#x2F;&#x2F;成员变量<br><br>public Student() {<br>    &#x2F;&#x2F;错误，不能相互调用<br>    this(“张三”);<br>}<br><br>public Student(String name) {<br>    &#x2F;&#x2F;错误，不能相互调用<br>    this();<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Super</span><br><span class="line"></span><br><span class="line">###  使用super调用父类中重写的方法、访问父类中被隐藏的字段</span><br><span class="line"></span><br><span class="line">子类重写了父类中的某一个方法，隐藏父类中的字段，假如想在子类中访问到父类中被重写的方法和隐藏父类的字段，可以在子类中通过使用关键字super来调用父类中被重写的方法和访问父类中被隐藏的字段。例如：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package first;</span><br><span class="line">class A&#123;</span><br><span class="line">    public String name=&quot;张飞&quot;;         //添加成员变量</span><br><span class="line">public void say() &#123;                //添加成员方法say</span><br><span class="line">System.out.println(&quot;我是父类A成员方法say&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public String name=&quot;关羽&quot;;         //与父类中同名的字段，隐藏父类</span><br><span class="line">public void say()&#123;                 //重写方法say</span><br><span class="line">super.say();                   //使用super关键字调用父类中的方法</span><br><span class="line">System.out.println(&quot;我是子类B成员方法say&quot;);</span><br><span class="line">        System.out.println(&quot;父类的name名字：&quot;+super.name); //使用super关键字访问父类中的变量</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class myfirst &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  B b=new B();                     //创建子类的一个实例对象</span><br><span class="line">  b.say();                         //调用子类中重写的方法</span><br><span class="line">  System.out.println(&quot;子类的name名字：&quot;+b.name);   //调用子类中的name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>运行结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是父类A成员方法say</span></span><br><span class="line"><span class="comment">//我是子类B成员方法say</span></span><br><span class="line"><span class="comment">//父类的name名字：张飞</span></span><br><span class="line"><span class="comment">//子类的name名字：关羽</span></span><br></pre></td></tr></table></figure><h3 id="使用super调用父类的无参数构造方法-x2F-有参数构造方法"><a href="#使用super调用父类的无参数构造方法-x2F-有参数构造方法" class="headerlink" title="使用super调用父类的无参数构造方法&#x2F;有参数构造方法"></a>使用super调用父类的无参数构造方法&#x2F;有参数构造方法</h3><p>子类不继承其父类的构造方法。</p><ul><li>当使用无参数的super()时，父类的无参数构造方法就会被调用；</li><li>当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;              <span class="comment">//创建父类SuperClass</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;            <span class="comment">//声明一个私有变量n</span></span><br><span class="line">  SuperClass()&#123;             <span class="comment">//父类无参数构造方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是父类SuperClass无参数构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(<span class="type">int</span> n) &#123;       <span class="comment">//父类有参数构造方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是父类SuperClass有参数构造方法&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;     <span class="comment">// SubClass类继承SuperClass类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;                       <span class="comment">//声明一个私有变量n</span></span><br><span class="line">  SubClass()&#123;                          <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是子类无参数构造方法&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(<span class="type">int</span> n)</span>&#123;              <span class="comment">//子类有参数构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="number">300</span>);                        <span class="comment">//调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是子类有参数构造方法&quot;</span>+n);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();      <span class="comment">//创建子类SubClass实例对象，调用其无参数构造方法</span></span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(<span class="number">100</span>);   <span class="comment">//创建子类SubClass实例对象，调用其有参数构造方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是父类SuperClass无参数构造方法</span></span><br><span class="line"><span class="comment">//这是子类无参数构造方法</span></span><br><span class="line"><span class="comment">//这是父类SuperClass有参数构造方法</span></span><br><span class="line"><span class="comment">//这是子类有参数构造方法100</span></span><br></pre></td></tr></table></figure><p>注意</p><ul><li><p>如果要初始化父类中的字段，可以在子类的构造方法中通过关键字super调用父类的构造方法；</p></li><li><p>对父类的构造放的调用必须放在子类构造方法的第一行；</p></li><li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器；</p></li><li><p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表；</p></li><li><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</p></li></ul><h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。</p><h3 id="强调一下"><a href="#强调一下" class="headerlink" title="强调一下"></a>强调一下</h3><ul><li>static修饰的成员变量和方法，从属于类</li><li>普通变量和方法从属于对象</li><li>静态方法不能调用非静态成员，编译会报错</li></ul><h3 id="static关键字的用途"><a href="#static关键字的用途" class="headerlink" title="static关键字的用途"></a>static关键字的用途</h3><p>一句话描述就是：<strong>方便在没有创建对象的情况下进行调用(方法&#x2F;变量)。</strong></p><p>显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p><p>static可以用来修饰类的成员方法、类的成员变量，另外也可以编写static代码块来优化程序性能</p><h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><p>static方法也成为静态方法，由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this的，因为不依附于任何对象，既然都没有对象，就谈不上this了，并且由于此特性，在静态方法中不能访问类的非静态成员变量和非静态方法，因为非静态成员变量和非静态方法都必须依赖于具体的对象才能被调用。</p><p>虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量。</p><p>代码示例：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20180807172546687" alt="这里写图片描述"></p><p>从上面代码里看出：</p><p>静态方法test2()中调用非静态成员变量address，编译失败。这是因为，在编译期并没有对象生成，address变量根本就不存在。</p><p>静态方法test2()中调用非静态方法test1()，编译失败。这是因为，编译器无法预知在非静态成员方法test1()中是否访问了非静态成员变量，所以也禁止在静态方法中调用非静态成员方法</p><p>非静态成员方法test1()访问静态成员方法test2()&#x2F;变量name是没有限制的</p><p>所以，如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。最常见的静态方法就是main方法，这就是为什么main方法是静态方法就一目了然了，因为程序在执行main方法的时候没有创建任何对象，只有通过类名来访问。</p><p>特别说明：static方法是属于类的，非实例对象，在JVM加载类时，就已经存在内存中，不会被虚拟机GC回收掉，这样内存负荷会很大，但是非static方法会在运行完毕后被虚拟机GC掉，减轻内存压力</p><h3 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h3><p>static变量也称为静态变量，静态变量和非静态变量的区别：</p><p>静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化</p><p>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</p><p>static成员变量初始化顺序按照定义的顺序来进行初始化</p><h3 id="static块"><a href="#static块" class="headerlink" title="static块"></a>static块</h3><p>构造方法用于对象的初始化。静态初始化块，用于类的初始化操作。</p><p>在静态初始化块中不能直接访问非staic成员。</p><h4 id="static块的作用"><a href="#static块的作用" class="headerlink" title="static块的作用"></a>static块的作用</h4><p>静态初始化块的作用就是：提升程序性能。</p><p>为什么说静态初始化块能提升程序性能，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBornBoomer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> Date.valueOf(<span class="string">&quot;1946&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> Date.valueOf(<span class="string">&quot;1964&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">&quot;1946&quot;</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">&quot;1964&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBornBoomer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行</p><p>静态初始化块可以置于类中的任何地方，类中可以有多个静态初始化块。<br>在类初次被加载时，会按照静态初始化块的顺序来执行每个块，并且只会执行一次。</p><hr><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><h3 id="类变量的定义"><a href="#类变量的定义" class="headerlink" title="类变量的定义"></a>类变量的定义</h3><p>类变量也叫静态变量&#x2F;静态方法,是该类的所有对象共享的变量,任何一个该类的对象访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量.</p><h3 id="类变量的定义语法"><a href="#类变量的定义语法" class="headerlink" title="类变量的定义语法"></a>类变量的定义语法</h3><p>推荐使用 :      访问修饰符 static 数据类型 变量名;<br>当然也可以:    static 访问修饰符 数据类型 变量名</p><h3 id="访问类变量"><a href="#访问类变量" class="headerlink" title="访问类变量"></a>访问类变量</h3><p>推荐使用: 类名.类变量名<br>当然也可以用: 对象名.类变量名<br>需要注意的是</p><p>静态变量的访问修饰符的访问权限和范围与普通类型是一样的<br>类变量是随着类加载而加载(用到类的时候会加载,只加载一次),所以即使没有创建实例对象也可以访问<br>访问变量名的代码解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Visit</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.name);<span class="comment">//输出张三</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();              <span class="comment">//两个输出效果相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.name=&quot;</span>+a.name);<span class="comment">//输出a.name=张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>什么时候需要用类变量<ol><li>需要让某个类的所有对象共享一个变量时,可以考虑使用类变量</li></ol></li><li>类变量和实例变量区别<ol><li>类变量是该类所有对象共享的,而实例变量是每个对象独享的</li></ol></li><li>加上static称为<strong>类变量</strong>或者<strong>静态变量</strong>,否则称为实例变量&#x2F;普通变量&#x2F;非静态变量，</li><li>实例变量不能用类名.变量名访问</li><li>类变量可以通过 <strong>类名.类变量名</strong> 或者  <strong>对象名.类变量名</strong>  来访问，但Java设计者推荐  类名.类变量名 方式访问</li><li>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了就可以使用类变量</li><li>类变量的生命周期随类的加载开始，随类消亡而销毁</li></ol><h3 id="关于静态变量-x2F-类变量在内存中的位置"><a href="#关于静态变量-x2F-类变量在内存中的位置" class="headerlink" title="关于静态变量&#x2F;类变量在内存中的位置"></a>关于静态变量&#x2F;类变量在内存中的位置</h3><p>关于这个问题网上流传版本不同,原因是随着jdk的版本不同,但却有以下共识</p><p>static变量是同一个类所有对象共享,不必知道其具体位置也行<br>static在类加载时生成,只加载一次,没有创建对象实例也可以通过类名.类变量来访问,生命周期随类加载而开始,随类消失而消亡那个,与对象无关</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类方法也叫静态方法</p><p>形式如下</p><p>访问修饰符 static 数据返回类型 方法名(){ }</p><p>static 访问修饰符 数据返回类型 方法名(){  }</p><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p><strong>类名.类方法名</strong>   或者    <strong>对象名.类方法名</strong>  </p><blockquote><p>前提是 满足访问修饰符的访问权限和范围</p></blockquote><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：<ol><li>类方法中无this的参数</li><li>普通方法中隐含着this的参数</li></ol></li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用，比如<strong>对象名.方法名(参数)</strong>,不能通过类名调用</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>** <strong>在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。</strong></p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；<br>非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p> 因为静态方法和静态数据成员会随着类的定义而被分配和装载入<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中，而非静态方法和非静态数据成员只有在类的对象创建时在对象的内存中才有这个方法的代码段。</p><p>引用静态方法时，可以用类名.方法名或者对象名.方法名的形式。<br>对以上描述进行验证的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        System.out.println(S.getStatic());<span class="comment">//使用类名加前缀访问静态方法</span></span><br><span class="line">        S s=<span class="keyword">new</span> <span class="title class_">S</span>();</span><br><span class="line">        System.out.println(s.getStatic());<span class="comment">//使用实例化对象名访问静态方法</span></span><br><span class="line">        System.out.println(s.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">S</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态初始器：由static和&#123;&#125;组成，只在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。</span></span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            a=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态方法只能访问静态数据成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getStatic</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getT</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态方法可以访问静态方法和非静态方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            getT();</span><br><span class="line">            getStatic();</span><br><span class="line">            t=a;<span class="comment">//非静态方法可以访问非静态数据成员和静态数据成员</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>（1）<a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>修饰的静态方法会随着类的定义而被分配和装载入内存中，编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然可能有多个实例，但这些实例共享该内存，特别值得注意的是，任何一个对象对静态数据成员的修改，都会影响其它对象。<br>（2）静态不能引用非静态这一特性，是由于静态的会随着类的定义而被分配和装载入内存中这一关键点决定的；如果静态引用了非静态的，根本无法从内存中找到非静态的代码段，势必会出错，这种做法是Java虚拟机决不允许的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>静态方法，只能访问静态成员</li><li>非静态方法，可以访问所有成员</li><li>遵守访问权限规则</li></ol><hr><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>定义：Java中，final 表示最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。</p><p>用途：final 应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变。</p><p>使用注意事项：</p><ol><li>final 修饰变量，表示变量的值不可改变，此时该变量可被称为常量。</li><li>final 修饰方法，表示方法不能被子类重写；<ol><li>重写概念：子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。</li></ol></li><li>final 用在类的前面表示该类不能有子类，即该类不可以被继承。</li></ol><h3 id="final修饰"><a href="#final修饰" class="headerlink" title="final修饰"></a>final修饰</h3><p>1、final变量<br>final变量，凡是对成员变量或者(在方法中的或者代码块中的变量称为本地变量)声明为 final 的都叫作 final 变量。final 变量经常和 static 关键字一起使用，作为常量。下面是 final 变量的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">NAME = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;李四&quot;</span>); <span class="comment">//invalid compilation error</span></span><br><span class="line"><span class="comment">//final 变量是只读的。</span></span><br></pre></td></tr></table></figure><p>2、final 方法<br>final 声明方法，这个方法不允许在派生类中进一步被覆写（override）。</p><p>Java 中非私有的成员方法默认都是虚方法，而虚方法就可以在派生类中被覆写。</p><p>为保证某个类上的某个虚方法不在派生类中被进一步覆写，就需要使用 final 修饰符来声明，让编译器（例如 javac）与 JVM 共同检查并保证这个限制总是成立。</p><p>下面是 final 方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span>张三<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Reader extends User&#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public final String getName()&#123;</span></span><br><span class="line"><span class="string">        return &quot;</span>李四<span class="string">&quot;; //compilation error: overridden method is final</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>3、final 类<br>final 修饰的类叫作 final 类，final类通常是功能完整的，不能被继承，Java 中有许多类是 final 的，比如 String, Interger 以及其他包装类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol><li>final 关键字，提高了性能，JVM 和 Java 应用都会缓存 final 变量。</li><li>final 变量，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>final 关键字可以用于修饰成员变量、本地变量、方法以及类。</li><li>final 成员变量，必须在声明的时初始化或者在构造器中初始化，否则报编译错误。</li><li>final 变量不能再次赋值；final 方法不能被重写；final 类不能被继承。</li><li>在匿名类中，所有变量都必须是 final 变量。</li><li>接口中，声明的所有变量本身是 final 的。</li><li>final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的。</li><li>声明时未初始化的 final 变量，称为空白 final 变量(blank final variable)，必须在构造器中进行初始化，或者调用 this() 初始化，否则，编译器会报错final变量(变量名)需要进行初始化。</li><li>按照 Java 编码规范，final 变量就是常量，而且通常常量名要大写。</li><li>对于集合对象声明为 final 指的是引用不能被更改。</li></ol><hr><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li>java虚拟机需要调用类的main()方法，所以该方法的访问必须是public</li><li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li><li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，</li><li>java执行的程序 参数1，参数2，参数3<ol><li><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919153604012.png" alt="image-20220919153604012"></li></ol></li></ol><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>public是一种访问权限修饰符，public中文翻译共有，正如它的实际意思一样，在Java里面所有被public修饰的方法，类等都可以在任意其他地方调用。main方法之所以是public，是因为一个Java程序在运行时首先创建一个JVM实例，程序要运行需要调用main方法，JVM从外部调用main方法这就需要访问权限修饰符必须给出外部访问的权限，所以只能用public。</p><p>static的定义是为了JVM在调用main方法时不用实例化对象，只需要在初始时加载main方法所在类，然后直接通过类名.main来调用main方法。</p><p>void表示main方法没有返回值，没有返回值的原因是因为Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序。</p><p>main的名称不能变是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。main方法作为程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程，非守护线程和守护线程，main方法属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以表明自己的线程是守护线程。当程序中所有的非守护线程终止时，JVM退出。也可以用Runtime类或者System.exit()来退出。</p><p>String[] args,是main方法中唯一可以改变的地方！args是arguments的缩写，只是一个变量默认名，习惯性写作它，但是也可以改变的，只要符合命名规则随便你写成什么。在使用集成开发工具的今天，String[] args更像是一种摆设了，很多初学者都不知道它的作用，其实它是程序运行传入的一个参数组。一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainMethod</span>&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;获取数组args[]的数据&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;第&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;个实参：&quot;</span> + args[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入实参（1 2 3）</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919164420682.png" alt="image-20220919164420682"></p><p>输出结果为：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919164850936.png" alt="image-20220919164850936"></p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ol><li>在main()方法中，可以直接调用main方法所在类的静态方法或静态属性</li><li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>封装（encapsulation）就是把抽象出的数据[属性]和对数据的操作[方法]封装再一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法].才能对数据进行操作</p><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。<br>实现Java封装的步骤</p></li><li><p>修改属性的可见性来限制对属性的访问（一般限制为private），例如:</p><ol><li>&#96;&#96;&#96;java<br>public class person{<br>private String name;<br>private int age;<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</span><br><span class="line"></span><br><span class="line">2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class Person&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">      ​</span><br><span class="line">        public int getAge()&#123;</span><br><span class="line">         return age;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public String getName()&#123;</span><br><span class="line">         return name;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public void setAge(int age)&#123;</span><br><span class="line">         this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public void setName(String name)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</li></ol></li></ol><p>一个java封装类的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名: EncapTest.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncapTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String idNum;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getIdNum</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> idNum;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">( <span class="type">int</span> newAge)</span>&#123;</span><br><span class="line">   age = newAge;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span>&#123;</span><br><span class="line">   name = newName;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIdNum</span><span class="params">( String newId)</span>&#123;</span><br><span class="line">   idNum = newId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上实例中public方法是外部类访问该类成员变量的入口。</p><p>通常情况下，这些方法被称为getter和setter方法。</p><p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p><p>通过如下的例子说明EncapTest类的变量怎样被访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* F文件名 : RunEncap.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunEncap</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">   <span class="type">EncapTest</span> <span class="variable">encap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncapTest</span>();</span><br><span class="line">   encap.setName(<span class="string">&quot;James&quot;</span>);</span><br><span class="line">   encap.setAge(<span class="number">20</span>);</span><br><span class="line">   encap.setIdNum(<span class="string">&quot;12343ms&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   System.out.print(<span class="string">&quot;Name : &quot;</span> + encap.getName()+ </span><br><span class="line">               <span class="string">&quot; Age : &quot;</span>+ encap.getAge());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码编译运行结果：</p><blockquote><p>Name : James   Age : 20</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>继承的作用：通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。</p><p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 父类&#123;</span><br><span class="line">    ...       <span class="comment">//成员变量、成员方法</span></span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">    ...       <span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">        Systme.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        s.age = <span class="number">19</span>;</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//学生</span></span><br><span class="line"><span class="comment">//Tom</span></span><br><span class="line"><span class="comment">//19</span></span><br></pre></td></tr></table></figure><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>子类不能选择性继承父类；</li><li>Java不支持多重继承，但一个类可以实现多个接口，从而克服单继承的缺点；</li><li>构造方法不会被子类继承，但可以从子类中调用父类的构造方法</li><li>当子类对象创建好后，与父类创建了查找的关系</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>继承过来的字段和方法，可以像任何其他字段和方法一样被直接使用；</li><li>在子类中可以声明一个与父类中同名的新字段或静态方法，从而“隐藏”父类中的字段或方法；</li><li>可以在子类中声明一个在父类中没有的新字段和方法；</li><li>可以在子类中编写一个父类当中具有相同名的新实例方法，这称为“方法重写”或“方法覆盖”；</li><li>可以在子类中编写一个调用父类构造方法的子类构造方法，既可以隐式地实现，也可以通过使用关键字super来实现。</li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220914114141070.png" alt="image-20220914114141070"></p><h3 id="重写和隐藏父类方法"><a href="#重写和隐藏父类方法" class="headerlink" title="重写和隐藏父类方法"></a>重写和隐藏父类方法</h3><p>子类继承了父类中的所有成员及方法，但在某种情况下，子类中该方法所表示的行为与其父类中该方法所表示的行为不完全相同，例如，在父类语言中定义了说话这个方法，而在子类中说话的方法是不同的：外国人说英文，中国人说中文，这时我们就需要重写或隐藏父类的该方法。</p><h3 id="重写父类中的方法"><a href="#重写父类中的方法" class="headerlink" title="重写父类中的方法"></a>重写父类中的方法</h3><p>当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;                      <span class="comment">//输出英文欢迎</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello,Welcome to Java!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayBye</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;GoodBye,everyone&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;                      <span class="comment">//输出中文欢迎  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;大家好，欢迎学习Java！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">B b=<span class="keyword">new</span> <span class="title class_">B</span>();                                <span class="comment">//创建子类B的一个实例对象，使用默认构造方法</span></span><br><span class="line">b.sayHello();                               <span class="comment">//调用子类中重写的方法</span></span><br><span class="line">b.sayBye();                                 <span class="comment">//调用父类中的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大家好，欢迎学习Java！！！</span></span><br><span class="line"><span class="comment">//GoodBye,everyone</span></span><br></pre></td></tr></table></figure><p>注意：重写的方法具有与其所重写的方法相同的名称、参数数量、类型和返回值。</p><p>隐藏父类中的方法<br>如果一个子类定义了一个静态类方法，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。</p><ul><li><p>当调用被重写的方法时，调用的版本是子类的方法；</p></li><li><p>当调用被隐藏的方法时，调用的版本取决于是从父类中调用还是从子类中调用。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;             <span class="comment">//静态类方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;大家好，这是A的静态类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello2</span><span class="params">()</span> &#123;                   <span class="comment">//实例方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;大家好，这是A中的实例方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;             <span class="comment">//静态类方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;大家好，这是B的静态类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello2</span><span class="params">()</span> &#123;                   <span class="comment">//实例方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;大家好，这是B的实例方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    B b=<span class="keyword">new</span> <span class="title class_">B</span>();                           <span class="comment">//创建B类的实例对象b</span></span><br><span class="line">    A a=b;                                 <span class="comment">//隐式对象类型转换</span></span><br><span class="line">    A.sayHello();                          <span class="comment">//调用A类的静态类方法</span></span><br><span class="line">    a.sayHello();                          <span class="comment">//调用a对象的静态类方法</span></span><br><span class="line">    B.sayHello();                          <span class="comment">//调用B类的静态方法</span></span><br><span class="line">    a.sayHello2();                         <span class="comment">//调用a对象的实例方法</span></span><br><span class="line">    b.sayHello2();                         <span class="comment">//调用b对象的的实例方法</span></span><br><span class="line">    A a2=<span class="keyword">new</span> <span class="title class_">A</span>();                          <span class="comment">//创建A类的实例对象a2</span></span><br><span class="line">    a2.sayHello2();                        <span class="comment">//调用a2对象的实现方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大家好，这是A的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是A的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的实例方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的实例方法</span></span><br><span class="line"><span class="comment">//大家好，这是A中的实例方法</span></span><br></pre></td></tr></table></figure><p>得到调用的隐藏方法是父类中的方法，而得到调用的重写方法是子类中的方法。</p><h3 id="方法重写和隐藏后的修饰符"><a href="#方法重写和隐藏后的修饰符" class="headerlink" title="方法重写和隐藏后的修饰符"></a>方法重写和隐藏后的修饰符</h3><p>在子类中被重写的方法，其访问权限允许大于但不允许小于被其重写的方法，例如：父类中一个受保护的实例方法(protected)在子类中可以是公共的(public)的，但不可以是私有的(private)。如果一个方法在父类中是static方法，那么在子类也必须是static方法；如果一个方法在父类中是实例方法，那么在子类中也必须是实例方法。</p><h3 id="子类访问父类私有成员"><a href="#子类访问父类私有成员" class="headerlink" title="子类访问父类私有成员"></a>子类访问父类私有成员</h3><p>子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。那么如何在子类中访问到父类中的字段呢，我们可以在父类中提供用来访问其私有字段的public或protected方法，子类使用这些方法来访问相应的字段。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;                     <span class="comment">//父类A</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> value=<span class="number">10</span>;    <span class="comment">//声明一个私有变量value并赋值为10</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getvalue</span><span class="params">()</span> &#123;  <span class="comment">//声明一个公有成员方法getvalue，返回value</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;           <span class="comment">//A的子类B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  B b=<span class="keyword">new</span> <span class="title class_">B</span>();           <span class="comment">//创建子类B的一个实例对象</span></span><br><span class="line">  System.out.println(<span class="string">&quot;子类通过父类提供的公共接口访问A中的私有字段value:&quot;</span>+b.getvalue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类通过父类提供的公共接口访问A中的私有字段value:10</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h3><p>多态是面向对象程序设计（OOP）的一个重要特征，指同一个实体同时具有多种形式，即同一个对象，在不同时刻，代表的对象不一样，指的是对象的多种形态。</p><p>可以把不同的子类对象都当作父类来看，进而屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，统一调用标准。</p><p>比如，小猫、小狗、小猪我们可以把他们都归纳成小动物，每种小动物都需要吃东西,所以我们可以统一设置他们都必须吃，但是每种小动物的习性不一样，那这个就可以设置成小动物自己特有的功能,多态对象只能调用父类中定义子类中重写的功能,并不能调用子类的特有功能,这样就实现了代码的统一</p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>通俗点讲，多态就是不同对象对同一物体或事件发出不同的反应或响应。比如stuendt是一个父类，那么在操场上上体育课的学生和在教室里面的学生就是它的子类。这时上课铃声响了，上体育课的学生去操场，在教室里面上课的学生则是回教室，不同的学生有着不同的反应，这就是多态。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>父类类型  引用名 &#x3D; new 子类类型();</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>多态的前提1：是继承</li><li>多态的前提2：要有方法的重写</li><li>父类引用指向子类对象,如：Animal a &#x3D; new Cat();</li><li>多态中，编译看左边，运行看右边</li></ol><h3 id="实现多态的条件"><a href="#实现多态的条件" class="headerlink" title="实现多态的条件"></a>实现多态的条件</h3><p>1.继承：必须要有子类继承父类的继承关系。<br>2.重写：子类需要对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法而不是原本父类的方法。<br>3.向上转型：在多态中需要将父类引用指向子类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220908100824809.png" alt="image-20220908100824809"></p><h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ol><li>多态可以让我们不用关心某个对象到底具体是什么类型,就可以使用该对象的某些方法</li><li>提高了程序的可扩展性和可维护性</li></ol><h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p>前提:多态对象把自己看做是父类类型</p><ol><li>成员变量: 使用的是父类的</li><li>成员方法: 由于存在重写现象,所以使用的是子类的</li><li>属性没有重写之说，属性的值看编译类型</li><li>静态成员: 随着类的加载而加载,谁调用就返回谁的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.oop2;</span><br><span class="line"><span class="comment">/*本类用于测试多态成员的使用情况*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//7.创建纯纯的子类对象</span></span><br><span class="line">        <span class="type">Dog2</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2</span>();</span><br><span class="line">        System.out.println(d.sum);<span class="comment">//20,子类自己的属性</span></span><br><span class="line">        d.eat();<span class="comment">//小狗爱吃肉包子,子类自己的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.创建多态对象</span></span><br><span class="line">        <span class="comment">/*口诀1：父类引用指向子类对象*/</span></span><br><span class="line">        <span class="comment">/*口诀2：编译(保存)看左边，运行(效果)看右边*/</span></span><br><span class="line">        <span class="type">Animal2</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2</span>();</span><br><span class="line">        <span class="comment">/*多态中，成员变量使用的是父类的*/</span></span><br><span class="line">        System.out.println(a.sum);<span class="comment">//10</span></span><br><span class="line">        <span class="comment">/*多态中，方法的声明使用的是父类的，方法体使用的是子类的*/</span></span><br><span class="line">        a.eat();<span class="comment">//小狗爱吃肉包子</span></span><br><span class="line">        <span class="comment">/*多态中，调用的静态方法是父类的，因为多态对象把自己看作是父类类型</span></span><br><span class="line"><span class="comment">        * 直接使用父类中的静态资源*/</span></span><br><span class="line">        a.play();<span class="comment">//没有提示，玩啥都行~</span></span><br><span class="line">        Animal2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal2</span>&#123;</span><br><span class="line">    <span class="comment">//3.创建父类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//4.创建父类的普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃啥都行~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9.1定义父类的静态方法play</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩啥都行~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog2</span> <span class="keyword">extends</span> <span class="title class_">Animal2</span>&#123;</span><br><span class="line">    <span class="comment">//5.定义子类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//6.重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗爱吃肉包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9.2创建子类的静态方法play</span></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">/*这不是一个重写的方法，只是恰巧在两个类中出现了一模一样的两个静态方法</span></span><br><span class="line"><span class="comment">    * 静态方法属于类资源，只有一份，不存在重写的现象</span></span><br><span class="line"><span class="comment">    * 在哪个类里定义，就作为哪个类的资源使用*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗喜欢玩皮球~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h3><p>在JAVA中，继承是一个重要的特征，通过extends关键字，子类可以复用父类的功能，如果父类不能满足当前子类的需求，则子类可以重写父类中的方法来加以扩展。<br>那么在这个过程中就存在着多态的应用。存在着两种转型方式，分别是：向上转型和向下转型。</p><p><strong>向上转型</strong>：可以把不同的子类对象都当作父类来看，进而屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，统一调用标准。<br>比如：父类Parent,子类Child<br>父类的引用指向子类对象：Parent p&#x3D;new Child();<br>说明：向上转型时，子类对象当成父类对象，只能调用父类的功能，如果子类重写了父类中声明过的方法，方法体执行的就是子类重过后的功能。但是此时对象是把自己看做是父类类型的，所以其他资源使用的还是父类型的。<br>比如：花木兰替父从军，大家都把花木兰看做她爸，但是实际从军的是花木兰，而且，花木兰只能做她爸能做的事，在军营里是不可以化妆的。</p><p><strong>向下转型</strong>(较少)：子类的引用的指向子类对象，过程中必须要采取到强制转型。这个是之前向上造型过的子类对象仍然想执行子类的特有功能，所以需要重新恢复成子类对象<br>Parent p &#x3D; new Child();&#x2F;&#x2F;向上转型，此时，p是Parent类型<br>Child c &#x3D; (Child)p;&#x2F;&#x2F;此时，把Parent类型的p转成小类型Child<br>其实，相当于创建了一个子类对象一样，可以用父类的，也可以用自己的<br>说明：向下转型时，是为了方便使用子类的特殊方法，也就是说当子类方法做了功能拓展，就可以直接使用子类功能。<br>比如：花木兰打仗结束，就不需要再看做是她爸了，就可以”对镜贴花黄”了</p><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());<span class="comment">//40</span></span><br><span class="line">        System.out.println(a.sum1());<span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>A a &#x3D; new B();是向上转型，调用方法看运行类型</strong><br><strong>a.sum()和a.sum1()分别输出40和30，这一点毫无疑问</strong></p><h3 id="动态绑定机制-调用对象方法"><a href="#动态绑定机制-调用对象方法" class="headerlink" title="动态绑定机制-调用对象方法"></a>动态绑定机制-调用对象方法</h3><p><strong>如果把上述子类中的sum()注释掉，结果会有什么不同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个时候a.sum()访问子类，发现子类中没有sum方法，再去访问父类，父类中有sum方法，调用的过程中getl()出现了分歧，父类和子类中都有getl()，该调用哪一个？</strong><br><strong>这里就体现出java的动态绑定机制</strong></p><blockquote><p><strong>java的动态绑定机制</strong><br><strong>1.当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</strong><br><strong>2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public int sum1()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>根据案例2中对动态绑定机制的描述，很容易分析出<br>a.sum()和a.sum1()分别输出30和20</strong></p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。而抽象类是指在普通类的结构里面增加抽象方法的组成部分。</p><p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而<strong>抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure><p>而拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。<br>定义一个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: </span></span><br><span class="line"><span class="comment">//Cannot instantiate the type A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//at com.wz.abstractdemo.TestDemo.main(TestDemo.java:15)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上可知，A是抽象的，无法直接进行实例化操作。为什么不能直接实例化呢？当一个类实例化之后，就意味着这个对象可以调用类中的属性或者放过了，但在抽象类里存在抽象方法，而抽象方法没有方法体，没有方法体就无法进行调用。既然无法进行方法调用的话，又怎么去产生实例化对象呢。</p><p>抽象类的使用原则如下：</p><ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；</li><li>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；</li><li>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</li><li>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//B类是抽象类的子类，是一个普通类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;<span class="comment">//强制要求覆写</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line"></span><br><span class="line">a.print();<span class="comment">//被子类所覆写的过的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hello World!</span></span><br></pre></td></tr></table></figure><p>现在就可以清楚的发现：</p><ol><li>抽象类继承子类里面有明确的方法覆写要求，而普通类可以有选择性的来决定是否需要覆写；</li><li>抽象类实际上就比普通类多了一些抽象方法而已，其他组成部分和普通类完全一样；</li><li>普通类对象可以直接实例化，但抽象类的对象必须经过向上转型之后才可以得到。</li></ol><p>虽然一个类的子类可以去继承任意的一个普通类，可是从开发的实际要求来讲，普通类尽量不要去继承另外一个普通类，而是去继承抽象类。</p><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong></p><h3 id="抽象类的使用限制"><a href="#抽象类的使用限制" class="headerlink" title="抽象类的使用限制"></a>抽象类的使用限制</h3><ol><li>抽象类中有构造方法，由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</li><li>抽象类不可以用final声明，因为抽象类必须有子类，而final定义的类不能有子类；</li><li>外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</li><li>可以直接调用抽象类中的static声明的方法，任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</li><li>有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><ol><li>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</li></ol></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><ol><li>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</li></ol></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><ol><li>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设 计。</li></ol></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p><ol><li>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</li></ol></li></ol><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>有如下需求；</p><ul><li>有多个类，完成不同的任务job</li><li>要求统计得到的各自完成任务的时间</li></ul><p>抽象行为类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">time</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        job();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;运行时长为：&quot;</span> + (end - start) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>job_1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( <span class="string">&quot;aa =&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>job_2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( <span class="string">&quot;bb =&quot;</span> + num );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        AA aa = new AA();</span></span><br><span class="line"><span class="comment">//        aa.time();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        BB bb = new BB();</span></span><br><span class="line"><span class="comment">//        bb.time();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Template</span> <span class="variable">t_a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        t_a.time();</span><br><span class="line">        <span class="type">Template</span> <span class="variable">t_b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        t_b.time();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aa =3200040000</span></span><br><span class="line"><span class="comment">//运行时长为：1</span></span><br><span class="line"><span class="comment">//bb =200010000</span></span><br><span class="line"><span class="comment">//运行时长为：1</span></span><br></pre></td></tr></table></figure><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合。接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">class 子类 [extends 父类] [implemetns 接口<span class="number">1</span>,接口<span class="number">2</span>,...] &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果一个类只由抽象方法和全局常量组成，那么这种情况下不会将其定义为一个抽象类。只会定义为一个接口，所以接口严格的来讲属于一个特殊的类，而这个类里面只有抽象方法和全局常量，就连构造方法也没有。</p><p>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p><blockquote><p>解释：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</p></blockquote><p>定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。 </p><ul><li>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。</li><li>一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。</li><li>如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）</li><li>一个JAVA库中接口的例子是：Comparator 接口，这个接口代表了“能够进行比较”这种能力，任何类只要实现了这个Comparator接口的话，这个类也具备了“比较”这种能力，那么就可以用来进行排序操作了。</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>由于接口里面存在抽象方法，所以接口对象不能直接使用关键字new进行实例化。接口的使用原则如下：</p><ol><li>接口必须要有子类，但此时一个子类可以使用implements关键字实现多个接口；</li><li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li><li>接口的对象可以利用子类对象的向上转型进行实例化。</li></ol><h3 id="实际应用（标准定义）"><a href="#实际应用（标准定义）" class="headerlink" title="实际应用（标准定义）"></a>实际应用（标准定义）</h3><p>在日常的生活之中，接口这一名词经常听到的，例如：USB接口、打印接口、充电接口等等。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20161006002203942" alt="interface"></p><p>如果要进行开发，要先开发出USB接口标准，然后设备厂商才可以设计出USB设备。</p><p>现在假设每一个USB设备只有两个功能：安装驱动程序、工作。<br>定义一个USB的标准：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;   <span class="comment">// 操作标准       </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在电脑上应用此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">plugin</span><span class="params">(USB usb)</span> &#123;</span><br><span class="line">          usb.install() ;</span><br><span class="line">          usb.work() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义USB设备—手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装手机驱动程序。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;手机与电脑进行工作。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义USB设备—打印机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装打印机驱动程序。&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;进行文件打印。&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试主类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>() ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> <span class="title class_">Phone</span>()) ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装手机驱动程序。</span></span><br><span class="line"><span class="comment">//手机与电脑进行工作。</span></span><br><span class="line"><span class="comment">//安装打印机驱动程序。</span></span><br><span class="line"><span class="comment">//进行文件打印。</span></span><br></pre></td></tr></table></figure><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol><li><p>接口不能被实例化</p></li><li><p>接口中所有的方法师public方法，接口中抽象方法，可以不用abstract修饰</p></li><li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p></li><li><p>抽象类实现接口，可以不用实现接口的方法</p></li><li><p>一个类可以实现多个接口</p></li><li><p>接口中的属性，只能是final的，而且是public static final修饰符，比如：</p><ol><li>&#96;&#96;&#96;java<br>int a &#x3D; 1;<br>&#x2F;&#x2F;实际上为<br>public static final int a &#x3D; 1;&#x2F;&#x2F;在接口中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 接口中属性的访问形式，接口名.属性名</span><br><span class="line"></span><br><span class="line">8. 一个接口不能继承其他的类，但是可以继承多个别的接口</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      interface A extends B,C&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>接口的修饰符只能是public和默认，这点和类的修饰符相同</p></li></ol><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>代码块又称为初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p><p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[修饰符]&#123;</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//普通代码块</span></span><br><span class="line">&#123; </span><br><span class="line">  ...普通代码块</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><p>也叫：实例代码块<br>定义在类中的代码块(不加修饰符)<br><strong>构造代码块一般用于初始化实例成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">//构造代码块</span></span><br><span class="line">        name = <span class="string">&quot;花花&quot;</span>;</span><br><span class="line">        sex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造代码块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行</p><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>用 <a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>{ } 包裹起来的代码片段<br>只会执行一次，静态代码块优先于构造代码块执行，<strong>一般用于初始化静态成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">    money = <span class="number">100</span>;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是静态代码块！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919172541150.png" alt="image-20220919172541150"></p><p><strong>静态代码块在类加载时只执行一次</strong></p><p>在类加载阶段执行，在编译阶段时，编译器会将多个静态代码块按照定义的先后次序依次合并，最终放在生成的方法中</p><p>总结：</p><ul><li>静态代码块不管生成多少个对象，其只会执行一次</li><li>静态成员变量是类的属性，因此是在JVM加载类时开辟空间并初始化的</li><li>Java代码在经过编译器编译之后，如果要运行必须先要经过类加载子系统加载到JVM中才能运行</li><li>如果一个类中包含多个静态代码块，在编译代码时，编译器会按照定义的先后次序依次合并，最终放在生成的&lt;&gt;方法中，该方法在类加载时调用，并且只调用一次</li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>使用synchronized（）{}包裹起来的代码块，在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中</p><h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol><li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且他随着类的加载而执行，并且只会执行一次，如果时普通代码块，没创建一个对象，就执行一次</p></li><li><p>什么时候被加载</p><ol><li>普通代码块，创建对象实例时（new）创建一次，调用一次</li><li>创建子类对象实例，父类也会被加载（父类先被加载，子类后被加载）</li><li>使用类的静态成员时（静态属性，静态方法）</li></ol></li><li><p>普通的代码块，在创建对象实例时，会被隐式的调用，被创建一次就会调用一次，如果只是使用类的静态成员，普通代码块不会被执行</p></li><li><p>创建一个对象时，在一个类中的调用顺序：</p><ol><li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级语音，如果有多个静态代码块，和多个静态变量初始化，则按定义的顺序调用）</li><li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级语音，如果有多个普通代码块，和多个普通变量初始化，则按定义的顺序调用）</li><li>调用构造方法</li></ol></li><li><p>构造方法（构造器）的最前面隐含了super()和调用普通代码块。静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此时优先于构造器和普通代码块执行的</p></li><li><p>创建一个子列对象时（继承关系），静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法懂得调用顺序如下：</p><ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>子类的构造方法</li></ol></li><li><p>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p></li></ol><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p>可以将一个类的定义放在里另一个类的内部，这就是内部类。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*我是一个外部类（外部是相对内部而言）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*我是一个内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><blockquote><p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》</p></blockquote><p>也就是说内部类拥有类的基本特征。(eg：可以继承父类，实现接口。)在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。（注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，这里不推荐使用。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. Outer类继承了ClassA，实现了IFunctionA</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> <span class="keyword">extends</span> <span class="title class_">ClassA</span> <span class="keyword">implements</span> <span class="title class_">IFunctionA</span>&#123; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Inner类继承了ClassB，实现了IFunctionB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> <span class="keyword">extends</span> <span class="title class_">ClassB</span> <span class="keyword">implements</span> <span class="title class_">IfunctionB</span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li><li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li><li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li></ol><p>具体来说，内部类信息（属性、方法）可以和外部类重名；内部类是具有类的基本特征的独立实体；可以利用访问修饰符隐藏内部类的实施细节，提供了更好的封装；静态内部类使用时可直接使用，不需先创造外部类。</p><h3 id="局部（方法）内部类"><a href="#局部（方法）内部类" class="headerlink" title="局部（方法）内部类"></a>局部（方法）内部类</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterType</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/** 局部内部类Inner*/</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol><li>局部内部类类似方法的局部变量，所以在类外或者类的其他方法中不能访问这个内部类，但这并不代表局部内部类的实例和定义了它的方法中的局部变量具有相同的生命周期。</li><li>只能在方法内部，类（局部内部类）定义之后使用，不存在外部可见性问题，因此没有访问修饰符，但是可以使用final 或 abstract修饰。</li><li>不能在局部内部类中使用可变的局部变量</li><li>可以访问外围类的成员变量。如果是static方法，则只能访问static修饰的成员变量</li><li>作用域：仅仅在定义他的方法或代码块中</li><li>如果外部类和局部内部类的成员重名，默认遵循就近原则，如果访问外部类的成员，使用  外部类名.this.成员 去访问</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote><p><strong>一个接口&#x2F;类的</strong>方法的<strong>某个实现方式</strong>在程序中<strong>只会执行一次</strong>，但为了使用它，我们需要创建它的实现类&#x2F;<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>去实现&#x2F;重写。此时可以使用匿名内部类的方式，可以无需创建新的类，<strong>减少代码冗余</strong></p></blockquote><p>假设当前有一个接口，接口中只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用该接口的show方法，我们需要去创建一个实现类，同时书写show方法的具体实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01Impl</span> <span class="keyword">implements</span> <span class="title class_">Interface01</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a impl class...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实现类Interface01Impl全程只使用一次，那么为了这一次的使用去创建一个类，未免太过麻烦。我们需要一个方式来帮助我们摆脱这个困境。匿名内部类则可以很好的解决这个问题。</p><p>我们使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Interface01</span> <span class="variable">interface01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interface01</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里使用了匿名内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//调用接口方法</span></span><br><span class="line">    interface01.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了匿名内部类</span></span><br></pre></td></tr></table></figure><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 接口/类名(参数<span class="number">1</span>, 参数<span class="number">2.</span>..)&#123;</span><br><span class="line">    实现方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    实现方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在上文代码编译后，我们查看一下class文件的路径</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/BxrQZd.png" alt="BxrQZd.png"></p><p>再反编译一下看看</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/BxsW1f.png" alt="BxsW1f.png"></p><p>至此，我们可以得知，匿名内部类在编译期间，会生成一个名称以<code>$编号</code>结尾的class文件，即<strong>它被识别为一个真实的类</strong>，仅在编译前（java文件）为匿名的形态。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>设存在具体类Class01，抽象类AbstractClass01，接口Interface01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啦啦啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass01</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类TestInner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重写具体类的方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;具体类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写抽象类的抽象方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClass01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;抽象类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现接口的抽象方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Interface01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;接口&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是一个具体类</span></span><br><span class="line"><span class="comment">//我是一个抽象类</span></span><br><span class="line"><span class="comment">//我是一个接口</span></span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><strong>成员内部类</strong> ：定义在<strong>外部类中方法外</strong>的类</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类名 [extends 外部类的父类] [implements 外部类的父接口们] &#123;</span><br><span class="line">    [修饰符] class 内部类名 [extends 非静态内部类自己的父类] [implements 非静态内部类的父接口们] &#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部类的其他成员列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://so.csdn.net/so/search?q=%E5%A4%96%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">外部类</a>、内部类的父类、父接口没有关系，各是各的</p></blockquote><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul><li>成员内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和符 号 。 例 如 ： O u t e r 符号。例如：Outer符号。例如：OuterInner.class</li><li>成员内部类可以使用修饰符public，protected，缺省，private</li><li>成员内部类还可以使用final或abstract修饰</li><li>成员内部类中不可以声明静态成员</li><li>成员内部类可以直接使用外部类的所有成员，包括私有的。如果成员内部类有与外部类的非静态属性重名时，可以通过“外部类名.this.属性”进行区别，如果与外部类的静态属性重名时，可以通过“外部类名.类变量”进行区别</li><li>外部类要访问内部类的成员，必须要建立内部类的对象</li></ul><h4 id="使用成员内部类"><a href="#使用成员内部类" class="headerlink" title="使用成员内部类"></a>使用成员内部类</h4><ul><li><p>在外部类中使用成员内部类</p><ul><li>在外部类的静态成员中不能使用非静态的成员内部类</li><li>在外部类的非静态成员中，直接创建内部类的对象来访问内部类的属性与方法。此时把它当做一个普通的类即可</li></ul></li><li><p>在外部类的外面使用成员内部类：</p><ul><li><p>要么通过外部类的对象，去创建内部类的对象</p></li><li><p>&#96;&#96;&#96;java<br>外部类名 外部对象名 &#x3D; new 外部类型();<br>内部类名 对象名 &#x3D; 外部对象名.new 外部类型();<br>&#x2F;&#x2F;可合并为：<br>外部类名.内部类名 对象名 &#x3D; new 外部类型().new 内部类型();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 要么通过外部类的对象，去获取内部类的对象</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Outer out = new Outer();</span><br><span class="line">  Outer.Inner in  = out.getInner();</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outerMethod();</span><br><span class="line"><span class="comment">//通过外部类的对象，去创建内部类的对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        oi.innerMethod();</span><br><span class="line"><span class="comment">//通过外部类的对象，去获取内部类的对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">obj</span> <span class="operator">=</span> out.getInner();</span><br><span class="line">        obj.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*Inner in = new Inner();//错误，静态成员中不能使用非静态成员内部类</span></span><br><span class="line"><span class="comment">in.innerMethod();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的方法&quot;</span>);</span><br><span class="line"><span class="comment">/*Inner in = new Inner();//可以</span></span><br><span class="line"><span class="comment">in.innerMethod();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法访问外部类的私有非静态属性：&quot;</span>+Outer.<span class="built_in">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法访问外部类的私有静态属性：&quot;</span>+Outer.b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过外部类的某个方法返回内部类的对象</span></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有非静态属性：1</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有静态属性：2</span></span><br><span class="line"><span class="comment">//内部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有非静态属性：1</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有静态属性：2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义在<strong>外部类中方法外</strong>，使用 <code>static</code> 修饰的类</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类名 [extends 外部类的父类] [implements 外部类的父接口们] &#123;</span><br><span class="line">[修饰符] <span class="keyword">static</span> class 内部类名 [extends 静态内部类自己的父类] [implements 静态内部类的父接口们] &#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 外部类的其他成员列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul><li>静态内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和符 号 。 例 如 ： O u t e r 符号。例如：Outer符号。例如：OuterInner.clas</li><li>静态内部类可以使用修饰符public，protected，default，private</li><li>静态内部类还可以使用final或abstract修饰</li><li>静态内部类中可以声明静态成员</li><li>静态内部类可以直接使用外部类的静态成员，包括私有的。但不能使用外部类的非静态成员。</li><li>静态内部类中有与外部类的静态属性重名时，如果要使用外部类的属性，那么用“外部类名.属性”</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ul><li>在外部类中使用静态内部类：就和使用其他普通类一样</li><li>在外部类的外面使用成员内部类：<ul><li>使用静态内部类的静态成员：外部类名.静态内部类名.静态内部类的静态成员</li><li>使用静态内部类的非静态成员：外部类名.静态内部类名 obj &#x3D; new 外部类名.静态内部类名(); obj.静态内部类的非静态成员</li></ul></li></ul><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.StaticInnerClass.innerStaticMethod();</span><br><span class="line">        Outer.<span class="type">StaticInnerClass</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInnerClass();</span><br><span class="line">        os.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        StaticInnerClass.innerStaticMethod();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        StaticInnerClass.innerStaticMethod();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">innerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的非静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><blockquote><p><a href="http://www.java265.com/JavaCourse/202109/1153.html">一篇文章让你彻底理解Java的单例设计模式 (java265.com)</a></p></blockquote><p>   <strong>单例（<a href="https://so.csdn.net/so/search?q=Singleton&spm=1001.2101.3001.7020">Singleton</a>）模式的定义</strong>：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>   在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p><p>   单例模式有 3 个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ol><h3 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h3><p>   单例模式是<a href="http://c.biancheng.net/design_pattern/">设计模式</a>中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><p>   下面来分析其基本结构和实现方法。</p><h4 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h4><p>   单例模式的主要角色如下。</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><p>   <img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c7c2f601aebbe257b1036cb74b93d339.gif" alt="img"></p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="(饿汉式)"></a>(饿汉式)</h4><p>   该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="(懒汉式)"></a>(懒汉式)</h4><p>   该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p><h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/2022/05/15/JavaSE/"/>
      <url>/2022/05/15/JavaSE/</url>
      
        <content type="html"><![CDATA[<h2 id="编译型、解释型"><a href="#编译型、解释型" class="headerlink" title="编译型、解释型"></a>编译型、解释型</h2><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>​            使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>​            在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>现有的C、C++、Objective等都属于编译型语言。</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/70-164708429946416-164708454272221.png"></p><h3 id="解释性语言"><a href="#解释性语言" class="headerlink" title="解释性语言"></a>解释性语言</h3><p>​            使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>​            解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>Python等属于解释型语言</li></ol><p><img src="https://img-blog.csdn.net/20180802084124396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxODQ1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><hr><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。</p><p>​        JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</p><p>  　　JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac&#x2F;java&#x2F;jdb等）和Java基础的类库（即Java API 包括rt.jar）</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​        JRE是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。</p><p>​        JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。</p><p>  　　与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​        jvm就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><p>​        也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机（相当于中间层）间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><p>  　　只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p><p>  　　JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p><h3 id="三者之间关系"><a href="#三者之间关系" class="headerlink" title="三者之间关系"></a>三者之间关系</h3><p> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/jdkjeejvm.png">)</p><h3 id="JAVA应用程序的运行机制"><a href="#JAVA应用程序的运行机制" class="headerlink" title="JAVA应用程序的运行机制"></a>JAVA应用程序的运行机制</h3><p><img src="https://img-blog.csdnimg.cn/20190401111217837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xnbDc4MjUxOTE5Nw==,size_16,color_FFFFFF,t_70"></p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</p><h3 id="八大基本类型（primitiv-type）"><a href="#八大基本类型（primitiv-type）" class="headerlink" title="八大基本类型（primitiv  type）"></a>八大基本类型（primitiv  type）</h3><p>​        基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p><h4 id="Java的基本类型及其封装器类"><a href="#Java的基本类型及其封装器类" class="headerlink" title="Java的基本类型及其封装器类"></a>Java的基本类型及其封装器类</h4><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下：</p><ul><li>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之</li><li>short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。</li><li>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</li><li>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</li><li>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</li><li>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</li><li>boolean：只有true和false两个取值。</li><li>char：16位，存储Unicode码，用单引号赋值。</li></ul><p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。</p><table><thead><tr><th>简单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th><th>void</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td><td>–</td></tr><tr><td>封装器类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Void</td></tr></tbody></table><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p><p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p><p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p><p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p><p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p><p>注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。</p><p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p><p>基本类型的优势：数据存储相对简单，运算效率比较高</p><p>包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="自动类型转换-隐式类型转换"><a href="#自动类型转换-隐式类型转换" class="headerlink" title="自动类型转换(隐式类型转换)"></a>自动类型转换(隐式类型转换)</h4><p>整型、实型(常量)、字符型数据可以混合运算。不同类型的数据先转化为同类型再进行运算</p><p>自动转换按从低级到高级顺序:</p><pre><code>      char       ↓       Byte→short→int→long---›float→double</code></pre><p>自动转换有以下规律：</p><p>小的类型自动转化为大的类型</p><p>整数类型可以自动转化为浮点类型，可能会产生舍入误差</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ol><li>强制类型转换 将 取值范围大的类型 强制转换成 取值范围小的类型</li><li>特点 : 代码需要进行特殊的格式处理, 不能自动完成</li><li>转换格式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span><br><span class="line">int i = (int) 1.7; // 强制转化后 i--&gt; 1</span><br></pre></td></tr></table></figure><ol start="4"><li>代码展示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntLongDoubleChange</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(getType(((<span class="type">int</span>) <span class="number">100L</span>)));  <span class="comment">// Long ---&gt; int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">100L</span>; <span class="comment">// 100L是长整型</span></span><br><span class="line">        System.out.println(getType((<span class="type">short</span>) i));  <span class="comment">//  int ---&gt; short</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object a)</span> &#123;  <span class="comment">// 获取这些数据的数据类型</span></span><br><span class="line">        <span class="keyword">return</span> a.getClass().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意事项； </p><ol><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>再把高容量转换到低容量的时候，强制转换</li><li>转换的时候可能存在内存溢出，或者精度问题</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型分为：数组，类，接口，字符串。</p><blockquote><p>数组：其实就是一个容器，存储同一种数据类型的集合；如 int[] a &#x3D; {1,2,3,4}</p><p>类：对象是对事物的抽象，而类是对对象的抽象和归纳；如 public class Person{ ……}</p><p>接口：使用interface来定义一个接口，只能定义方法，不能有方法的实现；如public interface personImpl{……}</p><p>字符串：是存放数据区（静态区）以Unicode编码的字符集合，如 String a&#x3D;”你好”</p></blockquote><p>基本类型与引用类型的区别：</p><p>（1）基本数据类型传值，对形参的修改不会影响实参；<br>（2）引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；<br>（3）String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</p><hr><h2 id="什么是标识符？"><a href="#什么是标识符？" class="headerlink" title="什么是标识符？"></a>什么是标识符？</h2><p>  凡是可以由自己命名的地方都称为标识符。<br>  例如，对于常量、变量、函数、语句块、类、项目等都需要一个名字，这些我们都统统称为标识符。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>标识符有字母、数字、_(下划线)、$所组成，其中不能以数字开头，不能用Java中的保留字（关键字）</li><li>标识符采用有意义的简单命名</li><li>“$”不要在代码中出现。（是由于在后面内部类中，编译后会出现$符号）</li></ol><ul><li>类名和接口名：每个单词的首字母，其余为小写。（大驼峰）</li><li>方法名：第二个单词起的首字母为大写，其余全为小写。（小驼峰）</li><li>常量名：基本数据类型的常量名使用全部大写字母，字与字之间用下划线分隔。</li></ul><hr><h2 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java关键字是<a href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91%E8%AF%AD%E8%A8%80">电脑语言</a>里事先定义的，有特别意义的<a href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&spm=1001.2101.3001.7020">标识符</a>，有时又叫<a href="https://baike.baidu.com/item/%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><table><thead><tr><th><a href="https://baike.baidu.com/item/abstract">abstract</a></th><th><a href="https://baike.baidu.com/item/assert"> assert</a></th><th><a href="https://baike.baidu.com/item/boolean"> boolean</a></th><th>break</th><th><a href="https://baike.baidu.com/item/byte"> byte</a></th></tr></thead><tbody><tr><td>case</td><td><a href="https://baike.baidu.com/item/catch">catch</a></td><td><a href="https://baike.baidu.com/item/char">char</a></td><td><a href="https://baike.baidu.com/item/class">class</a></td><td>const</td></tr><tr><td>continue</td><td><a href="https://baike.baidu.com/item/default">default</a></td><td><a href="https://baike.baidu.com/item/do">do</a></td><td><a href="https://baike.baidu.com/item/double">double</a></td><td><a href="https://baike.baidu.com/item/else">else</a></td></tr><tr><td><a href="https://baike.baidu.com/item/enum">enum</a></td><td><a href="https://baike.baidu.com/item/extends">extends</a></td><td><a href="https://baike.baidu.com/item/final">final</a></td><td><a href="https://baike.baidu.com/item/finally">finally</a></td><td>float</td></tr><tr><td><a href="https://baike.baidu.com/item/for">for</a></td><td>goto</td><td><a href="https://baike.baidu.com/item/if">if</a></td><td><a href="https://baike.baidu.com/item/implements">implements</a></td><td><a href="https://baike.baidu.com/item/import">import</a></td></tr><tr><td><a href="https://baike.baidu.com/item/instanceof">instanceof</a></td><td><a href="https://baike.baidu.com/item/int">int</a></td><td><a href="https://baike.baidu.com/item/interface">interface</a></td><td>long</td><td>native</td></tr><tr><td>new</td><td><a href="https://baike.baidu.com/item/package">package</a></td><td><a href="https://baike.baidu.com/item/private">private</a></td><td><a href="https://baike.baidu.com/item/protected">protected</a></td><td><a href="https://baike.baidu.com/item/public">public</a></td></tr><tr><td><a href="https://baike.baidu.com/item/return">return</a></td><td><a href="https://baike.baidu.com/item/strictfp">strictfp</a></td><td><a href="https://baike.baidu.com/item/short">short</a></td><td><a href="https://baike.baidu.com/item/static">static</a></td><td><a href="https://baike.baidu.com/item/super">super</a></td></tr><tr><td><a href="https://baike.baidu.com/item/switch">switch</a></td><td><a href="https://baike.baidu.com/item/synchronized">synchronized</a></td><td><a href="https://baike.baidu.com/item/this">this</a></td><td><a href="https://baike.baidu.com/item/throw">throw</a></td><td><a href="https://baike.baidu.com/item/throws">throws</a></td></tr><tr><td><a href="https://baike.baidu.com/item/transient">transient</a></td><td>try</td><td><a href="https://baike.baidu.com/item/void">void</a></td><td><a href="https://baike.baidu.com/item/volatile">volatile</a></td><td><a href="https://baike.baidu.com/item/while">while</a></td></tr><tr><td>true</td><td>false</td><td>null</td><td></td><td></td></tr></tbody></table><p>　另外，Java还有3个保留字:true、false、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样,它们也不可以作为标识符使用。参考<a href="https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_43">https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_43</a></p><h3 id="定义类、接口、抽象类"><a href="#定义类、接口、抽象类" class="headerlink" title="定义类、接口、抽象类"></a>定义类、接口、抽象类</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>class</td><td>声明一个类</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr></tbody></table><h3 id="用于建立类与类之间关系"><a href="#用于建立类与类之间关系" class="headerlink" title="用于建立类与类之间关系"></a>用于建立类与类之间关系</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>implements</td><td>表明一个类实现了给定的接口类</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型，常见的类型有类和接口</td></tr></tbody></table><h3 id="用于定义访问权限修饰符"><a href="#用于定义访问权限修饰符" class="headerlink" title="用于定义访问权限修饰符"></a>用于定义访问权限修饰符</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>private</td><td>私有权限，修饰的属性和方法仅供本类引用</td></tr><tr><td>protected</td><td>保护权限，保护子类，当前包内和继承的子类中可以引用</td></tr><tr><td>default</td><td>默认模式，不写任何访问修饰权限，本包内可以使用</td></tr><tr><td>public</td><td>公用模式，可跨包使用，凡是环境下的类和方法都可以使用，需导入包</td></tr></tbody></table><h3 id="用于定义建立实例及引用实例、判断实例"><a href="#用于定义建立实例及引用实例、判断实例" class="headerlink" title="用于定义建立实例及引用实例、判断实例"></a>用于定义建立实例及引用实例、判断实例</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>用来创建新的实例对象</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr></tbody></table><h3 id="用于定义类、函数、变量修饰符"><a href="#用于定义类、函数、变量修饰符" class="headerlink" title="用于定义类、函数、变量修饰符"></a>用于定义类、函数、变量修饰符</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>final</td><td>终结器，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td></tr><tr><td>static</td><td>表示具有静态属性</td></tr><tr><td>synchronized</td><td>线程同步，修饰一段代码表示多个线程都能同步执行</td></tr><tr><td>volatile</td><td>意识，表明两个或者多个变量必须同步地发生变化</td></tr><tr><td>native</td><td>本地用来声明一个方法是由计算机相关语言实现的(如C&#x2F;C++语言等)</td></tr></tbody></table><h3 id="用于异常处理"><a href="#用于异常处理" class="headerlink" title="用于异常处理"></a>用于异常处理</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>finally</td><td>用于异常处理情况，用来声明一个基本肯定会被执行到的语句块（有没有异常都执行）</td></tr><tr><td>throw</td><td>通常用在方法体中，并且抛出一个异常对象，程序在执行到throw语句时立即停止，它后面的语句都不执行</td></tr><tr><td>throws</td><td>如果一个方法可以引发异常，本身不对异常进行处理，将异常抛给调用者使程序可以继续执行下去</td></tr></tbody></table><h3 id="用于包的关键字"><a href="#用于包的关键字" class="headerlink" title="用于包的关键字"></a>用于包的关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>import</td><td>导入这个类所存在的包</td></tr><tr><td>package</td><td>定义包的关键字，将有关类放在一个包中</td></tr></tbody></table><h3 id="其他修饰符关键字"><a href="#其他修饰符关键字" class="headerlink" title="其他修饰符关键字"></a>其他修饰符关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>assert</td><td>断言，用来进行程序调试</td></tr></tbody></table><hr><h2 id="变量、常量"><a href="#变量、常量" class="headerlink" title="变量、常量"></a>变量、常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>变量</strong>是可以变化的量<br><strong>java</strong>是一种强类型语言，每个变量都必须声明其类型。<br><strong>java</strong>变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><h4 id="变量可分为：成员变量、局部变量、静态变量"><a href="#变量可分为：成员变量、局部变量、静态变量" class="headerlink" title="变量可分为：成员变量、局部变量、静态变量"></a>变量可分为：成员变量、局部变量、静态变量</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>在某个方法外部，类内部定义的变量，从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型默认的初始值。部分变量的默认初始值如下表所示</p><table><thead><tr><th>数据类型</th><th>初始值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVariable</span>&#123;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//成员变量，会自动初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">TestVariable</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestVariable</span>();</span><br><span class="line">        System.out.println(test.a);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量是方法或语句块内部定义的变量，其<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>是从声明位置开始到方法或语句块执行完毕为止。局部变量在使用前必须先声明并初始化（赋值），否则会出错。<br>局部变量的初始化有两种方式，一种是先定义再初始化，代码中方式一所示，另外一种是定义的同时进行初始化，如方式二所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">age=<span class="number">18</span>;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">int</span> weight=<span class="number">50</span>;</span><br><span class="line"><span class="comment">//错误赋值示例！！！注意这样写是错误的，不要模仿！！！！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">height</span>&#123;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line">height=<span class="number">180</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量使用static定义，从属于类，声明周期伴随类始终，从类加载时产生，类卸载时结束。如果不进行初始化，与成员变量一样，会自行初始化成该类型的默认初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> a;<span class="comment">//静态变量，会自动初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>每个变量都有类型，类型可以是基本类型，也可以是引用类型。<br>变量名必须是合法的标识符。<br>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span>&#123;     </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">       <span class="comment">// int a,b,c;</span></span><br><span class="line">       <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">       String name=<span class="string">&quot;ZDJ&quot;</span>;</span><br><span class="line">       <span class="type">char</span> x=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">       <span class="type">double</span> pi=<span class="number">3.14</span>;     </span><br><span class="line">       <span class="comment">//定义变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h4><p><a href="https://www.bilibili.com/video/BV12J41137hu?p=26">狂神说java</a></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/b743599935054ed5b26cf550604d5cb6.png" alt="在这里插入图片描述"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>常量定义：在程序执行的过程中，其值不可以发生改变的量。常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义。</li><li>常量值定义：常量和常量值是不同的概念，常量值又称为字面常量，它是通过数据直接表示的。</li><li>关系：常量值是常量的具体和直观的表现形式，常量是形式化的表现。通常在程序中既可以直接使用常量值，也可以使用常量。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>字符串常量 用双引号括起来的内容(“HelloWorld”)</li><li>整数常量 所有整数(12,-23)</li><li>小数常量 所有小数(12.34)</li><li>字符常量 用单引号括起来的内容(‘a’,’A’,’0’)</li><li>布尔常量 较为特有，只有true和false</li><li>空常量 null</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>Java 语言使用 final 关键字来定义一个常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> COUNT=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> HEIGHT=<span class="number">10.2F</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>在定义常量时就需要对该常量进行初始化。</li><li>final 关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</li><li>为了与变量区别，常量取名一般都用大写字符。</li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>求和</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>乘积</td></tr><tr><td>&#x2F;</td><td>商</td></tr><tr><td>%</td><td>求余数（求模）</td></tr><tr><td>++</td><td>自加一</td></tr><tr><td>–</td><td>自减一</td></tr></tbody></table><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="++运算符"></a>++运算符</h4><ul><li>++在变量前</li><li>当++出现在变量前，会先自加一，在做赋值运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ++x;</span><br><span class="line">步骤： ② ①</span><br><span class="line">System.out.println(x); <span class="comment">// 101</span></span><br><span class="line">System.out.println(y); <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><ul><li>++在变量后</li><li>当++出现在变量后，会先做赋值运算，再自加1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m++;</span><br><span class="line">步骤： ① ②</span><br><span class="line">System.out.println(n); <span class="comment">// 20</span></span><br><span class="line">System.out.println(m); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><ul><li>特别地，在print中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">System.out.println(c++);  <span class="comment">// 传，这个“传”在这里有一个隐形的赋值运算。90</span></span><br><span class="line"><span class="comment">// 把上面代码拆解开</span></span><br><span class="line"><span class="comment">//int temp = c++;</span></span><br><span class="line"><span class="comment">//System.out.println(temp);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">System.out.println(++d); <span class="comment">//81</span></span><br><span class="line"><span class="comment">// 拆解</span></span><br><span class="line"><span class="comment">//int temp2 = ++d;</span></span><br><span class="line"><span class="comment">//System.out.println(temp2);</span></span><br></pre></td></tr></table></figure><h4 id="–运算符（例子同-运算符）"><a href="#–运算符（例子同-运算符）" class="headerlink" title="–运算符（例子同++运算符）"></a>–运算符（例子同++运算符）</h4><ul><li><p>–在变量前</p><ul><li><strong>当–出现在变量前，会先自减一，在做赋值运算</strong></li></ul></li><li><p>–在变量后</p><ul><li><strong>当–出现在变量后，会先做赋值运算，再自减1</strong></li></ul></li></ul><blockquote><p>注意:<br>对于++运算符来说：<br>  1.可以出现在变量前，也可以出现在变量后。<br>  2.不管出现在变量前还是后，总之++执行结束之后，变量的值一定会自加1。</p></blockquote><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr></tbody></table><blockquote><p><em><strong>注意</strong></em>：所有的关系运算符的运算结果都是布尔类型，不是true就是false，不可能是其他值。</p></blockquote><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>＆</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr><tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr><tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr><tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td></tr><tr><td>+&#x3D;</td><td>加等（原先的基础上加上&#x2F;追加这个数）</td></tr><tr><td>-&#x3D;</td><td>减等（同理）</td></tr><tr><td>*&#x3D;</td><td>乘等（同理）</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等（同理）</td></tr><tr><td>%&#x3D;</td><td>模等（同理）</td></tr></tbody></table><blockquote><p>注：除了第一个是赋值运算符，其他都死拓展赋值运算符！！</p></blockquote><h4 id="很重要的语法机制："><a href="#很重要的语法机制：" class="headerlink" title="很重要的语法机制："></a>很重要的语法机制：</h4><p>使用扩展赋值运算符的时候，永远都不会改变运算结果类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">m += <span class="number">10</span>; 类似于 m = m + <span class="number">10</span>;-------&gt;注意是类似！！！！</span><br><span class="line"></span><br><span class="line">实际不同：</span><br><span class="line">i = i + <span class="number">10</span>; 和 i += <span class="number">10</span>;一样吗？</span><br><span class="line"><span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">i += <span class="number">10</span>;-----&gt;没报错</span><br><span class="line">其实 x += <span class="number">1</span> 等同于：x = (<span class="type">byte</span>)(x + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">i = i + <span class="number">10</span>;----&gt;错误: 不兼容的类型: 从<span class="type">int</span>转换到<span class="type">byte</span>可能会有损失</span><br><span class="line">编译器检测到x + <span class="number">1</span>是<span class="type">int</span>类型，<span class="type">int</span>类型不可以直接赋值给<span class="type">byte</span>类型的变量x！</span><br><span class="line">详见Java类型转换的时候需要遵循的规则第六点</span><br><span class="line"></span><br><span class="line">i += <span class="number">190</span>; <span class="comment">// i = (byte)(i + 190);</span></span><br><span class="line">System.out.println(i); <span class="comment">// 44 （当然会自动损失精度了。）</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>含义</th><th>结果</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与（可以翻译成并且）</td><td>两边都是true，结果才是true</td></tr><tr><td>│</td><td>逻辑或（可以翻译成或者）</td><td>有一边是true，结果就是true</td></tr><tr><td>!</td><td>逻辑非（取反）</td><td>!true &#x3D; false、!false &#x3D; true</td></tr><tr><td>&amp;&amp;</td><td>短路与</td><td>两边都是true，结果才是true</td></tr><tr><td>││</td><td>短路或</td><td>有一边是true，结果就是true</td></tr></tbody></table><h4 id="短路与-amp-amp"><a href="#短路与-amp-amp" class="headerlink" title="短路与 &amp;&amp;"></a>短路与 &amp;&amp;</h4><ul><li>短路与&amp;&amp; 和 逻辑与 &amp;有什么区别？<ul><li>首先这两个运算符的运算结果没有任何区别，完全相同。</li><li>只不过“短路与&amp;&amp;”会发生短路现象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">System.out.println(x &gt; y &amp; x &gt; y++); <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路与&amp;&amp;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路与&amp;&amp;的时候，当左边的表达式为false的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &gt; n &amp;&amp; m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><ul><li><p>什么是短路现象呢？</p><ul><li>右边表达式不执行，这种现象叫做短路现象。</li></ul></li><li><p>什么时候使用&amp;&amp;，什么时候使用&amp; ？</p><ul><li>从效率方面来说，&amp;&amp;比&amp;的效率高一些。</li><li>因为逻辑与&amp;不管第一个表达式结果是什么，第二个表达式一定会执行。</li></ul></li></ul><p>以后的开发中，短路与&amp;&amp;和逻辑与还是需要同时并存的。<br>大部分情况下都建议使用短路与&amp;&amp;只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&amp;。</p><h4 id="短路或"><a href="#短路或" class="headerlink" title="短路或 ||"></a>短路或 ||</h4><h4 id="跟短路与类似"><a href="#跟短路与类似" class="headerlink" title="跟短路与类似"></a>跟短路与类似</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">System.out.println(x &lt; y | x &gt; y++); <span class="comment">//teur</span></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路或||</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路或||的时候，当左边的表达式为true的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &lt; n || m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>使用短路与 &amp;&amp; 的时候，当左边的表达式为false的时候，右边的表达式不执行    </li><li>使用短路或 || 的时候当左边的表达式结果是true的时候，右边的表达式不执行</li><li>注意：逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。</li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><h4 id="语法格式：（三目运算符。）"><a href="#语法格式：（三目运算符。）" class="headerlink" title="语法格式：（三目运算符。）"></a>语法格式：（三目运算符。）</h4><ul><li>布尔表达式 ? 表达式1 : 表达式2</li></ul><h4 id="执行原理是什么？"><a href="#执行原理是什么？" class="headerlink" title="执行原理是什么？"></a>执行原理是什么？</h4><ul><li>布尔表达式的结果为true时，表达式1的执行结果作为整个表达式的结果。</li><li>布尔表达式的结果为false时，表达式2的执行结果作为整个表达式的结果。</li></ul><h4 id="好玩点："><a href="#好玩点：" class="headerlink" title="好玩点："></a>好玩点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br><span class="line">以上两个都报错。</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面可以</span></span><br><span class="line"> <span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> s += <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符(+)"></a>字符串连接运算符(+)</h3><h4 id="运算符在java语言中有两个作用。"><a href="#运算符在java语言中有两个作用。" class="headerlink" title="+运算符在java语言中有两个作用。"></a>+运算符在java语言中有两个作用。</h4><ul><li><p>作用1：求和</p></li><li><p>作用2：字符串拼接</p></li></ul><h4 id="什么时候求和？什么时候进行字符串的拼接呢？"><a href="#什么时候求和？什么时候进行字符串的拼接呢？" class="headerlink" title="什么时候求和？什么时候进行字符串的拼接呢？"></a>什么时候求和？什么时候进行字符串的拼接呢？</h4><ul><li><p>当 + 运算符两边都是数字类型的时候，求和。</p></li><li><p>当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。</p></li></ul><h4 id="一定要记住：字符串拼接完之后的结果还是一个字符串。"><a href="#一定要记住：字符串拼接完之后的结果还是一个字符串。" class="headerlink" title="一定要记住：字符串拼接完之后的结果还是一个字符串。"></a>一定要记住：字符串拼接完之后的结果还是一个字符串。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 这里的 + 两边都是数字，所以加法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span>  + a + b);<span class="comment">//100+200=100200</span></span><br><span class="line">System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span>  + (a + b));<span class="comment">//100+200=300</span></span><br></pre></td></tr></table></figure><blockquote><p>注：遵循“自左向右”的顺序依次执行。（除非额外添加了小括号，小括号的优先级高）</p></blockquote><hr><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><blockquote><ul><li>Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</li><li>顺序结构是最简单的算法结构。</li><li><strong>顺序结构是任何一个算法都离不开的一种基本算法结构。</strong></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501213059243.png" alt="image-20220501213059243"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;到&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;依&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if单选择机构"><a href="#if单选择机构" class="headerlink" title="if单选择机构"></a>if单选择机构</h3><blockquote><ul><li>if语句的执行步骤<ul><li>对条件进行判断</li><li>判断条件为true，则执行代码块</li><li>判断条件为false，则跳过该语句</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501213713847.png" alt="image-20220501213713847"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h3><blockquote><ul><li>if-else的执行语句<ul><li>对条件进行判断</li><li>如果条件为true，则执行代码1</li><li>如果条件为false，则执行代码2</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501214013036.png" alt="image-20220501214013036"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h3><p>在if-else if-else语句中，if以及多个else-if后面的一对（）内的表达式的值必须为boolean类型。程序执行该语句时按照语句中表达式的顺序，首先计算表达式1的值，如果结果为true则执行紧跟着的复合语句，结束当前该语句的执行。如果结果为false则继续执行表达式2的值，以此类推，假设第M个表达式的值为true则执行跟着的复合语句，结束当前语句的执行，否则执行第M+1个表达式的值，如果所有的表达式的值都为false则执行关键字else后面的复合语句，结束当前语句的执行。</p><blockquote><p>执行流程：</p><ul><li>表达式1为true，则执行代码块1，再退出整个结构。</li><li>表达式2为true，则执行代码块2，再退出整个结构。</li><li>表达式3为true，则执行代码块3，再退出整个结构。</li><li>以上均为false，则执行代码块4，再退出整个结构。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>) &#123;</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (<span class="keyword">if</span>表达式<span class="number">2</span>)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (<span class="keyword">if</span>表达式<span class="number">3</span>)&#123;</span><br><span class="line">语句块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">else</span>(条件表达式n)&#123;</span><br><span class="line">语句块n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501214837908.png" alt="image-20220501214837908"></p><h3 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的if语句</h3><p>很多问题是一次简单的选择判断结构所解决不了的，需要进行多次选择判断，嵌套的if语句便是其中的一种解决方法。嵌套的if语句是一种多重选择结构。多重选择结构，顾名思义，就是有多种选择可以经过多次判断的结构。</p><blockquote><p>执行流程：</p><ul><li>当外层条件满足时，再判断内层条件。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">2</span>) &#123;</span><br><span class="line">语句 <span class="number">1</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">语句 <span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">3</span>) &#123;</span><br><span class="line">语句 <span class="number">3</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">语句 <span class="number">4</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501215733141.png" alt="image-20220501215733141"></p><h3 id="Switch选择语句"><a href="#Switch选择语句" class="headerlink" title="Switch选择语句"></a>Switch选择语句</h3><blockquote><p>switch语句和if的区别在于，switch只能进行等值判断，其限制较大</p></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501222540416.png" alt="image-20220501222540416"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">1</span>：</span><br><span class="line">语句块 <span class="number">1</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">2</span>：</span><br><span class="line">语句块 <span class="number">2</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">3</span>：</span><br><span class="line">语句块 <span class="number">3</span>；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line"><span class="keyword">case</span> 常量值n:</span><br><span class="line">语句块 n；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">default</span>：</span><br><span class="line">语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">while</span>( 布尔表达式 )&#123;</span><br><span class="line"><span class="comment">//循环结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>只要布尔表达式为true，循环就会一直执行下去。</p></li><li><p>我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。</p></li><li><p>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</p></li><li><p>循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或造成程序卡死崩溃</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//计算1+2+3+4+...+100=?</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><ul><li><p>对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p></li><li><p>do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (a&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="while和do…while的区别："><a href="#while和do…while的区别：" class="headerlink" title="while和do…while的区别："></a>while和do…while的区别：</h3><ul><li>while先判断后执行。dowhile是先执行后判断！</li><li>do…while总是保证循环体会被至少执行一次！这是他们的主要差别。</li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul><li>虽然所有循环结构都可以使用while或者do…while表示，但Java提供了另一种语句—for循环，使一些循环结构变得更加简单。</li><li>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</li><li>for循环执行的次数是在执行前就确定的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//初始化条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(a&lt;=<span class="number">100</span>)&#123;<span class="comment">//条件判断</span></span><br><span class="line">            System.out.println(a);<span class="comment">//循环体</span></span><br><span class="line">            a+=<span class="number">2</span>;<span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;while循环结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;for循环结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        关于for循环有以下几点说明：</span></span><br><span class="line"><span class="comment">        最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</span></span><br><span class="line"><span class="comment">        然后检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</span></span><br><span class="line"><span class="comment">        执行一次循环后，更新循环控制变量（迭代因子控制循环变量的增减）。</span></span><br><span class="line"><span class="comment">        再次检测布尔表达式。循环执行上面的过程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">for</span> ( ; ;)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(声明语句 : 表达式 )&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句快，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;; <span class="comment">//定义了一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123; </span><br><span class="line">            System.out.println(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历数组的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:numbers)&#123;<span class="comment">//增强for循环</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="breal、continue、return"><a href="#breal、continue、return" class="headerlink" title="breal、continue、return"></a>breal、continue、return</h2><h3 id="break和continue的作用和区别"><a href="#break和continue的作用和区别" class="headerlink" title="break和continue的作用和区别"></a>break和continue的作用和区别</h3><h4 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h4><p>break和continue都是用来控制循环结构的，主要作用是停止循环。</p><h4 id="break和continue的区别"><a href="#break和continue的区别" class="headerlink" title="break和continue的区别"></a>break和continue的区别</h4><p>1、break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。</p><p><strong>注意</strong>：</p><ul><li>只能在循环体内和switch语句体内使用break。</li><li>不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。</li><li>当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。</li></ul><p>2、continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。</p><p><strong>注意</strong>：</p><ul><li>continue语句并没有使整个循环终止。</li><li>continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。</li></ul><h4 id="break、return、continue的区别"><a href="#break、return、continue的区别" class="headerlink" title="break、return、continue的区别"></a>break、return、continue的区别</h4><p>break用于完全结束一个循环，跳出循环体。不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 break不仅可以结束其所在的循环，还可结束其外层循环。此时需要在break后紧跟一个标签，这个标签用于标识一个外层循环。Java中的标签就是一个紧跟着英文冒号（:）的标识符。且它必须放在循环语句之前才有作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakTest2</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// 外层循环，outer作为标识符</span></span><br><span class="line">　　　　outer:</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line">　　　　　　<span class="comment">// 内层循环</span></span><br><span class="line">　　　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span> ; j++ )&#123;</span><br><span class="line">　　　　　　　　System.out.println(<span class="string">&quot;i的值为:&quot;</span> + i + <span class="string">&quot; j的值为:&quot;</span> + j);</span><br><span class="line">　　　　　　　　<span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　　　<span class="comment">// 跳出outer标签所标识的循环。</span></span><br><span class="line">　　　　　　　　　　　<span class="keyword">break</span> outer;</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>continue的功能和break有点类似，区别是continue只是中止本次循环，接着开始下一次循环。而break则是完全中止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinueTest</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">// 一个简单的for循环</span></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">&quot;i的值是&quot;</span> + i);</span><br><span class="line">　　　　　　　<span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　　<span class="comment">// 忽略本次循环的剩下语句</span></span><br><span class="line">　　　　　　　　　<span class="keyword">continue</span>;</span><br><span class="line">　　　　　　　&#125;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">&quot;continue后的输出语句&quot;</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return关键字并不是专门用于跳出循环的，return的功能是结束一个方法。 一旦在循环体内执行到一个return语句，return语句将会结束该方法，循环自然也随之结束。与continue和break不同的是，return直接结束整个方法，不管这个return处于多少层循环之内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnTest</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// 一个简单的for循环</span></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;i的值是&quot;</span> + i);</span><br><span class="line">　　　　　　<span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;return后的输出语句&quot;</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归，就是在运行的过程中调用自己。"><a href="#递归，就是在运行的过程中调用自己。" class="headerlink" title="递归，就是在运行的过程中调用自己。"></a><strong>递归，就是在运行的过程中调用自己。</strong></h3><p>递归结构包含两个部分：</p><ul><li><strong>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环</strong></li><li><strong>递归体：什么时候需要调用自身方法</strong></li></ul><p>构成递归需具备的条件：<br><strong>1. 子问题须与原始问题为同样的事，且更为简单；</strong><br><strong>2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。</strong></p><h3 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h3><p>我们知道递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方，也就是下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(参数<span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recursion(参数<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>对递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处。</p><p><strong>阶乘</strong></p><p>一个最简单的递归调用-阶乘，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">System.out.println( f(<span class="number">5</span>) );</span><br><span class="line"><span class="comment">//结果：120</span></span><br></pre></td></tr></table></figure><p>第2-3行是终止条件，第5行是调用自己。就用n等于5的时候来画个图看一下递归究竟是怎么调用的</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220513152851533.png" alt="image-20220513152851533"></p><p>这种递归还是很简单的，我们求f(5)的时候，只需要求出f(4)即可，如果求f(4)我们要求出f(3)……，一层一层的调用，当n&#x3D;1的时候，我们直接返回1，然后再一层一层的返回，直到返回f(5)为止。</p><p>递归的目的是把一个大的问题细分为更小的子问题，我们只需要知道递归函数的功能即可，不要把递归一层一层的拆开来想，如果同时调用多次的话这样你很可能会陷入循环而出不来。比如上面的题中要求f(5)，我们只需要计算f(4)即可，即f(5)&#x3D;5*f(4)；至于f(4)是怎么计算的，我们就不要管了。因为我们知道f(n)中的n可以代表任何正整数，我们只需要传入4就可以计算f(4)。</p><p>递归规则</p><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量是独立的，不会相互影响比如n变量</li><li>如果方法中使用的是引用类型的变量（比如数组，对象）就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无线递归，出现（StackOverflowError，死归）</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。</strong></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>其长度是确定的，数组一旦被创建，它的大小就是不可以改变的</li><li>其元素必须是相同类型的，不允许出现混合类型</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型</li><li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量，</li></ul><p>数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，都是可以的</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>数组的两种常见初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>格式：</p><blockquote><p>数组存储的数据类型[ ] 数组名字 &#x3D; new 数组存储的数据类型[数组长度];<br>数组存储的数据类型 数组名字[ ] &#x3D; new 数组存储的数据类型[数组长度];</p></blockquote><ul><li><p>数组定义格式详解：</p></li><li><p>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</p></li><li><p>[] : 表示数组。</p></li><li><p>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</p></li><li><p>new：关键字，创建数组使用的关键字。</p></li><li><p>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</p></li><li><p>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</p></li><li><p>注意：数组有定长特性，长度一旦指定，不可更改。</p></li></ul><p>和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。<br>举例:<br>定义可以存储3个整数的数组容器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];  </span><br><span class="line"><span class="type">int</span>   arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 可以拆分 </span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><ul><li>格式：</li></ul><blockquote><p>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,元素3…};</p></blockquote><ul><li>举例： 定义存储1，2，3，4，5整数的数组容器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">// 可以拆分 </span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="静态初始化省略格式（不能拆分）"><a href="#静态初始化省略格式（不能拆分）" class="headerlink" title="静态初始化省略格式（不能拆分）"></a>静态初始化省略格式（不能拆分）</h4><ul><li>格式：</li></ul><blockquote><p>数据类型[] 数组名 &#x3D; {元素1,元素2,元素3…};</p></blockquote><ul><li>举例：</li></ul><p>定义存储1，2，3，4，5整数的数组容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><ul><li><p>索引：  每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。</p></li><li><p>格式：</p><blockquote><p>数组名[索引]</p></blockquote></li><li><p>数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数组的最大索引值为数组名.length-1。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">  System.out.println(arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>索引访问数组中的元素：</p><blockquote><p>数组名[索引] &#x3D; 数值，为数组中的元素赋值<br>变量 &#x3D; 数组名[索引]，获取出数组中的元素</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5 </span></span><br><span class="line"> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="comment">//为0索引元素赋值为6 </span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">6</span>; </span><br><span class="line">  <span class="comment">//获取数组0索引上的元素 </span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr[<span class="number">0</span>]; </span><br><span class="line">  System.out.println(i); </span><br><span class="line">  <span class="comment">//直接输出数组0索引元素 </span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组初始化</p><p>同一维数组一样，共有4总不同形式的定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> array2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> array3[][] = &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="type">int</span> array4[][] = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;&#125;;</span><br></pre></td></tr></table></figure><p>不定长二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">array[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>获取二维数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">// 获取二维数组的第一维长度（3）</span></span><br><span class="line">System.out.println(length1);</span><br><span class="line"><span class="comment">// 获取二维数组的第一维的第一个数组长度（1）</span></span><br><span class="line">System.out.println(length2);</span><br></pre></td></tr></table></figure><p>遍历打印二位数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = &#123; &#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">         System.out.print( array[i][j] );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>Sparse Array 稀疏数组。</p><h4 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h4><p>先来看一个实际需求，比较好思考</p><p>编写五子棋程序中的 <strong>存盘退出</strong> 和 <strong>续上盘</strong> 功能</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703215903031.8ffc1996.png" alt="image-20200703215903031"></p><p>我们首先能想到的就是使用一个 <strong>二维数组</strong>，如上图所示：</p><ul><li>0：表示没有棋子</li><li>1：表示黑棋</li><li>2：表示白棋</li></ul><h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>可以看到二维数组中很多值都是 0，因此记录了很多没有意义的数据。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>定义：当一个数组中 <strong>大部分元素为 0（或是同一个值）</strong> 时，可以使用 <strong>稀疏数组</strong> 来保存该数组</p><p>处理方法：</p><ol><li>记录数组一共有 <strong>几行几列</strong>，<strong>有多少个不同的值</strong></li><li>把具有 <strong>不同值的元素</strong> 的 <strong>行列及值</strong> 记录在一个 <strong>小规模的数组</strong> 中，从而缩小程序的规模</li></ol><p>这个小规模的数组就称为 <strong>稀疏数组</strong>，举个例子，如下图</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703221437344.19a0a264.png" alt="image-20200703221437344"></p><p>左侧是原始的二维数组 <code>6x7 = 42 个格子</code>，右侧是稀疏数组 <code>9 x 3 = 27 个格子</code></p><ul><li><p><code>[0]</code>：记录了棋盘的大小，6 行 7 列，棋盘上有 8 个不为 0 的值</p></li><li><p>其他行：分别记录每一个非 0 值的所在行、所在列、值</p><p>比如 <code>[1]</code>：在第 0 行第 3 列上有一个 22（这里的行列都是下标）</p></li></ul><p>可以看到原始 42 个数据，压缩成 27 个数据。一定程度上压缩了数据。</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>使用 <strong>稀疏数组</strong> 保留类似前面的 <strong>二维数组</strong>（如棋盘、地图等等的场景），把 <strong>稀疏数组存盘</strong>，并且可以从新 <strong>恢复原来的二维数组</strong></p><p>####稀疏数组与二维数组互转思路</p><p>以前面的棋盘数据来讲解</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703223528941.02cbe7fb.png" alt="image-20200703223528941"></p><p>如上图，总结出来稀疏数组为右侧那样。那么他们互转思路如下：</p><p>二维数组转稀疏数组思路：</p><ol><li>遍历原始的二维数组，得到有效个数 sum</li><li>根据 sum 创建 <strong>稀疏数组</strong> <code>sparseArr = int[sum + 1][3]</code></li><li>将二维数据的有效数据存入到稀疏数组中（从第 2 行开始存储）</li><li>最后将棋盘大小和有效个数写入第一行</li></ol><p>稀疏数组转原始二维数组思路：</p><ol><li>读取第一行数据，根据棋盘大小，创建原始的二维数组 <code>chessArr = int [11][11]</code></li><li>从第二行开始，将有效数据还原到原始数组中</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrcode.study.dsalgtutorialdemo.datastructure.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  稀疏数组：</span></span><br><span class="line"><span class="comment"> *      1. 二维数组转稀疏数组</span></span><br><span class="line"><span class="comment"> *      2. 稀疏数组转二维数组</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原始二维数组</span></span><br><span class="line">        <span class="comment">// 0：没有棋子，1：黑棋，2：白棋</span></span><br><span class="line">        <span class="comment">// 棋盘大小 11 x 11</span></span><br><span class="line">        <span class="type">int</span> chessArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 预览棋盘上的棋子位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;预览原始数组&quot;</span>);</span><br><span class="line">        printChessArray(chessArr);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 二维数组转稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = chessToSparse(chessArr);</span><br><span class="line"><span class="comment">// int[][] sparseArr = chessToSparse2(chessArr); // 紧凑版本可以参考笔记配套项目</span></span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组转稀疏数组&quot;</span>);</span><br><span class="line">        printChessArray(sparseArr);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 稀疏数组转二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr2 = sparseToChess(sparseArr);</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组转二维数组&quot;</span>);</span><br><span class="line">        printChessArray(chessArr2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二维数组转稀疏数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] chessToSparse(<span class="type">int</span>[][] chessArr) &#123;</span><br><span class="line">        <span class="comment">// 1. 遍历数组得到有效棋子个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> chess : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chess != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 3. 将二维数据的有效数据存入到稀疏数组中（从第 2 行开始存储）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chessRow</span> <span class="operator">=</span> chessArr.length;  <span class="comment">// 行： 棋盘大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chessCol</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 列： 棋盘大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前是第几个非 0 的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rows = chessArr[i];</span><br><span class="line">            <span class="keyword">if</span> (chessCol == <span class="number">0</span>) &#123;</span><br><span class="line">                chessCol = rows.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; rows.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">chess</span> <span class="operator">=</span> rows[j];</span><br><span class="line">                <span class="keyword">if</span> (chess == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;  <span class="comment">// 第一行是棋盘信息，所以先自增</span></span><br><span class="line">                sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                sparseArr[count][<span class="number">2</span>] = chess;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 补全第一行的棋盘大小和有效数据</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = chessRow;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = chessCol;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="keyword">return</span> sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 稀疏数组转二维数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sparseArr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] sparseToChess(<span class="type">int</span>[][] sparseArr) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 2. 恢复有效数据到二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rows = sparseArr[i];</span><br><span class="line">            chessArr[rows[<span class="number">0</span>]][rows[<span class="number">1</span>]] = rows[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chessArr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印棋盘上的棋子布局</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printChessArray</span><span class="params">(<span class="type">int</span>[][] chessArr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                <span class="comment">// 左对齐，使用两个空格补齐 2 位数</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%-2d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">预览原始数组</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">二维数组转稀疏数组</span><br><span class="line"><span class="number">11</span><span class="number">11</span><span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line">稀疏数组转二维数组</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="八大排序"><a href="#八大排序" class="headerlink" title="八大排序"></a>八大排序</h2><hr><h2 id="栈、堆"><a href="#栈、堆" class="headerlink" title="栈、堆"></a>栈、堆</h2><p>Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a><strong>栈内存</strong></h3><p>栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a><strong>堆内存</strong></h3><p>存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p><p>主函数里的语句   int [] arr&#x3D;new int [3];在内存中是怎么被定义的：</p><p>主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220514173855512.png" alt="image-20220514173855512"></p><h3 id="堆和栈是怎么联系起来的呢"><a href="#堆和栈是怎么联系起来的呢" class="headerlink" title="堆和栈是怎么联系起来的呢?"></a>堆和栈是怎么联系起来的呢?</h3><p> 给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。</p><p>如果当<strong>int [] arr&#x3D;null;</strong></p><p> arr不做任何指向，null的作用就是取消引用数据类型的指向。、</p><p> 当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。<br>  所以堆与栈的区别很明显：</p><ol><li>栈内存存储的是局部变量而堆内存存储的是实体</li><li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li></ol><hr><h2 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h2><p>javadoc是Sun公司提供的一个技术，它从程序<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969">源代码</a>中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。</p><p>javadoc命令是用来生成自己<a href="https://baike.baidu.com/item/API/10154">API</a>文档的，使用方式：使用命令行在目标文件所在目录输入javadoc +文件名.java。</p><table><thead><tr><th>标签</th><th>说明</th><th>JDK 1.1 doclet</th><th>标准doclet</th><th>标签类型</th></tr></thead><tbody><tr><td>@author 作者</td><td>作者标识</td><td>√</td><td>√</td><td>包、 类、接口</td></tr><tr><td>@version 版本号</td><td>版本号</td><td>√</td><td>√</td><td>包、 类、接口</td></tr><tr><td>@param 参数名 描述</td><td>方法的入参名及描述信息，如入参有特别要求，可在此注释。</td><td>√</td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@return 描述</td><td>对函数返回值的注释</td><td>√</td><td>√</td><td>方法</td></tr><tr><td>@deprecated 过期文本</td><td>标识随着程序版本的提升，当前API已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个API。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>@throws异常类名</td><td>构造函数或方法所会抛出的异常。</td><td></td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@exception 异常类名</td><td>同@throws。</td><td>√</td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@see 引用</td><td>查看相关内容，如类、方法、变量等。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>@since 描述文本</td><td>API在什么程序的什么版本后开发支持。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>{@link包.类#成员 标签}</td><td>链接到某个特定的成员对应的文档中。</td><td></td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>{@value}</td><td>当对常量进行注释时，如果想将其值包含在文档中，则通过该标签来引用常量的值。</td><td></td><td>√(JDK1.4)</td><td>静态值域</td></tr></tbody></table><p>此外还有@serial、@serialField、@serialData、{@docRoot}、{@inheritDoc}、{@literal}、{@code} {@value arg}几个不常用的标签，由于不常使用，我们不展开叙述，感兴趣的读者可以查看帮助文档。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序</title>
      <link href="/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/big-o.png" alt="img"></a></p><ul><li>直接插入排序</li><li>希尔排序</li><li>简单选择排序</li><li>堆排序</li><li>冒泡排序</li><li>快速排序</li><li>归并排序</li><li>基数排序</li></ul><p>这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms">Github：<strong>SortAlgorithms</strong></a>，其中也包括了排序测试模块[<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java">Test.java]</a>和排序算法对比模块[<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java">Bench.java]</a>，可以试运行。</p><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p>⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪内部排序⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序{内部排序{插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序</p><h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p><p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p><h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/insert-sort.gif" alt="直接插入排序演示"></a>直接插入排序演示</p><p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p><p>如果<strong>比较操作</strong>的代价比<strong>交换操作</strong>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95">二分查找法</a>来减少<em>比较操作</em>的数目。可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&action=edit&redlink=1">二分查找插入排序</a>。</p><h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line"> * 5. 将新元素插入到该位置后</span><br><span class="line"> * 6. 重复步骤2~5</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i = 1; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        int temp = arr[i];    // 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line">        for( int j = i; j &gt;= 0; j-- ) &#123;</span><br><span class="line">            if( j &gt; 0 &amp;&amp; arr[j-1] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-1];    // 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span><br><span class="line">                System.out.println(&quot;Temping:  &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将新元素插入到该位置后</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交换次数较多的实现</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i=0; i&lt;arr.length-1; i++ ) &#123;</span><br><span class="line">        for( int j=i+1; j&gt;0; j-- ) &#123;</span><br><span class="line">            if( arr[j-1] &lt;= arr[j] )</span><br><span class="line">                break;</span><br><span class="line">            int temp = arr[j];      //交换操作</span><br><span class="line">            arr[j] = arr[j-1];</span><br><span class="line">            arr[j-1] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序复杂度如下：</p><ul><li>最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1n−1；移动次数(RMN)为00。则对应的时间复杂度为O(n)O(n)。</li><li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22 ; 移动次数(RMN)为：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22。则对应的时间复杂度为O(n2)O(n2)。</li><li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n22n22，因此，<strong>直接插入排序的平均时间复杂度</strong>为O(n2)O(n2)。</li></ul><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/shell-sort.jpg" alt="img"></a></p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap&#x3D;1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>。</p><h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shellSort(int[] arr)&#123;</span><br><span class="line">    int gap = arr.length / 2;</span><br><span class="line">    for (; gap &gt; 0; gap /= 2) &#123;      //不断缩小gap，直到1为止</span><br><span class="line">        for (int j = 0; (j+gap) &lt; arr.length; j++)&#123;     //使用当前gap进行组内插入排序</span><br><span class="line">            for(int k = 0; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                if(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    int temp = arr[k+gap];      //交换操作</span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(&quot;    Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>①. 第一层for循环表示一共有多少个增量。增量的序列的个数，就是希尔排序的趟数。上面的增量序列为： <code>arr.length/2, arr.length/2/2, arr.length/2/2/2, .... 2, 1</code><br>②. 里层的两个for循环，实际上就是以一个gap拆分为一组的<strong>组内插入排序</strong>。</p><p>下面是维基百科官方实现，大家注意gap步长取值部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序（Wiki官方版）</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shell_sort(int[] arr) &#123;</span><br><span class="line">    int gap = 1, i, j, len = arr.length;</span><br><span class="line">    int temp;</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;      // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span><br><span class="line">    for (; gap &gt; 0; gap /= 3) &#123;</span><br><span class="line">        for (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是希尔排序复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog2 n)</td><td align="left">O(nlog2 n)</td><td align="left">O(nlog2 n)</td><td align="left">O(1)</td></tr></tbody></table><h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr><blockquote><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></a>选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p></blockquote><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p><h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</span><br><span class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</span><br><span class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void selectionSort(int[] arr)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.length-1; i++)&#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for(int j = i+1; j &lt; arr.length; j++)&#123;    //选出之后待排序中值最小的位置</span><br><span class="line">            if(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min != i)&#123;</span><br><span class="line">            int temp = arr[min];      //交换操作</span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是选择排序复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²&#x2F;2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：nn个元素的序列 {k1,k2,⋅⋅⋅,kn}{k1,k2,···,kn} 当且仅当满足下关系时，称之为堆。</p><p>{kiki⩽k2i⩽k2i+1或{kiki⩾k2i⩾k2i+1(i&#x3D;1,2,⋅⋅⋅,⌊n2⌋){ki⩽k2iki⩽k2i+1或{ki⩾k2iki⩾k2i+1(i&#x3D;1,2,···,⌊n2⌋)</p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列K[1..n]K[1..n]建成一个大顶堆, 那么此时第一个元素K1K1最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录K1K1 (即堆顶, 第一个元素)和无序区的最后一个记录 KnKn 交换, 由此得到新的无序区K[1..n−1]K[1..n−1]和有序区K[n]K[n], 且满足K[1..n−1].keys⩽K[n].keyK[1..n−1].keys⩽K[n].key<br>③. 交换K1K1 和 KnKn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p><p>动图效果如下所示：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></a>堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p><h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</span><br><span class="line"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</span><br><span class="line"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void heapSort(int[] arr)&#123;</span><br><span class="line">    for(int i = arr.length; i &gt; 0; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        int temp = arr[0];      //堆顶元素(第一个元素)与Kn交换</span><br><span class="line">        arr[0] = arr[i-1];</span><br><span class="line">        arr[i-1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void max_heapify(int[] arr, int limit)&#123;</span><br><span class="line">    if(arr.length &lt;= 0 || arr.length &lt; limit) return;</span><br><span class="line">    int parentIdx = limit / 2;</span><br><span class="line"></span><br><span class="line">    for(; parentIdx &gt;= 0; parentIdx--)&#123;</span><br><span class="line">        if(parentIdx * 2 &gt;= limit)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = parentIdx * 2;       //左子节点位置</span><br><span class="line">        int right = (left + 1) &gt;= limit ? left : (left + 1);    //右子节点位置，如果没有右节点，默认为左节点位置</span><br><span class="line"></span><br><span class="line">        int maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        if(arr[maxChildId] &gt; arr[parentIdx])&#123;   //交换父节点与左右子节点中的最大值</span><br><span class="line">            int temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Max_Heapify: &quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 &#x3D;&#x3D; Math.floor(x&#x2F;2) .</p></blockquote><p>以上,<br>①. 建立堆的过程, 从length&#x2F;2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(1)</td></tr></tbody></table><p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p><h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort02.gif" alt="冒泡排序的思想"></a>冒泡排序的思想</p><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort.gif" alt="冒泡排序演示"></a>冒泡排序演示</p><h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p><h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><br><span class="line"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><br><span class="line"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">    for (int i = arr.length; i &gt; 0; i--) &#123;      //外层循环移动游标</span><br><span class="line">        for(int j = 0; j &lt; i &amp;&amp; (j+1) &lt; i; j++)&#123;    //内层循环遍历游标及之后(或之前)的元素</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²&#x2F;2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p><h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></a>使用快速排序法对一列数字进行排序的过程</p><h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/quick-sort09.gif" alt="快速排序演示"></a>快速排序演示</p><h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p><p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></a>快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> * @param low   左边界</span><br><span class="line"> * @param high  右边界</span><br><span class="line"> */</span><br><span class="line">public static void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    if(low &gt;= high) return;</span><br><span class="line">    int left = low;</span><br><span class="line">    int right = high;</span><br><span class="line"></span><br><span class="line">    int temp = arr[left];   //挖坑1：保存基准的值</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-1);</span><br><span class="line">    quickSort(arr, left+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（非递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void quickSortByStack(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    //初始状态的左右指针入栈</span><br><span class="line">    stack.push(0);</span><br><span class="line">    stack.push(arr.length - 1);</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        int high = stack.pop();     //出栈进行划分</span><br><span class="line">        int low = stack.pop();</span><br><span class="line"></span><br><span class="line">        int pivotIdx = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        //保存中间变量</span><br><span class="line">        if(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= 0)&#123;</span><br><span class="line">            stack.push(pivotIdx + 1);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int partition(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return -1;</span><br><span class="line">    if(low &gt;= high) return -1;</span><br><span class="line">    int l = low;</span><br><span class="line">    int r = high;</span><br><span class="line"></span><br><span class="line">    int pivot = arr[l];    //挖坑1：保存基准的值</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><p>以下是快速排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n²)</td><td align="left">O(1)（原地分区递归版）</td></tr></tbody></table><p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p><p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p><h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr><blockquote><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort_sample.jpg" alt="img"></a></p></blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="这个图很有概括性，来自维基"></a>这个图很有概括性，来自维基</p><h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>一、递归法</strong>（假设序列共有n个元素）：</p><p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n&#x2F;2)个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 floor(n&#x2F;4)个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort.gif" alt="img"></a></p><p><strong>二、迭代法</strong></p><p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p><h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p><strong>如何合并？</strong></p><p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p><p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p><p><strong>如何分解？</strong></p><p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p>这里我写了递归算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 归并排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span><br><span class="line"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span><br><span class="line"> * ③. 重复步骤②，直到所有元素排序完毕。</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static int[] mergingSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line">    int num = arr.length &gt;&gt; 1;</span><br><span class="line">    int[] leftArr = Arrays.copyOfRange(arr, 0, num);</span><br><span class="line">    int[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(&quot;split two array: &quot; + Arrays.toString(leftArr) + &quot; And &quot; + Arrays.toString(rightArr));</span><br><span class="line">    return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      //不断拆分为最小单元，再排序合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] mergeTwoArray(int[] arr1, int[] arr2)&#123;</span><br><span class="line">    int i = 0, j = 0, k = 0;</span><br><span class="line">    int[] result = new int[arr1.length + arr2.length];  //申请额外的空间存储合并之后的数组</span><br><span class="line">    while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      //选取两个序列中的较小值放入新数组</span><br><span class="line">        if(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; arr1.length)&#123;     //序列1中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; arr2.length)&#123;     //序列2中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Merging: &quot; + Arrays.toString(result));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p><p>以下是归并排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</li><li><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</li></ul><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radix-sort_sample.gif" alt="基数排序LSD动图演示"></a>基数排序LSD动图演示</p><h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数；<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</li><li><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序（LSD 从低位开始）</span><br><span class="line"> *</span><br><span class="line"> * 基数排序适用于：</span><br><span class="line"> *  (1)数据范围较小，建议在小于1000</span><br><span class="line"> *  (2)每个数值都要大于等于0</span><br><span class="line"> *</span><br><span class="line"> * ①. 取得数组中的最大数，并取得位数；</span><br><span class="line"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</span><br><span class="line"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">    //取得数组中的最大数，并取得位数</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(max &lt; arr[i])&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxDigit = 1;</span><br><span class="line">    while(max / 10 &gt; 0)&#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;maxDigit: &quot; + maxDigit);</span><br><span class="line"></span><br><span class="line">    //申请一个桶空间</span><br><span class="line">    int[][] buckets = new int[10][arr.length];</span><br><span class="line">    int base = 10;</span><br><span class="line"></span><br><span class="line">    //从低位到高位，对每一位遍历，将所有元素分配到桶中</span><br><span class="line">    for(int i = 0; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        int[] bktLen = new int[10];        //存储各个桶中存储元素的数量</span><br><span class="line">        </span><br><span class="line">        //分配：将所有元素分配到桶中</span><br><span class="line">        for(int j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            int whichBucket = (arr[j] % base) / (base / 10);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int b = 0; b &lt; buckets.length; b++)&#123;</span><br><span class="line">            for(int p = 0; p &lt; bktLen[b]; p++)&#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">        base *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(d*(n+r))</td><td align="left">O(d*(n+r))</td><td align="left">O(d*(n+r))</td><td align="left">O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p><p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>各种排序性能对比如下，有些排序未详细介绍，暂且放到这里。实例测试结果可以看这里：<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md"><strong>八大排序算法耗时对比</strong></a> 。</p><table><thead><tr><th align="left">排序类型</th><th align="left">平均情况</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">辅助空间</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">选择排序</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">直接插入排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">折半插入排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">希尔排序</td><td align="left">O(n^1.3)</td><td align="left">O(nlogn)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">归并排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n)</td><td align="left">稳定</td></tr><tr><td align="left">快速排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n²)</td><td align="left">O(nlog₂n)</td><td align="left">不稳定</td></tr><tr><td align="left">堆排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">计数排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(k)</td><td align="left">稳定</td></tr><tr><td align="left">桶排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n²)</td><td align="left">O(n+k)</td><td align="left">(不)稳定</td></tr><tr><td align="left">基数排序</td><td align="left">O(d(n+k))</td><td align="left">O(d(n+k))</td><td align="left">O(d(n+kd))</td><td align="left">O(n+kd)</td><td align="left">稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><p>(1). 平方阶O(n²)排序：**<code>各类简单排序：直接插入、直接选择和冒泡排序</code>**；</p><p>(2). 线性对数阶O(nlog₂n)排序：**<code>快速排序、堆排序和归并排序</code>**；</p><p>(3). O(n1+§))排序，§是介于0和1之间的常数：**<code>希尔排序</code>**</p><p>(4). 线性阶O(n)排序：**<code>基数排序，此外还有桶、箱排序</code><strong>。<br>　　<br>到此，很多人会注意到</strong>基数排序**的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/radixsort-comparison.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radixsort-comparison.jpg" alt="img"></a></p><p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p><h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p><ol><li>计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数</li><li>基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值</li><li>桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li></ol><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O( nlgn)</strong> 。参考<a href="https://www.zhihu.com/question/24516934">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/2016-07-15_%25E5%25B8%25B8%25E7%2594%25A8%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown文档常用写法</title>
      <link href="/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/"/>
      <url>/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><p>第一种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165256359-1045755089.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165419890-1445220158.png" alt="img"></p><p>前面带#号，后面带文字，分别表示h1-h6,上图可以看出，只到h6，而且h1下面会有一条横线，注意，#号后面有空格</p><p>第二种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165937218-1530465248.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165947968-314903197.png" alt="img"></p><p>这种方式好像只能表示一级和二级标题，而且&#x3D;和-的数量没有限制，只要大于一个就行</p><p>第三种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121170247156-1219352477.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121170255531-442290753.png" alt="img"></p><p>这里的标题支持h1-h6，为了减少篇幅，我就偷个懒，只写前面二个，这个比较好理解，相当于标签闭合，注意，标题与#号要有空格</p><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121172350078-1462814017.png" alt="img"></p><p>在线地址请看这里： <a href="http://tool.oschina.net/markdown/">markdown在线编辑</a> （只是想看看背后的转换原理，没有广告之嫌）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>我们都知道，列表分为有序列表和无序列表，下面直接展示2种列表的写法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121171909093-661987876.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121171919343-1747027523.png" alt="img"></p><p>可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121173226140-1875382054.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121173239421-1080651187.png" alt="img"></p><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的，比如说：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175940718-1084956249.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175948687-1987133124.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175958281-1526944139.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180005984-1893005909.png" alt="img"></p><p>第一组本来是3 2 1 倒序，但是现实3 4 5 ，后面一组 序号是乱的， 但是还是显示 3 4 5 ，这点必须注意了</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174024531-1893848795.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174034406-909064775.png" alt="img"></p><p>无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格</p><p>引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174722343-1828411427.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174734109-810075211.png" alt="img"></p><p>将上面的代码稍微改一下，全部加上引用标签，就变成了一个大的引用，还有引用里面还有引用，那引用嵌套引用还没有别的写法呢？</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175159984-1386789693.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175207031-1980491226.png" alt="img"></p><p>上图可以看出，想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的&gt;是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧</p><h2 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h2><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180722171-1035491697.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180731562-316920662.png" alt="img"></p><p>应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121181659734-1035365203.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121181708390-1994007685.png" alt="img"></p><p>上图可知，行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中，举一反三，经常出现的列表链接就应该这样写：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121182158531-1522139664.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121182206671-1837073264.png" alt="img"></p><p>链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来</p><p><img src="https://images2015.cnblogs.com/blog/600165/201701/600165-20170121182852468-1462512454.png" alt="img"></p><p>这是行内式的写法，参数式的怎么写：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121183435890-1350949010.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121183445640-1750855701.png" alt="img"></p><p>这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系，参数定义时，这3种写法都可以：</p><p>还支持这种写法，如果你不想混淆的话：</p><p>其实还有一种隐式链接的写法，但是我觉得那种写法不直观，所以就不写了，经常用的一般就上面2种，如果你想了解隐式链接，可以看我文章最后放出的参考地址</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片也有2种方式：行内式和参数式，</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121185054312-549083784.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121185106031-1426410254.png" alt="img"></p><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190316875-1459932813.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190325703-1235022505.png" alt="img"></p><p>要是多行这个就不行了，多行可以用这个：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190613718-1073029883.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190635656-1896064058.png" alt="img"></p><p>多行用三个反引号，如果要写注释，可以在反引号后面写</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这个写的有点麻烦，注意看</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121192302156-105192980.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121192312453-411896732.png" alt="img"></p><p>从这3种不同写法看，表格的格式不一定要对的非常起，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的，不过现实出来的结果是，表格外面并没有线框包起来，不知道别人的怎么弄的</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193336406-237336360.png" alt="img">   <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193346781-1402792187.png" alt="img"></p><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193837156-99120890.png" alt="img">   <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193847093-1553208687.png" alt="img"></p><p>就不一一列举了，基本上跟js转义是一样的</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><img src="https://images2015.cnblogs.com/blog/600165/201701/600165-20170121194131015-499064556.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121194138656-989711852.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必备网站大全，给你全面惊喜</title>
      <link href="/2022/04/06/%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99%E5%A4%A7%E5%85%A8%EF%BC%8C%E7%BB%99%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%83%8A%E5%96%9C/"/>
      <url>/2022/04/06/%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99%E5%A4%A7%E5%85%A8%EF%BC%8C%E7%BB%99%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%83%8A%E5%96%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="学习类"><a href="#学习类" class="headerlink" title="学习类"></a>学习类</h1><p>CSDN： <a href="https://www.csdn.net/">https://www.csdn.net/</a><br>TED（最优质的演讲）：<a href="https://www.ted.com/">https://www.ted.com/</a><br>谷粉学术： <a href="https://gfsoso.99lb.net/scholar.html">https://gfsoso.99lb.net/scholar.html</a><br>大学资源网：<a href="http://www.dxzy163.com/">http://www.dxzy163.com/</a><br>简答题：<a href="http://www.jiandati.com/">http://www.jiandati.com/</a><br>网易公开课：<a href="https://open.163.com/ted/">https://open.163.com/ted/</a><br>网易云课堂：<a href="https://study.163.com/">https://study.163.com/</a><br>中国大学MOOC：<a href="http://www.icourse163.org/">www.icourse163.org</a><br>网易云课堂：<a href="https://study.163.com/">https://study.163.com</a><br>哔哩哔哩弹幕网： <a href="http://www.bilibili.com/">www.bilibili.com</a><br>我要自学网： <a href="http://www.51zxw.net/">www.51zxw.net</a><br>知乎：<a href="http://www.zhihu.com/">www.zhihu.com</a><br>学堂在线：<a href="http://www.xuetangx.com/">www.xuetangx.com</a><br>爱课程：<a href="http://www.icourses.cn/">www.icourses.cn</a><br>猫咪论文：<a href="https://lunwen.im/">https://lunwen.im/</a><br>iData（论文搜索）：<a href="http://www.cn-ki.net/">www.cn-ki.net</a><br>文泉考试：<a href="https://www.wqkaoshi.com/">https://www.wqkaoshi.com</a></p><h1 id="书籍类"><a href="#书籍类" class="headerlink" title="书籍类"></a>书籍类</h1><p>书栈网（极力推荐）： <a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a><br>码农之家（计算机电子书下载）：<a href="http://www.xz577.com/">www.xz577.com</a><br>鸠摩搜书：<a href="http://www.jiumodiary.com/">www.jiumodiary.com</a><br>云海电子图书馆：<a href="http://www.pdfbook.cn/">www.pdfbook.cn</a><br>周读（书籍搜索）：<a href="http://ireadweek.com/">http://ireadweek.com</a><br>知轩藏书：<a href="http://www.zxcs.me/">http://www.zxcs.me/</a><br>脚本之家电子书下载：<a href="https://www.jb51.net/books/">https://www.jb51.net/books/</a><br>搜书VIP-电子书搜索：<a href="http://www.soshuvip.com/all.html">http://www.soshuvip.com/all.html</a><br>书格（在线古籍图书馆）：<a href="https://new.shuge.org/">https://new.shuge.org/</a><br>caj云阅读：<a href="http://cajviewer.cnki.net/cajcloud/">http://cajviewer.cnki.net/cajcloud/</a><br>必看网（人生必看的书籍）：<a href="https://www.biikan.com/">https://www.biikan.com/</a></p><h1 id="冷知识-x2F-黑科技"><a href="#冷知识-x2F-黑科技" class="headerlink" title="冷知识 &#x2F; 黑科技"></a>冷知识 &#x2F; 黑科技</h1><p>上班摸鱼必备（假装电脑系统升级）： <a href="http://fakeupdate.net/">http://fakeupdate.net/</a><br>PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）： <a href="http://www.species-in-pieces.com/">http://www.species-in-pieces.com/</a><br>图片立体像素画： <a href="https://pissang.github.io/voxelize-image/">https://pissang.github.io/voxelize-image/</a><br>福利单词（一个不太正经的背单词网站）： <a href="http://dict.ftqq.com/">http://dict.ftqq.com</a><br>查无此人（刷新网站，展现一张AI 生成的人脸照片）：<a href="https://thispersondoesnotexist.com/">https://thispersondoesnotexist.com/</a><br>在线制作地图图例：<a href="https://mapchart.net/">https://mapchart.net/</a><br>创意光线绘画：<a href="http://weavesilk.com/">http://weavesilk.com/</a><br>星系观察： <a href="https://stellarium-web.org/">https://stellarium-web.org/</a><br>煎蛋：<a href="http://jandan.net/">http://jandan.net/</a><br>渣男-说话的艺术：<a href="https://lovelive.tools/">https://lovelive.tools/</a><br>全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a><br>iData：<a href="https://www.cn-ki.net/">https://www.cn-ki.net/</a><br>术语在线：<a href="http://www.termonline.cn/">http://www.termonline.cn/</a></p><h1 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h1><p>GitHub：<a href="https://github.com/">https://github.com/</a><br>码云：<a href="https://gitee.com/">https://gitee.com/</a><br>源码之家：<a href="https://www.mycodes.net/">https://www.mycodes.net/</a><br>JSON to Dart： <a href="https://javiercbk.github.io/json_to_dart/">https://javiercbk.github.io/json_to_dart/</a><br>Json在线解析验证： <a href="https://www.json.cn/">https://www.json.cn/</a><br>在线接口测试（Getman）：<a href="https://getman.cn/">https://getman.cn/</a></p><h1 id="搜资源"><a href="#搜资源" class="headerlink" title="搜资源"></a>搜资源</h1><p>DogeDoge搜索引擎：<a href="http://www.dogedoge.com/">www.dogedoge.com</a><br>秘迹搜索：<a href="https://mijisou.com/">https://mijisou.com/</a><br>小白盘：<a href="https://www.xiaobaipan.com/">https://www.xiaobaipan.com/</a><br>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com/">www.yunpanjingling.com</a><br>虫部落（资源搜索）：<a href="http://www.chongbuluo.com/">www.chongbuluo.com</a><br>如风搜（资源搜索）：<a href="http://www.rufengso.net/">http://www.rufengso.net/</a><br>爱扒：<a href="https://www.zyboe.com/">https://www.zyboe.com/</a></p><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><p>奶牛快传（在线传输文件利器）： <a href="http://cowtransfer.com/">http://cowtransfer.com</a><br>文叔叔（大文件传输，不限速）：<a href="https://www.wenshushu.cn/">https://www.wenshushu.cn/</a><br>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/">https://uzer.me/</a><br>香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：<a href="https://www.xiangdang.net/">https://www.xiangdang.net/</a><br>二维码生成：<a href="https://cli.im/">https://cli.im/</a><br>搜狗翻译：<a href="http://fanyi.sogou.com/">http://fanyi.sogou.com</a><br>熵数（图表制作，数据可视化）：<a href="https://dydata.io/appv2/#/pages/index/home">https://dydata.io/appv2/#/pages/index/home</a><br>拷贝兔：<a href="https://cp.anyknew.com/">https://cp.anyknew.com/</a><br>图片无限变放大：<a href="http://bigjpg.com/zh">http://bigjpg.com/zh</a><br>幕布（在线大纲笔记工具）：mubu.com<br>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/">https://zh.justcnw.com/</a><br>调查问卷制作：<a href="https://www.wenjuan.com/">https://www.wenjuan.com/</a><br>果核剥壳（软件下载）：<a href="https://www.ghpym.com/">https://www.ghpym.com/</a><br>软件下载：<a href="https://www.unyoo.com/">https://www.unyoo.com/</a><br>MSDN我告诉你（windows10系统镜像下载）：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p><h1 id="导航页"><a href="#导航页" class="headerlink" title="导航页"></a>导航页</h1><p>世界各国网址大全： <a href="http://www.world68.com/">http://www.world68.com/</a><br>小森林导航：<a href="http://www.xsldh6.com/">http://www.xsldh6.com/</a><br>简捷工具：<a href="http://www.shulijp.com/">http://www.shulijp.com/</a><br>NiceTool.net 好工具网：<a href="http://www.nicetool.net/">http://www.nicetool.net/</a><br>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/">http://tool.uixsj.cn/</a><br>蓝调网站：<a href="http://lcoc.top/">http://lcoc.top/</a><br>偷渡鱼：<a href="https://touduyu.com/">https://touduyu.com/</a><br>牛导航：<a href="http://www.ziliao6.com/">http://www.ziliao6.com/</a><br>小呆导航：<a href="https://www.webjike.com/index.html">https://www.webjike.com/index.html</a><br>简法主页：<a href="http://www.jianfast.com/">http://www.jianfast.com/</a><br>KIM主页：<a href="https://kim.plopco.com/">https://kim.plopco.com/</a><br>聚BT：<a href="https://jubt.net/cn/index.html">https://jubt.net/cn/index.html</a><br>精准云工具合集：<a href="https://jingzhunyun.com/">https://jingzhunyun.com/</a><br>兔2工具合集：<a href="https://www.tool2.cn/">https://www.tool2.cn/</a><br>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com/">www.toolnb.com</a><br>工具导航：<a href="https://hao.logosc.cn/">https://hao.logosc.cn/</a></p><h1 id="看视频"><a href="#看视频" class="headerlink" title="看视频"></a>看视频</h1><p>阿木影视： <a href="https://www.aosk.online/">https://www.aosk.online/</a><br>电影推荐（分类别致）：<a href="http://www.mvcat.com/">http://www.mvcat.com</a><br>APP影院：<a href="https://app.movie/">https://app.movie/</a><br>去看TV：<a href="https://www.qukantv.net/">https://www.qukantv.net/</a><br>动漫视频网：<a href="http://www.zzzfun.com/">http://www.zzzfun.com/</a><br>94神马电影网：<a href="http://www.9rmb.com/">http://www.9rmb.com/</a><br>NO视频官网：<a href="http://www.novipnoad.com/">http://www.novipnoad.com/</a><br>蓝光画质电影：<a href="http://www.languang.co/">http://www.languang.co/</a><br>在线看剧：<a href="http://dy.27234.cn/">http://dy.27234.cn/</a><br>大数据导航：<a href="http://hao.199it.com/">http://hao.199it.com/</a><br>多功能图片网站：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a><br>牛牛TV：<a href="http://www.ziliao6.com/tv/">http://www.ziliao6.com/tv/</a><br>VideoFk解析视频：<a href="http://www.videofk.com/">http://www.videofk.com/</a><br>蓝调网站：<a href="http://lcoc.top/vip2.3/">http://lcoc.top/vip2.3/</a><br>永久资源采集网：<a href="http://www.yongjiuzy1.com/">http://www.yongjiuzy1.com/</a></p><h1 id="学设计"><a href="#学设计" class="headerlink" title="学设计"></a>学设计</h1><p>码力全开（产品&#x2F;设计师&#x2F;独立开发者的资源库）： <a href="https://www.maliquankai.com/designnav/">https://www.maliquankai.com/designnav/</a><br>免费音频素材：<a href="https://icons8.cn/music">https://icons8.cn/music</a><br>新CG儿（视频素材模板，无水印+免费下载）：<a href="https://www.newcger.com/">https://www.newcger.com/</a><br>Iconfont（阿里巴巴矢量图标库）： <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a><br>小图标下载：<a href="https://www.easyicon.net/">https://www.easyicon.net/</a><br>Flight Icon：<a href="https://www.flighticon.co/">https://www.flighticon.co/</a><br>第一字体转换器：<a href="http://www.diyiziti.com/">http://www.diyiziti.com/</a><br>doyoudosh（平面设计）：<a href="http://www.doyoudo.com/">www.doyoudo.com</a><br>企业宣传视频在线制作：<a href="https://duomu.tv/">https://duomu.tv/</a><br>MAKE海报设计官网：<a href="http://maka.im/">http://maka.im/</a><br>一键海报神器：<a href="https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral">https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral</a><br>字由（字体设计）：<a href="http://www.hellofont.cn/">http://www.hellofont.cn/</a><br>查字体网站：<a href="https://fonts.safe.360.cn/">https://fonts.safe.360.cn/</a><br>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）： <a href="http://www.aigei.com/">http://www.aigei.com/</a><br>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor">https://bilibili.clipchamp.com/editor</a></p><h1 id="搞文档"><a href="#搞文档" class="headerlink" title="搞文档"></a>搞文档</h1><p>即书（在线制作PPT）：<a href="https://www.keysuper.com/">https://www.keysuper.com/</a><br>PDF处理：<a href="https://smallpdf.com/cn">https://smallpdf.com/cn</a><br>PDF处理：<a href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a><br>PDF处理： <a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a><br>PDF处理：<a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a><br>图片压缩，PDF处理：<a href="https://docsmall.com/">https://docsmall.com/</a><br>腾讯文档（在线协作编辑和管理文档）：<a href="http://docs.qq.com/">http://docs.qq.com</a><br>ProcessOn（在线协作制作结构图）：<a href="http://www.processon.com/">www.processon.com</a><br>iLovePDF（在线转换PDF利器）：<a href="http://www.ilovepdf.com/">www.ilovepdf.com</a><br>PPT在线制作：<a href="https://www.woodo.cn/">https://www.woodo.cn/</a><br>PDF24工具（pdf处理工具）：<a href="https://tools.pdf24.org/en">https://tools.pdf24.org/en</a><br>IMGBOT（在线图片处理）：<a href="http://www.imgbot.ai/">www.imgbot.ai</a><br>福昕云编辑（在线编辑PDF）：<a href="http://edit.foxitcloud.cn/">http://edit.foxitcloud.cn</a><br>TinyPNG（在线压缩图片）：<a href="http://tinypng.com/">http://tinypng.com</a><br>UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套<br>）：<a href="http://uzer.me/">http://uzer.me</a><br>优品PPT（模板下载）： <a href="http://www.ypppt.com/">http://www.ypppt.com/</a><br>第一PPT（模板下载）：<a href="http://www.1ppt.com/xiazai/">http://www.1ppt.com/xiazai/</a><br>三顿PPT导航：sandunppt.com<br>Excel函数表： <a href="https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188">https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188</a></p><h1 id="找图片"><a href="#找图片" class="headerlink" title="找图片"></a>找图片</h1><p>电脑壁纸：<a href="http://lcoc.top/bizhi/">http://lcoc.top/bizhi/</a><br><a href="https://unsplash.com/">https://unsplash.com/</a><br><a href="https://pixabay.com/">https://pixabay.com/</a><br><a href="https://www.pexels.com/">https://www.pexels.com/</a><br><a href="https://visualhunt.com/">https://visualhunt.com/</a><br><a href="https://www.ssyer.com/">https://www.ssyer.com/</a><br>彼岸图网：<a href="http://pic.netbian.com/">http://pic.netbian.com/</a><br>极像素（超高清大图）：<a href="https://www.sigoo.com/">https://www.sigoo.com/</a><br>免费版权图片搜索：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly页脚养鱼</title>
      <link href="/2022/04/04/Hexo-Butterfly%E9%A1%B5%E8%84%9A%E5%85%BB%E9%B1%BC/"/>
      <url>/2022/04/04/Hexo-Butterfly%E9%A1%B5%E8%84%9A%E5%85%BB%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<p>最终效果在本站页脚，向下滑动即可看到。</p><hr><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>参考文章一共介绍了两种方法，第一种是有针对于Butterfly主题的修改。第二种方法是通用方法（其他也主题可参考）</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>打开站点的主题配置文件_config.butterfly.yml，找到inject，在bottom处直接引入以下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li>找到footer.pug文件：\themes\butterfly\layout\includes\footer.pug，写入以下内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#jsi-flying-fish-container.container</span><br><span class="line">   script(src=&#x27;js/fish.js&#x27;)</span><br><span class="line">style.</span><br><span class="line"></span><br><span class="line">       @media only screen and (max-width: 767px)&#123;</span><br><span class="line">       #sidebar_search_box input[type=text]&#123;width:calc(100% - 24px)&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>点的主题配置文件_config.butterfly.yml，找到inject，在bottom处直接引入<a href="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js">https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>​        注意：引入的js文件需要依赖jquery，所以在之前如果没有引用过的就需要在bottom处的最开始引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>这样效果就出现了。但是引入之后页脚会过高，需要修改footer.styl文件：\themes\butterfly\source\css_layout\footer.styl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#footer</span><br><span class="line">  position: relative</span><br><span class="line">  background: $light-blue</span><br><span class="line">  background-attachment: local</span><br><span class="line">  background-position: bottom</span><br><span class="line">  background-size: cover</span><br><span class="line"></span><br><span class="line">  if hexo-config(&#x27;footer_bg&#x27;) != false</span><br><span class="line">    &amp;:before</span><br><span class="line">      position: absolute</span><br><span class="line">      width: 100%</span><br><span class="line">      height: 100%</span><br><span class="line">      background-color: alpha($dark-black, .1) </span><br><span class="line">      content: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#footer-wrap</span><br><span class="line">  position: absolute</span><br><span class="line">  padding: 1.2rem 1rem 1.4rem</span><br><span class="line">  color: var(--light-grey)</span><br><span class="line">  text-align: center</span><br><span class="line">  left: 0</span><br><span class="line">  right: 0</span><br><span class="line">  top: 0</span><br><span class="line">  bottom: 0</span><br><span class="line"></span><br><span class="line">  a</span><br><span class="line">    color: var(--light-grey)</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      text-decoration: underline</span><br><span class="line"></span><br><span class="line">  .footer-separator</span><br><span class="line">    margin: 0 .2rem</span><br><span class="line"></span><br><span class="line">  .icp-icon</span><br><span class="line">    padding: 0 4px</span><br><span class="line">    vertical-align: text-bottom</span><br><span class="line">    max-height: 1.4em</span><br><span class="line">    width auto</span><br></pre></td></tr></table></figure></li><li><p>参考文章的技术流程写到这里就结束了，如果还有页脚文字被遮挡的情况，可以修改页脚的透明度，在\themes\butterfly\source\css路径下创建一个xxx.css文件，在文件中添加如下代码：</p></li></ol><ul><li>页脚半透明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 页脚半透明 */</span><br><span class="line">#footer &#123;</span><br><span class="line">    background: rgba(255, 255, 255, 0);</span><br><span class="line">    color: #000;</span><br><span class="line">    border-top-right-radius: 20px;</span><br><span class="line">    border-top-left-radius: 20px;</span><br><span class="line">    backdrop-filter: saturate(100%) blur(5px)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer::before &#123;</span><br><span class="line">    background: rgba(255,255,255,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer #footer-wrap &#123;</span><br><span class="line">    color: var(--font-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer #footer-wrap a &#123;</span><br><span class="line">    color: var(--font-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页脚全透明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 页脚透明 */</span><br><span class="line">#footer &#123;</span><br><span class="line">    background: transparent !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后将该文件引入到inject的head处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>至此操作结束，去看看你的页脚有没有发生变化吧。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个更为简单的方法，引入带有颜色的页脚养鱼，效果如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/fish.png" alt="img"></p><p>只需要在_config.butterfly.yml文件中，找到inject，在bottom处直接引入：<a href="https://uuuuu.cf/js/fishes.js">https://uuuuu.cf/js/fishes.js</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script defer src=&quot;https://uuuuu.cf/js/fishes.js&quot;&gt;&lt;/script&gt; # 页脚养鱼(彩色)</span><br></pre></td></tr></table></figure><p>注意：该操作同样需要在之前引入jquery。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> Butterfly魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Butterfly魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARK方舟Windows ARK Server Manager开服教程</title>
      <link href="/2022/04/04/ARK%E6%96%B9%E8%88%9FWindows-ARK-Server-Manager%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/ARK%E6%96%B9%E8%88%9FWindows-ARK-Server-Manager%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h3><ul><li>内存：4G能满足游戏运行，不过容易卡顿，6G能稳定运行。推荐8G以上。</li><li>网络：2M~4M上行带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力，避免卡顿。</li><li>端口：默认UDP 777，UDP 27015</li></ul><h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><p>[官网下载](<a href="https://redirect.viglink.com/?format=go&amp;jsonp=vglnk_163763550743810&amp;key=71fe2139a887ad501313cd8cce3053c5&amp;libId=kwbhw0zk0102ylrr000DLkz08zkab&amp;loc=https://arkservermanager.freeforums.net/thread/5193/downloads?page=1&scrollTo=29985&amp;ccpaConsent=1---&amp;v=1&amp;out=https://raw.githubusercontent.com/Bletch1971/ServerManagers/master/ASM/latest.exe&amp;ref=https://arkservermanager.freeforums.net/&amp;title=Downloads">https://redirect.viglink.com/?format=go&amp;jsonp=vglnk_163763550743810&amp;key=71fe2139a887ad501313cd8cce3053c5&amp;libId=kwbhw0zk0102ylrr000DLkz08zkab&amp;loc=https%3A%2F%2Farkservermanager.freeforums.net%2Fthread%2F5193%2Fdownloads%3Fpage%3D1%26scrollTo%3D29985&amp;ccpaConsent=1---&amp;v=1&amp;out=https%3A%2F%2Fraw.githubusercontent.com%2FBletch1971%2FServerManagers%2Fmaster%2FASM%2Flatest.exe&amp;ref=https%3A%2F%2Farkservermanager.freeforums.net%2F&amp;title=Downloads</a> | ARK Server Manager&amp;txt&#x3D;Latest.exe)ARK Server Manager</p><p><a href="https://pan.wapriaily.com/index.php/s/L6W3QfDZL7oJH9b">国内下载</a>ARK Server Manager</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>新建一个ARK文件夹，把ARK Server Manager移动到文件夹内运行</li><li>安装完后启动ARK Server Manager，会提示缺少SteamCMD，一路确定就会自动安装SteamCMD</li><li>安装完SteamCMD后ARK Server Manager就打开了</li></ul><h3 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h3><ul><li>在右上角找到设置按钮，将语言设置为中文。</li><li>然后返回主界面新建配置文件</li><li>点击右边安装按钮等待安装</li></ul><h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><ul><li>首先需要在地图和MOD功能里选择地图</li><li>然后就可以更改服务器的名称</li><li>根据自己的服务器配置调整服务器端口以及最大玩家数量</li></ul><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><ul><li>配置好服务器后点击右上角开始按钮启动服务器即可</li><li>启动时间根据服务器配置而定，时间可能较长</li><li>如长时间没有启动成功，重新启动即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七日杀(7 Days to Die)Liunx开服教程</title>
      <link href="/2022/04/04/%E4%B8%83%E6%97%A5%E6%9D%80-7-Days-to-Die-Liunx%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/%E4%B8%83%E6%97%A5%E6%9D%80-7-Days-to-Die-Liunx%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G能满足正常进行游戏，内存越大，支持的人数越多。推荐8G以上。</li><li>网络：2M~4M上行带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 27000，TCP 27021，TCP 27020</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 或 Debian</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> update</span><br><span class="line">$ sudo apt-<span class="built_in">get</span><span class="built_in"> upgrade</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># CentOS</span></span><br><span class="line">$ yum update -y</span><br><span class="line">$ yum<span class="built_in"> upgrade </span>-y</span><br></pre></td></tr></table></figure><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><h3 id="首先添加一个单独的用户"><a href="#首先添加一个单独的用户" class="headerlink" title="首先添加一个单独的用户"></a>首先添加一个单独的用户</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>adduser <span class="number">7</span>dtd</span><br></pre></td></tr></table></figure><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> glibc.i686 libstdc++i686 -y</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ yum <span class="keyword">install</span> glibc.i686 libstdc++i686 -y</span><br></pre></td></tr></table></figure><h3 id="安装终端复用器"><a href="#安装终端复用器" class="headerlink" title="安装终端复用器"></a>安装终端复用器</h3><p>根据个人喜好安装其中一个</p><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> tmux</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt <span class="keyword">install </span><span class="keyword">screen</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#CentOS</span></span><br><span class="line">$ yum <span class="keyword">install </span><span class="keyword">screen</span></span><br></pre></td></tr></table></figure><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - <span class="number">7</span>dtd</span><br><span class="line">cd <span class="regexp">/home/</span>steam</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Tmux</span></span><br><span class="line"><span class="attribute">tmux</span> new -s <span class="number">7</span>dtd</span><br><span class="line"><span class="comment">#Screen</span></span><br><span class="line"><span class="attribute">screen</span> -s <span class="number">7</span>dtd</span><br></pre></td></tr></table></figure><h3 id="下载SteamCMD"><a href="#下载SteamCMD" class="headerlink" title="下载SteamCMD"></a>下载SteamCMD</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>steamcdn-a.akamaihd.net<span class="regexp">/client/i</span>nstaller/steamcmd_linux.tar.gz</span><br><span class="line">tar -xvzf steamcmd_liunx.tar.gz</span><br></pre></td></tr></table></figure><h3 id="下载服务端"><a href="#下载服务端" class="headerlink" title="下载服务端"></a>下载服务端</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./steamcmd.sh</span><br><span class="line">login anonymous</span><br><span class="line">force_install_dir <span class="regexp">/home/</span>steam/<span class="number">7</span>DaysToDieServer</span><br><span class="line">app_update <span class="number">294420</span> validate</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam/<span class="number">7</span>DaysToDieServer</span><br><span class="line">vi serverconfig.xml</span><br></pre></td></tr></table></figure><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/7DaysToDieServer</span></span><br><span class="line"><span class="string">./startserver.sh</span> -configfile=serverconfig.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>饥荒Liunx SteamCMD开服教程</title>
      <link href="/2022/04/04/%E9%A5%A5%E8%8D%92Liunx-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/%E9%A5%A5%E8%8D%92Liunx-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G能满足5个人左右正常游玩，4G够10个人左右，根据人数选服务器即可，大量MOD需要高配置的服务器。</li><li>网络：4M以上的带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 10998,TCP 10999</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">sudo yum-y <span class="keyword">install</span> glibc.i686 libstdc++i686</span><br></pre></td></tr></table></figure><h2 id="安装终端复用器"><a href="#安装终端复用器" class="headerlink" title="安装终端复用器"></a>安装终端复用器</h2><p>根据个人喜好安装其中一个</p><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> tmux</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt <span class="keyword">install </span><span class="keyword">screen</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#CentOS</span></span><br><span class="line">$ yum <span class="keyword">install </span><span class="keyword">screen</span></span><br></pre></td></tr></table></figure><h2 id="安装SteamCMD"><a href="#安装SteamCMD" class="headerlink" title="安装SteamCMD"></a>安装SteamCMD</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adduser dst</span><br><span class="line">su -dst</span><br><span class="line">cd /home/steam</span><br><span class="line">n-<span class="selector-tag">a</span><span class="selector-class">.akamaihd</span>.net/client/installer/steamcmd_linux<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">tar -xvzf steamcmd_liunx<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">./steamcmd.sh</span><br></pre></td></tr></table></figure><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br><span class="line">force_install_dir <span class="regexp">/home/</span>steam/dstserver</span><br><span class="line">app_update <span class="number">343050</span> validate</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>Liunx服务端的组件有错误，需要更改一下后启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>lib<span class="regexp">/libcurl.so.4  /</span>home<span class="regexp">/steam/</span>dstserver<span class="regexp">/bin/</span>lib32/libcurl-gnutls.so.<span class="number">4</span></span><br><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstserver/</span>bin</span><br><span class="line">echo <span class="string">&quot;./dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root /home/dstsave -conf_dir dst -cluster World1 -shard Master&quot;</span> &amp;gt; master_start.sh</span><br><span class="line">echo <span class="string">&quot;./dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root /home/dstsave -conf_dir dst -cluster World1 -shard Caves&quot;</span> &amp;gt; cave_start.sh</span><br><span class="line">chmod +x master_start.sh cave_start.sh</span><br><span class="line">.master_start.sh</span><br></pre></td></tr></table></figure><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>启动完后关闭进程</p><p>在&#x2F;home&#x2F;steam&#x2F;dstserver&#x2F;dst&#x2F;World1&#x2F;文件会生成默认的配置文件</p><p>接下来我们需要将电脑上的配置文件传到服务端上，有能力的可以直接在服务端更改配置即可</p><p>打开游戏，创建新的世界，配置好名词，描述，密码，地洞等</p><p>创建好世界后退出世界，返回主界面，点击左下角的游戏数据</p><p>找到Cluster_1文件夹（后面数字为创建的世界顺序）</p><p>打开文件夹后将所有文件上传到服务端的home&#x2F;steam&#x2F;dstserver&#x2F;dst&#x2F;World1&#x2F;目录</p><p>上传完后，在游戏主界面点击左下角的账号信息，点击查看我的游戏按钮</p><p>点击右上角Don’t Strave Together Servers</p><p>拉到最后输入Token名称，点击添加新的服务器，就会生成Token</p><p>复制Token，粘贴到服务端World1目录里的cluster_token.txt里，不会编辑的可以在本地电脑创建同名的txt文件上传替换即可</p><h2 id="启动世界"><a href="#启动世界" class="headerlink" title="启动世界"></a>启动世界</h2><p>依次启动主世界和洞穴，以下教程使用Tmux</p><h3 id="主世界"><a href="#主世界" class="headerlink" title="主世界"></a>主世界</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/steam/dstserver</span><br><span class="line">tmux new -s master</span><br><span class="line">./master_start.sh</span><br></pre></td></tr></table></figure><h3 id="洞穴"><a href="#洞穴" class="headerlink" title="洞穴"></a>洞穴</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmux -s cave</span><br><span class="line">./cave_start.sh</span><br></pre></td></tr></table></figure><p>启动完以上进程后就可以再游戏你们看到服务器了</p><h2 id="配置MOD"><a href="#配置MOD" class="headerlink" title="配置MOD"></a>配置MOD</h2><p>将World1文件夹里的modoverrides.lua文件打开</p><p>找到MOD们的workshop数字ID记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstserver/m</span>ods</span><br></pre></td></tr></table></figure><p>找到dedicated_server_mods_setup.lua文件并打开</p><p>在最后一栏注释上面将所有MOD以下面格式添加</p><p>ServerModSetup(“workshop数字ID”)</p><p>添加完后重启服务器MOD就配置完毕了</p><p>不会编辑的朋友可以将文件下载下来，编辑后上传即可</p><h2 id="配置服主管理员"><a href="#配置服主管理员" class="headerlink" title="配置服主管理员"></a>配置服主管理员</h2><p>点击主界面的账号信息</p><p>找到KLEI用户ID记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstsave/</span>dst<span class="regexp">/World1/</span></span><br><span class="line">vim adminlist.txt</span><br></pre></td></tr></table></figure><p>创建好txt文件后将KLEI用户ID输入后保存</p>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unturned未转变者Windows SteamCMD开服教程</title>
      <link href="/2022/04/04/Unturned%E6%9C%AA%E8%BD%AC%E5%8F%98%E8%80%85Windows-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/Unturned%E6%9C%AA%E8%BD%AC%E5%8F%98%E8%80%85Windows-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G以上即可，越高越好，根据期望用户量增加。</li><li>网络：2M以上的带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 27015</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip">点击下载</a>SteamCMD</p><p><a href="https://gsf-fl.softonic.com/3a8/2ff/6c396563e808aef56baa9e1ac9b34960d3/npp.8.1.9.Installer.exe?Expires=1637759025&Signature=f8fb1aaa36e1203e3d7094c455eea099b751b5c2&url=https://notepad-plus.en.softonic.com&Filename=npp.8.1.9.Installer.exe">点击下载</a>Notepad++</p><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><p>在桌面创建一个SteamCMD文件夹，将下载的SteamCMD压缩包解压进去</p><p>右键管理员启动SteamCMD等待下载安装</p><p>显示Steam&gt;时代表已经安装完毕</p><h2 id="使用SteamCMD安装"><a href="#使用SteamCMD安装" class="headerlink" title="使用SteamCMD安装"></a>使用SteamCMD安装</h2><p>若仅是个人开服请使用下方的Steam安装方法更加方便以及无需翻墙</p><p>  1.启动SteamCMD，以匿名用户登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br></pre></td></tr></table></figure><p>  2.安装服务端（时间比较久，大约1.7G，并且可能需要梯子，请注意日志）同时本指令可以用于以后的服务端更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_update 1110390</span><br></pre></td></tr></table></figure><p>  3.输入以下指令关闭SteamCMD（不建议直接叉掉）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><p>  4.现在你的服务端文件将存于<code>SteamCMD目录``/steamapps/common/U3DS</code>内</p><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>在SteamCMD\steamapps\common\U3DS\找到服务端启动Unturned.exe</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220408213735639.png" alt="image-20220408213735639"></p><p>显示这个界面即为运行完成，然后输入shutdown关闭服务器</p><p>第一次启动服务端是为了生成世界</p><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>在U3DS目录找到Servers文件夹，打开默认服务器文件夹Default</p><p>打开Server文件夹，会看到一个Commands.dat文件</p><p>使用Notepad++编辑该文件，按个人需求选填以下指令，当然不添加新的指令在原本的指令更改也可以。</p><table><thead><tr><th>配置代码</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>Name</td><td>服务器名称</td><td></td></tr><tr><td>Map</td><td>地图类型</td><td>默认PEI</td></tr><tr><td>Password</td><td>服务器密码</td><td>公开不填</td></tr><tr><td>Welcome</td><td>服务器欢迎语</td><td></td></tr><tr><td>Maxplayer</td><td>服务器人数</td><td>根据服务器配置填</td></tr><tr><td>Mode</td><td>服务器难度</td><td>可填Eazy,Normal,Hard</td></tr><tr><td>Perspective</td><td>服务器视角限制</td><td>可填First,Third,Both,Vehicle</td></tr><tr><td>PVE</td><td>开启PVE模式</td><td>留空为PVP</td></tr><tr><td>Cheats</td><td>服务器作弊模式</td><td>开True关False</td></tr><tr><td>Port</td><td>服务器端口</td><td>默认27015,更改需要开放端口</td></tr></tbody></table><p>或许你可能不知道这些代表着什么，下面介绍几个常用的</p><ul><li><p><strong>Map</strong> ——此类型可以选择地图<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map Russia</span><br></pre></td></tr></table></figure></li></ul><p>这样就是设置Russia地图了，默认不填写情况下是使用PEI地图</p><ul><li><p><strong>Port</strong> ——此类型选择你的服务器端口<br>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 23333</span><br></pre></td></tr></table></figure></li></ul><p>这样则是设置了使用23333端口，默认不填写情况下是使用27015 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请注意，在改版后，运行公共服务器（也就是Internet模式）需要向你的端口号+1来分别负责与服务器列表通信和与游戏流量传输，比如我使用23333端口来开服，此端口会用于游戏列表通信，23334端口来与客户端游戏通信，也就是会占用2个端口</span><br></pre></td></tr></table></figure><ul><li><p><strong>Name</strong> ——你的服务器名称（将会显示在服务器列表）<br>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name 你的服务器名称</span><br></pre></td></tr></table></figure></li><li><p><strong>Password</strong>——服务器密码，若填写上去并且后面写入字符将会要求提供密码才能加入服务器，一般不需要填写，也不用写上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Password 114514</span><br></pre></td></tr></table></figure></li></ul><p>这样就要求提供密码才能加入</p><ul><li><p><strong>Perspective</strong> ——视角限制，可以填入有<code>First</code>, <code>Third</code>, <code>Both</code>, <code>Vehicle</code>，分别对应仅限第一人称、仅限第三人称、任意、只能在驾驶载具时使用第三人称<br>示例;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perspective Both</span><br></pre></td></tr></table></figure></li></ul><p>这样就能够第一第三人称任意切换</p><ul><li><p><strong>Cheats</strong> ——作弊设置，可以填入的有<code>True</code>和<code>False</code>，分别对应开和关，打开后只能管理员作弊，关闭后管理员都不能作弊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cheats True</span><br></pre></td></tr></table></figure></li></ul><p>这样管理员就能作弊了(没有试过，具体功效不明)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name (服务器名字，不能有数字不能有字符名字必须大于五个字）</span><br><span class="line">password （密码）</span><br><span class="line">Map （地图）</span><br><span class="line">Maxplayers 8 （最大玩家数）</span><br><span class="line">Mode Normal （游戏难度）</span><br><span class="line">PVE（玩家间伤害，不填写则是默认为PVP）</span><br><span class="line">Port 25444 （端口）</span><br><span class="line">Cheats on （作弊是否开启）</span><br><span class="line">Perspective both （第一人称和第三人称的限制）</span><br><span class="line">Loadout 255/(id)  (服务器开局物品）</span><br><span class="line">Welcome （服务器欢迎语）</span><br></pre></td></tr></table></figure><p>配置完后保存，启动steamCMD\steamapps\common\U3DS\Unturned.exe文件</p><p>加载完毕我们就可以看到服务器了(记得放行上方配置文件配置的端口)</p><blockquote><p>部分人在连接服务器时会出现“未能初始化steam网络身份验证”（懒狗，没截图）得情况</p><p>这是因为steam在国内被墙，使用加速器加速steam即可</p></blockquote><h2 id="创意工坊"><a href="#创意工坊" class="headerlink" title="创意工坊"></a>创意工坊</h2><p>在SteamCMD\steamapps\common\U3DS\Servers\Default</p><p>咱们能看到WorkshopDownloadConfig.json文件</p><p>使用Notepad++编辑该文件添加你想要添加的创意工坊文件ID即可</p><h2 id="Rocket与OpenMod"><a href="#Rocket与OpenMod" class="headerlink" title="Rocket与OpenMod"></a>Rocket与OpenMod</h2><p>| Rocket是一种旧式的插件适配框架，OpenMod是新出的插件框架，Rocket具有更多的插件，OpenMod具有更好的兼容性，两者可以同时使用</p><h3 id="Rocket安装方法"><a href="#Rocket安装方法" class="headerlink" title="Rocket安装方法"></a>Rocket安装方法</h3><ol><li>打开服务端文件夹（非服务器文件夹），找到<code>Extras</code>目录，将其中的<code>Rocket.Unturned</code>文件复制</li><li>返回上一级，找到<code>Modules</code>文件夹，将其粘贴在文件夹内即可完成安装</li></ol><h3 id="OpenMod安装方法"><a href="#OpenMod安装方法" class="headerlink" title="OpenMod安装方法"></a>OpenMod安装方法</h3><p>OpenMod有两种安装方法，一种是通过Rocket安装，还有一种是手动安装</p><h5 id="通过Rocket安装OpenMod"><a href="#通过Rocket安装OpenMod" class="headerlink" title="通过Rocket安装OpenMod"></a>通过Rocket安装OpenMod</h5><ol><li>在<a href="https://github.com/openmod/OpenMod.Installer.RocketMod/releases/">此处</a>下载OpenMod安装程序插件</li><li>将dll文件移动至<code>/Rocket/Plugins</code>文件夹下并且重启服务端</li><li>重启服务器端后在窗口内输入&#x2F;openmod install并且按照其说明进行安装即可</li><li>安装完毕后您可以在<a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https://openmod.github.io/openmod-docs/userdoc/concepts/plugins.html">此处</a>查看OpenMod的插件安装方法</li></ol><h5 id="通过离线安装OpenMod"><a href="#通过离线安装OpenMod" class="headerlink" title="通过离线安装OpenMod"></a>通过离线安装OpenMod</h5><ol><li>在<a href="https://github.com/openmod/OpenMod/releases/latest">此处</a>下载最新的OpenMod模块，名字通常为<code>OpenMod.Unturned.Module-vX.X.X.zip</code></li><li>将压缩包中的<code>OpenMod.Unturned</code>文件夹复制到Unturned安装目录中的<code>Modules</code>文件夹中</li><li>启动你的服务器，第一次启动需要一段时间，因为 OpenMod 会下载所需的核心组件</li><li>安装完毕后您可以在<a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https://openmod.github.io/openmod-docs/userdoc/concepts/plugins.html">此处</a>查看OpenMod的插件安装方法</li></ol><h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><h3 id="Rocket插件安装方法"><a href="#Rocket插件安装方法" class="headerlink" title="Rocket插件安装方法"></a>Rocket插件安装方法</h3><p>只需要将dll文间移至<code>/Rocket/Plugins</code>文件夹并重启服务器端即可，而后的内容请参考插件手册</p><h3 id="OpenMod插件安装方法"><a href="#OpenMod插件安装方法" class="headerlink" title="OpenMod插件安装方法"></a>OpenMod插件安装方法</h3><ul><li>您可以通过<a href="https://www.nuget.org/packages?q=openmod-plugin">NuGet市场</a>或<a href="https://openmod.github.io/openmod-plugins/search">OpenMod插件列表</a>来查找您所需的插件</li><li>您可以在OpenMod插件列表直接点击<strong>COPY INSTALL COMMAND</strong>按钮来获得安装命令，将其复制在服务器窗口中并回车即可安装</li><li>在NuGet市场中找到您心仪的插件时，您只需要输入<code>openmod install &lt;package id&gt;</code>来安装插件或输入<code>openmod install &lt;package id&gt;@&lt;version&gt;</code>来安装特定版本，以及可以输入<code>openmod install &lt;package id&gt; -Pre</code>来安装测试版（记得去除掉&lt;&gt;）</li><li>输入<code>openmod install &lt;package id&gt;</code>来更新插件</li><li>您也可以下载好插件以及所需库后将其放置到<code>/openmod/plugins</code>文件夹来手动安装插件，当然如果只有dll也可以通过<code>openmod install &lt;package id&gt;</code>来安装所需库，如果需要更新请自行替换dll</li><li>手动安装的插件需要自行删除dll文件，在线安装的插件可以通过<code>openmod remove &lt;package id&gt;</code>来卸载插件</li><li>在安装、删除、更新插件后都需要输入<code>openmod reload</code>来重新加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux上搭建QQ搜图机器人——基于go-cqhttp和cq-picsearcher-bot</title>
      <link href="/2022/03/22/%E5%9C%A8linux%E4%B8%8A%E6%90%AD%E5%BB%BAQQ%E6%90%9C%E5%9B%BE%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ego-cqhttp%E5%92%8Ccq-picsearcher-bot/"/>
      <url>/2022/03/22/%E5%9C%A8linux%E4%B8%8A%E6%90%AD%E5%BB%BAQQ%E6%90%9C%E5%9B%BE%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ego-cqhttp%E5%92%8Ccq-picsearcher-bot/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系统：CentOS</p><p>文中服务器已安装<a href="https://www.bt.cn/download/linux.html">宝塔Linux面板</a>，并以其演示</p><p>FinalShell  SHH终端</p><p>主要用到的程序 <a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> 和 <a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">cq-picsearcher-bot</a></p><p><a href="https://github.com/Mrs4s/go-cqhttp">https://github.com/Mrs4s/go-cqhttp</a></p><p><a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">https://github.com/Tsuk1ko/cq-picsearcher-bot</a></p></blockquote><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget git screen nodejs</span><br></pre></td></tr></table></figure><h2 id="创建目录，并到该目录下"><a href="#创建目录，并到该目录下" class="headerlink" title="创建目录，并到该目录下"></a>创建目录，并到该目录下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir go-cqhttp &amp;&amp; cd go-cqhttp</span><br></pre></td></tr></table></figure><h2 id="下载-go-cqhttp"><a href="#下载-go-cqhttp" class="headerlink" title="下载 go-cqhttp"></a>下载 go-cqhttp</h2><p>先下载该项目程序：</p><p><a href="https://github.com/Mrs4s/go-cqhttp/releases">https://github.com/Mrs4s/go-cqhttp/releases</a></p><p>一般默认选 go-cqhttp_linux_amd64.tar.gz 作为我们 amd64 架构服务器用到的程序（arm 架构系统选用 arm64）</p><ul><li>Windows 下 32 位文件为 go-cqhttp-v*-windows-386.zip</li><li>Windows 下 64 位文件为 go-cqhttp-v*-windows-amd64.zip</li><li>Windows 下 arm 用 (如使用高通 CPU 的笔记本) 文件为 go-cqhttp-v*-windows-arm.zip</li><li>Linux 下 32 位文件为 go-cqhttp-v*-linux-386.tar.gz</li><li>Linux 下 64 位文件为 go-cqhttp-v*-linux-amd64.tar.gz</li><li>Linux 下 arm 用 (如树莓派) 文件为 go-cqhttp-v*-linux-arm.tar.gz</li><li>MD5 文件为 *.md5 , 用于校验文件完整性</li><li>如果没有你所使用的系统版本或者希望自己构建，请移步 进阶指南 - 如何自己构建</li></ul><p>然后在服务器上下载这个压缩包</p><p>解压该压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf [文件名]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/go-cqhttp.png"></p><p>解压完只有这三个文件。</p><p>然后输入以下命令，回车</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./go-cqhttp</span><br></pre></td></tr></table></figure><p>选择第二个 ws，输入数字 2 回车即可（你甚至可以全部选择，输入 1234 回车）然后生成 config.yml 以后可以 <code>ctrl+c</code> 终止进程</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322140753738.png" alt="image-20220322140753738"></p><h2 id="配置-go-cqhttp"><a href="#配置-go-cqhttp" class="headerlink" title="配置 go-cqhttp"></a>配置 go-cqhttp</h2><p>宝塔中刷新目录，然后会发现多出了个 <code>config.yml</code> 文件，打开然后编辑</p><p>主要就是填入 QQ 账号和密码，别的都不用管</p><p>然后 Save 保存文件即可</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322141236497.png" alt="image-20220322141236497"></p><h2 id="加载-go-cqhttp"><a href="#加载-go-cqhttp" class="headerlink" title="加载 go-cqhttp"></a>加载 go-cqhttp</h2><p>然后再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./go-cqhttp</span><br></pre></td></tr></table></figure><p>如图即正常加载了</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322142536140.png" alt="image-20220322142536140"></p><p>当然，估计你因为异地登录会让你输入滑块验证码反馈</p><p>查看宝塔面板go-cqhttp目录，会生成一张二维码图片，打开手机QQ扫码登陆即可</p><p>或另一种解决方案：<a href="https://docs.go-cqhttp.org/faq/slider.html">https://docs.go-cqhttp.org/faq/slider.html</a></p><p>那么这时候按照他的指示，复制网址到浏览器打开，然后先不要拖动滑块，先按 F12 打开开发者工具</p><p>选择 network，抓取 <code>ticket</code> 字段，并黏贴到 ssh 里要求输入的地方，即可通过。</p><h2 id="安装部署-qc-picsearcher-bot"><a href="#安装部署-qc-picsearcher-bot" class="headerlink" title="安装部署 qc-picsearcher-bot"></a>安装部署 qc-picsearcher-bot</h2><p>然后ctrl c 退出登录。</p><p>回到上级目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>到cq-picsearcher-bot下载最新的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Tsuk1ko/cq-picsearcher-bot &amp;&amp; cd cq-picsearcher-bot &amp;&amp; cp config.default.jsonc config.jsonc</span><br></pre></td></tr></table></figure><p>下载完毕之后，再输入指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i </span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>config.jsonc 文件需要配置的地方太多了，而且根据每个人不同的习惯都各不相同，这个还请自行配置，参考官方配置文档：</p><p><a href="https://github.com/Tsuk1ko/cq-picsearcher-bot/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">https://github.com/Tsuk1ko/cq-picsearcher-bot/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E</a></p><p>其中几个地方都需要配置 api 才能使用，如 saucenao 和 setu 功能 </p><p>因为要用到saucenao的搜图，要注册拿到api key</p><p>注册：<a href="https://saucenao.com/user.php">https://saucenao.com/user.php</a>?</p><p>api key: <a href="https://saucenao.com/user.php?page=search-api">https://saucenao.com/user.php?page=search-api</a></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20210330233614736.png" alt="img"></p><p>复制，粘贴到cq-picsearcher-bot目录中的config.jsonc文件中。（拉到最下面）</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20210330233943367.png" alt="img"></p><h2 id="启动-qc-picsearcher-bot"><a href="#启动-qc-picsearcher-bot" class="headerlink" title="启动 qc-picsearcher-bot"></a>启动 qc-picsearcher-bot</h2><p>配置完成后先启动 go-cqhttp 再运行本程序 ！</p><p>回到go-cqhttp目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">cd go-cqhttp</span><br><span class="line"></span><br><span class="line">//启动后台登录</span><br><span class="line"></span><br><span class="line">nohup ./go-cqhttp &gt; /dev/null 2&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>回到cq-picsearcher-bot目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .. </span><br><span class="line">cd cq-picsearcher-bot</span><br></pre></td></tr></table></figure><p>然后输入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322143158880.png" alt="image-20220322143158880"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm stop</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm restart</span><br></pre></td></tr></table></figure><h3 id="查看日志（平时日志也会保存在-logs-文件夹内）"><a href="#查看日志（平时日志也会保存在-logs-文件夹内）" class="headerlink" title="查看日志（平时日志也会保存在 logs 文件夹内）"></a>查看日志（平时日志也会保存在 logs 文件夹内）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run log</span><br></pre></td></tr></table></figure><h2 id="食用"><a href="#食用" class="headerlink" title="食用"></a>食用</h2><ul><li>私聊<ul><li>直接发送图片即可</li></ul></li><li>群组<ul><li>@ 机器人并发送图片</li><li>回复某人（也可以是自己）发送的图片，在消息中 @ 机器人</li></ul></li><li>可以在同一条消息中包含多张图片，会自动批量搜索</li><li>搜索图片时可以在消息内包含以下参数来指定搜索范围或者使用某项功能，参数之间除 –debug 外互斥，优先级从上到下<ul><li>–get-url：获取图片的在线链接（不会搜图）</li><li>–all：全库搜索（默认）</li><li>–pixiv：从 P 站中搜索</li><li>–danbooru：从 Danbooru 中搜索</li><li>–doujin：搜索本子</li><li>–anime：搜索番剧</li><li>–a2d：使用 ascii2d 进行搜索（优势搜索局部图能力较强）</li><li>–debug：调试，会在控制台中输出搜图时网络请求的内容</li></ul></li><li>对于 saucenao<ul><li>如果得到的结果相似度低于 60%（可配置），会自动使用 ascii2d 进行搜索（可配置）</li><li>如果额度耗尽，会自动使用 ascii2d 进行搜索（可配置）</li><li>如果搜索到本子，会自动在 nhentai 中搜索并返回链接（如果有汉化本会优先返回汉化本链接）</li><li>如果搜到番剧，会自动使用 WhatAnime 搜索番剧详细信息<ul><li>AnimeDB 与 WhatAnime 的结果可能会不一致，是正常现象，毕竟这是两个不同的搜索引擎</li><li>同时展示这两个搜索的目的是为了尽力得到你可能想要的识别结果</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> bot </category>
          
          <category> qqx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bot </tag>
            
            <tag> qq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + GitHub搭建个人图床</title>
      <link href="/2022/03/12/PicGo%20+%20GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/03/12/PicGo%20+%20GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="配置GtiHub"><a href="#配置GtiHub" class="headerlink" title="配置GtiHub"></a>配置GtiHub</h2><p>新建仓库</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312230017936.png"></p><p>这里需要注意：仓库得设置为 Public 。因为后面通过客户端访问算是外部访问，因此无法访问 Private ，这样的话图片传上来之后只能存储不能显示。</p><p>仓库建好之后，点击页面右上角，进入 Settings：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211350596.png" alt="image-20220426211350596"></p><p>然后进入 Developer settings：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/O%40%7DH%5D%7D%7B%7EYV8D6%7E%24%7BLGAF96A.png"></p><p>点击 Personal access tokens，再点 Generate new token 新建 token</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211239697.png" alt="image-20220426211239697"></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211253151.png" alt="image-20220426211253151"></p><p>填写 Notes 信息，选择 token 过期时间，为了安全，GitHub 会强烈建议不要设置成永久。这个大家根据自己实际情况选择，到期之后重新生成即可。</p><p>复选框的话，repo 一定要全选，其他的无所谓，我是都勾选了。</p><p>确定之后，就生成我们需要的 token 了。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211453791.png" alt="image-20220426211453791"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>下载 PicGo：点击<a href="https://link.segmentfault.com/?enc=Ptgik6w7iSuBHgEgu5ndyA==.OxB/dUe4VpLBJtUlwtNy8DWnb+AJo1LHGidh20qqXVQNEQbpfnvA7chetn/FaQuN">下载地址</a>，然后安装。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312230958908.png"></p><ul><li>设定仓库名：上文在 GitHub 创建的仓库。</li><li>设定分支名：main。</li><li>设定 Token：上文生成的 token。</li><li>指定存储路径：为空的话会上传到跟目录，也可以指定路径。</li></ul><p>配置完成后就可以使用了。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231444544.png"></p><p>直接拖拽，或者点击上传都可以。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231619090.png"></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231643155.png"></p><p>最后，在相册里复制外链，粘贴到我们的 markdown 文档中，就可以看到图片了。</p><h2 id="Typora关联PicGo粘贴图片自动上传"><a href="#Typora关联PicGo粘贴图片自动上传" class="headerlink" title="Typora关联PicGo粘贴图片自动上传"></a>Typora关联PicGo粘贴图片自动上传</h2><p>打开设置———偏好设置</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211924526.png" alt="image-20220426211924526"></p><p>选择图像——在上传服务设定一栏中上传服务选择PicGo、路径选择PicGo安装路径</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426212043248.png" alt="image-20220426212043248"></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joplin与坚果云搭建免费云盘</title>
      <link href="/2022/03/12/Joplin%E4%B8%8E%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E7%9B%98/"/>
      <url>/2022/03/12/Joplin%E4%B8%8E%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><h2 id="Joplin"><a href="#Joplin" class="headerlink" title="Joplin"></a>Joplin</h2><p>一款开源的、支持自定义同步服务器、多平台支持的makedown笔记。<br>joplin官网<a href="https://joplinapp.org/">https://joplinapp.org/</a><br>第一眼看到joplin发现布局很像印象笔记，就决定用来代替印象笔记了。<br>功能上当然没有印象笔记多，但是基本的makedown、标签、全笔记搜索、目录结构、多平台、云同步还是有的。<br>编辑功能少了一点，但是开源可以进行二次开发，也不知道有没有朋友已经在开发了。</p><h2 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h2><p>一款国内的云存储服务，主要支持<a href="https://so.csdn.net/so/search?q=webdav&spm=1001.2101.3001.7020">webdav</a>可以供joplin实现云同步。<br>可以创建免费用户，每个月有1G上传和3G下载的流量，对于笔记来说应该是很够的了，速度对于笔记来讲也是足够的。</p><h2 id="搭建开始"><a href="#搭建开始" class="headerlink" title="搭建开始"></a>搭建开始</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>注册坚果云账户，在根目录创建一个joplin云储存的文件夹。</p><p><img src="https://img-blog.csdnimg.cn/20200624221255552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><h3 id="步骤2-创建webdav应用"><a href="#步骤2-创建webdav应用" class="headerlink" title="步骤2     创建webdav应用"></a>步骤2     创建webdav应用</h3><p>点击右上角的用户头像进入账户信息页面</p><p><img src="https://img-blog.csdnimg.cn/20200624221430930.png"></p><p>选择安全选项，右下方添加应用（我的已经添加了）</p><p><img src="https://img-blog.csdnimg.cn/20200624221558205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>现在我们有了webdav三个内容：服务器地址，账户，密码</p><h3 id="步骤3-下载安装joplin（想要哪个平台下哪个）"><a href="#步骤3-下载安装joplin（想要哪个平台下哪个）" class="headerlink" title="步骤3 下载安装joplin（想要哪个平台下哪个）"></a>步骤3 下载安装joplin（想要哪个平台下哪个）</h3><h3 id="步骤4-joplin接入云同步"><a href="#步骤4-joplin接入云同步" class="headerlink" title="步骤4 joplin接入云同步"></a>步骤4 joplin接入云同步</h3><p>点击 工具 -》 选项 -》 同步，按照如下填写webdav账户信息，这里需要注意网站后面要加上在坚果云创建的文件夹名字&#x2F;joplin</p><p><img src="https://img-blog.csdnimg.cn/20200624221944862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>点击 检查同步配置，成功之后，就可以通过ctrl+s把文件同步上去了</p><p><img src="https://img-blog.csdnimg.cn/20200624222108517.png"></p><p>其他平台类似方法接入同一个webdav即可时间多设备云同步。<br>我们同步完成之后，坚果云joplin文件夹下便存放我们的笔记内容</p><p><img src="https://img-blog.csdnimg.cn/20200624222508898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>.md后缀是我们的文本笔记<br>笔记里面的图片、附件等内容则在resources</p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青龙面板批量部署依赖库</title>
      <link href="/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>把常见的依赖库都给它装上去，免得以后运行其他羊毛脚本的时候提示各种错误。</p><p>这里分享下<a href="https://unfall.top/tags/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/">青龙面板</a>的部署教程《<a href="https://unfall.top/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/">青龙面板自动领JD京豆</a>》，再此基础上部署依赖库。再此基础上部署依赖库。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看青龙面板 Docker 是否正常运行，记下青龙 Docker 的容器名字，如果是按照缙哥哥的部署教程操作，那么默认的名称就是<code>qinglong</code></p><p><img src="https://img.dujin.org/uploads/2021/12/20211219214338.png"></p><p>输入一键安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it qinglong bash</span><br></pre></td></tr></table></figure><p>如果你的青龙容器不叫<code>qinglong</code>，那自己替换为相应的容器名字。</p><p>安装依赖命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/shufflewzc/QLDependency/main/Shell/QLOneKeyDependency.sh | sh</span><br></pre></td></tr></table></figure><p>然后慢慢等就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> JD </tag>
            
            <tag> 青龙面板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青龙面板自动领JD京豆</title>
      <link href="/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/"/>
      <url>/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/</url>
      
        <content type="html"><![CDATA[<p>青龙面板是一个多功能的可视化面板，本教程利用青龙面板来自动执行京东领京豆，做东东农场任务签到浇水免费领水果，京喜牧场养小鸡收集鸡蛋，京东极速版金币，京东赚赚领金币，东东萌宠喂养。同时还能自动领取京东红包、京喜红包、京东极速版红包……</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ol><li>需要一台服务器，最好是国内的，毕竟你是在国内使用京东购物，挂机服务器在海外太过明显。</li><li>全新安装 CentOS操作系统，并放开 22、5600 端口，如果想安装宝塔，则额外放开 888、8888 端口。</li></ol><h1 id="安装青龙面板"><a href="#安装青龙面板" class="headerlink" title="安装青龙面板"></a>安装青龙面板</h1><p>通过 SSH 连接服务器，安装 Docker 环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>启动 Docker（下方第一行），并设置 Docker 开机自动启动 （下方第二行） 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>直接执行下方代码拉取镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull whyour/qinglong:latest</span><br></pre></td></tr></table></figure><p>如果你是群辉之类的 NAS 安装青龙镜像，在 Dockers 官方镜像列表中拉取最新版的青龙镜像，直接使用 Dockers 搜索镜像<code>qinglong</code>即可。</p><p>接着部署青龙面板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">-v $PWD/ql/config:/ql/config \</span><br><span class="line">-v $PWD/ql/log:/ql/log \</span><br><span class="line">-v $PWD/ql/db:/ql/db \</span><br><span class="line">-p 5600:5600 \</span><br><span class="line">--name qinglong \</span><br><span class="line">--hostname qinglong \</span><br><span class="line">--restart always \</span><br><span class="line">whyour/qinglong:latest</span><br></pre></td></tr></table></figure><h1 id="初始化青龙面板"><a href="#初始化青龙面板" class="headerlink" title="初始化青龙面板"></a>初始化青龙面板</h1><p>部署完成后，直接访问<code>IP:5600</code>访问青龙面板的安装界面。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184333.png"></p><p>直接开始安装进入下一步。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184403.png"></p><p>这里可以根据你自己的喜欢设置通知方式，比如每天22:00告诉你今天领取了多少京豆、多少金币、多少红包……当然，你也可以直接跳过该步骤。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184443.png"></p><p>设置管理员账号密码，这是初始化安装青龙面板最重要的步骤，当然，如果你不小心忘了，或者说不明原因没有进入这个配置页面，也没有关系，可以通过 SSH 执行下方命令查看账号及密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it qinglong cat /ql/config/auth.json</span><br></pre></td></tr></table></figure><h1 id="配置青龙面板定时任务"><a href="#配置青龙面板定时任务" class="headerlink" title="配置青龙面板定时任务"></a>配置青龙面板定时任务</h1><p>青龙面板本身不具备京东脚本的功能，只是一个管理和执行相应脚本的可视化平台。为了使其能够完成媷羊毛的功能，接下来使用青龙面板拉去一些库，使其自动更新一些功能。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184720.png"></p><p>登录面板后选择<code>定时任务</code>→<code>添加任务</code>。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216185453.png"></p><h1 id="京东定时任务库"><a href="#京东定时任务库" class="headerlink" title="京东定时任务库"></a>京东定时任务库</h1><p>下方整理 GitHub 上的一些任务库，通过添加任务，并设置定时规则，使其自动拉取、更新羊毛任务。</p><p><strong>KingRan&#x2F;KR（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/KingRan/KR.git &quot;jd_|jx_|jdCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|function|sign|sendNotify|ql|JDJR&quot;</span><br></pre></td></tr></table></figure><p><strong>Curtinlv 仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/curtinlv/JD-Script.git</span><br></pre></td></tr></table></figure><p><strong>Zy143L&#x2F;wskey（wskey转换库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/Zy143L/wskey.git &quot;wskey&quot;</span><br></pre></td></tr></table></figure><p><strong>smiek2121（开卡库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo ql repo https://github.com/smiek2121/scripts.git &quot;jd_|gua_&quot; &quot;&quot; &quot;ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js|cleancart_activity.js|jdCookie.js|sendNotify.js&quot;</span><br></pre></td></tr></table></figure><p><strong>Yun-City&#x2F;City（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/Yun-City/City.git &quot;jd_|jx_|gua_|jddj_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|function|utils|sendnotify|ZooFaker_Necklace|jd_Cookie|JDJRValidator_|sign_graphics_validate|ql|magic|cleancart_activity&quot;</span><br></pre></td></tr></table></figure><p><strong>6dylan6&#x2F;jdpro（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/6dylan6/jdpro.git &quot;jd_|jx_|jddj_&quot; &quot;backUp&quot; &quot;^jd[^_]|USER|JD|function|sendNotify&quot;</span><br></pre></td></tr></table></figure><p><strong>gys619&#x2F;Absinthe（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/gys619/Absinthe.git &quot;jd_|jx_|jddj_|gua_|getJDCookie|wskey&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|ZooFaker_Necklace|JDJRValidator_|sign_graphics_validate|jddj_cookie|function|ql|magic|JDJR|JD&quot; &quot;main&quot;</span><br></pre></td></tr></table></figure><p><strong>zero205&#x2F;JD_tencent_scf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/zero205/JD_tencent_scf.git &quot;jd_|jx_|jdCookie&quot; &quot;backUp|icon&quot; &quot;^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql&quot; &quot;main&quot;</span><br></pre></td></tr></table></figure><p><strong>龙珠</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/whyour/hundun.git &quot;quanx&quot; &quot;tokens|caiyun|didi|donate|fold|Env&quot;</span><br></pre></td></tr></table></figure><p>为了防止漏掉某些羊毛，<strong>上方所有的库</strong>新建定时任务拉取，里面有重复脚本禁用脚本，重复的内容会被禁用的。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216185930.png"></p><h1 id="定时规则"><a href="#定时规则" class="headerlink" title="定时规则"></a>定时规则</h1><p>这里的定时规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">秒 分 时 天 月 周</span><br></pre></td></tr></table></figure><p>各个单位之间分别以空格分割，假设该任务需要每天12:23:45执行一次。那么则应该这么设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 23 12 * * *</span><br></pre></td></tr></table></figure><p>拉完之后记得运行，不运行的话要等到你设置好的时间才会自动执行。运行后会自动拉去一些执行活动的脚本</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216190140.png"></p><h1 id="获取京东Cookie"><a href="#获取京东Cookie" class="headerlink" title="获取京东Cookie"></a>获取京东Cookie</h1><p>使用 Chrome 内核浏览器（比如 Google 浏览器、Edge 浏览器、360 极速浏览器……），打开开发者模式（快捷键：F12），打开 Network（网络）标签，浏览器当前页面访问京东移动端登录地址<code>m.jd.com</code>，按照提示登录你的京东账号，复制你的京东账号 Cookie，也就是下图所示内容：</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216214832.png"></p><p>然后打开青龙面板，选择<code>环境变量</code>→<code>添加变量</code>，名称为<code>JD_COOKIE</code>，值为刚复制的京东账号<code>Cookie</code>，备注自己填方便识别，别的不需要动。添加后点<code>确定</code>就可以，如果需要添加多个账号，只需要获取多个Cookie添加上去就可以了，名称仍然为<code>JD_COOKIE</code>。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216190257.png"></p><p>添加好京东账号 Cookie 之后就可以去执行脚本了，如果等不及想尝试，可以自己触发脚本运行，否则就会在相应的时间执行。</p><p>顺带一说，Cookie 值并不需要这么多，只需要里面的<code>pt_key</code>与<code>pt_pin</code>两个就行了，懂的人自行提取，不懂的人全部复制粘贴上去。</p><p><strong>温馨提醒：</strong>不要频繁的去执行，避免黑号。还有就是建议京东账号绑定微信，有个活动抽奖抽到微信红包会自动提现到微信钱包。</p><h1 id="开启京东游戏任务"><a href="#开启京东游戏任务" class="headerlink" title="开启京东游戏任务"></a>开启京东游戏任务</h1><p>建议把所有活动游戏都点击一次，京东工厂这种需要自己选产品的建议自己选，不然会自动选一个，有的干脆不选。这里给大家说下各个游戏入口位置：</p><p>京东APP</p><ul><li><p>摇钱树：京东APP→右下角我的→中间更多工具</p></li><li><p>东东萌宠：京东APP→右下角我的</p></li><li><p>宠汪汪：京东APP→右下角我的</p></li><li><p>东东农场：京东APP→右下角我的</p></li><li><p>京喜工厂：惊喜APP→右下角我的</p></li><li><p>京喜牧场：惊喜APP→右下角我的</p></li><li><p>京喜财富岛：惊喜APP→右下角我的</p></li><li><p>发财大赢家：京东极速版→右下角我的</p></li><li><p>汪汪乐园：京东极速版→右下角我的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> JD </tag>
            
            <tag> 青龙面板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访客地图</title>
      <link href="/2022/03/10/%E8%AE%BF%E5%AE%A2%E5%9C%B0%E5%9B%BE/"/>
      <url>/2022/03/10/%E8%AE%BF%E5%AE%A2%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="访客地图"><a href="#访客地图" class="headerlink" title="访客地图"></a>访客地图</h1><p>前往 clustrmaps 网站注册一个帐号。</p><p>找到 Free Tools下面的 Website Widget, 点击 Get Map Widget。</p><p>输入你的博客网址，点击Next。根据你自己的喜好选择样式Map widget 或 Globe Widget。</p><p>找到如下代码，记住 src (** 的部分):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; id=&quot;clstr_globe&quot; src=&quot;**********************&quot;&gt;</span><br></pre></td></tr></table></figure><p>在 <strong>themes\Butterfly\layout\includes\widget</strong>文件夹新建<strong>card_map.pug</strong>文件，文件内容如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-map</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_map&#x27;)</span><br><span class="line">    script#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;此处填入你自己的代码&quot;)</span><br></pre></td></tr></table></figure><p>编辑 <strong>themes\Butterfly\layout\includes\widget\index.pug</strong> 文件，在你想要显示的位置插入以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!=partial(&#x27;includes/widget/card_map&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>（切记：如果主题版本大于3.6，请务必将**{cache:theme.fragment_cache}** 改为 { **cache:true }**）：</p><p>编辑_config.butterfly.yml 文件，在<strong>card_webinfo</strong> 下面添加一行<strong>card_map: true</strong></p><p>编辑<strong>themes\Butterfly\languages\zh-CN.yml</strong>文件 (请根据你的网站语言选择)，找到<strong>card_announcement:</strong> 公告 , 在下面添加一行<strong>card_map: 访客地图</strong> (后面的文本可自定义),繁体字方法一样，修改<strong>themes\Butterfly\languages\zh-TW.yml</strong>文件就行。</p><p>如果不想显示，直接把 <strong>_config.butterfly.yml</strong>文件的<strong>card_map: true</strong> 改为 <strong>card_map: false</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> Butterfly美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pixie日推</title>
      <link href="/2022/03/08/pixie%E6%97%A5%E6%8E%A8/"/>
      <url>/2022/03/08/pixie%E6%97%A5%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pixie日推"><a href="#pixie日推" class="headerlink" title="pixie日推"></a>pixie日推</h1><blockquote><p>注意： <a href="https://cloud.mokeyjay.com/pixiv">https://cloud.mokeyjay.com/pixiv</a> 使用的是<a href="https://www.mokeyjay.com/">超能小紫</a>提供的服务，也可以自行搭建，搭建方式请看这里-&gt;<a href="https://www.mokeyjay.com/archives/1063">传送门</a></p></blockquote><h2 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h2><ol><li><p>在 <strong>themes\Butterfly\layout\includes\widget</strong>文件夹新建card_pixiv.pug 文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-pixiv</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-image(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_pixiv&#x27;)</span><br><span class="line">    iframe(src=&quot;https://cloud.mokeyjay.com/pixiv&quot; frameborder=&quot;0&quot; style=&quot;width:99%;height:380px;margin:0;&quot;)</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>themes\Butterfly\layout\includes\widget\index.pug</strong> 文件，在你想要显示的位置插入以下代码（注意要对齐还有不要有空格符）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_pixiv</span><br><span class="line">       !=partial(&#x27;includes/widget/card_pixiv&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>butterfly.yml</strong> 文件，在 <strong>card_webinfo</strong> 下面添加一行 <strong>card_pixiv: true</strong></p></li><li><p>编辑 <strong>themes\Butterfly\languages\zh-CN.yml</strong> 文件 (请根据你的网站语言选择)，找到 <strong>card_announcement:</strong> 公告 , 在下面添加一行 <strong>card_pixiv: Pixiv日榜Top50</strong>(后面的文本可自定义)</p></li><li><p>如果不想显示，直接把 <strong>butterfly.yml</strong> 文件的 <strong>card_pixiv: true</strong> 改为 <strong>card_pixiv: false</strong> 即可</p></li></ol><blockquote><p><strong>文章来自转载：</strong></p><p><strong>文章作者:</strong> <a href="mailto:undefined">bt-sonny</a></p><p><strong>文章链接:</strong> <a href="https://chuchendjs.github.io/posts/BY-MOchange/">https://chuchendjs.github.io/posts/BY-MOchange/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Butterfly美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/01/hello-world/"/>
      <url>/2022/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
