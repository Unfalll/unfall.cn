<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IDEA如何进行debug调式</title>
      <link href="/2022/10/27/idea%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Cdebug%E8%B0%83%E5%BC%8F/"/>
      <url>/2022/10/27/idea%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Cdebug%E8%B0%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>🍃第一步，设断点，打开debug<br>        设断点是什么意思，其实就是暂定，等待的意思。当程序执行到用户设置的断点时，程序暂定执行，等待下一步命令的执行。在IDEA中只需在代码注释行旁边单击鼠标左键即可。</p><p><img src="https://img-blog.csdnimg.cn/20210313160439567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 在IDEA中，我们不光可以设置断点，还可以为该断点添加条件，比如在如下实例中，设置条件为i &#x3D; 5。此时断点样式右下角会有一个疑问符号，表示该断点是被赋予条件的。意思是程序直接执行到i &#x3D; 5 时才暂定执行，等待下一步命令执行。</p><p><img src="https://img-blog.csdnimg.cn/20210313160701862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210313160744697.png" alt="在这里插入图片描述"></p><p> 给断点添加条件有快捷键（shift + ctrl + F8)。在使用快捷键时，有一个小细节，你的鼠标一定要放在断点红色代码这一行中，否者快捷键按的就不是给断点添加条件，而是查看所有断点，如下，因为他们的快捷键是一样的，区别在于鼠标的光标的位置，在断点处所在行就是给断点添加条件，在非断点处所在行就是查看所有断点。</p><p><img src="https://img-blog.csdnimg.cn/20210313162623826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 当你已经把断点设置好了，便可以打开debug调试了。打开的方式有很多，在IDEA中，我们可以在最上面的工具栏中选择Run中的Debug打开；也可以选择右上角的Debug图标打开；还可以在代码里面单击鼠标右键选择Debug调试。</p><p>🌱方式一</p><p><img src="https://img-blog.csdnimg.cn/20210313161605916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>🌱方式二</p><p><img src="https://img-blog.csdnimg.cn/20210313161640701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>🌱方式三</p><p><img src="https://img-blog.csdnimg.cn/20210313161716855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>🍃第二步，使用Debug调试的功能键<br>我们先来了解Debug栏中位于左侧的主要的5个功能键。</p><p><img src="https://img-blog.csdnimg.cn/20210313163238903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e0b3c08643674757a04c87313645118d.png" alt="在这里插入图片描述"> 第一个，<strong>有返回箭头的按钮</strong>，功能是重新执行Debug，当你在执行Debug一半时，发行并不能解决你的问题，这时你不需要重新关闭并打开Debug，按下此按钮，Debug调试会重新执行。</p><p><img src="https://img-blog.csdnimg.cn/4b1e05dddc884bc081691603b040b2e8.png" alt="在这里插入图片描述">第二个，一个竖杠加向右的三角形的按钮，功能是跳到下一次断点执行，两个断点之间的代码都被加载执行过了。<br>        但是当一个断点在一个for循环中，如果循环有n（n&gt;&#x3D;1)次，for循环外有一个断点，此时该功能是跳过一次for循环，并不是跳过所有循环而直接到下一个断点，那么如果先要跳过所有循环可以将断点暂时不启用，也就是将enabled去掉，因为enable是启用断点的意思。</p><p><img src="https://img-blog.csdnimg.cn/7ccaad02a56547b397c77e4e8787e096.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/70d5f59e1b064cbb94ad855926b2376c.png" alt="在这里插入图片描述">第三个，<strong>一个红色的正方块的按钮</strong>，功能是结束Debug 的执行。按下之后，整个Debug调试都会将结束并停止执行。</p><p><img src="https://img-blog.csdnimg.cn/2182e49f429042e999bc5c61ee86085f.png" alt="在这里插入图片描述">第四个，<strong>两个重叠的红色圆圈的按钮</strong>，功能是查看所有的断点。快捷键是（<code>shift + ctrl + F8</code>)，至于它的用法在上面将给断点添加条件时已讲述</p><p><img src="https://img-blog.csdnimg.cn/99c886098c424fda8ddeb9fd8fd27464.png" alt="在这里插入图片描述">第五个，<strong>一个红色的圆圈中有一个灰色的斜杠的按钮</strong>，功能是隐藏所有的Debug断点。用途就是，当你在Debug调试时，你觉得此时已经没有问题了，这时可以暂时隐藏所有Debug断点，无障碍运行一次，如果有问题还要取消隐藏，不至于重新打开Debug。</p><hr><p><img src="https://img-blog.csdnimg.cn/20210313165959224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7896c70e72ee4970b577880b6e42e445.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是将你的光标移动到当前代码所执行处，不管此刻你的鼠标光标的位置在哪里。</p><p><img src="https://img-blog.csdnimg.cn/d6560aba1d724a49bfe146d014d2b275.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是单步跳入。Debug调试是一行一行的执行下去，但是如果遇到调用方法时，是不会进入方法里面的。</p><p><img src="https://img-blog.csdnimg.cn/24370a73d82748c09b78aae3e18b119d.png" alt="在这里插入图片描述"><strong>按钮</strong> 与<img src="https://img-blog.csdnimg.cn/2b3dde9fd1754f4694014ed23a644ed4.png" alt="在这里插入图片描述"><strong>按钮</strong>，因为功能相似，放在一起讲。两个的功能都是单步进入的执行，但唯一的区别是，<strong>蓝色向下箭头</strong>的按钮遇到方法时，只有当经过的方法时用户自定义的方法才会跳进去，如果是系统自定的方法则不会跳进去。而<strong>红色向下箭头</strong>的按钮，不管是系统自定义的方法还是用户自定义的方法都会跳入到方法里面去执行</p><p><img src="https://img-blog.csdnimg.cn/5db0e6408e7740b7b454e8c9408bf910.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是单步跳出。可以跳出进入的方法。</p><p><img src="https://img-blog.csdnimg.cn/e0b04dcb721049499a52cf9e82d15675.png" alt="在这里插入图片描述"><strong>按钮</strong>，功能是将当前执行的位置直接执行到用户指定鼠标光标的位置。</p><hr><p>接下来就是最后一个功能区，如下图片，详细解释。</p><p><img src="https://img-blog.csdnimg.cn/202103131719500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21qaDE2NjcwMDIwMTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_oopPLUS</title>
      <link href="/2022/10/10/Java-oopPLUS/"/>
      <url>/2022/10/10/Java-oopPLUS/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="枚举类-1"><a href="#枚举类-1" class="headerlink" title="枚举类"></a>枚举类</h3><p>实例（也叫对象）有限且固定不变的类，在Java里被称为枚举类。</p><p>枚举类是一种特殊的类，它一样可以有自己的成员变量、方法，可以实现一个或多个接口，也可以有自己的构造器。</p><p>枚举类的对象只能是有有限个且是确定的。比如说星期类：星期一到星期日；性别类：男女</p><p><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>枚举类对象的属性不应允许被改动，所以应该使用private，final修饰</li><li>枚举类的使用private final修饰的属性应该在构造器中为其赋值</li><li>若枚举类显式的定义了带参数的构造器，则在列出枚举值时，也必须对应的传入参数</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li><p>枚举类默认继承 java.lang.Enum 类，而不是 Object 类，因此枚举类不能显示继承其他父类。</p></li><li><p>使用 enum 定义的非抽象的枚举类默认会使用 final 修饰，因此非抽象枚举类不能派生子类（即不能被继承) </p><blockquote><p>final关键字回顾：final修饰的类不能被继承、修饰的方法不能被重写、修饰的属性其值不能改变。</p></blockquote></li><li><p>枚举类的构造器只能使用 private 访问控制符，如果忽略访问控制符的话，则默认使用 private 修饰；如果强制指定其他的访问控制符（例如public、procted等）,则会报错。</p></li><li><p>枚举类的所有实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不可能产生实例。列出的这些实例，系统会自动给它们加上 public static final 修饰。枚举类的实例以逗号分隔，分号结束，这些列出的枚举值代表了该枚举类的所有可能的实例。</p></li></ol><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><p>自定义枚举类的步骤</p><ol><li>私有化类的构造器，保证无法在类的外部创建对象；</li><li>类内部创建枚举类的实例，声明为<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a> static final</li><li>对象若有实例变量，声明为private final，并在构造器中初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name,String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = name;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enum定义枚举类"><a href="#enum定义枚举类" class="headerlink" title="enum定义枚举类"></a>enum定义枚举类</h3><ol><li>使用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li><li>枚举类的构造器只能使用private权限修饰符</li><li>枚举类的所有实例必须再枚举类中显式列出（, 分隔  ;  结尾）列出的实例系统会自动添加public static final 修饰</li><li>必须在枚举类的第一行声明枚举类对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SeasonEnum</span> <span class="variable">seasonEnum</span> <span class="operator">=</span> SeasonEnum.SPRING;</span><br><span class="line">        System.out.println(seasonEnum);</span><br><span class="line">        System.out.println(seasonEnum.getClass().getSuperclass());<span class="comment">//class java.lang.Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SeasonEnum</span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象，对象之间使用，分开，最后一个使用：</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String name,String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = name;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSEASONDESC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONDESC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSEASONNAME</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONNAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SeasonEnum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li><li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</li><li>toString()：返回当前枚举类对象常量的名称</li><li>ordinal();  得到当前枚举常量的次序</li><li></li></ul><p>以上enum定义枚举类为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSeason</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//没有重写枚举类里的.toString()，直接打印的是枚举对象的名称，不是地址值，因为枚举类的父类不是Object</span></span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN);</span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getSEASONNAME());</span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getSEASONDESC());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取AUTUMN的对象代表的类</span></span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getClass());</span><br><span class="line">        <span class="comment">//获取AUTUMN的对象代表的枚举类父类【父类是Enum类，而非Object】</span></span><br><span class="line">        System.out.println(SeasonEnum.AUTUMN.getClass().getSuperclass());</span><br><span class="line">        <span class="comment">//ordinal得到当前枚举常量的次序</span></span><br><span class="line">        System.out.println( SeasonEnum.AUTUMN.ordinal() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取枚举类里所有的对象</span></span><br><span class="line">        SeasonEnum[] values = SeasonEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (SeasonEnum season : values) &#123;</span><br><span class="line">            System.out.println(season);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将字符串AUTUMN转化为枚举类里的对象</span></span><br><span class="line">        <span class="type">SeasonEnum</span> <span class="variable">autumn</span> <span class="operator">=</span> SeasonEnum.valueOf(<span class="string">&quot;AUTUMN&quot;</span>);</span><br><span class="line">        System.out.println(autumn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报错</span></span><br><span class="line">        <span class="type">SeasonEnum</span> <span class="variable">autumn2</span> <span class="operator">=</span> SeasonEnum.valueOf(<span class="string">&quot;autumn&quot;</span>);</span><br><span class="line">        System.out.println(autumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;秋天&#x27;</span>, SEASONDESC=<span class="string">&#x27;秋高气爽&#x27;</span>&#125;</span><br><span class="line">秋天</span><br><span class="line">秋高气爽</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.unfall.Enum.SeasonEnum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Enum</span><br><span class="line"><span class="number">2</span></span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;春天&#x27;</span>, SEASONDESC=<span class="string">&#x27;春暖花开&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;夏天&#x27;</span>, SEASONDESC=<span class="string">&#x27;夏日炎炎&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;秋天&#x27;</span>, SEASONDESC=<span class="string">&#x27;秋高气爽&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;冬天&#x27;</span>, SEASONDESC=<span class="string">&#x27;白雪皑皑&#x27;</span>&#125;</span><br><span class="line">SeasonEnum&#123;SEASONNAME=<span class="string">&#x27;秋天&#x27;</span>, SEASONDESC=<span class="string">&#x27;秋高气爽&#x27;</span>&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: No <span class="keyword">enum</span> <span class="title class_">constant</span> com.unfall.Enum.SeasonEnum.autumn</span><br><span class="line">at java.lang.Enum.valueOf(Enum.java:<span class="number">238</span>)</span><br><span class="line">at com.unfall.Enum.SeasonEnum.valueOf(Enumerstion02.java:<span class="number">19</span>)</span><br><span class="line">at com.unfall.Enum.TestSeason.main(TestSeason.java:<span class="number">33</span>)</span><br></pre></td></tr></table></figure><h3 id="实现接口枚举类"><a href="#实现接口枚举类" class="headerlink" title="实现接口枚举类"></a>实现接口枚举类</h3><ul><li>和普通Java类一样，枚举类可以实现一个或多个接口</li><li>若每个枚举类在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li></ul><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></blockquote><p>注解(Annotation):对代码的描述, 作为代码形式保留下来,</p><p>Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>注释: 类似超市商品下面的标签, 描述商品 方便给顾客查看的</p><p>注解: 类似商品的条形码, 描述商品, 方便后期商品结算</p><p>注解的本质: 特殊的接口</p><p>声明注解: 创建了一个特殊接口</p><p>使用注解: @注解名(创建注解的一个对象)</p><ol><li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等 </li><li>跟踪代码依赖性，实现替代配置文件功能。比如Spring的注入，未来java开发，将大量注解配置，具有很大用处; 后期学习框架大量使用, 基于注解的开发 </li><li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>提供信息给编译器：编译器可直接通过注解探测错误和警告信息，例如：@Override，@Deprecated</li><li>编译阶段时的处理：软件工具可以用来利用注解信息生成代码、html文档或者做其他相应处理，例如：@Param，@Return，@See，@Author用于生成javadoc文档</li><li>运行时的处理：某些注解可以在程序运行时接收代码的提取，但注解本身不是代码的一部分</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><p>内置注解：jdk定义好这个注解的声明，开发者直接使用，语法检查</p><ol><li><p>@Override 检测重写</p></li><li><p>@Deprecated 已过时, 只是一个标志, 还是能够使用</p></li><li><p>@SuppressWarnings(“all”) 抑制编译器生成警告信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">        demo2.fun1(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//2022 - 1970 = 52  1900 ~ 1999</span></span><br><span class="line">        System.out.println(d.getYear()); <span class="comment">//2022  122</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> <span class="keyword">extends</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    <span class="comment">//重写Demo1的</span></span><br><span class="line">   <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a  声明了方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  声明方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元注解:jdk定义好这个注解的声明, 在注解上使用</p><ol><li><p>@Documented-注解是否将包含在JavaDoc中</p><p>一个简单的Annotations标记注解，表示是否将注解信息添加在javadoc文档中</p></li><li><p>@Retention –什么时候使用该注解</p><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间</p></li><li><p>@Target–注解用于什么地方</p><p>默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括 ● ElementType.CONSTRUCTOR:用于描述构造器 ● ElementType.FIELD:成员变量、对象、属性（包括enum实例） ● ElementType.LOCAL_VARIABLE:用于描述局部变量 ● ElementType.METHOD:用于描述方法 ● ElementType.PACKAGE:用于描述包 ● ElementType.PARAMETER:用于描述参数 ● ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p></li><li><p>@Inherited – 定义该注释和子类的关系</p><p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个注解接口</span></span><br><span class="line"><span class="comment"> *  使用元注解对自定义的注解进行一些声明,说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">//表示该MyAnnotation1注解将会在生成doc文档上出现</span></span><br><span class="line"><span class="comment">//跟注解的参数赋值: 如果数组类型</span></span><br><span class="line"><span class="meta">@Target(value=&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span>    <span class="comment">//目标: 表示这个MyAnnotation1注解在那些地方使用</span></span><br><span class="line">            <span class="comment">// 如果没有写, 表示这个注解在任意的地方使用</span></span><br><span class="line"><span class="meta">@Retention(value= RetentionPolicy.RUNTIME)</span> <span class="comment">//自定义注解,保留期一定是Runtime</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 表示这个MyAnnotation1这个注解标记的类, 这个类的子类是否继承父类该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation1</span>  <span class="comment">//创建了MyAnnotation1的一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> stuno;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@MyAnnotation1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">( <span class="type">int</span> stuno, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuno = stuno;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStuno</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stuno;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStuno</span><span class="params">(<span class="type">int</span> stuno)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuno = stuno;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">SubStudent</span> <span class="keyword">extends</span>  <span class="title class_">Student</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ol><li>自定义注解: 关键字@interface , 默认继承Annotation接口, 本质就是一个接口</li><li>参数成员访问修饰符: public 或者是缺省的(还是public), 参数名后面必须是()</li></ol><p>参数本质就是一个抽象方法</p><p>但是我们可以使用注解的时候,给参数赋值, 在声明的时候, 设置默认值</p><p>参数名() default 值;</p><p>如果一个参数没有设置default默认值, 使用这个注解的时候, 一定要给参数赋值,</p><p>如果使用default, 使用注解的时候, 可以给参数赋值,也可以不赋值(使用默认值)</p><ol><li>参数的数据类型: 八大基本数据类型,String, 枚举,Class,注解类型,或者12种的数组类型</li><li>自定义的注解,可以有参数,也可以没有参数, 如果没有参数,这个注解没有意义</li><li>自定义注解,它的功能, 必须写代码解析注解,并给它赋予功能,自定义注解保留期: 一定为RUNTIME, 获取该注解的对象, 只能使用反射来获取</li></ol><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>声明注解的语法: @interface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line"><span class="comment">//成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用注解:</p><p>在方法,类型,包,构造方法,属性,参数… 使用注解</p><p>@注解名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(value=&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Annotation1 &#123;</span><br><span class="line"> <span class="comment">//成员参数</span></span><br><span class="line"> <span class="comment">// value参数有一个默认值, 这个方法默认返回值</span></span><br><span class="line"> <span class="comment">//给这个参数赋值, 就是设置这个方法的返回值</span></span><br><span class="line"> String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"> SexEnum <span class="title function_">sex</span><span class="params">()</span> <span class="keyword">default</span> SexEnum.MAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line"> MAN,WOMAN</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Annotation1(value=&quot;lisi&quot;,sex=SexEnum.WOMAN)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池</p><p>　这个运行时生成的动态代理对象是可以导出到文件的，方法有两种</p><ul><li>在代码中加入System.setProperty(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);</li><li>在运行时加入jvm 参数 -Dsun.misc.ProxyGenerator.saveGeneratedFiles&#x3D;true</li></ul><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>什么是异常：程序执行过程中的<strong>不正常</strong>情况。</li><li>异常的作用：增强程序的 **<code>健壮性</code>**。</li></ul><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException(&quot;/ by zero&quot;);</span></span><br><span class="line">        <span class="comment">// 并且JVM将new的异常对象抛出，打印输出信息到控制台了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;/&quot;</span> + b + <span class="string">&quot;=&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处运行也会创建一个：ArithmeticException类型的异常对象。</span></span><br><span class="line">        System.out.println(<span class="number">100</span> / <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的捕获和处理"><a href="#异常的捕获和处理" class="headerlink" title="异常的捕获和处理"></a>异常的捕获和处理</h3><p>设计时如果已经预测到某部分代码在执行时可能会产生异常就应当对这块代码进行异常的捕获及相应的处理。<br>如果异常未被捕获，那么程序执行到此就结束了，对于用户来讲就感到莫名其妙。<br>捕获和处理异常的语句是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Try&#123;</span><br><span class="line">       可能会出异常的语句块;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型参数 参数名)&#123;<span class="comment">//异常类型要与产生的异常类型匹配，匹配是指符合向上转型的条件，catch可以有多个</span></span><br><span class="line">   处理异常的语句块</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   释放资源;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>,b = <span class="number">0</span>;</span><br><span class="line">    cal(a, b);<span class="comment">//接受cal方法抛出的异常，后面的代码不执行，把异常抛给jvm，异常信息是jvm打印的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main方法产生异常后&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法会产生异常</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a/b;<span class="comment">//此处抛异常，直接抛给main，后面的代码不执行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;cal方法产生异常后&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上try语句</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = a/b;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>异常分为 <strong><code>编译时异常</code></strong> 和 **<code>运行时异常</code>**。</p><p>所有异常都是在 <strong><code>运行阶段</code></strong> 发生的。因为只有程序运行阶段才可以 <strong>new</strong>对象。</p><p>因为异常的发生就是 **<code>new异常对象</code>**。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221011160943919.png" alt="image-20221011160943919"></p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20210503143543377.png" alt="在这里插入图片描述"></p><ul><li>Exception的直接子类：<strong>编译时异常</strong>（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</li><li>RuntimeException：<strong>运行时异常</strong>。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</li></ul><h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><ol><li>catch后面的小括号中的类型可以是 **<code>具体的异常类型</code>**，也可以是该异常类型的 **<code>父类型</code>**。</li><li>catch可以写<strong>多个</strong>。建议catch的时候，<strong>精确的一个一个处理</strong>。这样有利于程序的调试。</li><li>catch写多个的时候，<strong>从上到下</strong>，必须遵守 **<code>从小到大</code>**。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Download\\Javabean-addperson案例解析.docx&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Download\\Javabean-addperson案例解析.docx&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;<span class="comment">// 多态：Exception e = new FileNotFoundException();</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Download\\Javabean-addperson案例解析.docx&quot;</span>);</span><br><span class="line">    fis.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;读文件报错了！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String <strong>getMessage</strong>()</td><td>返回异常的详细详细信息</td></tr><tr><td>void <strong>printStackTrace</strong>()</td><td>追踪堆栈异常信息(采用异步线程)</td></tr></tbody></table><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>在finally子句中的代码是最后执行的，并且是 <strong><code>一定会执行</code></strong> 的，即使try语句块中的代码出现了异常。</p><p><strong>finally</strong>子句必须和<strong>try</strong>一起出现，不能单独编写。</p><p>通常在finally语句块中完成 **<code>资源的释放/关闭</code>**。</p><h3 id="try-catch-finally之间的关系"><a href="#try-catch-finally之间的关系" class="headerlink" title="try catch finally之间的关系"></a>try catch finally之间的关系</h3><ol><li>try 可以与catch或finally搭配使用，try{}catch{} try{}finally{}</li><li>Catch 不能没有try，它不能单独有。try没有发生异常，catch不会执行</li><li>Finally 也不能没有try，它也不能单独用。</li><li>如果有finally，无论异常是否被catch处理，finally中的语句都会执行，哪怕在catch中有return，finally都会执行</li></ol><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li>如果没有发生异常，则执行try中的语句，不执行catch中的语句，如果有finally，最后还需要执行finally中的语句</li><li>如果出现异常，则try中异常发生后，try块剩下的语句不再执行，将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。因此需要自定义异常</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>编写一个类<strong>继承</strong> <strong><code>Exception</code></strong> 或者 <strong><code>RuntimeException</code></strong>.</li><li>提供两个 <strong><code>构造方法</code><strong>，一个</strong>无参数</strong>的，一个<strong>带有String参数</strong>的。</li></ol><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="comment">//自定义的异常类    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewException</span> <span class="params">(msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种用法：直接在一个判断语句下throw该异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NewException</span>(<span class="string">&quot;我是抛出的新异常！&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种：throws之后，再try——catch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span><span class="keyword">throws</span> NewException&#123;</span><br><span class="line">    <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NewException</span>(<span class="string">&quot;我是抛出的新异常！&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NewException e)&#123;</span><br><span class="line">            System.out,println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="throw-amp-thorows"><a href="#throw-amp-thorows" class="headerlink" title="throw &amp; thorows"></a>throw &amp; thorows</h3><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法生命处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><hr><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p> java是一门面向对象的语言，但是8中基本数据类型不具备面向对象的特征，所以实际使用中很不便所以为java八种基本数据类型提供了对应的包装类。</p><table><thead><tr><th>基本数据类型</th><th>对应包装类</th><th>包装类的父类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr></tbody></table><ol><li>对应包装类比较特殊的就是int对应的Integer和char对应的Character；</li><li>对应包装类的直接父类：前6个由于是数，直接父类为Number，而后两个的直接父类就是Object类；</li></ol><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p>静态方法 valueOf()</p><ul><li><p>参数为基本数据类型，返回包装类对象；</p></li><li><p>参数为String字符串（Character类没有以String为 参数的该方法）,返回包装类对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*1.参数为基本数据类型</span></span><br><span class="line"><span class="comment"> * 作用：将基本数据类型转换为对应包装类 * */</span></span><br><span class="line">Integer i=Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">System.out.println(i);<span class="comment">//输出10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.参数为String字符串时，</span></span><br><span class="line"><span class="comment"> * 作用：返回指定字符串值的包装类对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">Integer a=Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">Integer b=Integer.valueOf(<span class="string">&quot;100a&quot;</span>)为</span><br><span class="line">System.out.println(b);<span class="comment">//运行错误，字符串的值不少一个int类型的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态方法parseXXX(String str)</p><ul><li><p>Character类没有该方法；</p></li><li><p>作用：将字符串装换为对应的基本数据类型（注意此处和上面的valueOf方法返回值的不同）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*作用：将给定字符串装换为对应的基本数据类型</span></span><br><span class="line"><span class="comment"> * 前提是该字符串必须正确描述该基本数据类型表示的值*/</span></span><br><span class="line"><span class="type">int</span> a=Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b=Integer.parseInt(<span class="string">&quot;100a&quot;</span>);</span><br><span class="line">System.out.println(b);<span class="comment">//运行错误，字符串的值不为int类型</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>非静态方法XXXValue()</p><ul><li><p>因为是非静态方法，所以不能像上面两个方法用类名调用了；</p></li><li><p>数字类的包装类（八种包装类中父类是Number的的六个类）才有该方法；</p></li><li><p>作用：将当前包装类对象转换为对应的基本数据类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*作用：将包装类对象转换为对应的基本数据类型*/</span></span><br><span class="line"></span><br><span class="line">Integer a=Integer.valueOf(<span class="number">100</span>);<span class="comment">//将基本数据类型转换为包装类对象</span></span><br><span class="line"><span class="type">int</span> b=a.intValue();<span class="comment">//将包装类对象转换为对应的基本数据类型</span></span><br><span class="line">System.out.println(b);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">Double c=Double.valueOf(<span class="number">2.33</span>);</span><br><span class="line"><span class="type">double</span> d=c.doubleValue();</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>jdk1.5之后的新特性。该特性是编译器认可的，是在编译器自动将基本数据类型和包装类相互转换，节省了麻烦。</p><ol><li><strong>自动拆箱 包装类——&gt;基本数据类型</strong> (原理是调用了xxxValue方法)  </li><li><strong>自动装箱</strong> <strong>基本数据类型——&gt;包装类</strong> (原理是调用了valueOf方法)</li></ol><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*自动装箱：valueOf*/</span></span><br><span class="line">Integer i=<span class="number">123</span>;<span class="comment">//原理是 Integer i=Integer.valueOf(123);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*自动拆箱*/</span></span><br><span class="line"><span class="type">int</span> i1=i+<span class="number">1</span>;<span class="comment">//原理是int i1=i.intValue()+1;</span></span><br><span class="line"></span><br><span class="line">Integer a=<span class="number">123</span>;</span><br><span class="line">Integer b=<span class="number">123</span>;</span><br><span class="line">Integer c=a+b;</span><br><span class="line"><span class="comment">/*原理为Integer c=Integer.valueOf(a.intValue()+b.intValue());*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueOf-源码"><a href="#valueOf-源码" class="headerlink" title="valueOf()源码"></a>valueOf()源码</h3><ul><li>通过按住Ctrl键，鼠标点击该方法即可查看源码，以Integer类的valueOf(int i)的源码为例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>*<em>关于源码的理解：Integer类的valueOf(int i)方法首先会判断i是否在*</em>-128~127**之间，如果在的话，就返回的对象是Integer类中*<em>静态数组*</em>*<em>cache*<em>中的对象，如果不是在这之间，就会重写创建一个新的对象。</em></em></li></ul><p><strong>通过查看其它类的该方法的源码之后，可以得到该表：</strong></p><table><thead><tr><th>包装类</th><th>valueOf（X i）返回对象的原则</th></tr></thead><tbody><tr><td>byte</td><td>直接取，数组范围内（-128，127），且byte值的范围也是（-128，127）</td></tr><tr><td>Shout</td><td>（-128，127）之间在数组中取，否则new</td></tr><tr><td>Integer</td><td>（-128，127）之间在数组中取，否则new</td></tr><tr><td>Long</td><td>（-128，127）之间在数组中取，否则new</td></tr><tr><td>Folut</td><td>直接new</td></tr><tr><td>Double</td><td>直接new</td></tr><tr><td>Boolean</td><td>直接返回，不new</td></tr><tr><td>Character</td><td>0-127之间从数组中取，否则new</td></tr></tbody></table><hr><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><p>String表示<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>类型，属于 **<code>引用数据类型</code>**，不属于基本数据类型。</p></li><li><p>在java中随便使用 <strong><code>双引号括起来</code></strong> 的都是String对象。</p></li><li><p>String对象用于保存字符串，也就是一组字符序列</p></li><li><p>“jack”字符串常量，双引号括起的字符序列</p></li><li><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p></li><li><p>java中规定，双引号括起来的字符串，是 不可变 的，也就是说”abc”自出生到最终死亡，不可变，不能变成”abcd”，也不能变成”ab”</p></li><li><p>在JDK当中双引号括起来的字符串，例如：“abc” “def”都是直接存储在“方法区”的“字符串常量池”当中的。</p></li><li><p>String类有很多构造器，构造器的重载</p></li><li><p>String类实现了</p><ol><li>接口Serializable【String可以串行化：可以在网络传输】</li><li>接口Comparable 【String 对象可以比较大小】</li></ol></li><li><p>String 是final类，不能被其他类继承</p></li><li><p>String 有属性private final char value[]; 用于存放字符串内容</p></li><li><p>value是一个final类型，不可以修改：即value不能指向新的地址，但是单个字符内容是可以变化的</p></li><li><p>为什么SUN公司把字符串存储在一个“字符串常量池”当中呢？</p><p>因为字符串在实际的开发中使用太频繁。为了执行效率，所以把字符串放到了方法区的字符串常量池当中。</p></li></ol><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span> + <span class="string">&quot;xy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析：这是使用new的方式创建的字符串对象。这个代码中的&quot;xy&quot;是从哪里来的？</span></span><br><span class="line">        <span class="comment">// 凡是双引号括起来的都在字符串常量池中有一份。</span></span><br><span class="line">        <span class="comment">// new对象的时候一定在堆内存当中开辟空间。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221013151915385.png" alt="image-20221013151915385"></p><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// &quot;hello&quot;是存储在方法区的字符串常量池当中</span></span><br><span class="line">        <span class="comment">// 所以这个&quot;hello&quot;不会新建。（因为这个对象已经存在了！）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// == 双等号比较的是变量中保存的内存地址</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// == 双等号比较的是变量中保存的内存地址</span></span><br><span class="line">        System.out.println(x == y); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221013152046138.png" alt="image-20221013152046138"></p><h3 id="实例化两种方式"><a href="#实例化两种方式" class="headerlink" title="实例化两种方式"></a>实例化两种方式</h3><ol><li><p>通过字面量定义的方式</p><ol><li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;通过字面量定义的方式:此时数据abc声明在方法区中的字符串常量池中<br>    String s1&#x3D;”abc”;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 通过new + 构造器() 的方式</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      //通过new+构造器的方式: 此时s1保存的地址值，是数据在堆空间中开辟以后对应的地址值</span><br><span class="line">              String s1 = new String(&quot;abc&quot;);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221018155302762.png" alt="image-20221018155302762"></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th>构造方法名</th><th>eg。</th></tr></thead><tbody><tr><td>String s &#x3D; “xxx”</td><td>最常用</td></tr><tr><td>String(String original)</td><td>String(“xxx”)</td></tr><tr><td>String(char数组)</td><td></td></tr><tr><td>String(char数组，起始下标，长度)</td><td></td></tr><tr><td>String(byte数组)</td><td></td></tr><tr><td>String(byte数组，起始下标，长度)</td><td></td></tr><tr><td>String(StringBuffer buffer)</td><td></td></tr><tr><td>String(StringBuilder builder)</td><td></td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//最常用的方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;我是中国人&quot;</span>;</span><br><span class="line">        System.out.println(s1);<span class="comment">//我是中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我是中国人&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">//我是中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c = &#123;<span class="string">&#x27;我&#x27;</span> , <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;果&#x27;</span>, <span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">        System.out.println(s3);<span class="comment">//我是中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s4);<span class="comment">//中果人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = &#123;<span class="number">65</span>, <span class="number">66</span> ,<span class="number">67</span>, <span class="number">68</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">        System.out.println(s5);<span class="comment">//ABCD</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(s6);<span class="comment">//BC</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我是福建人&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);</span><br><span class="line">        System.out.println(s7);<span class="comment">//我是福建人</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;我是厦门人&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb2);</span><br><span class="line">        System.out.println(s8);<span class="comment">//我是厦门人</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>char charAt(int index)</td><td>返回指定位置的字符</td></tr><tr><td>int compareTo(String anotherString)</td><td>比较两个字符串，相等返回0，前大后小返回1，前小后大返回-1</td></tr><tr><td>boolean contains(CharSequence s)</td><td>判断字符串是否包含s</td></tr><tr><td>boolean endsWith(String suffix)</td><td>判断字符串是否以suffix结尾</td></tr><tr><td>boolean equals(Object anObject)</td><td>判断两个串是否相等</td></tr><tr><td>boolean equalsIgnoreCase(String anotherString)</td><td>忽略大小写判断两个串是否相等</td></tr><tr><td>byte[] getBytes()</td><td>将字符串串变成字节数组返回</td></tr><tr><td>int indexOf(String str)</td><td>返回str在字符串第一次出现的位置</td></tr><tr><td>boolean isEmpty()</td><td>字符串是否为空</td></tr><tr><td>int length()</td><td>字符串长度</td></tr><tr><td>int lastIndexOf(String str)</td><td>返回str最后一次出现的位置</td></tr><tr><td>String replace(CharSequence target, CharSequence replacement)</td><td>用replacement替换字符串target的字符</td></tr><tr><td>String[] split(String regex)</td><td>将字符串以regex分割</td></tr><tr><td>boolean startsWith(String prefix)</td><td>判断字符串是否以prefix开始</td></tr><tr><td>String substring(int beginIndex)</td><td>从beginIndex开始截取字串</td></tr><tr><td>String substring(int beginIndex, int endIndex)</td><td>截取beginIndex到endIndex - 1的字符串</td></tr><tr><td>char[] toCharArray()</td><td>将字符串转换乘char数组</td></tr><tr><td>String toLowerCase()</td><td>字符串转小写</td></tr><tr><td>String toUpperCase()</td><td>字符串转大写</td></tr><tr><td>String trim()</td><td>去除字符串两边空格</td></tr><tr><td>静态方法</td><td></td></tr><tr><td>static String valueOf(int i)</td><td>将 i 转换成字符串</td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.charAt(<span class="number">6</span>));<span class="comment">//w</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">        System.out.println(s2.compareTo(s3));<span class="comment">//-23</span></span><br><span class="line">        System.out.println(s3.compareTo(s4));<span class="comment">//0</span></span><br><span class="line">        System.out.println(s4.compareTo(s1));<span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2.equals(s3));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;world&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;t&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;HELLO worLD&quot;</span>;</span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s5));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = s1.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(b));<span class="comment">//[104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;world&quot;</span>));<span class="comment">//6</span></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;h&quot;</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1.length());<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javapythonc++cphpjavapython&quot;</span>;</span><br><span class="line">        System.out.println(s6.lastIndexOf(<span class="string">&quot;java&quot;</span>));<span class="comment">//17</span></span><br><span class="line">        System.out.println(s6.lastIndexOf(<span class="string">&quot;h&quot;</span>));<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;name=zhangsan&amp;age=18&amp;sex=男&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newS7</span> <span class="operator">=</span> s7.replace(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        System.out.println(newS7);<span class="comment">//name=zhangsan;age=18;sex=男</span></span><br><span class="line"></span><br><span class="line">        String[] splitS7 = s7.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(splitS7));<span class="comment">//[name=zhangsan, age=18, sex=男]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s6.startsWith(<span class="string">&quot;java&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s6.startsWith(<span class="string">&quot;python&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s6.substring(<span class="number">10</span>));<span class="comment">//c++cphpjavapython</span></span><br><span class="line">        System.out.println(s6.substring(<span class="number">10</span>, <span class="number">13</span>));<span class="comment">//c++</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charS6 = s6.toCharArray();</span><br><span class="line">        System.out.println(Arrays.toString(charS6));<span class="comment">//[j, a, v, a, p, y, t, h, o, n, c, +, +, c, p, h, p, j, a, v, a, p, y, t, h, o, n]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s6.toUpperCase());<span class="comment">//JAVAPYTHONC++CPHPJAVAPYTHON</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s5.toLowerCase());<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;           你 好 世 界                   &quot;</span>;</span><br><span class="line">        System.out.println(s8.trim());<span class="comment">//你 好 世 界</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.valueOf(<span class="number">123</span>));<span class="comment">//123</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="number">3.14</span>));<span class="comment">//3.14</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="literal">true</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()));<span class="comment">//java.lang.Object@4554617c</span></span><br><span class="line">        <span class="comment">//valueOf会自动调用toString()方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>在JAVA中，字符串使用String类进行表示，虽然针对String直接操作很方便，但是由于字符串变量声明后不可改变，能改变的只是字符串对象的指向。换言之，不同的字符串常量会占用不同的内存空间，而在频繁修改的字符串操作上，不适用String类型，此时可以使用StringBuffer类型。也就是说该类型方便用户进行内容的修改</p><p>基本介绍</p><ol><li><p>StringBuffer的直接父类是AbstractStringBuilder</p></li><li><p>StringBuffer实现了Serializable 即StringBuffer的对象可以串行化</p></li><li><p>在父类中 AbstractStringBuilder 有属性 char[] value,不是final</p><p>在该value数组存放字符串内容,引出存放在堆中的</p></li><li><p>StringBuffer 是一个final类 不能被继承</p></li><li><p>StringBuffer是存放在 char[] value ,所有的变化 不用每次创建新对象,更换地址所以效率高于String</p></li></ol><h4 id="StringBuffer与String的区别："><a href="#StringBuffer与String的区别：" class="headerlink" title="StringBuffer与String的区别："></a>StringBuffer与String的区别：</h4><ol><li>StringBuffer的内容和长度都是可以改变的，String却不可以。</li><li>String创建每一个字符串都会在常量池开辟一个新的空间。而StringBuffer会提前给出容量，可以重新进行字符串拼接，而不会重新开辟空间。</li></ol><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>public StringBuffer();构造一个没有字符的字符串缓冲区，初始容量为16字符。</p><p>public StringBuffer(int capacity);构造一个没有字符的字符串缓冲区和指定的初始容量。</p><p>public StringBuffer(String str);构造一个初始化为指定内容的字符串缓冲区。</p><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.one;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public StringBuffer()  构造一个没有字符的字符串缓冲区，初始容量为16个字符。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;sb1:&quot;</span> + sb1); <span class="comment">//StringBuffer重写了toString方法</span></span><br><span class="line">        <span class="comment">//如何获取StringBuffer的容量</span></span><br><span class="line">        <span class="comment">//public int capacity()返回当前容量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前StringBuffer的容量为：&quot;</span> + sb1.capacity());</span><br><span class="line">        <span class="comment">//public int length()返回长度（字符数）。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb1.length());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line">        <span class="comment">//public StringBuffer(int capacity)  构造一个没有字符的字符串缓冲区和指定的初始容量。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span> + sb2); <span class="comment">//StringBuffer重写了toString方法</span></span><br><span class="line">        <span class="comment">//如何获取StringBuffer的容量</span></span><br><span class="line">        <span class="comment">//public int capacity()返回当前容量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前StringBuffer的容量为：&quot;</span> + sb2.capacity());</span><br><span class="line">        <span class="comment">//public int length()返回长度（字符数）。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb2.length());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line">        <span class="comment">//public StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb3:&quot;</span> + sb3); <span class="comment">//StringBuffer重写了toString方法</span></span><br><span class="line">        <span class="comment">//如何获取StringBuffer的容量</span></span><br><span class="line">        <span class="comment">//public int capacity()返回当前容量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前StringBuffer的容量为：&quot;</span> + sb3.capacity()); <span class="comment">// 21 = 16 + 5</span></span><br><span class="line">        <span class="comment">//public int length()返回长度（字符数）。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb3.length()); <span class="comment">// 5</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><blockquote><p>首先我们需要创建一个StringBuffer对象</p><p>可以有初始值</p><p>添加语法:StringBuffer对象.append(插入的string值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello,&quot;</span>)</span><br><span class="line">string.append(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="comment">//输出为  hello,world</span></span><br><span class="line"><span class="comment">//添加多个可以直接 append.append.append</span></span><br><span class="line">string.append(<span class="string">&quot;good&quot;</span>).append(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="comment">//输出  hello,worldgoodtrue</span></span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><blockquote><p>删除是删除开始索引到结束索引位置的 注意不包含结束索引值</p><p>语法:StringBuffer对象.delete(开始索引,结束索引)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.delete(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出为 ho,worldgoodtrue    </span></span><br></pre></td></tr></table></figure><blockquote><p>在hello中的o是第四个索引位置 并没有删除这里可以看出删除并不包含结束索引值 这是一个典型的左闭右开原则</p></blockquote><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><blockquote><p>替换也是一个典型的左闭右开原则</p><p>语法: StringBuffer对象.replace(开始索引,结束索引,替换掉的新值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&quot;java&quot;</span>)</span><br><span class="line"><span class="comment">//输出结果  javaworldgoodtrue</span></span><br></pre></td></tr></table></figure><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><blockquote><p>插入可以在指定位置索引插入内容,比如说有一个String 内容为abcd 但是我们想变成aocd 是不是很麻烦这时候发现还是StringBuffer类好用</p><p>语法:StringBuffer对象.inert(要插入的索引位置,插入的值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.inert(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//结果为hellojavaworldgoodtrue</span></span><br></pre></td></tr></table></figure><blockquote><p>上面我们在索引为0的位置插入了hello但是小伙伴们会发现j是索引为0的位置并没有被替换掉这是因为字符在插入时会自动向后移并不会消失</p></blockquote><h5 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h5><blockquote><p>StringBuffer对象.length()</p><p>返回一个StringBuffer对象内字符长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string在上面结果为hellojavaworldgoodtrue</span></span><br><span class="line">string.length()</span><br><span class="line"><span class="comment">//打印结果为22</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</strong></p><p>此类提供一个与StringBuffer兼容的API，但不保证同步，该类被设计用作，StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用，建议优先采用该类，因为在大多数实现中，他比StringBuffer更快</p><h3 id="StringBuffer实现线程安全方式："><a href="#StringBuffer实现线程安全方式：" class="headerlink" title="StringBuffer实现线程安全方式："></a>StringBuffer实现线程安全方式：</h3><p>StringBuffer类中实现的方法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019112232577.png" alt="StringBuffer类中实现的方法"></p><p>StringBuilder类中实现的方法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019112307896.png" alt="StringBuilder类中实现的方法"></p><p>由此可见，StringBuffer类中的方法都添加了<strong>synchronized关键字</strong>，也就是给这个方法添加了一个锁，用来保证线程安全。</p><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><p>当<strong>对字符串进行修改</strong>的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且<strong>不产生新的未使用对象</strong>。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><p><strong>三者的继承结构</strong></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019112954081.png" alt="image-20221019112954081"></p><ul><li>String：不可变字符序列</li><li>StringBuffer：可变字符序列，效率低，线程安全</li><li>StringBuilder：可变字符序列，效率高，线程不安全</li></ul><h3 id="String-StringBuffer-StringBuilder的选择"><a href="#String-StringBuffer-StringBuilder的选择" class="headerlink" title="String,StringBuffer,StringBuilder的选择"></a>String,StringBuffer,StringBuilder的选择</h3><ol><li>如果字符串存在大量的修改操作，一般使用StringBuffer和StringBuilder</li><li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li><li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li><li>如果字符串很少修改，被多个对象引用，使用String，比如配置信息等</li></ol><hr><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p><a href="http://c.biancheng.net/java/">Java</a> 中的 +、-、*、&#x2F; 和 % 等基本算术运算符不能进行更复杂的数学运算，例如，三角函数、对数运算、指数运算等。于是 Java 提供了 Math 工具类来完成这些复杂的运算。</p><p>在 Java 中 Math 类封装了常用的数学运算，提供了基本的数学操作，如指数、对数、平方根和三角函数等。Math 类位于 java.lang 包，它的构造方法是 private 的，因此无法创建 Math 类的对象，并且 Math 类中的所有方法都是类方法，可以直接通过类名来调用它们。</p><h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>Math 类中包含 E 和 PI 两个静态常量，正如它们名字所暗示的，它们的值分别等于 e（自然对数）和 π（圆周率）。</p><h4 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h4><p>调用 Math 类的 E 和 PI 两个常量，并将结果输出。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;E 常量的值：&quot;</span> + Math.E);System.out.println(<span class="string">&quot;PI 常量的值：&quot;</span> + Math.PI);</span><br></pre></td></tr></table></figure><p>执行上述代码，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E 常量的值：<span class="number">2.718281828459045</span></span><br><span class="line">PI 常量的值：<span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><h3 id="求最大值、最小值和绝对值"><a href="#求最大值、最小值和绝对值" class="headerlink" title="求最大值、最小值和绝对值"></a>求最大值、最小值和绝对值</h3><p>在程序中常见的就是求最大值、最小值和绝对值问题，如果使用 Math 类提供的方法可以很容易实现。这些方法的说明如下所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static int abs(int a)</td><td>返回 a 的绝对值</td></tr><tr><td>static long abs(long a)</td><td>返回 a 的绝对值</td></tr><tr><td>static float abs(float a)</td><td>返回 a 的绝对值</td></tr><tr><td>static double abs(double a)</td><td>返回 a 的绝对值</td></tr><tr><td>static int max(int x,int y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static double max(double x,double y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static long max(long x,long y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static float max(float x,float y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static int min(int x,int y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static long min(long x,long y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static double min(double x,double y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static float min(float x,float y)</td><td>返回 x 和 y 中的最小值</td></tr></tbody></table><h4 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h4><p>求 10 和 20 的较大值、15.6 和 15 的较小值、-12 的绝对值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test02 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;10 和 20 的较大值：&quot; + Math.max(10, 20));        System.out.println(&quot;15.6 和 15 的较小值：&quot; + Math.min(15.6, 15));        System.out.println(&quot;-12 的绝对值：&quot; + Math.abs(-12));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10和20的较大值：20</span><br><span class="line">15.6和15的较小值：15.0</span><br><span class="line">-12的绝对值：12</span><br></pre></td></tr></table></figure><h3 id="求整运算"><a href="#求整运算" class="headerlink" title="求整运算"></a>求整运算</h3><p>Math 类的求整方法有很多，详细说明如表 2 所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double ceil(double a)</td><td>返回大于或等于 a 的最小整数</td></tr><tr><td>static double floor(double a)</td><td>返回小于或等于 a 的最大整数</td></tr><tr><td>static double rint(double a)</td><td>返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数</td></tr><tr><td>static int round(float a)</td><td>将参数加上 1&#x2F;2 后返回与参数最近的整数</td></tr><tr><td>static long round(double a)</td><td>将参数加上 1&#x2F;2 后返回与参数最近的整数，然后强制转换为长整型</td></tr></tbody></table><h4 id="eg-2"><a href="#eg-2" class="headerlink" title="eg"></a>eg</h4><p>下面的实例演示了 Math 类中取整函数方法的应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;public class Test03 &#123;    public static void main(String[] args) &#123;        Scanner input = new Scanner(System.in);        System.outprintln(&quot;请输入一个数字：&quot;);        double num = input.nextDouble();        System.out.println(&quot;大于或等于 &quot;+ num +&quot; 的最小整数：&quot; + Math.ceil(num));        System.out.println(&quot;小于或等于 &quot;+ num +&quot; 的最大整数：&quot; + Math.floor(num));        System.out.println(&quot;将 &quot;+ num +&quot; 加上 0.5 之后最接近的整数：&quot; + Math.round(num));        System.out.println(&quot;最接近 &quot;+num+&quot; 的整数：&quot; + Math.rint(num));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入一个数字：</span><br><span class="line">99.01</span><br><span class="line">大于或等于 99.01 的最小整数：100.0</span><br><span class="line">小于或等于 99.01 的最大整数：99.0</span><br><span class="line">将 99.01 加上 0.5 之后最接近的整数：100</span><br><span class="line">最接近 99.01 的整数：99.0</span><br></pre></td></tr></table></figure><h3 id="三角函数运算"><a href="#三角函数运算" class="headerlink" title="三角函数运算"></a>三角函数运算</h3><p>Math 类中包含的三角函数方法及其说明如表 3 所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double sin(double a)</td><td>返回角的三角正弦值，参数以孤度为单位</td></tr><tr><td>static double cos(double a)</td><td>返回角的三角余弦值，参数以孤度为单位</td></tr><tr><td>static double asin(double a)</td><td>返回一个值的反正弦值，参数域在 [-1,1]，值域在 [-PI&#x2F;2,PI&#x2F;2]</td></tr><tr><td>static double acos(double a)</td><td>返回一个值的反余弦值，参数域在 [-1,1]，值域在 [0.0,PI]</td></tr><tr><td>static double tan(double a)</td><td>返回角的三角正切值，参数以弧度为单位</td></tr><tr><td>static double atan(double a)</td><td>返回一个值的反正切值，值域在 [-PI&#x2F;2,PI&#x2F;2]</td></tr><tr><td>static double toDegrees(double angrad)</td><td>将用孤度表示的角转换为近似相等的用角度表示的角</td></tr><tr><td>staticdouble toRadians(double angdeg)</td><td>将用角度表示的角转换为近似相等的用弧度表示的角</td></tr></tbody></table><p>在表 3 中，每个方法的参数和返回值都是 double 类型，参数以弧度代替角度来实现，其中 1 度等于 π&#x2F;180 弧度，因此平角就是 π 弧度。</p><h4 id="eg-3"><a href="#eg-3" class="headerlink" title="eg"></a>eg</h4><p>计算 90 度的正弦值、0 度的余弦值、1 的反正切值、120 度的弧度值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test04 &#123;    public static void main(String[] args) &#123;        System.out.println&#123;&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));        System.out.println(&quot;0 度的余弦值：&quot; + Math.cos(0));        System.out.println(&quot;1 的反正切值：&quot; + Math.atan(l));        System.out.println(&quot;120 度的弧度值：&quot; + Math.toRadians(120.0));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，因为 Math.sin() 中的参数的单位是弧度，而 90 度表示的是角度，因此需要将 90 度转换为弧度，即 Math.PI&#x2F;180*90，故转换后的弧度为 Math.PI&#x2F;2，然后调用 Math 类中的 sin() 方法计算其正弦值。</p><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">90 度的正弦值：1.0</span><br><span class="line">0 的余弦值：1.0</span><br><span class="line">1 的反正切值：0.7853981633974483</span><br><span class="line">120 度的弧度值：2.0943951023931953</span><br></pre></td></tr></table></figure><h3 id="指数运算"><a href="#指数运算" class="headerlink" title="指数运算"></a>指数运算</h3><p>指数的运算包括求方根、取对数及其求 n 次方的运算。在 Math 类中定义的指数运算方法及其说明如表 4 所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double exp(double a)</td><td>返回 e 的 a 次幂</td></tr><tr><td>static double pow(double a,double b)</td><td>返回以 a 为底数，以 b 为指数的幂值</td></tr><tr><td>static double sqrt(double a)</td><td>返回 a 的平方根</td></tr><tr><td>static double cbrt(double a)</td><td>返回 a 的立方根</td></tr><tr><td>static double log(double a)</td><td>返回 a 的自然对数，即 lna 的值</td></tr><tr><td>static double log10(double a)</td><td>返回以 10 为底 a 的对数</td></tr></tbody></table><h4 id="eg-4"><a href="#eg-4" class="headerlink" title="eg"></a>eg</h4><p>使用 Math 类中的方法实现指数的运算，main() 方法中的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test05 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;4 的立方值：&quot; + Math.pow(4, 3));        System.out.println(&quot;16 的平方根：&quot; + Math.sqrt(16));        System.out.println(&quot;10 为底 2 的对数：&quot; + Math.log1O(2));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 的立方值：64.0</span><br><span class="line">16 的平方根：4.0</span><br><span class="line">10 为底 2 的对数：0.3010299956639812</span><br></pre></td></tr></table></figure><hr><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays的常用方法那肯定是在Arrays类内了，所以导包：java.util.Arrays;</p><p>Arrays是针对<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>的工具类，可以进行复制、排序、查找等功能，大大提高了开发人员的工作效率</p><table><thead><tr><th>返回类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>toString(array)</td><td>将数组array转换成字符串</td></tr><tr><td>void</td><td>sort(array)</td><td>对数组进行排序，</td></tr><tr><td>void</td><td>fill(arr,val)</td><td>将数组arr全部元素赋值为val</td></tr><tr><td>boolean</td><td>equals(arr1,arr2)</td><td>判断两个数组是否相等</td></tr><tr><td>与arr类型相同</td><td>copyOf(arr,length)</td><td>将数组arr复制成一个长度为length的新数组</td></tr><tr><td>int</td><td>binarySearch(ary,val)</td><td>查询元素val在arr中的下标值</td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[]=&#123;<span class="number">12</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>,<span class="number">72</span>,<span class="number">26</span>,<span class="number">35</span>,<span class="number">10</span>,<span class="number">46</span>,<span class="number">26</span>,<span class="number">53</span>&#125;;</span><br><span class="line">        <span class="type">int</span> b[]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> c[]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        String str=Arrays.toString(a);       <span class="comment">//将特定数组转换成字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串：&quot;</span>+str);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(a);                      <span class="comment">//对数组array的元素进行升序排列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>+Arrays.toString(a)); </span><br><span class="line">        </span><br><span class="line">        Arrays.fill(a,<span class="number">10</span>);                   <span class="comment">//所以元素都赋值成特定值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;赋值后：&quot;</span>+Arrays.toString(a)); </span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> boo=Arrays.equals(a,b);      <span class="comment">//判断两个数组是否相等(对应位置上的元素是否相等)</span></span><br><span class="line">        <span class="type">boolean</span> boo2=Arrays.equals(b, c);</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span>+b);</span><br><span class="line">        System.out.println(<span class="string">&quot;c:&quot;</span>+c);</span><br><span class="line">        System.out.println(<span class="string">&quot;ab相等？&quot;</span>+boo);</span><br><span class="line">        System.out.println(<span class="string">&quot;bc相等？&quot;</span>+boo2);</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> d[]=Arrays.copyOf(b,b.length);   <span class="comment">//把数组复制成特定长度的数组,与直接赋值（引用传递）不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:&quot;</span>+Arrays.toString(d));</span><br><span class="line">        System.out.println(<span class="string">&quot;d:&quot;</span>+d);</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span>+b);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i=Arrays.binarySearch(b, <span class="number">5</span>);     <span class="comment">//查询特定因素在数组中的下标</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下标是：&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221019163526751.png" alt="image-20221019163526751"></p><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>System类位于java.lang包，代表当前Java程序的运行平台，系统级的很多属性和控制方法都放置在该类的内部。</p><p>  由于该类的<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">构造方法</a>是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员方法和成员变量都是static（静态）的，所以也可以很方便的调用他。</p><p>  system中包含了in、out和err三个成员变量，分别代表标准输入流（键盘输入）、标准输出流（显示器）和标准错误输出流（显示器）</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>System类有3个静态成员变量，分别是PrintStream out，InputStream in 和 PrintStream err。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in;</span><br><span class="line"><span class="comment">//标准输入流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out;</span><br><span class="line"><span class="comment">//标准输出流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err;</span><br><span class="line"><span class="comment">//标准错误流</span></span><br></pre></td></tr></table></figure><h4 id="PrintStream-out"><a href="#PrintStream-out" class="headerlink" title="PrintStream out"></a>PrintStream out</h4><p>标准输出流。此流已打开并准备接收输出数据。通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。</p><p>例如，编写一行输出数据的典型方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(data);</span><br></pre></td></tr></table></figure><p>其中，println 方法是属于流类 PrintStream 的方法，而不是 System 中的方法。</p><h4 id="InputStream-in"><a href="#InputStream-in" class="headerlink" title="InputStream in"></a>InputStream in</h4><p>标准输入流。此流已打开并准备提供输入数据。通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。</p><h4 id="PrintStream-err"><a href="#PrintStream-err" class="headerlink" title="PrintStream err"></a>PrintStream err</h4><p>标准的错误输出流。其语法与 System.out 类似，不需要提供参数就可输出错误信息。也可以用来输出用户指定的其他信息，包括变量的值。</p><h3 id="System-类的成员方法"><a href="#System-类的成员方法" class="headerlink" title="System 类的成员方法"></a>System 类的成员方法</h3><p>System 类中提供了一些系统级的操作方法，常用的方法有 arraycopy()、currentTimeMillis()、exit()、gc() 和 getProperty()。</p><h4 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy()"></a>arraycopy()</h4><p>该方法的作用是数组复制，即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。该方法的具体定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,<span class="type">int</span> srcPos,Object dest,<span class="type">int</span> destPos,<span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure><p>其中，src 表示源数组，srcPos 表示从源数组中复制的起始位置，dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。</p><p>下面的示例代码演示了 arraycopy() 方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_arrayCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] srcArray = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[] destArray = &#123;<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">        System.arraycopy(srcArray,<span class="number">1</span>,destArray,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;源数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; srcArray.length;i++) &#123;</span><br><span class="line">            System.out.println(srcArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; destArray.length;j++) &#123;</span><br><span class="line">            System.out.println(destArray[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，将数组 srcArray 中，从下标 1 开始的数据复制到数组 destArray 从下标 1 开始的位置，总共复制两个。也就是将 srcArray[1] 复制给 destArray[1]，将 srcArray[2] 复制给 destArray[2]。这样经过复制之后，数组 srcArray 中的元素不发生变化，而数组 destArray 中的元素将变为 E、B、C、 H，下面为输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源数组：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">//D</span></span><br><span class="line"><span class="comment">//目标数组：</span></span><br><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">//H</span></span><br></pre></td></tr></table></figure><h4 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h4><p>该方法的作用是返回当前的计算机时间，时间的格式为当前计算机时间与 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒所差的毫秒数。一般用它来测试程序的执行时间。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure><p>上述语句将获得一个长整型的数字，该数字就是以差值表达的当前时间。</p><p>使用 currentTimeMillis() 方法来显示时间不够直观，但是可以很方便地进行时间计算。例如，计算程序运行需要的时间就可以使用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_currentTimeMillis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000000</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行时间&quot;</span> + time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的变量 time 的值表示代码中 for 循环执行所需要的毫秒数，使用这种方法可以测试不同算法的程序的执行效率高低，也可以用于后期线程控制时的精确延时实现。</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h4><p> 退出虚拟机。exit(int)方法是终止当前正在运行的java虚拟机。参数是状态码。根据惯例，非0的状态码表示异常终止，0表是终止。而且，该方法永远不会正常返回。具体的定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure><p>其中，status 的值为 0 时表示正常退出，非零时表示异常退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is try&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是唯一一个能够退出程序并不执行finally的情况。说明：退出虚拟机会直接终止整个程序，这时的程序已经不是从代码的层面来终止程序，所以finally不会被执行。</p><h4 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h4><p>该方法的作用是请求系统进行垃圾回收，完成内存中的垃圾清除。至于系统是否立刻回收，取决于系统中垃圾回收算法的实现以及系统执行时的情况。定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="getProperty"><a href="#getProperty" class="headerlink" title="getProperty()"></a>getProperty()</h4><p>该方法的作用是获得系统中属性名为 key 的属性对应的值，具体的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure><p>系统中常见的属性名以及属性的说明如表所示</p><table><thead><tr><th>属性名</th><th>属性说明</th></tr></thead><tbody><tr><td>java.version</td><td>Java 运行时环境版本</td></tr><tr><td>java.home</td><td>Java 安装目录</td></tr><tr><td>os.name</td><td>操作系统的名称</td></tr><tr><td>os.version</td><td>操作系统的版本</td></tr><tr><td>user.name</td><td>用户的账户名称</td></tr><tr><td>user.home</td><td>用户的主目录</td></tr><tr><td>user.dir</td><td>用户的当前工作目录</td></tr></tbody></table><p>下面的示例演示了 getProperty() 方法的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_getProperty</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jversion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">oName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Java 运行时环境版本：&quot;</span>+jversion);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前操作系统是：&quot;</span>+oName);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前用户是：&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，输出结果如下（结果为我自己的运行环境）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 运行时环境版本：<span class="number">1.8</span><span class="number">.0_121</span></span><br><span class="line">当前操作系统是：Windows <span class="number">10</span></span><br><span class="line">当前用户是：Unfall</span><br></pre></td></tr></table></figure><h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>在 Java 中，有许多数字处理的类，比如 Integer类，但是Integer类有一定的局限性。</p><p>我们都知道 Integer 是 Int 的包装类，int 的最大值为 2^31-1。若希望描述更大的整数数据时，使用Integer 数据类型就无法实现了，所以Java中提供了BigInteger 类。</p><p>BigInteger类型的数字范围较Integer，Long类型的数字范围要大得多，它支持任意精度的整数，也就是说在运算中 BigInteger 类型可以准确地表示任何大小的整数值而不会丢失任何信息。</p><h3 id="读入方法"><a href="#读入方法" class="headerlink" title="读入方法"></a>读入方法</h3><p>nextBigInteger()：控制台读入一个BigInteger型数据，类似于int型的nextInt()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读入方法：nextBigInteger()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">// 读入</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt(); <span class="comment">// 读入一个int;</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextBigInteger();<span class="comment">// 读入一个BigInteger;</span></span><br><span class="line"><span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;scan.hasNext()=&quot;</span> + scan.hasNext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p>默认为十进制，也是我们最常用的，同时也支持自定义进制类型（已存在的）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进制转换</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScale</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//在构造将函数时，把radix进制的字符串转化为BigInteger</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1011100111&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">interNum1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(str,radix);<span class="comment">//743</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通常不写，则是默认成10进制转换，如下：</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">interNum2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(str);<span class="comment">//1011100111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>返回值为BigInteger类型：add()，subtract()，multiply()，divide()，mod()，remainder()，pow()，abs()，negate()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本运算:add(),subtract(),multiply(),divide(),mod(),remainder(),pow(),abs(),negate()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBasic</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.加</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> a.add(b);<span class="comment">//17</span></span><br><span class="line"><span class="comment">//2.减</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> a.subtract(b);<span class="comment">//9</span></span><br><span class="line"><span class="comment">//3.乘</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum3</span> <span class="operator">=</span> a.multiply(b);<span class="comment">//52</span></span><br><span class="line"><span class="comment">//4.除</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum4</span> <span class="operator">=</span> a.divide(b);<span class="comment">//3</span></span><br><span class="line"><span class="comment">//5.取模(需 b &gt; 0，否则出现异常：ArithmeticException(&quot;BigInteger: modulus not positive&quot;))</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum5</span> <span class="operator">=</span> a.mod(b);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//6.求余</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum6</span> <span class="operator">=</span> a.remainder(b);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//7.平方(需 n &gt;= 0，否则出现异常：ArithmeticException(&quot;Negative exponent&quot;))</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum7</span> <span class="operator">=</span> a.pow(n);<span class="comment">//2197</span></span><br><span class="line"><span class="comment">//8.取绝对值</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum8</span> <span class="operator">=</span> a.abs();<span class="comment">//13</span></span><br><span class="line"><span class="comment">//9.取相反数</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum9</span> <span class="operator">=</span> a.negate();<span class="comment">//-13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><p>compareTo()返回一个int型数据：1 大于； 0 等于； -1 小于；<br>max()，min()：分别返回大的（小的）那个BigInteger数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较大小:compareTo(),max(),min()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;52&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;27&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.compareTo()：返回一个int型数据（1 大于； 0 等于； -1 小于）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> bigNum1.compareTo(bigNum2);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.max()：直接返回大的那个数，类型为BigInteger</span></span><br><span class="line"><span class="comment">//原理：return (compareTo(val) &gt; 0 ? this : val);</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">compareMax</span> <span class="operator">=</span> bigNum1.max(bigNum2);<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.min()：直接返回小的那个数，类型为BigInteger</span></span><br><span class="line"><span class="comment">//原理：return (compareTo(val) &lt; 0 ? this : val);</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">compareMin</span> <span class="operator">=</span> bigNum1.min(bigNum2);<span class="comment">//27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量<br>ZERO，ONE，TEN 返回值为BigInteger类型：有朋友提到的-1，2，源码注释里面已表明不再输出(Not exported.)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量(返回BigInteger类型)</span></span><br><span class="line"><span class="comment">//有朋友提到的-1和2，源码注释里面已表明不再输出(Not exported.)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFinalNum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">zero</span> <span class="operator">=</span> BigInteger.ZERO;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">one</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">ten</span> <span class="operator">=</span> BigInteger.TEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型转换<br>将BigInteger数据转换成基本数据类型，还可以转换成radix进制的字符串形式；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型转换(返回类型如下)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToAnother</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;52&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.转换为bigNum的二进制补码形式</span></span><br><span class="line"><span class="type">byte</span>[] num1 = bigNum.toByteArray();</span><br><span class="line"><span class="comment">//2.转换为bigNum的十进制字符串形式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">num2</span> <span class="operator">=</span> bigNum.toString();<span class="comment">//52</span></span><br><span class="line"><span class="comment">//3.转换为bigNum的radix进制字符串形式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">num3</span> <span class="operator">=</span> bigNum.toString(radix);<span class="comment">//110100</span></span><br><span class="line"><span class="comment">//4.将bigNum转换为int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> bigNum.intValue();</span><br><span class="line"><span class="comment">//5.将bigNum转换为long</span></span><br><span class="line"><span class="type">long</span> <span class="variable">num5</span> <span class="operator">=</span> bigNum.longValue();</span><br><span class="line"><span class="comment">//6.将bigNum转换为float</span></span><br><span class="line"><span class="type">float</span> <span class="variable">num6</span> <span class="operator">=</span> bigNum.floatValue();</span><br><span class="line"><span class="comment">//7.将bigNum转换为double</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num7</span> <span class="operator">=</span> bigNum.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制运算<br>返回值为BigInteger类型，此类方法不常用，有备无患；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制运算(返回类型都为BigInteger，不常用，但有备无患)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBinaryOperation</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.与：a&amp;b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> a.and(b);<span class="comment">//0</span></span><br><span class="line"><span class="comment">//2.或：a|b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> a.or(b);<span class="comment">//15</span></span><br><span class="line"><span class="comment">//3.异或：a^b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum3</span> <span class="operator">=</span> a.xor(b);<span class="comment">//15</span></span><br><span class="line"><span class="comment">//4.取反：~a</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum4</span> <span class="operator">=</span> a.not();<span class="comment">//-14</span></span><br><span class="line"><span class="comment">//5.左移n位： (a &lt;&lt; n)</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum5</span> <span class="operator">=</span> a.shiftLeft(n);<span class="comment">//26</span></span><br><span class="line"><span class="comment">//6.右移n位： (a &gt;&gt; n)</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum6</span> <span class="operator">=</span> a.shiftRight(n);<span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限控制<br>setBit()，testBit()：可用于菜单的权限控制，非常好用，原理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//权限控制：setBit(),testBit()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetAndTest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//1.封装数据(setBit的值需 &gt;= 0，否则出现异常：ArithmeticException(&quot;Negative bit address&quot;))</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">permission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">numBig</span> <span class="operator">=</span> permission.setBit(<span class="number">2</span>);</span><br><span class="line">numBig = numBig.setBit(<span class="number">5</span>);</span><br><span class="line">numBig = numBig.setBit(<span class="number">13</span>);</span><br><span class="line">numBig = numBig.setBit(<span class="number">66</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原理：&quot;</span> + numBig);</span><br><span class="line"><span class="comment">// 原理：73786976294838214692 = 2^2+2^5+2^13+2^66 次方的和；</span></span><br><span class="line"><span class="comment">// 看！！即使这么大的数也不会溢出，而int最大值只有2147483647；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.取值验证（返回Boolean型）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> numBig.testBit(<span class="number">2</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> numBig.testBit(<span class="number">5</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag3</span> <span class="operator">=</span> numBig.testBit(<span class="number">13</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag4</span> <span class="operator">=</span> numBig.testBit(<span class="number">66</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag5</span> <span class="operator">=</span> numBig.testBit(<span class="number">27</span>);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析<br>setBit()：将set进去变量作为二进制数，计算它们的和，并以十进制显示；<br>testBit()：与setBit()相反，验证this的二进制组成元素中是否包含传入的变量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//权限控制源码分析：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.setBit()原理：计算this与2的n次方的和</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">setBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Negative bit address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">intNum</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[Math.max(intLength(), intNum+<span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; result.length; i++)</span><br><span class="line">result[result.length-i-<span class="number">1</span>] = getInt(i);</span><br><span class="line"></span><br><span class="line">result[result.length-intNum-<span class="number">1</span>] |= (<span class="number">1</span> &lt;&lt; (n &amp; <span class="number">31</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> valueOf(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.testBit()原理：计算this的值中是否包含2的n次方</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">testBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Negative bit address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (getInt(n &gt;&gt;&gt; <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; (n &amp; <span class="number">31</span>))) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><ol><li>BigInteger也是不可变的，在进行每一步运算时，都会产生一个新的对象。都会产生一个新的对象。发生异常算术条件时，会抛出ArithmeticException异常。例如，一个整数除以“0”，会抛出一个这个类的实例；</li><li>假设计算一个int数据平方与另一个大小的问题，很可能会内存溢出。除了使用二分法外，利用BigInteger的compareTo方法也是一个好选择，简单易懂，而且不需要算法支持；</li><li>本章作为笔记使用，内容比较全面，但常用的只有：构造函数，基本运算以及compareTo()，intValue()，setBit()，testBit()方法；</li><li>setBit()和testBit()方法可用于菜单的权限控制</li></ol><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p><a href="https://so.csdn.net/so/search?q=BigDecimal&spm=1001.2101.3001.7020">BigDecimal</a> 是java小数操作的一个专有类,在电商、金融行业 存储跟金额有关的字段</p><p>接下来看一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoubleSimple</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出:<code>0.3</code></p><p>在小数操作中,我们通常希望能有多种自由的定义方式。</p><blockquote><p>例如在不同的场景可能需要返回: 0.3, 0.4, 0.333 不同精度,在不同的精度进位时希望能自主控制</p></blockquote><p>这个时候,就轮到BigDecimal出场了</p><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p>首先来一段最简单的加减乘除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDecimalSimple</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5</span>);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">40</span>);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">add</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">subtract</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">multiply</span> <span class="operator">=</span> a.multiply(b);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> a.divide(b);</span><br><span class="line">     System.out.println(<span class="string">&quot;add:&quot;</span> + add);</span><br><span class="line">     System.out.println(<span class="string">&quot;subtract:&quot;</span> + subtract);</span><br><span class="line">     System.out.println(<span class="string">&quot;multiply:&quot;</span> + multiply);</span><br><span class="line">     System.out.println(<span class="string">&quot;divide:&quot;</span> + divide);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>控制台输出内容如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add:<span class="number">45</span></span><br><span class="line">subtract:-<span class="number">35</span></span><br><span class="line">multiply:<span class="number">200</span></span><br><span class="line">divide:<span class="number">0.125</span></span><br></pre></td></tr></table></figure><p>在了解了BigDecimal基本内容后,在去深入的去使用它的精度<br>精度控制<br>精度有7种模式，举例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRound</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 正无穷大方向取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;celling:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.CEILING)));</span><br><span class="line">     <span class="comment">// 负无穷大方向取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;floor:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.FLOOR)));</span><br><span class="line">     <span class="comment">//向 0 的方向取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;down a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.121</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.DOWN)));</span><br><span class="line">     System.out.println(<span class="string">&quot;down b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(-<span class="number">0.129</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.DOWN)));</span><br><span class="line">     <span class="comment">// 正数向正无穷大取整，负数向负无穷大取整</span></span><br><span class="line">     System.out.println(<span class="string">&quot;up a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.121</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.UP)));</span><br><span class="line">     System.out.println(<span class="string">&quot;up b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(-<span class="number">0.129</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.UP)));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 5,6,7,8,9 向上取整</span></span><br><span class="line"><span class="comment">      * 1,2,3,4 向下取整</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 常用的4舍5入</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;half up:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.HALF_UP)));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *  6,7,8,9 向上取整</span></span><br><span class="line"><span class="comment">      *  1,2,3,4,5 向下取整</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *  5 向下取整</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;half down:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.125</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">2</span>, RoundingMode.HALF_DOWN)));</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 小数位是5时，判断整数部分是奇数就进位</span></span><br><span class="line"><span class="comment">      * 1,2,3,4,  舍弃</span></span><br><span class="line"><span class="comment">      * 6,7,8,9,  进位</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;odd a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.4</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line">     System.out.println(<span class="string">&quot;odd b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.5</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 小数位是5时，判断整数部分是偶数就舍弃</span></span><br><span class="line"><span class="comment">      * 1,2,3,4,  舍弃</span></span><br><span class="line"><span class="comment">      * 6,7,8,9,  进位</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;even a:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">6.5</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line">     System.out.println(<span class="string">&quot;even b:&quot;</span> + <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">6.6</span>, <span class="keyword">new</span> <span class="title class_">MathContext</span>(<span class="number">1</span>, RoundingMode.HALF_EVEN)));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>控制台输出内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">celling:<span class="number">0.13</span></span><br><span class="line">floor:<span class="number">0.12</span></span><br><span class="line">down a:<span class="number">0.12</span></span><br><span class="line">down b:-<span class="number">0.12</span></span><br><span class="line">up a:<span class="number">0.13</span></span><br><span class="line">up b:-<span class="number">0.13</span></span><br><span class="line">half up:<span class="number">0.13</span></span><br><span class="line">half down:<span class="number">0.12</span></span><br><span class="line">odd a:<span class="number">5</span></span><br><span class="line">odd b:<span class="number">6</span></span><br><span class="line">even a:<span class="number">6</span></span><br><span class="line">even b:<span class="number">7</span></span><br></pre></td></tr></table></figure><p>在 RoundingMode.XXXXX 类型的源码注释上面，有更加详细的例子，可以看到是怎么舍入的</p><h3 id="除法特写"><a href="#除法特写" class="headerlink" title="除法特写"></a>除法特写</h3><p>我认为在电商，金融领域中，用BigDecimal最重要的原因有两个：</p><ol><li>精度准确</li><li>除法运算支持好</li></ol><p>所以一定要对除法做深入的了解,做项目的时候，才能不会对这些类型感到疑惑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDecimalDivide</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.4</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">3.1</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> a.divide(b);</span><br><span class="line">    System.out.println(<span class="string">&quot;divide:&quot;</span> + divide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现异常:<br><strong>java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</strong></p><p>明明刚刚还好好的，怎么现在出了事?</p><p>那是因为 5.4、3.1都是double类型转换的 BigDecimal。</p><p>实际上5.4在内存中可能是 5.40000003321546546 的内容。导致BigDecimal内部精度计算的时候，发生错误</p><p>这个错误是因为没有指定精度导致的，我们只要指定了结果的精度，就可以避免这个问题。</p><p>推荐做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDecimalStandDivide</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">5.4</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">3.1</span>);</span><br><span class="line">    <span class="comment">// 保留几位小数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 重点:务必是3个参数</span></span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> a.divide(b,scale,RoundingMode.HALF_UP);</span><br><span class="line">    System.out.println(<span class="string">&quot;divide:&quot;</span> + divide);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出:<strong>divide:1.74</strong></p><p>我们额外传入第二个参数:保留的小数,指定了结果的精度,就可以避免出现这种问题。</p><p>所以我们日常用BigDecimal做除法运算的时候，务必写成推荐的形式。避免出现了异常，自己还莫名其妙</p><h3 id="默认除法精度"><a href="#默认除法精度" class="headerlink" title="默认除法精度"></a>默认除法精度</h3><p>在文章的开头的除法，是用整数转成BigDecimal， 保留的3为小数。 那默认情况下会精确到几位呢？</p><p>在跟进到divide函数内部时，发现了构造MathContext的部分内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MathContext</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathContext</span>( (<span class="type">int</span>)Math.min(<span class="built_in">this</span>.precision() +</span><br><span class="line">                                                           (<span class="type">long</span>)Math.ceil(<span class="number">10.0</span>*divisor.precision()/<span class="number">3.0</span>),</span><br><span class="line">                                                           Integer.MAX_VALUE),</span><br><span class="line">                                             RoundingMode.UNNECESSARY);</span><br></pre></td></tr></table></figure><blockquote><p>整数 12345 的precision 是5<br>整数 332 的precision 是 3<br>小数5.4 的precision可能是 5.40000065464698656565454454555 的长度。 值不固定</p></blockquote><p>根据MathContext的第一个参数的计算方式得到默认除法精度:</p><ol><li>当被除数为:0x1 最低精度5</li><li>当被除数为:0xFFFFFFFF 最高精度36</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>BigDecimal精度描述</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>ceiling</td><td>正无穷大方向取整数</td></tr><tr><td>floor</td><td>负无穷大方向取整</td></tr><tr><td>fown</td><td>向0的方向取整</td></tr><tr><td>up</td><td>正数向无穷大取整，负数向无穷大取整</td></tr><tr><td>half_up</td><td>5，6，7，8向上取整，1，2，3，4向下取整，常用的四舍五入</td></tr><tr><td>half_down</td><td>6,7,8,9 向上取整 1,2,3,4,5 向下取整</td></tr><tr><td>half_even</td><td>小数位是5时，判断整数部分是奇数就进位、 小数位是5时，判断整数部分是偶数就舍弃、 1,2,3,4, 舍弃、 6,7,8,9, 进位</td></tr></tbody></table><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p><p>第一个构造函数使用当前日期和时间来初始化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date( )</span><br></pre></td></tr></table></figure><p>第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date(<span class="type">long</span> millisec)</span><br></pre></td></tr></table></figure><p>Date 对象创建以后，可以调用下面的方法</p><table><thead><tr><th>1</th><th><strong>boolean after(Date date)</strong> 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</th></tr></thead><tbody><tr><td>2</td><td><strong>boolean before(Date date)</strong> 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</td></tr><tr><td>3</td><td><strong>Object clone( )</strong> 返回此对象的副本。</td></tr><tr><td>4</td><td><strong>int compareTo(Date date)</strong> 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</td></tr><tr><td>5</td><td><strong>int compareTo(Object obj)</strong> 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</td></tr><tr><td>6</td><td><strong>boolean equals(Object date)</strong> 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</td></tr><tr><td>7</td><td><strong>long getTime( )</strong> 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td></tr><tr><td>8</td><td><strong>int hashCode( )</strong>  返回此对象的哈希码值。</td></tr><tr><td>9</td><td><strong>void setTime(long time)</strong>   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</td></tr><tr><td>10</td><td><strong>String toString( )</strong> 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)</td></tr></tbody></table><h4 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h4><p>Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// 初始化 Date 对象</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 使用 toString() 函数显示日期时间</span></span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mon May <span class="number">04</span> 09:<span class="number">51</span>:<span class="number">52</span> CDT <span class="number">2013</span></span><br></pre></td></tr></table></figure><h4 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h4><p>Java使用以下三种方法来比较两个日期：</p><ul><li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li><li>使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。</li><li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</li></ul><h4 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h4><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="type">Date</span> <span class="variable">dNow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>( );</span><br><span class="line">      <span class="type">SimpleDateFormat</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> (<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间为: &quot;</span> + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> (<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure><p>这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。</p><p><strong>注意</strong>:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。</p><p>以上实例编译运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时间为: <span class="number">2018</span>-09-<span class="number">06</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure><h4 id="日期和时间的格式化编码"><a href="#日期和时间的格式化编码" class="headerlink" title="日期和时间的格式化编码"></a>日期和时间的格式化编码</h4><p>时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：</p><table><thead><tr><th align="left"><strong>字母</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">G</td><td align="left">纪元标记</td><td align="left">AD</td></tr><tr><td align="left">y</td><td align="left">四位年份</td><td align="left">2001</td></tr><tr><td align="left">M</td><td align="left">月份</td><td align="left">July or 07</td></tr><tr><td align="left">d</td><td align="left">一个月的日期</td><td align="left">10</td></tr><tr><td align="left">h</td><td align="left">A.M.&#x2F;P.M. (1~12)格式小时</td><td align="left">12</td></tr><tr><td align="left">H</td><td align="left">一天中的小时 (0~23)</td><td align="left">22</td></tr><tr><td align="left">m</td><td align="left">分钟数</td><td align="left">30</td></tr><tr><td align="left">s</td><td align="left">秒数</td><td align="left">55</td></tr><tr><td align="left">S</td><td align="left">毫秒数</td><td align="left">234</td></tr><tr><td align="left">E</td><td align="left">星期几</td><td align="left">Tuesday</td></tr><tr><td align="left">D</td><td align="left">一年中的日子</td><td align="left">360</td></tr><tr><td align="left">F</td><td align="left">一个月中第几周的周几</td><td align="left">2 (second Wed. in July)</td></tr><tr><td align="left">w</td><td align="left">一年中第几周</td><td align="left">40</td></tr><tr><td align="left">W</td><td align="left">一个月中第几周</td><td align="left">1</td></tr><tr><td align="left">a</td><td align="left">A.M.&#x2F;P.M. 标记</td><td align="left">PM</td></tr><tr><td align="left">k</td><td align="left">一天中的小时(1~24)</td><td align="left">24</td></tr><tr><td align="left">K</td><td align="left">A.M.&#x2F;P.M. (0~11)格式小时</td><td align="left">10</td></tr><tr><td align="left">z</td><td align="left">时区</td><td align="left">Eastern Standard Time</td></tr><tr><td align="left">‘</td><td align="left">文字定界符</td><td align="left">Delimiter</td></tr><tr><td align="left">“</td><td align="left">单引号</td><td align="left">&#96;</td></tr></tbody></table><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>在java.util包下</p><p>Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>使用Calendar的静态方法<code>getInstance()</code>实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p> Calendar类的一些静态属性如年，月，日，星期并不是表示的是2022-3-8 12:12:12。 而是用于指代set,get方法到底是取什么类型的值。<strong>作为set,get方法的第一个参数，用来指定设置获取年月日。</strong><br> <strong>不能通过静态属性来获取时间!</strong></p><table><thead><tr><th align="left">常量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Calendar.YEAR</td><td align="left">年份</td></tr><tr><td align="left">Calendar.MONTH</td><td align="left">月份</td></tr><tr><td align="left">Calendar.DATE</td><td align="left">日期</td></tr><tr><td align="left">Calendar.DAY_OF_MONTH</td><td align="left">日期，和上面的字段意义完全相同</td></tr><tr><td align="left">Calendar.HOUR</td><td align="left">12小时制的小时</td></tr><tr><td align="left">Calendar.HOUR_OF_DAY</td><td align="left">24小时制的小时</td></tr><tr><td align="left">Calendar.MINUTE</td><td align="left">分钟</td></tr><tr><td align="left">Calendar.SECOND</td><td align="left">秒</td></tr><tr><td align="left">Calendar.DAY_OF_WEEK</td><td align="left">星期几</td></tr></tbody></table><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.YEAR : &quot;</span>+Calendar.YEAR); <span class="comment">// Calendar.YEAR : 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.MONTH : &quot;</span>+Calendar.MONTH); <span class="comment">// Calendar.MONTH : 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.DAY_OF_MONTH : &quot;</span>+Calendar.DAY_OF_MONTH ); <span class="comment">//Calendar.DAY_OF_MONTH : 5</span></span><br><span class="line">System.out.println(<span class="string">&quot;Calendar.DAY_OF_WEEK : &quot;</span>+Calendar.DAY_OF_WEEK); <span class="comment">//Calendar.DAY_OF_WEEK : 7</span></span><br><span class="line">System.out.println(Calendar.HOUR);  <span class="comment">// 十二小时制的小时</span></span><br><span class="line">System.out.println(Calendar.HOUR_OF_DAY); <span class="comment">//二十四小时制的小时</span></span><br><span class="line">System.out.println(Calendar.MINUTE); <span class="comment">//分</span></span><br><span class="line">System.out.println(Calendar.SECOND); <span class="comment">//秒</span></span><br><span class="line">System.out.println(Calendar.MILLISECOND); <span class="comment">//毫秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置时间set-int-field-int-value"><a href="#设置时间set-int-field-int-value" class="headerlink" title="设置时间set(int field , int value)"></a>设置时间set(int field , int value)</h4><p>  set(int field , int value)方法通过传入上述的静态属性（第一个参数）来设置对应的值（第二个参数）。<br> 在设置年月日星期中，月是从0开始算的，星期中星期天认为是1，以此类推。<br> 直接举例子。<br> 代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">c.set(Calendar.YEAR, <span class="number">1999</span>); <span class="comment">//将年设置为1999年</span></span><br><span class="line">c.set(Calendar.MONTH,<span class="number">11</span>);   <span class="comment">//将月设置为12月    传入0为1月</span></span><br><span class="line">c.set(Calendar.DAY_OF_MONTH,<span class="number">18</span>); <span class="comment">//将日设置为18日。</span></span><br><span class="line">c.set(Calendar.DAY_OF_WEEK,<span class="number">1</span>);  <span class="comment">//将星期设置为星期天</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取时间get-int-field"><a href="#获取时间get-int-field" class="headerlink" title="获取时间get(int field)"></a>获取时间get(int field)</h4><p> get(int field)通过传入上述的静态属性可以获取对应的年月日星期。<br> 根据上述set的例子来获取时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">1999</span>); <span class="comment">//将年设置为1999年</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">11</span>);   <span class="comment">//将月设置为12月    传入0为1月</span></span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">18</span>); <span class="comment">//将日设置为18日。</span></span><br><span class="line">        <span class="comment">//c.set(Calendar.DAY_OF_WEEK, 1);  //将星期设置为星期天</span></span><br><span class="line">        System.out.println(c.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line">        System.out.println(c.get(Calendar.YEAR)); <span class="comment">//输出 1999</span></span><br><span class="line">        System.out.println(c.get(Calendar.MONTH));   <span class="comment">//输出 11</span></span><br><span class="line">        System.out.println(c.get(Calendar.DAY_OF_MONTH));<span class="comment">//输出 18</span></span><br><span class="line">        System.out.println(c.get(Calendar.DAY_OF_WEEK)); <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>java.time.LocalDate -&gt;只对年月日做出处理</p><p>java.time.LocalTime -&gt;只对时分秒纳秒做出处理</p><p>java.time.LocalDateTime -&gt;同时可以处理年月日和时分秒</p><h4 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h4><p>LocalDate:默认返回一个日期格式为yyyy-MM-dd格式的日期</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalDate now()</td><td>获取默认时区的当前日期,默认返回格式yyyy-MM-dd</td></tr><tr><td>static LocalDate now(Clock clock)</td><td>从指定时钟获取当前日期</td></tr><tr><td>static LocalDate now(ZoneId zone)</td><td>获取指定时区的当前日期</td></tr><tr><td>static LocalDate of(int year, int month, int dayOfMonth)</td><td>根据指定的年、月、日获取LocalDate 实例</td></tr><tr><td>static LocalDate of(int year, Month month, int dayOfMonth)</td><td>根据指定的年、月、日获取LocalDate 实例</td></tr><tr><td>static LocalDate ofYearDay(int year,int dayOfYear)</td><td>根据指定的年，年中的第xx天获取LocalDate实例</td></tr><tr><td>static LocalDate ofEpochDay(long epochDay)</td><td>从1970-01-01开始获取指定天数的LocalDate实例</td></tr><tr><td>static LocalDate parse(CharSequence text)</td><td>将字符串转换为LocalDate,字符串的格式必须为yyyy-MM-dd 10位长度的日期格式，否则会报错</td></tr><tr><td>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)</td><td>将text字符串转换为formatter格式，<code>text的格式必须与formatter格式一致</code>，如text为yyyyMMdd格式,则formatter也应该为yyyyMMdd格式,否则会报错</td></tr></tbody></table><h5 id="创建LocalDate"><a href="#创建LocalDate" class="headerlink" title="创建LocalDate"></a>创建LocalDate</h5><h6 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h6><blockquote><p>从默认时区的系统时钟中获取当前日期。默认输出格式为yyyy-MM-dd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//2021-11-29</span></span><br></pre></td></tr></table></figure><h6 id="now-Clock-clock"><a href="#now-Clock-clock" class="headerlink" title="now(Clock clock)"></a>now(Clock clock)</h6><blockquote><p>从指定时钟获取当前日期。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.now(Clock.systemDefaultZone());</span><br><span class="line">System.out.println(l);</span><br><span class="line"></span><br><span class="line">System.out.println(Clock.systemDefaultZone());<span class="comment">//方法返回带有系统默认时区的Clock实例。</span></span><br><span class="line">System.out.println(Clock.systemUTC());<span class="comment">//此方法返回带有UTC时区的Clock实例。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br><span class="line"></span><br><span class="line">SystemClock[Asia/Shanghai]</span><br><span class="line">SystemClock[Z]</span><br></pre></td></tr></table></figure><h6 id="now-Zoneld-zone"><a href="#now-Zoneld-zone" class="headerlink" title="now(Zoneld zone)"></a>now(Zoneld zone)</h6><blockquote><p> 从指定时区的系统时钟中获取当前日期。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.now(ZoneId.of(<span class="string">&quot;UTC+1&quot;</span>));</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure><p>时区是用ZoneId类表示的，你可以使用ZoneId.now()或ZoneId.of(“xxx”)来实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;UTC+1&quot;</span>);</span><br></pre></td></tr></table></figure><p>传给of()方法的参数是时区的ID，如“UTC+1”指距离UTC（格林威治时间）有一小时的时差，你可以使用你想要的时差来表示ZoneId（如+1与-5等等）</p><p>你也可以使用另一种方式表示zone id，即使用地区名字，也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId2</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Copenhagen&quot;</span>);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId3</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Paris&quot;</span>);</span><br></pre></td></tr></table></figure><h6 id="of-int-year-int-month-int-dayOfMonth"><a href="#of-int-year-int-month-int-dayOfMonth" class="headerlink" title="of(int year, int month, int dayOfMonth)"></a>of(int year, int month, int dayOfMonth)</h6><blockquote><p>从年、月和日获取LocalDate实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">11</span>, <span class="number">29</span>);</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure><h6 id="ofYearDay-int-year-int-dayOfYear"><a href="#ofYearDay-int-year-int-dayOfYear" class="headerlink" title="ofYearDay(int year,int dayOfYear)"></a>ofYearDay(int year,int dayOfYear)</h6><blockquote><p>从指定年的指定天获取LocalDate实例 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取2021年第230天的日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.ofYearDay(<span class="number">2021</span>, <span class="number">230</span>);</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-08-<span class="number">18</span></span><br></pre></td></tr></table></figure><p>1</p><h6 id="ofEpochDay-long-epochDay"><a href="#ofEpochDay-long-epochDay" class="headerlink" title="ofEpochDay(long epochDay)"></a>ofEpochDay(long epochDay)</h6><blockquote><p>从1970-01-01开始获取指定天数的LocalDate实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.ofEpochDay(<span class="number">0</span>);<span class="comment">//1970-01-01</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l1</span> <span class="operator">=</span> LocalDate.ofEpochDay(-<span class="number">10</span>);<span class="comment">//1969-12-22</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l2</span> <span class="operator">=</span> LocalDate.ofEpochDay(<span class="number">10</span>);<span class="comment">//1970-01-11</span></span><br></pre></td></tr></table></figure><h6 id="parse-CharSequence-text"><a href="#parse-CharSequence-text" class="headerlink" title="parse(CharSequence text)"></a>parse(CharSequence text)</h6><blockquote><p>将字符串转换为LocalDate,字符串的格式必须为yyyy-MM-dd 10位长度的日期格式，否则会报错,字符串必须是一个合法的日期，否则会报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-01-29&quot;</span>);</span><br><span class="line">System.out.println(l); <span class="comment">//2021-01-29</span></span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期格式非yyyy-MM-dd</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-1-29&quot;</span>);</span><br><span class="line"><span class="comment">//日期格式非yyyy-MM-dd</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021/01/29&quot;</span>);</span><br><span class="line"><span class="comment">//字符串不是一个合法的日期，2月没有30号</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-02-30&quot;</span>);</span><br></pre></td></tr></table></figure><p>若parse(CharSequence text)中传入的格式非yyyy-MM-dd或不合法，会抛出异常，且长度需要是10位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.time.format.DateTimeParseException: Text <span class="string">&#x27;2021/11/29&#x27;</span> could not be parsed at index <span class="number">4</span></span><br><span class="line">at java.base/java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:<span class="number">2046</span>)</span><br><span class="line">at java.base/java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:<span class="number">1948</span>)</span><br><span class="line">at java.base/java.time.LocalDate.parse(LocalDate.java:<span class="number">428</span>)</span><br><span class="line">at java.base/java.time.LocalDate.parse(LocalDate.java:<span class="number">413</span>)</span><br><span class="line">at com.aexpec.mic.merchant.controller.Test.main(Test.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure><h6 id="parse-CharSequence-text-DateTimeFormatter-formatter"><a href="#parse-CharSequence-text-DateTimeFormatter-formatter" class="headerlink" title="parse(CharSequence text, DateTimeFormatter formatter)"></a>parse(CharSequence text, DateTimeFormatter formatter)</h6><blockquote><p>将text字符串转换为formatter格式，text的格式必须与formatter格式一致，如text为yyyyMMdd格式,则formatter也应该为yyyyMMdd格式,否则会报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20211129&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line">System.out.println(l);</span><br><span class="line">System.out.println(localDate1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure><p> 为什么localDate1输出后格式为yyyy-MM-dd?<br>虽然入参格式为yyyyMMdd,但是转换为LocalDate后，格式默认为yyyy-MM-dd, LocalDate返回的格式默认为yyyy-MM-dd，下面会讲如何转换为其他格式。<br>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例：text与formatter格式不一致，会抛出异常</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20211129&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="LocalDate日期比较"><a href="#LocalDate日期比较" class="headerlink" title="LocalDate日期比较"></a>LocalDate日期比较</h5><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>boolean isBefore(ChronoLocalDate other)</td><td>检查日期是否在指定日期之前</td></tr><tr><td>boolean isAfter(ChronoLocalDate other)</td><td>检查日期是否在指定日期之后</td></tr><tr><td>boolean isEqual(ChronoLocalDate other)</td><td>比较日期是否相同</td></tr><tr><td>int compareTo(ChronoLocalDate other)</td><td>日期比较localDateA.compareTo(localDateB)，若相等返回0；若A&gt;B，返回1 ；若A&lt;B返回-1</td></tr></tbody></table><h6 id="boolean-isBefore-ChronoLocalDate-other"><a href="#boolean-isBefore-ChronoLocalDate-other" class="headerlink" title="boolean isBefore(ChronoLocalDate other)"></a>boolean isBefore(ChronoLocalDate other)</h6><blockquote><p>用于检查此LocalDate值是否在给定的ChronoLocalDate(other)之前</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.isBefore(LocalDate.parse(&quot;2021-11-28&quot;))); //false</span><br><span class="line">System.out.println(l.isBefore(LocalDate.parse(&quot;2021-11-30&quot;))); //true</span><br></pre></td></tr></table></figure><h6 id="boolean-isAfter-ChronoLocalDate-other"><a href="#boolean-isAfter-ChronoLocalDate-other" class="headerlink" title="boolean isAfter(ChronoLocalDate other)"></a>boolean isAfter(ChronoLocalDate other)</h6><blockquote><p>用于检查此LocalDate值是否在给定的ChronoLocalDate(other)之后</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.isAfter(LocalDate.parse(&quot;2021-11-28&quot;))); //true</span><br><span class="line">System.out.println(l.isAfter(LocalDate.parse(&quot;2021-11-30&quot;))); //false</span><br></pre></td></tr></table></figure><h6 id="boolean-isEqual-ChronoLocalDate-other"><a href="#boolean-isEqual-ChronoLocalDate-other" class="headerlink" title="boolean isEqual(ChronoLocalDate other)"></a>boolean isEqual(ChronoLocalDate other)</h6><blockquote><p>用于检查此LocalDate值是否与给定的ChronoLocalDate(other)相等</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.isEqual(LocalDate.parse(&quot;2021-11-28&quot;))); //false</span><br><span class="line">System.out.println(l.isEqual(LocalDate.parse(&quot;2021-11-30&quot;))); //false</span><br><span class="line">System.out.println(l.isEqual(l)); //true</span><br></pre></td></tr></table></figure><h6 id="int-compareTo-ChronoLocalDate-other"><a href="#int-compareTo-ChronoLocalDate-other" class="headerlink" title="int compareTo(ChronoLocalDate other)"></a>int compareTo(ChronoLocalDate other)</h6><blockquote><p>比较两个日期A.compareTo(B)，若日期相同则返回0；<br>若A&gt;B，则返回1；<br>若A&lt;B，则返回-1；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate l = LocalDate.parse(&quot;2021-11-29&quot;);</span><br><span class="line">System.out.println(l.compareTo(LocalDate.parse(&quot;2021-11-28&quot;))); //1</span><br><span class="line">System.out.println(l.compareTo(LocalDate.parse(&quot;2021-11-30&quot;))); //-1</span><br><span class="line">System.out.println(l.compareTo(l)); //0</span><br></pre></td></tr></table></figure><h5 id="获取年、月、日"><a href="#获取年、月、日" class="headerlink" title="获取年、月、日"></a>获取年、月、日</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getYear()</td><td>获取年份</td></tr><tr><td>Month getMonth()</td><td>使用月枚举类型获取月份</td></tr><tr><td>int getMonthValue()</td><td>返回数字月份 1-12月</td></tr><tr><td>int getDayOfMonth()</td><td>获取日期在该月是第几天</td></tr><tr><td>DayOfWeek getDayOfWeek()</td><td>获取日期是星期几</td></tr><tr><td>int getDayOfYear()</td><td>获取日期在该年是第几天</td></tr><tr><td>boolean isLeapYear()</td><td>检查是否闰年</td></tr><tr><td>int lengthOfMonth()</td><td>返回日期所在月份共有几天</td></tr><tr><td>int lengthOfYear()</td><td>返回日期所在年份共有几天</td></tr><tr><td>long toEpochDay()</td><td>返回当前日期距离1970年1月1日的天数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(localDate); <span class="comment">// 2021-11-29</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;年 : &quot;</span> + localDate.getYear()); <span class="comment">// 2021</span></span><br><span class="line">System.out.println(<span class="string">&quot;月（英文） : &quot;</span> + localDate.getMonth()); <span class="comment">// NOVEMBER</span></span><br><span class="line">System.out.println(<span class="string">&quot;月（数字英文）: &quot;</span> + localDate.getMonth().getValue()); <span class="comment">// 11</span></span><br><span class="line">System.out.println(<span class="string">&quot;月（数字英文）: &quot;</span> + localDate.getMonthValue()); <span class="comment">// 11</span></span><br><span class="line">System.out.println(<span class="string">&quot;本月第几天 : &quot;</span> + localDate.getDayOfMonth()); <span class="comment">// 29</span></span><br><span class="line">System.out.println(<span class="string">&quot;星期几（英文） : &quot;</span> + localDate.getDayOfWeek()); <span class="comment">// MONDAY</span></span><br><span class="line">System.out.println(<span class="string">&quot;星期几（数字英文） : &quot;</span> + localDate.getDayOfWeek().getValue()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年的第几天 : &quot;</span> + localDate.getDayOfYear()); <span class="comment">// 333</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否润年 : &quot;</span> + localDate.isLeapYear()); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;本月天数 : &quot;</span> + localDate.lengthOfMonth()); <span class="comment">// 30</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年天数 : &quot;</span> + localDate.lengthOfYear()); <span class="comment">// 365</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="日期计算，加-x2F-减年、月、周、日"><a href="#日期计算，加-x2F-减年、月、周、日" class="headerlink" title="日期计算，加&#x2F;减年、月、周、日"></a>日期计算，加&#x2F;减年、月、周、日</h5><h6 id="加-x2F-减年、月、周、日"><a href="#加-x2F-减年、月、周、日" class="headerlink" title="加&#x2F;减年、月、周、日"></a>加&#x2F;减年、月、周、日</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDate plus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制增加天、周、月、年</td></tr><tr><td>LocalDate plusDays(long daysToAdd)</td><td>返回增加了*天的LocalDate副本</td></tr><tr><td>LocalDate plusWeeks(long weeksToAdd)</td><td>返回增加了*周的LocalDate副本</td></tr><tr><td>LocalDate plusMonths(long monthsToAdd)</td><td>返回增加了*月的LocalDate副本</td></tr><tr><td>LocalDate plusYears(long yearsToAdd)</td><td>返回增加了*年的LocalDate副本</td></tr><tr><td>LocalDate minus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制减少天、周、月、年</td></tr><tr><td>LocalDate minusDays(long daysToSubtract)</td><td>返回减少了*天的LocalDate副本</td></tr><tr><td>LocalDate minusWeeks(long weeksToSubtract)</td><td>返回减少了*周的LocalDate副本</td></tr><tr><td>LocalDate minusMonths(long monthsToSubtract)</td><td>返回减少了*月的LocalDate副本</td></tr><tr><td>LocalDate minusYears(long yearsToSubtract)</td><td>返回减少了*年的LocalDate副本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">localDate1 = LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>);</span><br><span class="line">System.out.println(localDate1); <span class="comment">// 2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加 : &quot;</span> + localDate1.plus(<span class="number">1</span>, ChronoUnit.DAYS));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;增加天数 : &quot;</span> + localDate1.plusDays(<span class="number">1</span>)); <span class="comment">// 2021-11-30</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加周数 : &quot;</span> + localDate1.plusWeeks(<span class="number">1</span>)); <span class="comment">// 2021-12-06</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加月数 : &quot;</span> + localDate1.plusMonths(<span class="number">1</span>)); <span class="comment">// 2021-12-29</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加年数 : &quot;</span> + localDate1.plusYears(<span class="number">1</span>)); <span class="comment">// 2022-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少 : &quot;</span> + localDate1.minus(<span class="number">1</span>, ChronoUnit.DAYS));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;减少天数 : &quot;</span> + localDate1.minusDays(<span class="number">1</span>)); <span class="comment">// 2021-11-28</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少月数 : &quot;</span> + localDate1.minusMonths(<span class="number">1</span>)); <span class="comment">// 2021-10-29</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少周数 : &quot;</span> + localDate1.minusWeeks(<span class="number">1</span>)); <span class="comment">// 2021-11-22</span></span><br><span class="line">System.out.println(<span class="string">&quot;减少年数 : &quot;</span> + localDate1.minusYears(<span class="number">1</span>)); <span class="comment">// 2020-11-29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上方法返回的都是LocalDate实例的副本，即源对象localDate1变量的值不变</p><h6 id="计算两个日期的间隔"><a href="#计算两个日期的间隔" class="headerlink" title="计算两个日期的间隔"></a>计算两个日期的间隔</h6><ol><li><p><strong>方法一</strong>：计算两个日期相差的天数</p><blockquote><p>调用LocalDate类的toEpochDay方法，返回距离1970年1月1日的long值<br>此方法只能计算两个日期相差的天数，不能计算月数，年数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">28</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间之间的相差的天数: &quot;</span>+(end.toEpochDay()-start.toEpochDay())); <span class="comment">//644</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong>计算两个日期相差的天数、月数、年数</p><blockquote><p>ChronoUnit也可以计算两个单元之间的天数、月数或年数。<br>我们使用ChronoUnit类的between() 方法来执行相同的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">28</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">long</span> days= ChronoUnit.DAYS.between(start , end );</span><br><span class="line">结果：<span class="number">644</span></span><br><span class="line"><span class="type">long</span> month= ChronoUnit.MONTHS.between(start , end );</span><br><span class="line">结果<span class="number">21</span></span><br><span class="line"><span class="type">long</span> year= ChronoUnit.YEARS.between(start , end );</span><br><span class="line">结果 <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>方法三</strong>: 计算两个日期相差的年月日</p><blockquote><p>此方法主要是计算两个日期相差的年月日，不能计算出具体相差了多少天</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">28</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(start,end);</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间之间的差值  年：&quot;</span>+period.getYears()+<span class="string">&quot;，月：&quot;</span>+period.getMonths()+<span class="string">&quot;，日：&quot;</span>+period.getDays());</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个时间之间的差值  年：1，月：9，日：5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String format(DateTimeFormatter formatter)</td><td>使用特定格式化形式将LocalDate转为字符串</td></tr><tr><td>static LocalDate parse(CharSequence text)</td><td>从文本字符串获取LocalDate实例，text必须是yyyy-MM-dd格式</td></tr><tr><td>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)</td><td>使用特定格式化形式从文本字符串获取LocalDate实例，<code>text的格式必须与formatter格式一致</code>，如text为yyyyMMdd格式,则formatter也应该为yyyyMMdd格式,否则会报错</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">l</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-01-29&quot;</span>);</span><br><span class="line">System.out.println(l); <span class="comment">//2021-01-29</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">l1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-11-29&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">System.out.println(l1); <span class="comment">//2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20211129&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line">System.out.println(localDate1); <span class="comment">//2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">System.out.println(l.format(dtf));<span class="comment">// 2021-01-29 十位转八位 ==&gt; 20210129</span></span><br><span class="line"></span><br><span class="line">dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">System.out.println(l.format(dtf));<span class="comment">// 2021-01-29  ==&gt; 2021年01月29日</span></span><br><span class="line"></span><br><span class="line">dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">System.out.println(l.format(dtf));<span class="comment">// 2021-01-29  ==&gt; 2021/01/29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LocalDate进阶-获取月末、月首、本周一、下周五、每个月的周一"><a href="#LocalDate进阶-获取月末、月首、本周一、下周五、每个月的周一" class="headerlink" title="LocalDate进阶,获取月末、月首、本周一、下周五、每个月的周一"></a>LocalDate进阶,获取月末、月首、本周一、下周五、每个月的周一</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDate with(TemporalAdjuster adjuster)</td><td>使用传递的TemporalAdjuster作为参数来调整此日期时间，并在调整后返回调整后的日期时间的副本</td></tr><tr><td>LocalDate with(TemporalField field, long newValue)</td><td>用于将LocalDate的指定字段设置为新值并返回新的日期时间的副本。此方法可用于更改任何受支持的字段，例如年，月或day-of-month。如果由于不支持该字段或其他原因而无法设置新值，则会引发异常。</td></tr><tr><td>LocalDate withMonth(int month)</td><td>修改LocalDate变量的月份，如LocalDate.parse(“2021-10-30”).withMonth(3)则为2021-03-30<br/>month:从1到12</td></tr><tr><td>LocalDate withDayOfMonth(int dayOfMonth)</td><td>修改LocalDate变量的日，如LocalDate.parse(“2021-10-30”).withDayOfMonth(3)则为2021-10-03 dayOfMonth：从1到28-31</td></tr><tr><td>LocalDate withDayOfYear(int dayOfYear)</td><td>返回当年第几天的日期，如当年第300天是几月几号，dayOfYear从1到365-366</td></tr><tr><td>LocalDate withYear(int year)</td><td>修改LocalDate变量的年份，如LocalDate.parse(“2021-10-30”).withYear(2000)则为2000-10-30 year:从MIN_YEAR到MAX_YEAR</td></tr></tbody></table><h6 id="LocalDate-with-TemporalAdjuster-adjuster"><a href="#LocalDate-with-TemporalAdjuster-adjuster" class="headerlink" title="LocalDate with(TemporalAdjuster adjuster)"></a>LocalDate with(TemporalAdjuster adjuster)</h6><blockquote><p>该方法用于使用传递的TemporalAdjuster作为参数来调整此日期时间，并在调整后返回调整后的日期时间的副本。使用指定的调整器策略对象进行调整。该LocalDate实例是不可变的，不受此方法调用的影响。</p></blockquote><p>参数：该方法接受调节器作为要使用的调节器的参数。</p><p>返回值：该方法将基于此方法返回LocalDate并进行调整。</p><p>异常：此方法引发以下异常：</p><ul><li>DateTimeException–如果无法进行调整。</li><li>ArithmeticException–如果发生数字溢出。</li></ul><p>TemporalAdjuster：时间调节器<br>有的时候，你需要进行一些更加灵活复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。这时，就需要时间调节器 TemporalAdjuster，可以更加灵活地处理日期。TemporalAdjusters 工具提供了一些通用的功能，并且你还可以新增你自己的功能。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static TemporalAdjuster firstDayOfMonth()</td><td>当前月的第一天</td></tr><tr><td>static TemporalAdjuster firstDayOfNextMonth()</td><td>下一个月的第一天</td></tr><tr><td>static TemporalAdjuster firstDayOfNextYear()</td><td>下一年的第一天</td></tr><tr><td>static TemporalAdjuster firstDayOfYear()</td><td>当年的第一天</td></tr><tr><td>static TemporalAdjuster lastDayOfYear()</td><td>当年的最后一天</td></tr><tr><td>static TemporalAdjuster lastDayOfMonth()</td><td>当月的最后一天</td></tr><tr><td>static TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)</td><td>某月的第一个星期几</td></tr><tr><td>static TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)</td><td>某月的最后一个星期几</td></tr><tr><td>static TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</td><td>某月的第几个星期几，例如，三月中第二个星期二</td></tr><tr><td>static TemporalAdjuster next(DayOfWeek dayOfWeek)</td><td>(往后不包括当天)下一个星期几是几月几号。若当前为周三，那么next(DayOfWeek.WEDNESDAY)指下一个周三即下周三；next(DayOfWeek.SUNDAY) 指下一个周日即本周日(此时并不是下周日)</td></tr><tr><td>static TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)</td><td>(往后包括当天)最近星期几的日期。如最近星期五的日期，如果今天是星期五，则返回今天日期，如果今天不是星期五，则返回下周五的日期</td></tr><tr><td>static TemporalAdjuster previous(DayOfWeek dayOfWeek)</td><td>(往前不包括当天)上一个星期几是几月几号。若当前为周三，那么previous(DayOfWeek.WEDNESDAY)指上一个周三即上周三；previous(DayOfWeek.TUESDAY) 指上一个周二即昨天(此时并不是上周二)</td></tr><tr><td>static TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)</td><td>(往前包括当天)最近星期几的日期。如最近星期五的日期，如果今天是星期五，则返回今天日期，如果今天不是星期五，则返回上周五的日期</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间：&quot;</span>+now); <span class="comment">//2021-11-30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当月第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfMonth()));<span class="comment">// 2021-11-01</span></span><br><span class="line"><span class="comment">//获取本月第2天：</span></span><br><span class="line">System.out.println(<span class="string">&quot;本月第2天：&quot;</span>+now.withDayOfMonth(<span class="number">2</span>)); <span class="comment">//2021-11-02</span></span><br><span class="line"><span class="comment">//获取下月第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;下月第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfNextMonth())); <span class="comment">//2021-12-01</span></span><br><span class="line"><span class="comment">//获取明年第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;明年第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfNextYear())); <span class="comment">//2022-01-01</span></span><br><span class="line"><span class="comment">//获取本年第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfYear()));<span class="comment">//2021-01-01</span></span><br><span class="line"><span class="comment">//获取当月最后一天，再也不用计算是28，29，30还是31：</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月最后一天：&quot;</span>+now.with(TemporalAdjusters.lastDayOfMonth())); <span class="comment">//2021-11-30</span></span><br><span class="line"><span class="comment">//获取本年最后一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年最后一天：&quot;</span>+now.with(TemporalAdjusters.lastDayOfYear())); <span class="comment">//2021-12-31</span></span><br><span class="line"><span class="comment">//获取当月的第一个星期一</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月的第一个星期一：&quot;</span>+now.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY))); <span class="comment">//2021-11-01</span></span><br><span class="line"><span class="comment">//获取当月的最后一个星期一</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月的最后一个星期一：&quot;</span>+now.with(TemporalAdjusters.lastInMonth(DayOfWeek.MONDAY))); <span class="comment">//2021-11-29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当月第三周星期五</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月第三周星期五：&quot;</span>+now.with(TemporalAdjusters.dayOfWeekInMonth(<span class="number">3</span>, DayOfWeek.FRIDAY))); <span class="comment">//2021-11-19</span></span><br><span class="line"><span class="comment">//获取本周一</span></span><br><span class="line">System.out.println(<span class="string">&quot;本周一：&quot;</span>+now.with(DayOfWeek.MONDAY)); <span class="comment">//2021-11-29</span></span><br><span class="line"><span class="comment">//获取上周二</span></span><br><span class="line">System.out.println(<span class="string">&quot;上周二：&quot;</span>+now.minusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)); <span class="comment">//2021-11-23</span></span><br><span class="line"><span class="comment">//(往前不包括当天)获取当前日期的上一个周一  如果今天是周一，则返回上周一</span></span><br><span class="line">System.out.println(<span class="string">&quot;上一个周一(不包括当天)：&quot;</span>+now.with(TemporalAdjusters.previous(DayOfWeek.MONDAY))); <span class="comment">//2021-11-29</span></span><br><span class="line"><span class="comment">//(往前包括当天)最近星期五的日期  如果今天是星期五，则返回今天日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;上一个周一(包括当天)：&quot;</span>+now.with(TemporalAdjusters.previousOrSame(DayOfWeek.FRIDAY))); <span class="comment">//2021-11-26</span></span><br><span class="line"><span class="comment">//获取下周二</span></span><br><span class="line">System.out.println(<span class="string">&quot;下周二：&quot;</span>+now.plusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)); <span class="comment">//2021-12-07</span></span><br><span class="line"><span class="comment">//(往后不包括当天)获取当前日期的下一个周日 如果今天是周日，则返回下周日的时间  如果今天是星期一，则返回本周日的时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;下一个周日(不包括当天)：&quot;</span>+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY))); <span class="comment">//2021-12-05</span></span><br><span class="line"><span class="comment">//(往后包括当天)最近星期五的日期  如果今天是星期五，则返回今天日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;下一个周日(包括当天)：&quot;</span>+now.with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY))); <span class="comment">//2021-12-03</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LocalDateTime与Date的互转"><a href="#LocalDateTime与Date的互转" class="headerlink" title="LocalDateTime与Date的互转"></a>LocalDateTime与Date的互转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Date转LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> date Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> LocalDateTime</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">dateToLocalDateTime</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">     <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="keyword">return</span> instant.atZone(zoneId).toLocalDateTime();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LocalDateTime转Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> localDateTime LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Date</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">localDateTimeToDate</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> localDateTime.atZone(zoneId);</span><br><span class="line">     <span class="keyword">return</span> Date.from(zdt.toInstant());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="LocalTime类"><a href="#LocalTime类" class="headerlink" title="LocalTime类"></a>LocalTime类</h4><p>java.time.LocalTime -&gt;只对时分秒纳秒做出处理</p><blockquote><p>默认格式：HH:mm:ss.SSSSSSSSS 例如：11:23:40.051942200。<br><code>当纳秒&lt;=0时，不显示纳秒</code><br><code>当秒&lt;=0且纳秒&lt;=0时，默认只显示时:分 如11：23</code></p></blockquote><h5 id="创建LocalTime"><a href="#创建LocalTime" class="headerlink" title="创建LocalTime"></a>创建LocalTime</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalTime now()</td><td>返回当前时间时分秒纳秒，默认格式：HH:mm:ss.SSSSSSSSS</td></tr><tr><td>static LocalTime now(ZoneId zone)</td><td>通过指定时区创建LocalTime实例</td></tr><tr><td>static LocalTime now(Clock clock)</td><td>通过指定时钟创建LocalTime实例</td></tr><tr><td>static LocalTime of(int hour, int minute)</td><td>通过时、分创建LocalTime实例， 输出格式为HH:mm,此时默认不输出秒、纳秒</td></tr><tr><td>static LocalTime of(int hour, int minute, int second)</td><td>通过时、分、秒创建LocalTime实例，默认输出格式为HH:mm:ss</td></tr><tr><td>static LocalTime of(int hour, int minute, int second, int nanoOfSecond)</td><td>通过时、分、秒、纳秒创建LocalTime实例，当纳秒&gt;0时显示纳秒，否则不显示纳秒</td></tr><tr><td>static LocalTime ofSecondOfDay(long secondOfDay)</td><td>通过一天的秒数创建LocalTime实例 secondOfDay：从0到24 * 60 * 60 – 1</td></tr><tr><td>static LocalTime ofNanoOfDay(long nanoOfDay)</td><td>通过一天的纳秒数创建LocalTime实例 nanoOfDay：从0到24 * 60 * 60 * 1,000,000,000 - 1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时分秒纳秒</span></span><br><span class="line">System.out.println(LocalTime.now()); <span class="comment">//15:51:01.167526700</span></span><br><span class="line"><span class="comment">//获取指定闹钟的时间</span></span><br><span class="line">System.out.println(LocalTime.now(Clock.systemUTC()));<span class="comment">//07:51:01.168523900 备注：utc时间与当前时间相差8小时</span></span><br><span class="line"><span class="comment">//获取指定时区的时间</span></span><br><span class="line">System.out.println(LocalTime.now(ZoneId.systemDefault())); <span class="comment">//15:51:01.168523900</span></span><br><span class="line"><span class="comment">//获取时、分</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>));<span class="comment">//13:23</span></span><br><span class="line"><span class="comment">//获取时、分、秒</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">23</span>));<span class="comment">//13:23:23</span></span><br><span class="line"><span class="comment">//获取时、分、秒(当秒=0时，默认不显示秒，只有HH:mm)</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">0</span>));<span class="comment">//13:23</span></span><br><span class="line"><span class="comment">//获取时、分、秒、纳秒</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">33</span>,<span class="number">1</span>));<span class="comment">//13:23:33.000000001</span></span><br><span class="line"><span class="comment">//获取时、分、秒、纳秒(当纳秒=0时，默认不显示纳秒)</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">13</span>, <span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//13:23</span></span><br><span class="line"><span class="comment">//通过一天内的秒创建LocalTime</span></span><br><span class="line">System.out.println(LocalTime.ofSecondOfDay(<span class="number">24</span>*<span class="number">60</span>));<span class="comment">//00:24</span></span><br><span class="line"><span class="comment">//通过一天内的纳秒创建LocalTime</span></span><br><span class="line">System.out.println(LocalTime.ofNanoOfDay(<span class="number">24</span>*<span class="number">60</span>));<span class="comment">//00:00:00.000001440</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="LocalTime时间比较"><a href="#LocalTime时间比较" class="headerlink" title="LocalTime时间比较"></a>LocalTime时间比较</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean isAfter(LocalTime other)</td><td>比较时间是否在other之后</td></tr><tr><td>boolean isBefore(LocalTime other)</td><td>比较时间是否在other之前</td></tr><tr><td>int compareTo(LocalTime other)</td><td>时间比较localTimeA.compareTo(localTimeB)，若相等返回0；若A&gt;B，返回1 ；若A&lt;B返回-1</td></tr><tr><td><strong>说明</strong></td><td></td></tr><tr><td>isAfter、isBefore只能比较之前之后，当值相等的时候，需要用compareTo比较</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">before</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">after</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前时分秒纳秒</span></span><br><span class="line">System.out.println(before.isAfter(after)); <span class="comment">//false</span></span><br><span class="line">System.out.println(before.isBefore(after)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(before.compareTo(after)); <span class="comment">//-1</span></span><br><span class="line">System.out.println(after.compareTo(before)); <span class="comment">//1</span></span><br><span class="line">System.out.println(before.compareTo(before)); <span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获取时、分、秒、纳秒"><a href="#获取时、分、秒、纳秒" class="headerlink" title="获取时、分、秒、纳秒"></a>获取时、分、秒、纳秒</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getHour()</td><td>获取小时 ，返回0到23</td></tr><tr><td>int getMinute()</td><td>获取分钟，返回0到59</td></tr><tr><td>int getSecond()</td><td>获取秒，返回0到59</td></tr><tr><td>int getNano()</td><td>获取纳秒，返回0到999,999,999</td></tr><tr><td>int get(TemporalField field)</td><td>通用方法，通过传入TemporalField对象可以获取时、分、秒、毫秒、纳秒 …</td></tr><tr><td>long getLong(TemporalField field)</td><td>通用方法，通过传入TemporalField对象可以获取时、分、秒、毫秒、纳秒…</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:51:01.167526700&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取小时</span></span><br><span class="line">System.out.println(now.getHour()); <span class="comment">//15</span></span><br><span class="line"><span class="comment">//获取分钟</span></span><br><span class="line">System.out.println(now.getMinute()); <span class="comment">//51</span></span><br><span class="line"><span class="comment">//获取秒</span></span><br><span class="line">System.out.println(now.getSecond()); <span class="comment">//1</span></span><br><span class="line"><span class="comment">//获取纳秒</span></span><br><span class="line">System.out.println(now.getNano()); <span class="comment">//167526700</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用获取，通过传入TemporalField对象，获取时、分、秒、纳秒等值</span></span><br><span class="line">System.out.println(now.get(ChronoField.HOUR_OF_DAY)); <span class="comment">//15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="时间计算，加-x2F-减时、分、秒、纳秒…"><a href="#时间计算，加-x2F-减时、分、秒、纳秒…" class="headerlink" title="时间计算，加&#x2F;减时、分、秒、纳秒…"></a>时间计算，加&#x2F;减时、分、秒、纳秒…</h5><h6 id="加-x2F-减时、分、秒、纳秒"><a href="#加-x2F-减时、分、秒、纳秒" class="headerlink" title="加&#x2F;减时、分、秒、纳秒"></a>加&#x2F;减时、分、秒、纳秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalTime plus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制增加纳秒、微秒、毫秒、秒、分、时</td></tr><tr><td>LocalTime plusHours(long hoursToAdd)</td><td>返回增加了*小时的LocalTime副本</td></tr><tr><td>LocalTime plusMinutes(long minutesToAdd)</td><td>返回增加了*分钟的LocalTime副本</td></tr><tr><td>LocalTime plusSeconds(long secondstoAdd)</td><td>返回增加了*秒的LocalTime副本</td></tr><tr><td>LocalTime plusNanos(long nanosToAdd)</td><td>返回增加了*纳秒的LocalTime副本</td></tr><tr><td>LocalTime minus(long amountToSubtract, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制减少纳秒、微秒、毫秒、秒、分、时</td></tr><tr><td>LocalTime minusHours(long hoursToSubtract)</td><td>返回减少了*小时的LocalTime副本</td></tr><tr><td>LocalTime minusMinutes(long minutesToSubtract)</td><td>返回减少了*分钟的LocalTime副本</td></tr><tr><td>LocalTime minusSeconds(long secondsToSubtract)</td><td>返回减少了*秒的LocalTime副本</td></tr><tr><td>LocalTime minusNanos(long nanosToSubtract)</td><td>返回减少了*纳秒的LocalTime副本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="comment">//LocalTime plus(long amountToAdd, TemporalUnit unit)  </span></span><br><span class="line"><span class="comment">//当前api中unit可以用的有NANOS、MICROS、MILLIS、SECONDS、MINUTES、HOURS、HALF_DAYS。其他单元不可用</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1小时：&quot;</span>+now.plus(<span class="number">1</span>, ChronoUnit.HOURS)); <span class="comment">//11:51:01.167526700</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;增加1小时：&quot;</span>+now.plusHours(<span class="number">1</span>));<span class="comment">//11:51:01.167526700</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1分钟：&quot;</span>+now.plusMinutes(<span class="number">1</span>));<span class="comment">//10:52:01.167526700</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1秒：&quot;</span>+now.plusSeconds(<span class="number">1</span>));<span class="comment">//10:51:02.167526700</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加1纳秒：&quot;</span>+now.plusNanos(<span class="number">1</span>));<span class="comment">//10:51:01.167526701</span></span><br></pre></td></tr></table></figure><h6 id="计算两个时间的间隔"><a href="#计算两个时间的间隔" class="headerlink" title="计算两个时间的间隔"></a>计算两个时间的间隔</h6><ol><li><p>方法一：</p><blockquote><p>通过Duration计算两个LocalTime相差的时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:52:03.167526701&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//between的用法是end-start的时间，若start的时间大于end的时间，则所有的值是负的</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+duration.toSeconds()+<span class="string">&quot;秒，相差：&quot;</span>+duration.toHours()+<span class="string">&quot;小时，相差：&quot;</span>+duration.toMinutes()+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">18062</span>秒，相差：<span class="number">5</span>小时，相差：<span class="number">301</span>分钟</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><blockquote><p>ChronoUnit也可以计算两个单元之间的差值。<br>我们使用ChronoUnit类的between() 方法来执行相同的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:52:03.167526701&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> ChronoUnit.SECONDS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">hour</span> <span class="operator">=</span> ChronoUnit.HOURS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">minute</span> <span class="operator">=</span> ChronoUnit.MINUTES.between(start , end );</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+seconds+<span class="string">&quot;秒，相差：&quot;</span>+hour+<span class="string">&quot;小时，相差：&quot;</span>+minute+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">18062</span>秒，相差：<span class="number">5</span>小时，相差：<span class="number">301</span>分钟</span><br></pre></td></tr></table></figure></li><li><p>方法三：</p><blockquote><p>通过LocalTime类的toSecondOfDay()方法，返回时间对应的秒数，然后计算出两个时间相差的间隔</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:52:03.167526701&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> end.toSecondOfDay() - start.toSecondOfDay();</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+time+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">18062</span>秒</span><br></pre></td></tr></table></figure></li></ol><h5 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalTime parse(CharSequence text)</td><td>从文本字符串获取LocalTime实例，text格式一般是10:15或者10:15:30</td></tr><tr><td>static LocalTime parse(CharSequence text, DateTimeFormatter formatter)</td><td>使用特定格式化形式从文本字符串获取LocalTime实例，text的格式一般与formatter格式一致，如text为HH:mm格式,则formatter也应该为HH:mm格式,否则可能会报错</td></tr><tr><td>String format(DateTimeFormatter formatter)</td><td>将LocalTime转为特定格式的字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:01.167526700&quot;</span>);</span><br><span class="line">System.out.println(time); <span class="comment">//10:51:01.167526700</span></span><br><span class="line"></span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;10:51&quot;</span>);</span><br><span class="line">System.out.println(time);<span class="comment">//10:51</span></span><br><span class="line"></span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;10:51:01&quot;</span>);</span><br><span class="line">System.out.println(time);<span class="comment">//10:51:01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若使用parse(CharSequence text, DateTimeFormatter formatter)，text格式需与formatter格式一致，否则可能会报错</span></span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;10:51:01&quot;</span>,DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>));</span><br><span class="line">System.out.println(time);<span class="comment">//10:51:01</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;HH-mm-ss&quot;</span>));</span><br><span class="line">System.out.println(time1); <span class="comment">//10-51-01</span></span><br></pre></td></tr></table></figure><h5 id="LocalTime进阶"><a href="#LocalTime进阶" class="headerlink" title="LocalTime进阶"></a>LocalTime进阶</h5><h6 id="修改LocalTime的时、分、秒、纳秒"><a href="#修改LocalTime的时、分、秒、纳秒" class="headerlink" title="修改LocalTime的时、分、秒、纳秒"></a>修改LocalTime的时、分、秒、纳秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalTime with(TemporalAdjuster adjuster)</td><td>使用传递的TemporalAdjuster时间调节器作为参数来调整此日期时间，并在调整后返回调整后的时间的副本</td></tr><tr><td>LocalTime with(TemporalField field, long newValue)</td><td>用于将LocalTime的指定字段设置为新值并返回新的时间的副本。此方法可用于更改任何受支持的字段，例如时、分、秒…。如果由于不支持该字段或其他原因而无法设置新值，则会引发异常。</td></tr><tr><td>LocalTime withHour(int hour)</td><td>修改LocalTime变量的小时，hour:从0到23</td></tr><tr><td>LocalTime withMinute(int minute)</td><td>修改LocalTime变量的分钟，minute:从0到59</td></tr><tr><td>LocalTime withSecond(int second)</td><td>修改LocalTime变量的秒，second:从0到59</td></tr><tr><td>LocalTime withNano(int nanoOfSecond)</td><td>修改LocalTime变量的纳秒，nanoOfSecond:从0到999,999,999</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:51:03.167526700&quot;</span>);</span><br><span class="line"><span class="comment">//修改LocalTime变量的小时</span></span><br><span class="line">System.out.println(time.withHour(<span class="number">1</span>)); <span class="comment">//01:51:03.167526700</span></span><br><span class="line"><span class="comment">//修改LocalTime变量的分钟</span></span><br><span class="line">System.out.println(time.withMinute(<span class="number">1</span>)); <span class="comment">//10:01:03.167526700</span></span><br><span class="line"><span class="comment">//修改LocalTime变量的秒</span></span><br><span class="line">System.out.println(time.withSecond(<span class="number">1</span>)); <span class="comment">//10:51:01.167526700</span></span><br><span class="line"><span class="comment">//修改LocalTime变量的纳秒</span></span><br><span class="line">System.out.println(time.withNano(<span class="number">1</span>)); <span class="comment">//10:51:03.000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改LocalTime变量的秒</span></span><br><span class="line">System.out.println(time.with(ChronoField.SECOND_OF_MINUTE, <span class="number">1</span>)); <span class="comment">//10:51:01.167526700</span></span><br></pre></td></tr></table></figure><h5 id="LocalTime的注意事项"><a href="#LocalTime的注意事项" class="headerlink" title="LocalTime的注意事项"></a>LocalTime的注意事项</h5><p>java.time.LocalTime -&gt;只对时分秒纳秒做出处理</p><blockquote><p>默认格式：HH:mm:ss.SSSSSSSSS 例如：11:23:40.051942200。<br><code>当纳秒&lt;=0时，不显示纳秒</code><br><code>当秒&lt;=0且纳秒&lt;=0时，默认只显示时:分 如11：23</code></p></blockquote><h6 id="LocalTime有时候不显示秒？"><a href="#LocalTime有时候不显示秒？" class="headerlink" title="LocalTime有时候不显示秒？"></a>LocalTime有时候不显示秒？</h6><blockquote><p>LocalTime有时候会不显示秒，有时候我们需要把时间转化为HH:mm:ss格式时，这可能就是个坑，那么如果让LocalTime输出指定的格式呢？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">t1</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;10:00:00&quot;</span>);</span><br><span class="line"><span class="comment">//不显示秒示例</span></span><br><span class="line">System.out.println(t1);<span class="comment">//10:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(dtf.format(t1)); <span class="comment">//10:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">LocalTime t2= LocalTime.parse(<span class="string">&quot;10:00:00&quot;</span>, dtf);</span><br><span class="line">System.out.println(t2.format(DateTimeFormatter.ISO_LOCAL_TIME));<span class="comment">//10:00:00</span></span><br></pre></td></tr></table></figure><h4 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h4><p>java.time.LocalDateTime -&gt;同时可以处理年月日和时分秒</p><blockquote><p>默认格式：yyyy-MM-ddTHH:mm:ss.SSSSSSSSS 例如：2021-12-01T11:27:22.598224900</p></blockquote><h5 id="创建LocalDateTime"><a href="#创建LocalDateTime" class="headerlink" title="创建LocalDateTime"></a>创建LocalDateTime</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalDateTime now()</td><td>获取默认时区的当前日期时间，默认格式yyyy-MM-ddTHH:mm:ss.SSSSSSSSS</td></tr><tr><td>static LocalDateTime now(ZoneId zone)</td><td>从指定时区获取日期时间</td></tr><tr><td>static LocalDateTime now(Clock clock)</td><td>从指定闹钟获取日期时间</td></tr><tr><td>static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)</td><td>根据年月日时分秒创建日期时间</td></tr><tr><td>static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</td><td>根据年月日时分秒纳秒创建日期时间</td></tr><tr><td>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)</td><td>根据年月日时分秒创建日期时间</td></tr><tr><td>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</td><td>根据年月日时分秒纳秒创建日期时间</td></tr><tr><td>static LocalDateTime of(LocalDate date, LocalTime time)</td><td>根据LocalDate与LocalTime创建时间</td></tr><tr><td>static LocalDateTime ofInstant(Instant instant, ZoneId zone)</td><td>通过Instant实例与时区创建时间</td></tr><tr><td>static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)</td><td>通过毫秒数、纳秒数及时区创建时间epochSecond：从1970-01-01T00:00:00到指定时间的秒数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;当前默认时间：&quot;</span>+LocalDateTime.now());</span><br><span class="line">System.out.println(<span class="string">&quot;当前指定时区时间：&quot;</span>+LocalDateTime.now(ZoneId.systemDefault()));</span><br><span class="line">System.out.println(<span class="string">&quot;当前指定闹钟时间：&quot;</span>+LocalDateTime.now(Clock.systemUTC()));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, Month.DECEMBER, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">23</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒纳秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, Month.DECEMBER, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>,<span class="number">23</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;指定时分秒纳秒时间：&quot;</span>+LocalDateTime.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>,<span class="number">23</span>,<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;localDate、LocalTime时间：&quot;</span>+LocalDateTime.of(LocalDate.now(),LocalTime.now()));</span><br><span class="line">System.out.println(<span class="string">&quot;创建Instant实例时间：&quot;</span>+LocalDateTime.ofInstant(Instant.now(), ZoneId.of(<span class="string">&quot;UTC&quot;</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;通过秒、毫秒创建时间：&quot;</span>+LocalDateTime.ofEpochSecond(Instant.now().getEpochSecond(), <span class="number">222</span>, ZoneOffset.UTC));</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前默认时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">33</span>:<span class="number">08.769938300</span></span><br><span class="line">当前指定时区时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">33</span>:<span class="number">08.805841900</span></span><br><span class="line">当前指定闹钟时间：<span class="number">2021</span>-<span class="number">12</span>-06T02:<span class="number">33</span>:<span class="number">08.805841900</span></span><br><span class="line">指定时分秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">指定时分秒纳秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23.000000001</span></span><br><span class="line">指定时分秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">指定时分秒纳秒时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">21</span>:<span class="number">23.000000001</span></span><br><span class="line">localDate、LocalTime时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">33</span>:<span class="number">08.809832100</span></span><br><span class="line">创建Instant实例时间：<span class="number">2021</span>-<span class="number">12</span>-06T02:<span class="number">33</span>:<span class="number">08.810829400</span></span><br><span class="line">通过秒、毫秒创建时间：<span class="number">2021</span>-<span class="number">12</span>-06T02:<span class="number">33</span>:<span class="number">08.000000222</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获取年月日时分秒纳秒"><a href="#获取年月日时分秒纳秒" class="headerlink" title="获取年月日时分秒纳秒"></a>获取年月日时分秒纳秒</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getYear()</td><td>获取年份</td></tr><tr><td>Month getMonth()</td><td>使用月枚举类型获取月份</td></tr><tr><td>int getMonthValue()</td><td>返回数字月份 1-12月</td></tr><tr><td>int getDayOfMonth()</td><td>获取日期在该月是第几天</td></tr><tr><td>DayOfWeek getDayOfWeek()</td><td>获取日期是星期几</td></tr><tr><td>int getDayOfYear()</td><td>获取日期在该年是第几天</td></tr><tr><td>int getHour()</td><td>获取小时， 返回0到23</td></tr><tr><td>int getMinute()</td><td>获取分钟， 返回0到59</td></tr><tr><td>int getSecond()</td><td>获取秒，返回0到59</td></tr><tr><td>int getNano()</td><td>获取纳秒，返回0到999,999,999</td></tr></tbody></table><p>使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前默认时间：&quot;</span>+now);</span><br><span class="line"><span class="comment">//获取年份</span></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span>+now.getYear());</span><br><span class="line"><span class="comment">//获取月份</span></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+now.getMonth().getValue());</span><br><span class="line"><span class="comment">//获取当前日期是当月的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+now.getDayOfMonth());</span><br><span class="line"><span class="comment">//获取当前日期是星期几</span></span><br><span class="line">System.out.println(<span class="string">&quot;星期几：&quot;</span>+now.getDayOfWeek());</span><br><span class="line"><span class="comment">//获取当前日期是当年的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+now.getDayOfYear());</span><br><span class="line"><span class="comment">//获取小时、分钟、秒、纳秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前时间：&quot;</span>+now.getHour()+<span class="string">&quot;小时，&quot;</span>+now.getMinute()+<span class="string">&quot;分钟，&quot;</span>+now.getSecond()+<span class="string">&quot;秒，&quot;</span>+now.getNano()+<span class="string">&quot;纳秒&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用获取日期时间方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前时间：&quot;</span>+now.get(ChronoField.HOUR_OF_DAY)+<span class="string">&quot;小时，&quot;</span>+now.get(ChronoField.MINUTE_OF_HOUR)+<span class="string">&quot;分钟，&quot;</span>+now.get(ChronoField.SECOND_OF_MINUTE)+<span class="string">&quot;秒&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前默认时间：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">57</span>:<span class="number">14.833390300</span></span><br><span class="line">年：<span class="number">2021</span></span><br><span class="line">月：<span class="number">12</span></span><br><span class="line">日：<span class="number">6</span></span><br><span class="line">星期几：MONDAY</span><br><span class="line">日：<span class="number">340</span></span><br><span class="line">当前时间：<span class="number">10</span>小时，<span class="number">57</span>分钟，<span class="number">14</span>秒，<span class="number">833390300</span>纳秒</span><br><span class="line">当前时间：<span class="number">10</span>小时，<span class="number">57</span>分钟，<span class="number">14</span>秒</span><br></pre></td></tr></table></figure><h5 id="LocalDateTime日期比较"><a href="#LocalDateTime日期比较" class="headerlink" title="LocalDateTime日期比较"></a>LocalDateTime日期比较</h5><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>boolean isBefore(ChronoLocalDateTime&lt;?&gt; other)</td><td>检查日期是否在指定日期之前</td></tr><tr><td>boolean isAfter(ChronoLocalDateTime&lt;?&gt; other)</td><td>检查日期是否在指定日期之后</td></tr><tr><td>boolean isEqual(ChronoLocalDateTime&lt;?&gt; other)</td><td>比较日期是否相同</td></tr><tr><td>int compareTo(ChronoLocalDateTime&lt;?&gt; other)</td><td>日期比较localDateTimeA.compareTo(localDateTimeB)，若相等返回0；若A&gt;B，返回1 ；若A&lt;B返回-1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">before</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:57:14.833390300&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">after</span>  <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T21:57:14.833390300&quot;</span>);</span><br><span class="line">System.out.println(before.isBefore(after));<span class="comment">//true</span></span><br><span class="line">System.out.println(before.isAfter(after));<span class="comment">//false</span></span><br><span class="line">System.out.println(before.isEqual(before)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(before.compareTo(after));<span class="comment">//-1</span></span><br><span class="line">System.out.println(after.compareTo(before));<span class="comment">//1</span></span><br><span class="line">System.out.println(after.compareTo(after));<span class="comment">//0</span></span><br></pre></td></tr></table></figure><h5 id="日期计算，加-x2F-减年、月、周、日、时、分、秒"><a href="#日期计算，加-x2F-减年、月、周、日、时、分、秒" class="headerlink" title="日期计算，加&#x2F;减年、月、周、日、时、分、秒"></a>日期计算，加&#x2F;减年、月、周、日、时、分、秒</h5><h6 id="加-x2F-减年、月、周、日、时、分、秒"><a href="#加-x2F-减年、月、周、日、时、分、秒" class="headerlink" title="加&#x2F;减年、月、周、日、时、分、秒"></a>加&#x2F;减年、月、周、日、时、分、秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDateTime plus(TemporalAmount amountToAdd)</td><td>通过TemporalAmount对象增加指定日期时间，TemporalAmount的实现一般是Period,Duration对象</td></tr><tr><td>LocalDateTime plus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制增加天、周、月、年</td></tr><tr><td>LocalDateTime plusDays(long daysToAdd)</td><td>返回增加了*天的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusWeeks(long weeksToAdd)</td><td>返回增加了*周的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusMonths(long monthsToAdd)</td><td>返回增加了*月的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusYears(long yearsToAdd)</td><td>返回增加了*年的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusHours(long hours)</td><td>返回增加了*小时的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusMinutes(long minutes)</td><td>返回增加了*分钟的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusSeconds(long seconds)</td><td>返回增加了*秒的LocalDateTime 副本</td></tr><tr><td>LocalDateTime plusNanos(long nanos)</td><td>返回增加了*纳秒的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minus(TemporalAmount amountToAdd)</td><td>通过TemporalAmount对象减少指定日期时间，TemporalAmount的实现一般是Period,Duration对象</td></tr><tr><td>LocalDateTime minus(long amountToAdd, TemporalUnit unit)</td><td>通用方法，可以通过unit参数控制减少天、周、月、年</td></tr><tr><td>LocalDateTime minusDays(long daysToSubtract)</td><td>返回减少了*天的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusWeeks(long weeksToSubtract)</td><td>返回减少了*周的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusMonths(long monthsToSubtract)</td><td>返回减少了*月的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusYears(long yearsToSubtract)</td><td>返回减少了*年的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusHours(long hours)</td><td>返回减少了*小时的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusMinutes(long minutes)</td><td>返回减少了*分钟的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusSeconds(long seconds)</td><td>返回减少了*秒的LocalDateTime 副本</td></tr><tr><td>LocalDateTime minusNanos(long nanos)</td><td>返回减少了*纳秒的LocalDateTime 副本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;增加1年：&quot;</span>+now.plusYears(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;增加1月：&quot;</span>+now.plusMonths(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;增加1天：&quot;</span>+now.plusDays(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;减少1小时：&quot;</span>+now.minusHours(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;减少1分钟：&quot;</span>+now.minusMinutes(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;减少1秒：&quot;</span>+now.minusSeconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime plus(TemporalAmount amountToAdd)</span></span><br><span class="line">System.out.println(<span class="string">&quot;增加2个月：&quot;</span>+now.plus(Period.ofMonths(<span class="number">2</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;增加2天：&quot;</span>+now.plus(Duration.ofDays(<span class="number">2</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;增加1纳秒：&quot;</span>+now.plus(<span class="number">1</span>, ChronoUnit.NANOS));</span><br><span class="line">System.out.println(<span class="string">&quot;减少1分钟：&quot;</span>+now.minus(<span class="number">1</span>, ChronoUnit.MINUTES));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">增加<span class="number">1</span>年：<span class="number">2022</span>-<span class="number">12</span>-06T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">1</span>月：<span class="number">2022</span>-<span class="number">01</span>-06T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">1</span>天：<span class="number">2021</span>-<span class="number">12</span>-07T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">减少<span class="number">1</span>小时：<span class="number">2021</span>-<span class="number">12</span>-06T10:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">减少<span class="number">1</span>分钟：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line">减少<span class="number">1</span>秒：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">01</span></span><br><span class="line">增加<span class="number">2</span>个月：<span class="number">2022</span>-<span class="number">02</span>-06T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">2</span>天：<span class="number">2021</span>-<span class="number">12</span>-08T11:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line">增加<span class="number">1</span>纳秒：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">01</span>:<span class="number">01.000000001</span></span><br><span class="line">减少<span class="number">1</span>分钟：<span class="number">2021</span>-<span class="number">12</span>-06T11:<span class="number">00</span>:<span class="number">01</span></span><br></pre></td></tr></table></figure><h6 id="计算两个日期时间的间隔"><a href="#计算两个日期时间的间隔" class="headerlink" title="计算两个日期时间的间隔"></a>计算两个日期时间的间隔</h6><p>方法一：</p><blockquote><p>通过Duration计算两个LocalTime相差的时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span>   <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-07T11:06:01&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//between的用法是end-start的时间，若start的时间大于end的时间，则所有的值是负的</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+duration.toDays()+<span class="string">&quot;天，相差&quot;</span>+duration.toSeconds()+<span class="string">&quot;秒，相差：&quot;</span>+duration.toHours()+<span class="string">&quot;小时，相差：&quot;</span>+duration.toMinutes()+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">1</span>天，相差<span class="number">86700</span>秒，相差：<span class="number">24</span>小时，相差：<span class="number">1445</span>分钟</span><br></pre></td></tr></table></figure><p>方法二：</p><blockquote><p>ChronoUnit也可以计算两个单元之间的差值。<br>我们使用ChronoUnit类的between() 方法来执行相同的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span>   <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-07T11:06:01&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> ChronoUnit.DAYS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> ChronoUnit.SECONDS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">hour</span> <span class="operator">=</span> ChronoUnit.HOURS.between(start , end );</span><br><span class="line"><span class="type">long</span> <span class="variable">minute</span> <span class="operator">=</span> ChronoUnit.MINUTES.between(start , end );</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+day + <span class="string">&quot;天，相差&quot;</span>+seconds+<span class="string">&quot;秒，相差：&quot;</span>+hour+<span class="string">&quot;小时，相差：&quot;</span>+minute+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">1</span>天，相差<span class="number">86700</span>秒，相差：<span class="number">24</span>小时，相差：<span class="number">1445</span>分钟</span><br></pre></td></tr></table></figure><p>方法三：</p><blockquote><p>通过LocalDateTime类的toEpochSecond()方法，返回时间对应的秒数，然后计算出两个时间相差的间隔</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span>   <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-07T11:06:01&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;两个时间相差：&quot;</span>+ (end.toEpochSecond(ZoneOffset.UTC) - start.toEpochSecond(ZoneOffset.UTC)) +<span class="string">&quot;秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">两个时间相差：<span class="number">86700</span>秒</span><br></pre></td></tr></table></figure><h5 id="时间格式化-1"><a href="#时间格式化-1" class="headerlink" title="时间格式化"></a>时间格式化</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static LocalDateTime parse(CharSequence text)</td><td>从文本字符串获取LocalDateTime实例，text格式一般是2007-12-03T10:15:30</td></tr><tr><td>static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)</td><td>使用特定格式化形式从文本字符串获取LocalDateTime实例，text的格式一般与formatter格式一致</td></tr><tr><td>String format(DateTimeFormatter formatter)</td><td>将LocalTime转为特定格式的字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T11:01:01&quot;</span>);</span><br><span class="line">System.out.println(time); <span class="comment">//2021-12-06T11:01:01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若使用parse(CharSequence text, DateTimeFormatter formatter)，text格式需与formatter格式一致，否则可能会报错</span></span><br><span class="line">time = LocalDateTime.parse(<span class="string">&quot;2021-12-06 11:01:01&quot;</span>,DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">System.out.println(time);<span class="comment">//2021-12-06T11:01:01</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH-mm-ss&quot;</span>));</span><br><span class="line">System.out.println(time1); <span class="comment">//2021-12-06 11-01-01</span></span><br></pre></td></tr></table></figure><p>注意：<br>parse(CharSequence text, DateTimeFormatter formatter)与format(DateTimeFormatter formatter)两个方法表现不一样，parse后输出格式为yyyy-MM-ddTHH:mm:ss.SSSSSSSSS，format后输出格式为formatter样式。</p><h6 id="LocalDateTime进阶"><a href="#LocalDateTime进阶" class="headerlink" title="LocalDateTime进阶"></a>LocalDateTime进阶</h6><h6 id="修改年、月、日、时、分、秒、纳秒"><a href="#修改年、月、日、时、分、秒、纳秒" class="headerlink" title="修改年、月、日、时、分、秒、纳秒"></a>修改年、月、日、时、分、秒、纳秒</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>LocalDateTime with(TemporalAdjuster adjuster)</td><td>使用传递的TemporalAdjuster时间调节器作为参数来调整此日期时间，并在调整后返回调整后的时间的副本</td></tr><tr><td>LocalDateTime with(TemporalField field, long newValue)</td><td>用于将LocalTime的指定字段设置为新值并返回新的时间的副本。此方法可用于更改任何受支持的字段，例如时、分、秒…。如果由于不支持该字段或其他原因而无法设置新值，则会引发异常。</td></tr><tr><td>LocalDateTime withYear(int year)</td><td>修改LocalTime变量的年</td></tr><tr><td>LocalDateTime withMonth(int month)</td><td>修改LocalTime变量的月份</td></tr><tr><td>LocalDateTime withDayOfMonth(int dayOfMonth)</td><td>修改LocalTime变量的日</td></tr><tr><td>LocalDateTime withHour(int hour)</td><td>修改LocalTime变量的小时，hour:从0到23</td></tr><tr><td>LocalDateTime withMinute(int minute)</td><td>修改LocalDateTime变量的分钟，minute:从0到59</td></tr><tr><td>LocalDateTime withSecond(int second)</td><td>修改LocalDateTime变量的秒，second:从0到59</td></tr><tr><td>LocalDateTime withNano(int nanoOfSecond)</td><td>修改LocalDateTime变量的纳秒，nanoOfSecond:从0到999,999,999</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:11:11&quot;</span>);</span><br><span class="line"><span class="comment">//修改LocalDateTime变量的年</span></span><br><span class="line">System.out.println(time.withYear(<span class="number">2020</span>)); <span class="comment">//2020-12-06T10:11:11</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的月</span></span><br><span class="line">System.out.println(time.withMonth(<span class="number">11</span>)); <span class="comment">//2021-11-06T10:11:11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的小时</span></span><br><span class="line">System.out.println(time.withHour(<span class="number">1</span>)); <span class="comment">//2021-12-06T01:11:11</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的分钟</span></span><br><span class="line">System.out.println(time.withMinute(<span class="number">3</span>)); <span class="comment">//2021-12-06T10:03:11</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的秒</span></span><br><span class="line">System.out.println(time.withSecond(<span class="number">1</span>)); <span class="comment">//2021-12-06T10:11:01</span></span><br><span class="line"><span class="comment">//修改LocalDateTime变量的纳秒</span></span><br><span class="line">System.out.println(time.withNano(<span class="number">1</span>)); <span class="comment">//2021-12-06T10:11:11.000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法，修改LocalDateTime变量的日</span></span><br><span class="line">System.out.println(time.with(ChronoField.DAY_OF_MONTH, <span class="number">12</span>)); <span class="comment">//2021-12-12T10:11:11</span></span><br></pre></td></tr></table></figure><p><strong>获取下周二上午10点的日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取下周二上午10点的日期</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">ldt = ldt.plusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)</span><br><span class="line">.with(ChronoField.MILLI_OF_DAY, <span class="number">0</span>).withHour(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>获取本月最后一天最后一刻</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span>   LocalDate.now()</span><br><span class="line">.with(TemporalAdjusters.lastDayOfMonth()).atTime(LocalTime.MAX);</span><br></pre></td></tr></table></figure><p><strong>下个月第一个周一的下午五点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span>   LocalDate.now()</span><br><span class="line">.with(TemporalAdjusters.lastDayOfMonth()).atTime(LocalTime.MAX);</span><br></pre></td></tr></table></figure><h6 id="LocalDateTime、LocalDate、LocalTime互转"><a href="#LocalDateTime、LocalDate、LocalTime互转" class="headerlink" title="LocalDateTime、LocalDate、LocalTime互转"></a>LocalDateTime、LocalDate、LocalTime互转</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:11:11&quot;</span>);</span><br><span class="line"><span class="comment">//1. LocalDateTime转LocalDate</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> localDateTime.toLocalDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. LocalDateTime转LocalTime</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> localDateTime.toLocalTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. LocalDate转LocalDateTime</span></span><br><span class="line"><span class="comment">//3.1 LocalDateTime atTime(LocalTime time)</span></span><br><span class="line">localDateTime = localDate.atTime(localTime);</span><br><span class="line"><span class="comment">//3.2 LocalDateTime atTime(int hour, int minute, int second)</span></span><br><span class="line">localDateTime = localDate.atTime(<span class="number">10</span>,<span class="number">11</span>,<span class="number">11</span>);</span><br><span class="line"><span class="comment">//3.3 LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond)</span></span><br><span class="line">localDateTime = localDate.atTime(<span class="number">10</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//3.4 获得一天的开始</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">beginningOfDay</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2016-06-12&quot;</span>).atStartOfDay(); <span class="comment">//2016-06-12T00：00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. LocalTime转LocalDateTime</span></span><br><span class="line"><span class="comment">//4.1 LocalDateTime atDate(LocalDate date)</span></span><br><span class="line">localDateTime = localTime.atDate(localDate);</span><br></pre></td></tr></table></figure><h6 id="LocalDateTime转为Instant、获取时间戳"><a href="#LocalDateTime转为Instant、获取时间戳" class="headerlink" title="LocalDateTime转为Instant、获取时间戳"></a>LocalDateTime转为Instant、获取<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020">时间戳</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-12-06T10:11:11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.LocalDateTime转Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> localDateTime.toInstant(ZoneOffset.UTC);</span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 获取距离1970-01-01T00:00:00Z的秒值</span></span><br><span class="line">System.out.println(instant.getEpochSecond());</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Instant获取时间戳  获取距离1970-01-01T00:00:00Z的毫秒值  与System.currentTimeMillis()一样，返回毫秒数</span></span><br><span class="line">System.out.println(instant.toEpochMilli());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. Date转LocalDateTime  static LocalDateTime ofInstant(Instant instant, ZoneId zone)</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(<span class="keyword">new</span> <span class="title class_">Date</span>().toInstant(),ZoneId.systemDefault());</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Date转LocalTime    static LocalTime ofInstant(Instant instant, ZoneId zone)</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.ofInstant(<span class="keyword">new</span> <span class="title class_">Date</span>().toInstant(),ZoneId.systemDefault());</span><br><span class="line">System.out.println(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. LocalDateTime/LocalTime转Date  static Date from(Instant instant)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(localDateTime.toInstant(ZoneId.systemDefault().getRules().getOffset(localDateTime)));</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.1 LocalDateTime/LocalTime转Date   Date(long date) date:毫秒值</span></span><br><span class="line">date = <span class="keyword">new</span> <span class="title class_">Date</span>(localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">12</span>-06T18:<span class="number">33</span>:<span class="number">17.965</span></span><br><span class="line"><span class="number">18</span>:<span class="number">33</span>:<span class="number">17.982</span></span><br><span class="line">Mon Dec <span class="number">06</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">17</span> CST <span class="number">2021</span></span><br><span class="line">Mon Dec <span class="number">06</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">17</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date转LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> date Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> LocalDateTime</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">dateToLocalDateTime</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">     <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="keyword">return</span> instant.atZone(zoneId).toLocalDateTime();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LocalDateTime转Date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> localDateTime LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Date</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">localDateTimeToDate</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">     <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">     <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> localDateTime.atZone(zoneId);</span><br><span class="line">     <span class="keyword">return</span> Date.from(zdt.toInstant());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>为什么要有集合</strong><br>提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行添加、修改、删除操作，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为Collection和Map两种体系。</p><p><strong>集合和数组</strong></p><ul><li><p>长度区别</p><ul><li>数组固定</li><li>集合可变</li></ul></li><li><p>内容区别</p><ul><li>数组可以是基本类型，也可以是引用类型</li><li>集合只能是引用类型</li></ul></li><li><p>元素内容</p><ul><li>数组只能存储同一种类型</li><li>集合可以存储不同类型（其实集合一般存储的也是同一种类型）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1010726-20170621004734695-988542448.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/1010726-20170621004756882-1379253225.gif" alt="img"> </p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025110431438.png" alt="image-20221025110431438"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025110453481.png" alt="image-20221025110453481"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>接口介绍</p><p>Collection 接口有 3 种子类型集合: List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、ArrayBlockingQueue等，下面是Collection的所有方法。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20221025161938824.png" alt="image-20221025161938824"></p><p>这些方法即可以操作Set集合，也可以操作Queue和List集合,下面分别使用<code>Collection</code>集合接口的方法说明</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>向集合添加元素e，若指定集合元素改变了则返回true</td></tr><tr><td>boolean addAll(Collection&lt;? extends E&gt; c)</td><td>把集合C中的元素全部添加到集合中，若指定集合元素改变返回true</td></tr><tr><td>void clear()</td><td>清空所有集合元素</td></tr><tr><td>boolean contains(Object o)</td><td>判断指定集合是否包含对象o</td></tr><tr><td>boolean containsAll(Collection&lt;?&gt; c)</td><td>判断指定集合是否包含集合c的所有元素</td></tr><tr><td>boolean isEmpty()</td><td>判断指定集合的元素size是否为0</td></tr><tr><td>boolean remove(Object o)</td><td>删除集合中的元素对象o,若集合有多个o元素，则只会删除第一个元素</td></tr><tr><td>boolean removeAll(Collection&lt;?&gt; c）</td><td>删除指定集合包含集合c的元素</td></tr><tr><td>boolean retainAll(Collection&lt;?&gt; c)</td><td>从指定集合中保留包含集合c的元素,其他元素则删除</td></tr><tr><td>int size()</td><td>集合的元素个数</td></tr><tr><td>T[] toArray(T[] a)</td><td>将集合转换为T类型的数组</td></tr></tbody></table><p>eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 创建Collection接口的实现</span></span><br><span class="line">      <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 添加元素</span></span><br><span class="line">      collection.add(<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;????&quot;</span>;</span><br><span class="line">      collection.add(src);</span><br><span class="line">      System.out.println(collection);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建Collection的实现</span></span><br><span class="line">      Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      coll.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      System.out.println(coll);</span><br><span class="line">      <span class="comment">// 添加一个集合数据</span></span><br><span class="line">      collection.addAll(coll);</span><br><span class="line">      <span class="comment">// 输出集合的长度</span></span><br><span class="line">      System.out.println(collection);</span><br><span class="line">      <span class="comment">// 判断是否包含</span></span><br><span class="line">      System.out.println(collection.contains(<span class="string">&quot;?&quot;</span>));</span><br><span class="line">      <span class="comment">// 移除元素</span></span><br><span class="line">      collection.remove(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      <span class="comment">// 添加对象</span></span><br><span class="line">      collection.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">5000d</span>));</span><br><span class="line">      <span class="comment">// 当认为两个对象属性一致，相等时候，需重写hashCode 和 equals方法</span></span><br><span class="line">      System.out.println(collection.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">5000d</span>)));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">      collection.add(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">      Collection&lt;String&gt; collection1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      collection1.add(<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">      collection1.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      <span class="comment">// 求两个集合的交集(只保留collection1存在的元素)</span></span><br><span class="line">      collection.retainAll(collection1);</span><br><span class="line">      System.out.println(collection);</span><br><span class="line">      <span class="comment">// 清空元素</span></span><br><span class="line">      collection.clear();</span><br><span class="line">      System.out.println(collection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>迭代器的介绍</p><p>迭代器，集合的专用遍历方式</p><p>Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</p><p>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</p><p>Collection集合的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用while循环改进元素的判断和获取</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二次遍历需要重置迭代器</span></span><br><span class="line">        it = c.iterator();</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强for循环遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Object o : c)&#123;</span><br><span class="line">        System.out.println( o );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ol><li>List集合类中元素有序（即添加顺序和取出顺序一致），且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以更具序号存取容器中的元素</li><li>JDK  API中List接口的实现类非常多，常用的有ArrayList、LinkedList、Vector<ol><li>ArrayList：底层由数组结构实现Object[]，可以存储任何Object类型的对象，是非线程安全的</li><li>LinkedList：List和Deque接口的双向链表实现。实现所有可选列表操作，并允许所有元素（包括null ）。所有操作都按照双向链表的预期执行。索引到列表中的操作将从开头或结尾遍历列表，以更接近指定索引的为准。</li><li>Vector：底层实现是动态数组的方式存放数据，是线程安全的，Vector源码当中每个方法都被synchronized关键字进行修饰，保证了Vector的线程安全，所以效率很低，尽量少使用</li></ol></li></ol><h4 id="List的继承、实现关系"><a href="#List的继承、实现关系" class="headerlink" title="List的继承、实现关系"></a>List的继承、实现关系</h4><p>其继承了Collection接口并由AbstractList来实现，Collection又继承了Iterable接口</p><p>Collection：集合层次结构中的根接口。一个集合表示一组对象，称为它的元素。一些集合允许重复元素，而另一些则不允许。有些是有序的，有些是无序的。<br>Iterable：实现此接口允许对象成为“for-each 循环”语句的目标。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2022020709121614.png" alt="img"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        </span><br><span class="line">List&lt;Object&gt; list1= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Map&gt; list2= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Student&gt; list3= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index, Object ele)</td><td>在index位置插入ele元素</td></tr><tr><td>boolean addAll(int index, Collection eles)</td><td>从index位置开始将eles中的所有元素添加进来</td></tr><tr><td>Object get(int index)</td><td>获取指定index位置的元素</td></tr><tr><td>int indexOf(Object obj</td><td>返回obj在集合中首次出现的位置</td></tr><tr><td>int lastIndexOf(Object obj)</td><td>返回obj在当前集合中末次出现的位置</td></tr><tr><td>Object remove(int index)</td><td>移除指定index位置的元素，并返回此元素</td></tr><tr><td>Object set(int index, Object ele)</td><td>设置指定index位置的元素为ele , 相当于是替换.</td></tr><tr><td>List subList(int fromIndex, int toIndex)</td><td>返回从fromIndex到toIndex位置的子集合</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line"><span class="comment">//        void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">//在index = 1的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        Object get(int index):获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"><span class="comment">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line"><span class="comment">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;玛丽&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list=[张三丰, 韩顺平, 贾宝玉]</span><br><span class="line">list=[张三丰, jack, tom, 韩顺平, 贾宝玉]</span><br><span class="line">jack</span><br><span class="line"><span class="number">2</span></span><br><span class="line">list=[张三丰, jack, tom, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">list=[jack, tom, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line">list=[jack, 玛丽, 韩顺平, 贾宝玉, 韩顺平]</span><br><span class="line">returnlist=[jack, 玛丽]</span><br></pre></td></tr></table></figure><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p> ArrayList实现了<a href="https://so.csdn.net/so/search?q=List%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">List接口</a>它是一个可调整大小的数组可以用来存放各种形式的数据。并提供了包括CRUD在内的多种方法可以对数据进行操作但是它不是线程安全的，外ArrayList按照插入的顺序来存放数据。</p><h5 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//数组默认初始容量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空的数组实例以供其他需要用到空数组的地方调用 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空数组，跟前面的区别就是这个空数组是用来判断ArrayList第一添加数据的时候要扩容多少。默认的构造器情况下返回这个空数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//数据存的地方它的容量就是这个数组的长度，同时只要是使用默认构造器（DEFAULTCAPACITY_EMPTY_ELEMENTDATA ）第一次添加数据的时候容量扩容为DEFAULT_CAPACITY = 10 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//当前数组的长度</span></span><br></pre></td></tr></table></figure><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20180530205624808" alt="img"></p><ol><li>第一个构造方法用来返回一个初始容量为10的数组（具体过程后面会提到）</li><li>第二个用来生成一个带数据的ArrayList这边不再赘述</li><li>第三个构造方法就是自定义初始容量。下面我将根据默认的构造方法来展开下文。</li></ol><p>可以看到默认的构造器就是用了参数DEFAULTCAPACITY_EMPTY_ELEMENTDATA返回了一个空的数组，所以这边我们可以了解到ArrayList在创建的时候如果没有指定初始容量的话就会返回一个长度为0的空数组。下面我想从ArrayList的扩容机制开始解析，因为在所有添加数据的操作上面都要需要判断当前数组容量是否足以容纳新的数据，如果不够的话就需要进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>扩容机制：<br>    ArrayList扩容的核心从ensureCapacityInternal方法说起。可以看到前面介绍成员变量的提到的ArrayList有两个默认的空数组：</p><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA：是用来使用默认构造方法时候返回的空数组。如果第一次添加数据的话那么数组扩容长度为DEFAULT_CAPACITY&#x3D;10。</p><p>EMPTY_ELEMENTDATA：出现在需要用到空数组的地方，其中一处就是使用自定义初始容量构造方法时候如果你指定初始容量为0的时候就会返回。</p><p>从下面可以看到如果是使用了空数组EMPTY_ELEMENTDATA话，那么不会返回默认的初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前数组是否是默认构造方法生成的空数组，如果是的话minCapacity=10反之则根据原来的值传入下一个方法去完成下一步的扩容判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//minCapacitt表示修改后的数组容量，minCapacity = size + 1 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//判断看看是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面谈谈ensureExplicitCapacity方法（modCount设计到Java的快速报错机制后面会谈到），可以看到如果修改后的数组容量大于当前的数组长度那么就需要调用grow进行扩容，反之则不需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//判断当前ArrayList是否需要进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//快速报错机制</span></span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后看下ArrayList扩容的核心方法grow()，下面将针对三种情况对该方法进行解析：</p><ol><li><p>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</p></li><li><p>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList扩容的核心方法，此方法用来决定扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>Vector是集合当中的一个重要知识点，它于ArrayList相比，最大的区别在于Vector是线程安全的，在源码当中的添加，删除等重要方法当中都加入了关键字 synchronized，实现了操作的线程安全，与ArrayList一样，Vector同样实现了 RandomAccess, Cloneable, Serializable接口。</p><h5 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector():构造一个空的Vector对象。</span><br><span class="line">Vector(<span class="type">int</span> initialCapacity):构造一个具有给定初始容量的空的Vector对象。</span><br><span class="line">Vector(<span class="type">int</span> initialCapacity,<span class="type">int</span> capacityIncrement):构造一个具有给定初始容量和容量增量的空的Vector对象。</span><br></pre></td></tr></table></figure><h5 id="Vector-扩容机制"><a href="#Vector-扩容机制" class="headerlink" title="Vector 扩容机制"></a>Vector 扩容机制</h5><p><strong>使用无参构造器跟进</strong></p><p><img src="https://img-blog.csdnimg.cn/20210617122819739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>Vector中三个重要的属性：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210617123051412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210617123125532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>step 1：</strong><img src="https://img-blog.csdnimg.cn/20210617123332468.png" alt="img"></p><p><strong>step 2：</strong><img src="https://img-blog.csdnimg.cn/20210617123501756.png" alt="img"></p><p><strong>step 3：</strong><img src="https://img-blog.csdnimg.cn/2021061712373943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p> 实例化完成：</p><p>往Vector集合中添加 11个元素，看第11个元素的扩容机制：</p><p><img src="https://img-blog.csdnimg.cn/20210617124717477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p>step 1：</p><p><img src="https://img-blog.csdnimg.cn/20210617124859168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p>step 2：</p><p><img src="https://img-blog.csdnimg.cn/20210617124941946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p>step 3：</p><p><img src="https://img-blog.csdnimg.cn/20210617125749832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p> step 4：方法弹栈消失。回到 add 方法中：</p><p><img src="https://img-blog.csdnimg.cn/20210617130253386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsYWd5aWxp,size_16,color_FFFFFF,t_70" alt="img"></p><p> Vector 其他两个 构造器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Vector(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        elementCount = a.length;</span><br><span class="line">        // 1： 如果是 ArrayList 集合</span><br><span class="line">        if (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            // 2： 则把 ArrayList集合的 elementData 赋值给 当前 Vectory实例的elementData指向。</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">              // 3： 如果不是则 先数组拷贝。再赋值指向。</span><br><span class="line">            elementData = Arrays.copyOf(a, elementCount, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">        super();</span><br><span class="line">        // 如果用户给的 初始化长度是 小于 0 </span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        // 初始化的elementData的数组的长度为 用户指定的长度。</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">        // 当前Vector实例的 容量增量是用户给的为准。</span><br><span class="line">        this.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 如果使用此构造器实例化 Vector对象时。当集合中的元素的数量超过。elementData数组的容量时。则<br>&#x2F;&#x2F; Vector 底层的扩容的新数组的长度每次都是  ： 旧数组的容量 + 用户给定的容量增量。</p><h4 id="ArrayList和Vector比较"><a href="#ArrayList和Vector比较" class="headerlink" title="ArrayList和Vector比较"></a>ArrayList和Vector比较</h4><table><thead><tr><th></th><th>底层结构</th><th>版本</th><th>线程安全（同步）效率</th><th>库容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>jdk1.2</td><td>不安全，效率高</td><td>如果有参构造为1.5倍，<br />如果是无参，第一次为10，第二次则是第一次的1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组</td><td>jdk1.0</td><td>安全，效率不高</td><td>如果是无参，默认10.满后，就按2倍扩容，<br />如果指定大小，则每次直接按2倍扩容</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字和保留字</title>
      <link href="/2022/09/09/Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97/"/>
      <url>/2022/09/09/Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof是Java的一个保留关键字，左边是对象，右边是类，返回类型是Boolean类型。它的具体作用是测试左边的对象是否是右边类或者该类的子类创建的实例对象，是，则返回true，否则返回false。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>先有继承关系，再有instanceof的使用。</li><li>当该测试对象创建时右边的声明类型和左边的类其中的任意一个跟测试类必须得是继承树的同一分支或存在继承关系，否则编译器会报错。</li></ol><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object &gt; Person &gt; teacher</span></span><br><span class="line">    <span class="comment">// Object &gt; Person &gt; Student</span></span><br><span class="line">    <span class="comment">// Object &gt; String</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// 主要看这个对象是什么类型与实例化的类名</span></span><br><span class="line">    <span class="comment">// instanceof关键字可以判断左边对象是否是右边类或者子类的一个实例</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Student); <span class="comment">// o 是Student类的一个实例对象 所以判断右边类跟student有无关系 以及显示声明有无关系</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Object); <span class="comment">// true</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> String); <span class="comment">// false</span></span><br><span class="line">    System.out.println(o <span class="keyword">instanceof</span> Teacher); <span class="comment">// 无关系</span></span><br><span class="line">    System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.println(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">    System.out.println(person <span class="keyword">instanceof</span> Object); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// System.out.println(person instanceof String); // 编译错误</span></span><br><span class="line">    System.out.println(person <span class="keyword">instanceof</span> Teacher); <span class="comment">// 无关系</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要用到对象的强制类型转换时，需要使用instanceof进行判断</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA使用记录（个人向）</title>
      <link href="/2022/09/01/IDEA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89/"/>
      <url>/2022/09/01/IDEA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><ol><li>删除当前行，自己配置CTRL + d</li><li>复制当前行，配置 CTRL + alt + 向下光标</li><li>补全代码 alt + &#x2F;</li><li>添加注释和取消注释 CTRL + &#x2F; 【第一次是添加注释，第二次是取消注释】</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220901112602360.png" alt="image-20220901112602360"></p><h3 id="模板-x2F-自定义模板"><a href="#模板-x2F-自定义模板" class="headerlink" title="模板&#x2F;自定义模板"></a>模板&#x2F;自定义模板</h3><p>file -&gt; settings -&gt; editor -&gt; Live templates -&gt; 查看有那些模板快捷键&#x2F;可以自己增加模板</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的与和或（||，|，&amp;&amp;，&amp;）</title>
      <link href="/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/"/>
      <url>/2022/08/25/JAVA%E4%B8%AD%E4%B8%8E%E3%80%81%E6%88%96%EF%BC%88-%EF%BC%8C-%EF%BC%8C-%EF%BC%8C-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>关于与(&amp;&amp;:并且)、或(||:或者)</p><p>学术话语：<br>或(或者)：(满足单方面一个就好了），不挑食，你满足了，那就跟我走吧。<br>“||”(短路或): 如果左边计算后的操作数为true,右边则不再执行，返回true；</p><p>与&amp;&amp;类似，只要遇到一个条件为True，表达式返回True，不进行后续条件判断。</p><p>“|”：(逻辑或)前后两个操作数都会进行计算。也就是说：“|”不存在短路。</p><p>与（并且）：（满足双方两个才可以）为了约束双方值不越界，我得看看这两个有没有都满足我条件才能带走。<br>&amp;&amp;(短路与)，当第一个判断条件不满足要求时（返回false），第二个判断条件就不会执行；只有当两个判断条件都返回true时，整个逻辑运算才返回true。</p><p>从左到右，只要遇到一个条件为False，表达式返回False，不进行后续条件判断。</p><p>&amp;(逻辑与)，不论什么情况下，两边的判断条件都会执行，当两边都返回true时，按位与才返回true。</p><p>直观解释：</p><p>最直观解释就是||和&amp;&amp;左边有一个不通过就不去执行右边了，没必要浪费时间。而|和&amp;不管左边有没有通过，都要磨磨唧唧两边都要先执行一遍，效率低</p><p>||、&amp;&amp;会先进行左边判断通过与否，再进行右边判断，再执行有没有通过</p><p>|、&amp;：就是先两边都执行，再去同时判断有没有通过。相当于||的一个逆向思路</p><p>开发中一般使用&amp;&amp;和||比较好一点，因为效率高</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDK和API的区别（转)</title>
      <link href="/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/08/25/SDK%E5%92%8CAPI%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="讲个小故事："><a href="#讲个小故事：" class="headerlink" title="讲个小故事："></a><strong>讲个小故事：</strong></h2><blockquote><p>研发人员A开发了软件A，研发人员B正在研发软件B。<br>有一天，研发人员B想要调用软件A的部分功能来用，但是他又不想从头看一遍软件A的源码和功能实现过程，怎么办呢？<br>研发人员A想了一个好主意： <strong>我把软件A里你需要的功能打包好，写成一个函数。你按照我说的流程，把这个函数放在软件B里，就能直接用我的功能了！</strong><br>其中，API就是研发人员A说的那个函数。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/5692a53d8119cf182034bdc59e92b0f6.png" alt="img"></p><p>这就是API的诞生。</p><h3 id="日常生活中，我们有很多类似API的场景，比如："><a href="#日常生活中，我们有很多类似API的场景，比如：" class="headerlink" title="日常生活中，我们有很多类似API的场景，比如："></a><strong>日常生活中，我们有很多类似API的场景，比如：</strong></h3><blockquote><p>电脑需要调用手机里面的信息，这时候你会拿一根数据线将电脑手机连接起来，电脑和手机上连接数据线的接口就相当于“API接口”。如图所示：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/81bf59a486bb1fe0961e6f6d9f67cd22.png" alt="img"></p><h2 id="那SDK又是什么？"><a href="#那SDK又是什么？" class="headerlink" title="那SDK又是什么？"></a><strong>那SDK又是什么？</strong></h2><p>SDK 就是 Software Development Kit 的缩写，翻译过来——软件开发工具包。这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。</p><p>SDK被开发出来是为了减少程序员工作量的。</p><p>比如——</p><blockquote><p>有公司开发出某种软件的某一功能，把它封装成SDK（比如数据分析SDK就是能够实现数据分析功能的SDK），出售给其他公司做开发用，其他公司如果想要给软件开发出某种功能，但又不想从头</p><h2 id="现在可以谈谈API和SDK的区别了。"><a href="#现在可以谈谈API和SDK的区别了。" class="headerlink" title="现在可以谈谈API和SDK的区别了。"></a><strong>现在可以谈谈API和SDK的区别了。</strong></h2><p>总的来说，两者没有值得比较的区别，因为是具有关联性的两种东西。</p><p>你可以把SDK想象成一个虚拟的<a href="https://www.zhihu.com/search?q=%E7%A8%8B%E5%BA%8F%E5%8C%85&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:770586138%7D">程序包</a>，在这个程序包中有一份做好的软件功能，这份程序包几乎是全封闭的，只有一个小小接口可以联通外界，这个接口就是API。</p><p>比如——</p><p>我们现在要在企业ERP系统中增加某个功能（比如自动备份、数据分析、云存储等），但又不想耗费大量时间、也没那么多研发亲自去做这个功能。这时我们可以选择使用这个“SDK”软件包，把ERP系统连接上API接口，就可以使用SDK软件包里的功能。</p><h3 id="举个实例辅助理解："><a href="#举个实例辅助理解：" class="headerlink" title="举个实例辅助理解："></a><strong>举个实例辅助理解：</strong></h3><p>【中铁大桥科研院】有一个自研的信息平台，用于管理业务数据。</p><p>但他们曾面临一个问题——尽管有信息平台，却因为系统的独立性，数据的上传和备份，需要依靠人工在excel里来回操作，效率很低。</p><p>由于系统的开发周期长、成本高，桥科院将目光聚焦到现成的功能软件上。</p><p>后来通过API将简道云直接插入公司数据库，数据可自动上传至信息平台上并统一展示；再通过webhook把数据推送到服务器，实现自动备份。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/da6c9f6f3d05fb3e1e789c8560fa8f44.png" alt="img"></p><p>API将信息平台与简道云相连</p><p>在这一过程中，简道云扮演的角色就是SDK，而简道云配备API接口，可以对接外部系统，让桥科院不用开发直接实现了数据自动上传、备份的功能。</p><p><strong>最后，贴近生活讲讲两者的关系：</strong></p><p><strong>有一杯密封饮料，它的名字叫做“SDK”。</strong></p><p><strong>饮料上插着吸管，吸管的名字叫“API”。</strong></p><p><strong>把你叫做“XX系统”。</strong></p><p><strong>如果你想喝到SDK里的饮料（让系统拥有SDK中的功能），你必须通过API这根吸管来实现（通过API连接你的系统和SDK工具包），否则你就喝不到饮料。</strong></p><p><strong>所以：</strong></p><p>SDK＝放着你想要的软件功能的软件包</p><p>API＝SDK上唯一的接口</p><p><strong>不知道你这次真的懂了没？</strong></p><hr><p><strong>这个问题好像又热起来了，既然如此，给大家推荐一个新“玩具”：前端事件。</strong></p><p><strong>理论上解释：</strong></p><blockquote><p>前端事件是一种全新的数据获取的方式，可以在数据提交或者表单填报时，主动调用外部接口，从而可以实现接口取数、数据验证、数据分析、触发事件等一系列的操作，用户可以基于现成的商业接口进行配置（无需编程），也可以根据自身需求封装接口，灵活地满足自身业务需求（需编程）</p></blockquote><p><strong>说人话解释：</strong></p><blockquote><p>用户填写快递单号，返回具体物流信息；<br>上传发票图片，返回发票金额；<br>上传身份证照片，获取身份证姓名、身份证号；<br>……等。</p></blockquote><p>例如，在发票报销场景中，根据前端事件配置，可在提交发票图片后自动获取发票中的开票金额、开票日期等基础信息。</p><p>开发，直接付钱省事。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本功|Java即时编译器原理解析及实践</title>
      <link href="/2022/08/18/%E5%9F%BA%E6%9C%AC%E5%8A%9F-Java%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/08/18/%E5%9F%BA%E6%9C%AC%E5%8A%9F-Java%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、导读"><a href="#一、导读" class="headerlink" title="一、导读"></a>一、导读</h2><p>常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。</p><p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p><p>即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</p><h2 id="二、Java的执行过程"><a href="#二、Java的执行过程" class="headerlink" title="二、Java的执行过程"></a>二、Java的执行过程</h2><p>Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。</p><p>怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/ba83857ecf9f344e4972fd551c4973d653952.png@648w_454h_80q" alt="img"></p><h3 id="1-JVM中的编译器"><a href="#1-JVM中的编译器" class="headerlink" title="1. JVM中的编译器"></a>1. JVM中的编译器</h3><p>JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。</p><p><strong>Client Compiler</strong></p><p>HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</p><ul><li>局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。</li><li>将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。</li><li>最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。</li></ul><p><strong>Server Compiler</strong></p><p>Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。</p><p><strong>C2 Compiler</strong></p><p>在Hotspot VM中，默认的Server Compiler是C2编译器。</p><p>C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。</p><p>Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。</p><p>无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/4c33853195a4e5e11951a6324a698b6c108881.png@823w_864h_80q" alt="img"></p><p><strong>Graal Compiler</strong></p><p>从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：</p><ul><li>前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。</li><li>使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。</li><li>更深层次的优化，比如虚函数的内联、部分逃逸分析等。</li></ul><p>Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。</p><h3 id="2-分层编译"><a href="#2-分层编译" class="headerlink" title="2. 分层编译"></a>2. 分层编译</h3><p>在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</p><ol><li>解释执行。</li><li>执行不带profiling的C1代码。</li><li>执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。</li><li>执行带所有profiling的C1代码。</li><li>执行C2代码。</li></ol><p>profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。</p><p>通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&gt;2层&gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：</p><p><img src="https://p0.meituan.net/travelcube/9dee40c45e1abb392243e07666ff6d5b79153.png@863w_680h_80q" alt="img"></p><ul><li>图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</li><li>如果方法比较小（比如Java服务中常见的getter&#x2F;setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</li><li>在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</li><li>前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</li><li>如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</li></ul><p>总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。</p><h3 id="3-即时编译的触发"><a href="#3-即时编译的触发" class="headerlink" title="3. 即时编译的触发"></a>3. 即时编译的触发</h3><p>Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：</p><p>循环回边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(Object obj) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</p><p>字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(java.lang.Object);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_0</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: sipush        200</span><br><span class="line">       8: if_icmpge     21</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: iload_2</span><br><span class="line">      13: iadd</span><br><span class="line">      14: istore_1</span><br><span class="line">      15: iinc          2, 1</span><br><span class="line">      18: goto          4</span><br><span class="line">      21: return</span><br></pre></td></tr></table></figure><p>在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。</p><p>当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</p><p>开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：</p><ul><li>方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</li><li>方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</li></ul><p>分层编译触发条件公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s) </span><br><span class="line">i为调用次数，b是循环回边次数</span><br></pre></td></tr></table></figure><p>上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。</p><h2 id="三、编译优化"><a href="#三、编译优化" class="headerlink" title="三、编译优化"></a>三、编译优化</h2><p>即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</p><h3 id="1-中间表达形式（Intermediate-Representation）"><a href="#1-中间表达形式（Intermediate-Representation）" class="headerlink" title="1. 中间表达形式（Intermediate Representation）"></a>1. 中间表达形式（Intermediate Representation）</h3><p>在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</p><p>Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：</p><p>SSA IR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a = 1;</span><br><span class="line">  a = 2;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以轻易地发现a &#x3D; 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</p><p>上面代码的SSA IR形式的伪代码可以表示为：</p><p>SSA IR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a_1 = 1;</span><br><span class="line">  a_2 = 2;</span><br><span class="line">  b_1 = a_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</p><p>除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a = 2;</span><br><span class="line">  int b = 0</span><br><span class="line">  if(2 &gt; 1)&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    b = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到SSA IR伪代码：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_1 = 2;</span><br><span class="line">b_1 = 0</span><br><span class="line">if true:</span><br><span class="line">  a_2 = 1;</span><br><span class="line">else</span><br><span class="line">  b_2 = 2;</span><br><span class="line">add(a,b)</span><br></pre></td></tr></table></figure><p>编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：</p><p>DeadCodeElimination</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">  int b = 0;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</p><p><strong>C1中的中间表达形式</strong></p><p>前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</p><p>HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/ecc6e309ee4a8f36cab407a6b5989c9b21165.png@262w_611h_80q" alt="img"></p><p>其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</p><p>从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：</p><p>字节码构造HIR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  字节码                     Local Value             operand stack              HIR</span><br><span class="line">5: iload_1                  [i1,i2]                 [i1]</span><br><span class="line">6: iload_2                  [i1,i2]                 [i1,i2]   </span><br><span class="line">                            ................................................   i3: i1 * i2</span><br><span class="line">7: imul                                   </span><br><span class="line">8: istore_3                 [i1,i2，i3]              [i3]</span><br></pre></td></tr></table></figure><p>可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。</p><p>C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</p><p><strong>Sea-of-Nodes IR</strong></p><p>C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：</p><p>example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int foo(int count) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的IR图如下所示：</p><p><img src="https://p0.meituan.net/travelcube/42ae260309e69d543bfdc4e7c3e1ea9a164249.png@1368w_1260h_80q" alt="img"></p><p>图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</p><p>这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</p><p>依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</p><p><strong>Phi And Region Nodes</strong></p><p>Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。</p><p>example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">int a = 0;</span><br><span class="line">  if(x == 1) &#123;</span><br><span class="line">    a = 5;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：</p><p><img src="https://p0.meituan.net/travelcube/41c8d6188f478a93566c2573b8ce263150102.png@631w_930h_80q" alt="img"></p><p>Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</p><p>Phi Nodes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">  a_1 = 0;</span><br><span class="line">  if(x == 1)&#123;</span><br><span class="line">    a_2 = 5;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    a_3 = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  a_4 = Phi(a_2,a_3);</span><br><span class="line">  return a_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Global Value Numbering</strong></p><p>Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</p><p>GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：</p><p>GVN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b = 2;</span><br><span class="line">c = a + b;</span><br><span class="line">d = a + b;</span><br><span class="line">e = d;</span><br></pre></td></tr></table></figure><p>GVN会利用Hash算法编号，计算a &#x3D; 1时，得到编号1，计算b &#x3D; 2时得到编号2，计算c &#x3D; a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d &#x3D; a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e &#x3D; d也可以由Hash表中查到而进行复用。</p><p>可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</p><h3 id="2-方法内联"><a href="#2-方法内联" class="headerlink" title="2.方法内联"></a>2.方法内联</h3><p>方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</p><p>Java服务中存在大量getter&#x2F;setter方法，如果没有方法内联，在调用getter&#x2F;setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter&#x2F;setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter&#x2F;setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：</p><p>方法内联的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean flag = true;</span><br><span class="line">public static int value0 = 0;</span><br><span class="line">public static int value1 = 1;</span><br><span class="line"></span><br><span class="line">public static int foo(int value) &#123;</span><br><span class="line">    int result = bar(flag);</span><br><span class="line">    if (result != 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int bar(boolean flag) &#123;</span><br><span class="line">    return flag ? value0 : value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bar方法的IR图：</p><p><img src="https://p1.meituan.net/travelcube/857398429cf23f82f291a9cbaceecea122617.png@794w_480h_80q" alt="img"></p><p>内联后的IR图：</p><p><img src="https://p0.meituan.net/travelcube/524631fb0c1db243b5b1fd08b185c23f59399.png@802w_1202h_80q" alt="img"></p><p>内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</p><p>被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</p><p>调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号&#x3D;&#x3D;节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</p><p>如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</p><p><strong>方法内联的条件</strong></p><p>编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</p><p>可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：</p><p><img src="https://p0.meituan.net/travelcube/5edc4a89d148535e6e4ef659a61882fc128193.png@1350w_612h_80q" alt="img"></p><p><strong>虚函数内联</strong></p><p>内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</p><p>C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：</p><p>virtual call</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj = new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 = new VirtualInvoke1();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000113369d37: callq  0x00000001132950a0  ; OopMap&#123;off=476&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  //代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 18)</span><br><span class="line">                                               ;   &#123;optimized virtual_call&#125;  //虚调用已经被优化</span><br></pre></td></tr></table></figure><p>可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</p><p>比如下面这段代码，我们增加一个实现：</p><p>多实现的虚调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj = new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 = new VirtualInvoke1();</span><br><span class="line">        VirtualInvoke2 obj2 = new VirtualInvoke2();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        invokeMethod(obj2);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class VirtualInvoke2 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反编译得到下面的汇编代码：</p><p>代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000000011f5f0a37: callq  0x000000011f4fd2e0  ; OopMap&#123;off=28&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  //代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 20)</span><br><span class="line">                                               ;   &#123;virtual_call&#125;  //虚调用未被优化</span><br></pre></td></tr></table></figure><p>可以看到多个实现的虚调用未被优化，依然是virtual_call。</p><p>Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。</p><h3 id="3-逃逸分析"><a href="#3-逃逸分析" class="headerlink" title="3. 逃逸分析"></a>3. 逃逸分析</h3><p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：</p><ol><li>对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。</li><li>对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</li></ol><p>逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      example();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void example() &#123;</span><br><span class="line">      Foo foo = new Foo();</span><br><span class="line">      Bar bar = new Bar();</span><br><span class="line">      bar.setFoo(foo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Foo &#123;&#125;</span><br><span class="line"></span><br><span class="line">  class Bar &#123;</span><br><span class="line">    private Foo foo;</span><br><span class="line">    public void setFoo(Foo foo) &#123;</span><br><span class="line">      this.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</p><p><strong>锁消除</strong></p><p>在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</p><p>如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</p><p><strong>栈上分配</strong></p><p>我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：</p><p>标量替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    Cat cat = new Cat(1,10);</span><br><span class="line">    addAgeAndWeight(cat.age,Cat.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    int age = 1;</span><br><span class="line">    int weight = 10;</span><br><span class="line">    addAgeAndWeight(age,weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>部分逃逸分析</strong></p><p>部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</p><h3 id="4-Loop-Transformations"><a href="#4-Loop-Transformations" class="headerlink" title="4. Loop Transformations"></a>4. Loop Transformations</h3><p>在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。</p><p><strong>循环展开</strong></p><p>循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。</p><p>循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：</p><p>循环展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i = 0;i&lt;200;i++)&#123;</span><br><span class="line">    delete(i);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：</p><p>循环展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i = 0;i&lt;200;i+=5)&#123;</span><br><span class="line">    delete(i);</span><br><span class="line">    delete(i+1);</span><br><span class="line">    delete(i+2);</span><br><span class="line">    delete(i+3);</span><br><span class="line">    delete(i+4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</p><p><strong>循环分离</strong></p><p>循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：</p><p>循环分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] = x[i] + x[a];</span><br><span class="line">  a = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这段代码除了第一次循环a &#x3D; 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：</p><p>循环分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[0] = x[0] + 10;</span><br><span class="line">for(int i = 1;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] = x[i] + x[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</p><h3 id="5-窥孔优化与寄存器分配"><a href="#5-窥孔优化与寄存器分配" class="headerlink" title="5. 窥孔优化与寄存器分配"></a>5. 窥孔优化与寄存器分配</h3><p>前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：</p><p>强度削减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y1=x1*3  经过强度削减后得到  y1=(x1&lt;&lt;1)+x1</span><br></pre></td></tr></table></figure><p>编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</p><p>寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</p><p>寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</p><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><p>即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。</p><h3 id="1-编译相关的重-要参数"><a href="#1-编译相关的重-要参数" class="headerlink" title="1. 编译相关的重* 要参数"></a>1. 编译相关的重* 要参数</h3><ul><li>-XX:+TieredCompilation：开启分层编译，JDK8之后默认开启</li><li>-XX:+CICompilerCount&#x3D;N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 &#x3D; 1:2</li><li>-XX:TierXBackEdgeThreshold：OSR编译的阈值</li><li>-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</li><li>-XX:TierXCompileThreshold：开启分层编译后的编译阈值</li><li>-XX:ReservedCodeCacheSize：codeCache最大大小</li><li>-XX:InitialCodeCacheSize：codeCache初始大小</li></ul><p>-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。</p><p>由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。</p><h3 id="2-通过JITwatch分析编译日志"><a href="#2-通过JITwatch分析编译日志" class="headerlink" title="2. 通过JITwatch分析编译日志"></a>2. 通过JITwatch分析编译日志</h3><p>通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile&#x3D;LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/5d82c16cf7739e16b1de7e5f5fa53123555106.png%25403360w_2099h_80q" alt="img"><img src="https://p0.meituan.net/travelcube/1a2cb3082b79eb778360e79f5acd1e83545877.png@3360w_2033h_80q" alt="img"></p><p>如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：</p><p><img src="https://p0.meituan.net/travelcube/b089edabd2fa9bb1fc7f068df79c8c8361195.png@1920w_218h_80q" alt="img"></p><p>我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。</p><p>区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。</p><h3 id="3-使用Graal编译器"><a href="#3-使用Graal编译器" class="headerlink" title="3. 使用Graal编译器"></a>3. 使用Graal编译器</h3><p>由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。</p><p>为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。</p><p>前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</p><p>前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。</p><p>这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。</p><p><strong>使用Graal编译器后性能表现</strong></p><p>在我们的线上服务中，启用Graal编译后，TP9999从60ms -&gt; 50ms ，下降10ms，下降幅度达16.7%。</p><p>运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。</p><p><strong>Graal编译器的问题</strong></p><p>Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。</p><p>考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><ul><li>《深入理解Java虚拟机》</li><li>《Proceedings of the Java™ Virtual Machine Research and Technology Symposium》Monterey, California, USA April 23–24, 2001</li><li>《Visualization of Program Dependence Graphs》 Thomas Würthinger</li><li>《深入拆解Java虚拟机》 郑宇迪</li><li><a href="https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ">JIT的Profile神器JITWatch</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线工具+资源</title>
      <link href="/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/"/>
      <url>/2022/08/17/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="在线工具-资源"><a href="#在线工具-资源" class="headerlink" title="在线工具+资源"></a>在线工具+资源</h1><h3 id="常用-x2F-未归类"><a href="#常用-x2F-未归类" class="headerlink" title="常用&#x2F;未归类"></a>常用&#x2F;未归类</h3><ul><li>有道翻译：<a href="https://fanyi.youdao.com/">https://fanyi.youdao.com</a></li><li>谷歌翻译：<a href="https://translate.google.cn/">https://translate.google.cn</a></li><li>蓝奏云盘：<a href="https://pc.woozooo.com/u">https://pc.woozooo.com/u</a></li><li>免费4k视频：<a href="https://www.4kdv.com/">https://www.4kdv.com</a></li><li>日本域名申请：<a href="https://www.value-domain.com/">https://www.value-domain.com</a></li><li><code>大量在线工具（网站内右上角搜索想要的工具）</code>：<a href="https://www.fly63.com/tool/home.html">https://www.fly63.com/tool/home.html</a></li><li>在线代码截图工具：<a href="https://carbon.now.sh/">https://carbon.now.sh/</a></li><li>在线短链接工具：<a href="https://urlify.cn/">https://urlify.cn/</a></li><li>0x3.me 短网址：<a href="https://0x3.me/">https://0x3.me</a></li></ul><h3 id="免费软件、资源下载"><a href="#免费软件、资源下载" class="headerlink" title="免费软件、资源下载"></a>免费软件、资源下载</h3><ul><li>吾爱破解论坛：<a href="https://52pojie.cn/">https://52pojie.cn/</a></li><li>免费正版Windows系统：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a></li><li>免费Mac软件：<a href="https://www.macwk.com/">https://www.macwk.com</a></li><li>小蚂蚁资源网：<a href="https://www.xmy7.com/">https://www.xmy7.com</a></li></ul><h3 id="视频、音频、图片、壁纸、二维码"><a href="#视频、音频、图片、壁纸、二维码" class="headerlink" title="视频、音频、图片、壁纸、二维码"></a>视频、音频、图片、壁纸、二维码</h3><ul><li>在线多媒体转换器合集：<a href="https://cn.office-converter.com/">https://cn.office-converter.com/</a></li><li>视频转GIF工具：<a href="http://www.fly63.com/tool/giftxt/">http://www.fly63.com/tool/giftxt/</a></li><li>在线音频剪辑：<a href="https://www.weixinsyt.com/">https://www.weixinsyt.com/</a></li><li>在线视频剪辑：<a href="https://www.kapwing.com/">https://www.kapwing.com/</a></li></ul><hr><ul><li>SVG转PNG工具：<a href="http://www.fly63.com/tool/svg2img/">http://www.fly63.com/tool/svg2img/</a></li><li>JPG 转换成WEBP：<a href="https://onlineconvertfree.com/zh/convert-format/jpg-to-webp/">https://onlineconvertfree.com/zh/convert-format/jpg-to-webp/</a></li><li>图片压缩：<a href="https://tinypng.com/">https://tinypng.com</a></li><li>图片智能放大工具：<a href="https://bigjpg.com/">https://bigjpg.com/</a></li></ul><hr><ul><li>在线抠图工具：<a href="https://www.remove.bg/zh">https://www.remove.bg/zh</a></li><li>在线PS：<a href="https://www.uupoop.com/#/old">https://www.uupoop.com/#/old</a></li><li>在线海报设计工具：<a href="https://www.designcap.com/">https://www.designcap.com/</a></li></ul><hr><ul><li>免费透明背景图片素材：<a href="http://pngimg.com/">http://pngimg.com/</a></li><li>免费PNG图片库：<a href="https://pluspng.com/">https://pluspng.com/</a></li><li>Pixabay图片素材库：<a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></li><li>Unsplash图片素材库：<a href="https://unsplash.com/">https://unsplash.com/</a></li><li>Pexels图片素材库：<a href="http://www.pexels.com/">http://www.pexels.com/</a></li><li>NASA图片视频素材库：<a href="https://images.nasa.gov/">https://images.nasa.gov/</a></li><li>千库网：<a href="https://588ku.com/">https://588ku.com</a></li><li>PngPix：<a href="https://www.pngpix.com/download/tag/fire">https://www.pngpix.com/download/tag/fire</a></li></ul><hr><ul><li>极简壁纸：<a href="https://bz.zzzmh.cn/">https://bz.zzzmh.cn/</a></li><li>Wallpaper Abyss壁纸：<a href="https://wall.alphacoders.com/">https://wall.alphacoders.com/</a></li><li>免费壁纸下载：<a href="https://wallhaven.cc/">https://wallhaven.cc</a></li></ul><hr><ul><li>二维码在线生成器：<a href="http://www.fly63.com/tool/ewm/">http://www.fly63.com/tool/ewm/</a></li><li>二维码在线解码：<a href="http://www.fly63.com/php/decoder/">http://www.fly63.com/php/decoder/</a></li><li>二维码美化器：<a href="https://mh.cli.im/">https://mh.cli.im/</a></li></ul><h3 id="图床、思维导图、流程图"><a href="#图床、思维导图、流程图" class="headerlink" title="图床、思维导图、流程图"></a>图床、思维导图、流程图</h3><ul><li>路过图床：<a href="https://imgtu.com/">https://imgtu.com</a></li><li>sm.ms图床：<a href="https://sm.ms/">https://sm.ms</a></li><li>图壳图床：<a href="https://imgkr.com/">https://imgkr.com/</a></li><li>图片上传 | PicX 图床神器：<a href="https://picx.xpoet.cn/">https://picx.xpoet.cn/</a></li></ul><hr><ul><li>在线画图工具ProcessOn：<a href="https://www.processon.com/">https://www.processon.com/</a></li><li>在线画图工具Draw.io：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a></li><li>在线思维导图工具MindLine：<a href="http://www.mindline.cn/webapp">http://www.mindline.cn/webapp</a></li></ul><h3 id="ICO、字体图标、logo、Emoji表情"><a href="#ICO、字体图标、logo、Emoji表情" class="headerlink" title="ICO、字体图标、logo、Emoji表情"></a>ICO、字体图标、logo、Emoji表情</h3><ul><li>ICO图标在线生成：<a href="http://www.fly63.com/php/ico/">http://www.fly63.com/php/ico/</a></li><li>ico图标包：[ICO_Sweet_Paranoia.rar：<a href="https://wws.lanzoub.com/ing8408aok7a">https://wws.lanzoub.com/ing8408aok7a</a></li><li>图标分享 | 30 个免费 icon 下载网站：<a href="https://zhuanlan.zhihu.com/p/431105940">https://zhuanlan.zhihu.com/p/431105940</a></li><li>Font Awesome-ico图标：<a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></li><li>Font Awesome 图标-菜鸟教程：<a href="https://www.runoob.com/font-awesome/fontawesome-tutorial.html">https://www.runoob.com/font-awesome/fontawesome-tutorial.html</a></li><li>免费logo在线制作：<a href="http://www.uugai.com/">http://www.uugai.com/</a></li><li>ICON图标在线下载：<a href="https://www.iconfinder.com/">https://www.iconfinder.com/</a></li><li>open source icons：<a href="https://feathericons.com/">https://feathericons.com/</a></li><li>阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></li><li>艺术字体在线生成：<a href="https://www.qt86.com/">https://www.qt86.com/</a></li></ul><hr><ul><li>Emoji表情搜索：<a href="https://emoji.svend.cc/">https://emoji.svend.cc/</a></li><li>Emoji表情包下载：<a href="https://emojiisland.com/">https://emojiisland.com/</a></li><li>表情包在线网站：<a href="https://fabiaoqing.com/">https://fabiaoqing.com/</a></li></ul><h3 id="文字、文本、PDF、表格、文件、RGB颜色"><a href="#文字、文本、PDF、表格、文件、RGB颜色" class="headerlink" title="文字、文本、PDF、表格、文件、RGB颜色"></a>文字、文本、PDF、表格、文件、RGB颜色</h3><ul><li>在线文字识别工具：<a href="https://ocr.wdku.net/">https://ocr.wdku.net/</a></li><li>在线字数统计：<a href="https://www.eteste.com/">https://www.eteste.com/</a></li><li>mdnice markdown排版工具：<a href="https://mdnice.com/">https://mdnice.com/</a></li><li>md2all markdown排版工具：<a href="http://md.aclickall.com/">http://md.aclickall.com/</a></li><li>在线文本代码对比工具：<a href="https://www.fly63.com/tool/textdiff/">https://www.fly63.com/tool/textdiff/</a></li><li>在线文本替换：<a href="http://www.fly63.com/tool/textreplace/">http://www.fly63.com/tool/textreplace/</a></li></ul><hr><ul><li>pdf在线处理套装1：<a href="https://tools.pdf24.org/zh/">https://tools.pdf24.org/zh/</a></li><li>pdf在线处理套装2：<a href="https://smallpdf.com/cn/pdf-tools">https://smallpdf.com/cn/pdf-tools</a></li><li>pdf转word在线工具：<a href="https://www.pdftoword.com/">https://www.pdftoword.com/</a></li><li>PDF to Markdown：<a href="https://pdf2md.morethan.io/">https://pdf2md.morethan.io</a></li><li>在线表格转换工具：<a href="https://tableconvert.com/">https://tableconvert.com/</a></li><li>在线文件压缩工具：<a href="https://docsmall.com/">https://docsmall.com/</a></li></ul><hr><ul><li>RGB颜色转换：<a href="https://www.zxgj.cn/g/yansezhi">https://www.zxgj.cn/g/yansezhi</a></li><li>RGB颜色对照表：<a href="https://bj.96weixin.com/tools/rgb">https://bj.96weixin.com/tools/rgb</a></li><li>貌似打开不了：<a href="http://xh.5156edu.com/page/z1015m9220j18754.html">http://xh.5156edu.com/page/z1015m9220j18754.html</a></li></ul><h3 id="json、xml、yaml、sql、css格式化"><a href="#json、xml、yaml、sql、css格式化" class="headerlink" title="json、xml、yaml、sql、css格式化"></a>json、xml、yaml、sql、css格式化</h3><ul><li>在线JSON解析：<a href="http://www.json.cn/">http://www.json.cn/</a></li><li>JSON&#x2F;YAML在线转换：<a href="http://www.fly63.com/tool/jsonyaml/">http://www.fly63.com/tool/jsonyaml/</a></li><li>JSON和XML在线转换：<a href="https://www.zxgj.cn/g/jsonxml">https://www.zxgj.cn/g/jsonxml</a></li><li>XML格式化工具：<a href="https://www.zxgj.cn/g/xmlformat">https://www.zxgj.cn/g/xmlformat</a></li><li>在线JS代码格式化工具：<a href="https://prettier.io/playground/">https://prettier.io/playground/</a></li><li>在线JSON解析：<a href="http://www.json.cn/">http://www.json.cn/</a></li><li>SQL压缩&#x2F;格式化工具：<a href="https://www.zxgj.cn/g/sqlformat">https://www.zxgj.cn/g/sqlformat</a></li><li>在线CSS代码可视化工具：<a href="https://enjoycss.com/">https://enjoycss.com/</a></li><li>在线数据可视化：<a href="https://flourish.studio/">https://flourish.studio/</a></li><li>在线前端编辑器：<a href="https://codepen.io/">https://codepen.io/</a></li></ul><h3 id="时间、进制、计量单位、人民币大小写转换"><a href="#时间、进制、计量单位、人民币大小写转换" class="headerlink" title="时间、进制、计量单位、人民币大小写转换"></a>时间、进制、计量单位、人民币大小写转换</h3><ul><li>时间戳转换工具：<a href="https://www.zxgj.cn/g/unix">https://www.zxgj.cn/g/unix</a></li><li>通用进制转换工具：<a href="https://www.zxgj.cn/g/jinzhi">https://www.zxgj.cn/g/jinzhi</a></li><li>在线浮点数十进制转换：<a href="http://www.binaryconvert.com/">http://www.binaryconvert.com/</a></li><li>计量单位换算工具：<a href="http://www.fly63.com/tool/unitable/">http://www.fly63.com/tool/unitable/</a></li><li>人民币大小写转换工具：<a href="http://www.fly63.com/tool/renmingbi/">http://www.fly63.com/tool/renmingbi/</a></li></ul><h3 id="随机数、正则表达式、接口测试"><a href="#随机数、正则表达式、接口测试" class="headerlink" title="随机数、正则表达式、接口测试"></a>随机数、正则表达式、接口测试</h3><ul><li>UUID在线生成器：<a href="https://www.zxgj.cn/g/uuid">https://www.zxgj.cn/g/uuid</a></li><li>随机数生成器：<a href="https://www.zxgj.cn/g/suijishu">https://www.zxgj.cn/g/suijishu</a></li></ul><hr><ul><li>正则表达式可视化工具：<a href="https://jex.im/regulex/#!flags=&amp;re=^">https://jex.im/regulex/#!flags=&amp;re=^</a>(a|b*%3F%24</li><li>正则表达式调试工具：<a href="https://regexr.com/">https://regexr.com/</a></li></ul><hr><ul><li>HTTP在线接口测试工具：<a href="http://www.fly63.com/php/http/">http://www.fly63.com/php/http/</a></li><li>在线接口文档管理工具：<a href="http://xiaoyaoji.cn/">http://xiaoyaoji.cn</a></li></ul><h3 id="Nginx、IP查询、CDN、谷歌插件、ASCII码"><a href="#Nginx、IP查询、CDN、谷歌插件、ASCII码" class="headerlink" title="Nginx、IP查询、CDN、谷歌插件、ASCII码"></a>Nginx、IP查询、CDN、谷歌插件、ASCII码</h3><ul><li>在线Nginx配置工具：<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN</a></li></ul><hr><ul><li>IP地址归属地查询：<a href="https://www.ip138.com/">https://www.ip138.com/</a></li><li>IP地址查询：<a href="https://www.ipip.net/ip.html">https://www.ipip.net/ip.html</a></li></ul><hr><ul><li>CDN查询：<a href="https://www.itdog.cn/">https://www.itdog.cn</a></li></ul><hr><ul><li>在线Chrome浏览器插件：<a href="https://www.crx4chrome.com/">https://www.crx4chrome.com</a></li></ul><hr><ul><li>在线ASCII码对照表：<a href="http://www.fly63.com/tool/ascii/">http://www.fly63.com/tool/ascii/</a></li></ul><h3 id="编译运行、编解码、加解密"><a href="#编译运行、编解码、加解密" class="headerlink" title="编译运行、编解码、加解密"></a>编译运行、编解码、加解密</h3><ul><li>C#在线编译运行：<a href="https://rextester.com/">https://rextester.com</a></li><li>C&#x2F;C++在线编译调试：<a href="https://www.onlinegdb.com/">https://www.onlinegdb.com</a></li><li>在线编译工具套装：<a href="https://c.runoob.com/">https://c.runoob.com</a></li></ul><hr><ul><li>BASE64编解码工具：<a href="https://base64.supfree.net/">https://base64.supfree.net/</a></li><li>MD5编码工具：<a href="https://www.zxgj.cn/g/md5">https://www.zxgj.cn/g/md5</a></li><li>JWT解码工具：<a href="http://jwt.calebb.net/">http://jwt.calebb.net/</a></li><li>ASCII编解码工具：<a href="https://www.matools.com/code-convert-ascii">https://www.matools.com/code-convert-ascii</a></li><li>Unicode编解码工具：<a href="https://www.zxgj.cn/g/unicode">https://www.zxgj.cn/g/unicode</a></li><li>UTF-8编解码工具：<a href="https://www.zxgj.cn/g/utf8">https://www.zxgj.cn/g/utf8</a></li><li>字符串编解码工具：<a href="https://www.zxgj.cn/g/enstring">https://www.zxgj.cn/g/enstring</a></li><li>URL编解码工具：<a href="http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1">http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1</a></li></ul><hr><ul><li>AES&#x2F;DES加解密：<a href="http://www.fly63.com/tool/cipher/">http://www.fly63.com/tool/cipher/</a></li></ul><h3 id="文档笔记工具"><a href="#文档笔记工具" class="headerlink" title="文档笔记工具"></a>文档笔记工具</h3><ul><li>onenote：<a href="https://www.onenote.com/">https://www.onenote.com</a></li><li>simplenote：<a href="https://simplenote.com/">https://simplenote.com</a></li><li>为知笔记：<a href="https://www.wiz.cn/zh-cn">https://www.wiz.cn/zh-cn</a></li><li>印象笔记：<a href="https://www.yinxiang.com/">https://www.yinxiang.com</a></li><li>幕布：<a href="https://mubu.com/home">https://mubu.com/home</a></li><li>有道笔记：<a href="https://note.youdao.com/">https://note.youdao.com</a></li><li>石墨：<a href="https://shimo.im/">https://shimo.im</a></li><li>语雀：<a href="https://www.yuque.com/">https://www.yuque.com</a></li></ul><h3 id="编程学习网"><a href="#编程学习网" class="headerlink" title="编程学习网"></a>编程学习网</h3><ul><li>哔哩哔哩：<a href="https://www.bilibili.com/">https://www.bilibili.com/</a></li><li>C语言网：<a href="https://www.dotcpp.com/">https://www.dotcpp.com/</a></li><li>cppreference：<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/首页</a></li><li>中国大学MOOC：<a href="https://www.icourse163.org/">https://www.icourse163.org/</a></li><li>网易公开课：<a href="https://open.163.com/">https://open.163.com/</a></li><li>CodeGym：<a href="https://codegym.cc/">https://codegym.cc/</a></li><li>BeginnersBook：<a href="https://beginnersbook.com/">https://beginnersbook.com/</a></li><li>codecademy：<a href="https://www.codecademy.com/">https://www.codecademy.com/</a></li><li>Coursera：<a href="https://www.coursera.org/">https://www.coursera.org/</a></li><li>StackOverFlow：<a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li><li>学破解论坛：<a href="https://www.52hb.com/">https://www.52hb.com</a></li><li>我要自学网：<a href="https://www.51zxw.net/">https://www.51zxw.net/</a></li><li>逆向未来：<a href="https://www.pd521.com/">https://www.pd521.com</a></li></ul><h3 id="在线教程和文档"><a href="#在线教程和文档" class="headerlink" title="在线教程和文档"></a>在线教程和文档</h3><ul><li>SVN中文手册：<a href="http://svnbook.red-bean.com/nightly/zh/index.html">http://svnbook.red-bean.com/nightly/zh/index.html</a></li><li>jQuery API中文文档：<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a></li><li>Nginx中文文档：<a href="https://www.nginx.cn/doc/index.html">https://www.nginx.cn/doc/index.html</a></li><li>Kafka中文文档：<a href="https://kafka.apachecn.org/">https://kafka.apachecn.org/</a></li><li>Mybatis中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li><li>微信小程序官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li><li>Nodejs中文教程文档：<a href="http://nodejs.cn/learn/">http://nodejs.cn/learn/</a></li><li>Apache Web Server文档：<a href="http://httpd.apache.org/docs/">http://httpd.apache.org/docs/</a></li><li>Golang标准库文档中文版：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></li><li>Tomcat 8官方文档：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></li><li>RabbitMQ官方文档：<a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></li><li>RocketMQ官方文档：<a href="http://rocketmq.apache.org/docs/quick-start/">http://rocketmq.apache.org/docs/quick-start/</a></li><li>Dubbo中文文档：<a href="https://dubbo.apache.org/zh/docs/">https://dubbo.apache.org/zh/docs/</a></li><li>Netty官方文档：<a href="https://netty.io/wiki/index.html">https://netty.io/wiki/index.html</a></li><li>Elasticsearch官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li>kubernetes中文文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a></li><li>thymeleaf官方文档：<a href="https://www.thymeleaf.org/documentation.html">https://www.thymeleaf.org/documentation.html</a></li><li>Vue.js中文文档：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></li><li>React.js官方文档：<a href="https://reactjs.org/docs/getting-started.html">https://reactjs.org/docs/getting-started.html</a></li><li>Jenkins中文文档：<a href="https://www.jenkins.io/zh/doc/">https://www.jenkins.io/zh/doc/</a></li><li>Oracle Help Center：<a href="https://docs.oracle.com/en/">https://docs.oracle.com/en/</a></li><li>敬伟PS教程全集：<a href="https://www.bilibili.com/video/av18792821?p=172&amp;vd_source=c57311942d38847adc4597a126bba185">https://www.bilibili.com/video/av18792821?p=172&amp;vd_source=c57311942d38847adc4597a126bba185</a></li></ul><h3 id="博主个人备忘书签"><a href="#博主个人备忘书签" class="headerlink" title="博主个人备忘书签"></a>博主个人备忘书签</h3><ul><li><a href="https://zx.js.cool/">https://zx.js.cool</a></li><li><a href="https://mail.qq.com/">https://mail.qq.com</a></li><li><a href="https://www.zhipin.com/">https://www.zhipin.com</a></li><li><a href="https://www.zhaopin.com/">https://www.zhaopin.com</a></li><li><a href="https://cloud.tencent.co蔰m(s忽泆hell瀄蚨root/">https://cloud.tencent.com（shell登录用户名root</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_oop</title>
      <link href="/2022/05/15/Java-oop/"/>
      <url>/2022/05/15/Java-oop/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p>它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。</p><p>在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p><p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。</p><p>当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。</p><p>在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称OOD）方面的知识。</p><p>许多流行的编程语言是面向对象的,它们的风格就是会透由对象来创出实例。</p><p>重要的面向对象编程语言包含Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP等。</p><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>属性：对象数据的描述<br>方法：对象的行为<br>构造方法：用于实例化对象<br>内部类：在类中声明的类（inner class）<br>块：分静态代码块与实例语句块。</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Java是一门面向对象的编程语言，理解Java，首先要理解类与对象这两个概念。</p><ul><li>类：类是一个模板，它描述一类对象的行为和状态。</li><li>对象：对象：对象是类的一个实例。</li></ul><p>综上所述，看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br>对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><p>类的定义：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220826114425837.png" alt="image-20220826114425837"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例说明：</p><ul><li>public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符会在面向对象—封装中详细介绍</li><li>class 是定义类的关键字</li><li>Admin 是类名称</li></ul><p>对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。<br>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p><p>声明：声明一个对象，包括对象名称和对象类型。<br>实例化：使用关键字new来创建一个对象。<br>初始化：使用new创建对象时，会调用构造方法初始化对象。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Admin admin=<span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br></pre></td></tr></table></figure><p>类和对象的内存分配机制</p><p>Java内存的结构分析</p><ol><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（Person p，数组）等</li><li>方法区：常量池（常量，比如字符串），类加载信息</li></ol><p>Java创建对象的流程简要分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = “jack”;</span><br><span class="line">p.age = <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>、先加载 Person 类信息(属性和方法信息, 只会加载一次)</span><br><span class="line"><span class="number">2</span>、在堆中分配空间, 进行默认初始化(看规则)</span><br><span class="line"><span class="number">3</span>、把地址赋给 p , p 就指向对象</span><br><span class="line"><span class="number">4</span>、进行指定初始化， 比如 p.name =”jack” p.age = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827132411595.png" alt="image-20220827132411595"></p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827132444738.png" alt="image-20220827132444738"></p><p>Java创建对象的流程简单分析</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827141004875.png" alt="image-20220827141004875"></p><ol><li>先加载person类信息（属性信息，方法信息，只会加载一次）</li><li>在堆中分配空间，执行默认初始化</li><li>在栈中分配一个空间存放对象，该对象指向堆空间</li><li>给属性赋初始值（如：p.name &#x3D; “jack”; p.age &#x3D; 10）</li></ol><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><p>1、类属性的定义</p><p>类的属性，是用来描述这一类的相关信息，例如管理员是一类人的总称，那么管理员就有自己的属性，大概包括姓名，年龄，用户名，密码等。定义类的属性通过声明变量的形式来完成。每个属性都有它对应的访问修饰符、数据类型、变量名。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String loginName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：定义类的属性可以不为变量赋初始化值，属性的初始值会在类对象被实例化时进行赋值</strong></p><p>2、类属性的分类：</p><p>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。<br>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种。</p><p>3、this关键字</p><p>当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是 this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this，并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。在本类中，方法内可以通过this访问累的非静态变量和方法。</p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>1、类方法的定义<br>Java语言中的“方法”（Method）在其他语言当中也可能被称为“函数”（Function）。对于一些复杂的代码逻辑，如果希望重复使用这些代码，并且做到“随时任意使用”，那么就可以将这些代码放在一个大括号“{}”当中，并且起一个名字。使用代码的时候，直接找到名字调用即可。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220826114941053.png" alt="image-20220826114941053"></p><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li>访问修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法会被谁访问到。</li><li>方法修饰符：用来修饰特殊方法的修饰符。</li><li>返回值类型：方法可能会返回值。return ValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。（构造方法除外）</li><li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li>方法参数：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li>方法体：方法体包含具体的语句，定义该方法的功能，使用大括号作为方法范围。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>方法：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li>程序开始执行的时候是先执行main方法。因为main方法是一个入口。</li><li>在java语言中所有的方法体中的代码都必须遵循自上而下的顺序依次逐行执行。</li><li>main方法不需要程序员手动调用，是由JVM调用的。但是除了main方法之外其他的方法，都需要程序员手动调用。</li><li>方法只有调用的时候才会执行，方法不调用是不会执行的。</li><li>方法定义在类体当中。方法定义的先后顺序没有关系</li><li>方法中的变量都属于局部变量。方法结束之后，局部变量占用的内存会自动释放</li></ol><h3 id="方法定义，语法机制"><a href="#方法定义，语法机制" class="headerlink" title="方法定义，语法机制"></a>方法定义，语法机制</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">方法体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>[] 符号叫做中括号，以上中括号[ ]里面的内容表示不是必须的，是<code>可选</code>的。</li><li>方法体由Java语句构成。</li><li>方法定义之后需要去调用，不调用是不会执行的。</li></ol><h4 id="修饰符列表"><a href="#修饰符列表" class="headerlink" title="修饰符列表"></a>修饰符列表</h4><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><ol><li>返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String…</li><li>什么是返回值？返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line"><span class="comment">// 调用a方法</span></span><br><span class="line">a();</span><br><span class="line">       <span class="comment">//如果a方法执行结束之后有返回值，这个返回值返回给main了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。</p><ol start="3"><li><p>当一个方法执行结束不返回任何值的时候，返回值 类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。</p></li><li><p>如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用”return 值;”这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句,那么编译器会报错。<br>return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。</p></li><li><p>只要有“return”关键字的语句执行，当前方法必然结束。<br>return只要执行，当前所在的方法结束，记住：不是整个程序结束。</p></li><li><p>如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前 方法的。</p></li><li><p>除了void之外，剩下的都必须有“return 值;”这样的语句。</p></li></ol><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名要见名知意。（<code>驼峰命名</code>方式）<br>方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。</p><h4 id="形式参数列表"><a href="#形式参数列表" class="headerlink" title="形式参数列表"></a>形式参数列表</h4><ol><li>简称：形参</li><li>注意：形式参数列表中的每一个参数都是“<code>局部变量</code>”，方法结束之后内存<code>释放</code>。</li><li>形参的个数是：<code>0 ~ N</code>个。</li><li>形参的数据类型起决定性作用，形参对应的变量名是随意的。（方法重载会涉及！）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sumInt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> d, String s)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参有多个的话使用“逗号,”隔开。逗号是英文的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><p>由Java语句构成。java语句以“<code>;</code>”结尾。<br>方法体当中编写的是业务逻辑代码，完成某个特定功能。<br>在方法体中的代码遵循自上而下的顺序依次逐行执行。<br>在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参</p><hr><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名(实际参数列表);</span><br></pre></td></tr></table></figure><p><strong>实参和形参的类型必须一一对应，另外个数也要一一对应。</strong></p><ul><li>在方法调用的时候，什么时候“类名.”是可以省略的。什么时候不能省略？<ul><li>a()方法调用b()方法的时候，a和b方法都在<code>同一个类</code>中，“类名.”<code>可以省略</code>。<br>如果不在同一个类中“类名.”不能省略。</li></ul></li></ul><h4 id="调用方法的三种形式"><a href="#调用方法的三种形式" class="headerlink" title="调用方法的三种形式"></a>调用方法的三种形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赋值调用：</strong>调用方法，在方法前面定义变量，接收方法返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出语句调用：在输出语句中调用方法， System.out.println(方法名()) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能用输出语句调用void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</p><h3 id="方法的调用机制分析"><a href="#方法的调用机制分析" class="headerlink" title="方法的调用机制分析"></a>方法的调用机制分析</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220827181717775.png" alt="image-20220827181717775"></p><p>方法调用：</p><ol><li>当程序执行到方法是时，就会开辟一个独立的空间（栈空间）</li><li>当方法执行完毕，或者执行到ruturn语句时，就会返回</li><li>返回到调用方法的地方</li><li>返回后，继续执行方法后面的代码</li><li>当main方法（栈）执行完毕，整个程序退出</li></ol><p>方法的注意事项</p><ol><li>方法不能定义在类中其他方法里面</li><li>方法名和变量名可以同名</li><li>方法要先定义后使用，方法要调用了才会执行</li><li>当方法有形参的时候,想调用该方法必须向其中传入相应的实际参数</li><li>形参和实际参数的变量名不需要相同,需要注意的是形参的个数,类型,类型顺序是否和实参一致</li><li>一个方法可以有多个return,但是只可能有一个return被执行</li></ol><h4 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h4><p>​            基本数据类型的传参机制</p><p>​            结论: 基本数据类型, 传递的是值(值拷贝) , 形参的任何改变不影响实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Hsp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 创建AA对象 名字叫obj</span></span><br><span class="line"><span class="type">AA</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">obj.swap(a,b); <span class="comment">//调用swap :交换</span></span><br><span class="line">System.out.println(“main方法: a=” + a + <span class="string">&quot; b= &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a和b交换前的值a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);</span><br><span class="line"><span class="comment">//完成了a和b的交换</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">System.out.println(<span class="string">&quot;a和b交换后的值a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>内存分析法：</li></ul><ol><li>堆 : 一般存放基本数据类型(局部变量)</li><li>栈 : 存放对象(Cat cat，数组，引用数据类型等)</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c31ef1ac7558489e8572a83446b3354c.png" alt="img"></p><ol start="3"><li>最后输出的 a,b的值是在main方法中，要找的是main方法中的a和b的值，而主函数中的a,b并没有发生交换，所以是 a &#x3D; 10,b &#x3D; 20</li><li>swap方法中发生交换，但并不影响主方法中的交换，因为mian栈和swap是两个独立的空间，而且a、b都是基本数据类型，不是引用数据类型，所以不会影响到主方法中的a、b的值</li></ol><p>引用数据类型的传参机制</p><ul><li><p>B 类中编写一个方法 test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？</p><p>答案：会变化</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">M2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">         <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">         b.test100(arr);    <span class="comment">//调用方法</span></span><br><span class="line">         System.out.println(<span class="string">&quot; main的 arr数组 &quot;</span>);</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         System.out.print(arr[i] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//B类中编写一个方法test100，</span></span><br><span class="line">    <span class="comment">//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">200</span>;<span class="comment">//修改元素</span></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot; test100的 arr数组 &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内存分析法：</p><ol><li>只要是调用一个方法就会产生一个新的栈</li><li>引用类型传递的是一个地址</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/2437149496074802b6a9720445bacb15.png" alt="img"></p><ol start="3"><li>B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？<strong>答案：会变化</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParameter02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;xdr630&quot;</span>;</span><br><span class="line">        p.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        b.test200(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age); <span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        person.age = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>结论:引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;xdr630&quot;</span>;</span><br><span class="line">        p.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        b.test200(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age); <span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>示意图</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/f9478134046c4381948fbc2d305c1e14.png" alt="img"></p><p>2、特殊的方法—-构造方法</p><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Admin</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Admin</span><span class="params">(String name,<span class="type">int</span> age,String loginName,String password)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.loginName=loginName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.password=password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>Java中方法的重载，就是在一个类中，有相同的方法名称，但形参不同的方法。</p><h4 id="方法重载的规则"><a href="#方法重载的规则" class="headerlink" title="方法重载的规则"></a>方法重载的规则</h4><ul><li>方法名称<strong>必须相同</strong></li><li>形参列表<strong>必须不同</strong>（参数个数不同、或参数类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同，不足以称为方法的重载。</li><li><strong>同一个类中，不允许两个方法的方法名称和参数列表都相同</strong></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>如下，代码中定义了三个<strong>max</strong>方法(即<strong>方法重载</strong>)，在调用它们时根据传入的实参类型和实参个数，分别调用了对应的 max 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mJane.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第一个max方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value1</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(max_value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第二个max方法，而不是第一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_value2</span> <span class="operator">=</span> max(<span class="number">10</span>,<span class="number">25</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(max_value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为2个浮点数，匹配到第三个max方法</span></span><br><span class="line"><span class="comment">//int max_value3 = (int)max(10.0,30.0);   //返回值类型为double， 高--&gt;低 : 强制转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">max_value3</span> <span class="operator">=</span> max(<span class="number">10.0</span>,<span class="number">30.0</span>);</span><br><span class="line">        System.out.println(max_value3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> num3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt; num3 ? result:num3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num1==num2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>方法名相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法执行，如果匹配失败(未找到对应方法)，则编译器报错。</p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p><strong>重写（override）</strong>：也称覆盖。重写是子类对父类非静态，非private，非final方法的实现过程进行重新编写，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的）和形参都不能改变。即外壳不变，核心重写。</p><p><strong>【方法重写的规则】</strong>：<br>1.子类在重写父类的方法时，一般必须与父类方法原型一致：修饰符 返回值类型 方法名(参数列表) 要完全一致<br>2.JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的。<br>3.访问权限不能比父类中被重写的方法的访问权限更低。<br>4.父类被static、private 、final修饰的方法不能被重写。</p><p><strong>重写的作用</strong></p><p>重写是为了增强类的重用性和复用性，扩展性；</p><p>重写是对类中方法的扩充，因为继承用的是父类的东西，重写则不仅得到父类的东西，同时也加入了自己的东西，两全其美。</p><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>1.重载<br>重载的参数列表是必须修改的，而返回值类型，访问限定符是可以修改的</p><p>重载是静态绑定，即在编译时就根据实参类型确定了调用哪个方法。</p><p>2.重写<br>重写的参数列表，返回类型（可以是父子类），访问限定符（不能更严厉），一般是不能修改的。</p><p>重写是动态绑定，即在编译时不能确定具体的调用方法，而在程序运行时，才能确定具体的被调用的方法。</p><p>即：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现</p><table><thead><tr><th>名称</th><th>发生范围</th><th>方法名</th><th>形参列表</th><th>返回类型</th><th>修饰符</th></tr></thead><tbody><tr><td>重载(overload)</td><td>本类</td><td>必须一样</td><td>类型，个数或者顺序至少有一个不同</td><td>无要求</td><td>无要求</td></tr><tr><td>重写(override)</td><td>父子类</td><td>必须一样</td><td>相同</td><td>子类重写的方法，返回类和父类返回类型一样，或者是其子类</td><td>子类方法不能缩小父类方法的访问范围</td></tr></tbody></table><blockquote><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p></blockquote><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>可变参数(variable argument)允许你指定可以采用多个同类型参数的方法，而不需要事先确定参数的数目。</p><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可变参数语法：</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> … args)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>调用可变参数的方法时, 编译器将自动创建一个数组保存传递给方法的可变参数，因此，程序员可以在方法体中以数组的形式访问可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ... nums)</span>&#123; </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个方法参数中只能使用一个省略号；且省略号必须出现在方法中参数列表的最后一个位置。<br>&#x2F;&#x2F;要把可变参数放到参数列表的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String s,<span class="type">int</span> ... nums)</span>&#123; <span class="comment">//把可变参数当成数组</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">   sum += nums[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol><li>可变参数的实参可以为0个或者任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li>在java编程中，主要的变量就是属性（成员变量）和局部变量</li><li>我们说的局部变量一般是指在成员方法中定义的变量</li><li>java中作用域的分类<ol><li>全局变量：也就是属性</li><li>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</li></ol></li><li>全局变量（属性）可以不赋值，直接使用，因为他有默认值，局部变量必须赋值后，才能使用，因为没有默认值</li></ol><p>注意事项：</p><ol><li>属性和局部变量可以重名，访问时遵循就近原则</li><li>在同一个作用域中，比如在同一个成员方法中，两恶搞局部变量，不能重名</li><li>属性生命周期长，伴随着对象的创建而创建，伴随则会对象的销毁而销毁，局部变量，生命周期较短，伴随着他的代码块的执行而创建，伴随这代码块的结束而销毁，即在一次方法调用过程中</li><li>作用域范围不同<ol><li>全局变量&#x2F;属性：可以被本类使用，或其他类使用(通过对象调用)</li><li>局部变量：只能在本类中对应的方法中使用</li></ol></li><li>修饰符不同<ol><li>全局变量&#x2F;属性可以加修饰符</li><li>局部变量不可以加修饰符</li></ol></li></ol><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>一般是指在成员方法中定义的变量</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;<span class="comment">//这是一个方法cry()</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">10</span>;<span class="comment">//这就是局部变量</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>局部变量没有默认值<br>如果出现没有赋值，那么就会报出为初始化变量</p><pre><code>public static void main(String[] args)&#123;    Cat a1=new Cat();    a1.cry();&#125;&#125;class Cat&#123;    public void cry()&#123;//这是一个方法cry()        int n;//这就是局部变量        System.out.println(n);    &#125;&#125;</code></pre><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java: 可能尚未初始化变量n</span><br></pre></td></tr></table></figure><h4 id="全局变量（或者属性）"><a href="#全局变量（或者属性）" class="headerlink" title="全局变量（或者属性）"></a>全局变量（或者属性）</h4><p>可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.eat();<span class="comment">//调用eat方法</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">10</span>;<span class="comment">//全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;<span class="comment">//eat方法</span></span><br><span class="line">        System.out.println(age);<span class="comment">//输出全局变量age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>全局变量默认值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byet <span class="number">0</span></span><br><span class="line"><span class="type">short</span> <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0</span></span><br><span class="line"><span class="type">long</span> <span class="number">0</span></span><br><span class="line"><span class="type">float</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">double</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">char</span> \u0000</span><br><span class="line"><span class="type">boolean</span> <span class="literal">false</span></span><br><span class="line">String <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>全局变量默认值可以直接输出</p><p>举例 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Cat a1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.eat();<span class="comment">//调用eat方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> age;<span class="comment">//全局变量age</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(age);<span class="comment">//输出age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>构造方法也叫构造器（constructor）是类的一种特殊的方法，他的主要作用是完成对<strong>新对象的初始化</strong>，</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用类的构造器完成对对象的初始化。</li></ol><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名 (形参列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>构造器的修饰符可以默认，也可以是public、private、protected</li><li>构造器<strong>没有返回值</strong></li><li>方法名和类名字必须一样</li><li>参数列表和成员方法一样的规则</li><li>构造器的调用由系统完成</li></ol><h4 id="注意事项-x2F-使用细节"><a href="#注意事项-x2F-使用细节" class="headerlink" title="注意事项&#x2F;使用细节"></a>注意事项&#x2F;使用细节</h4><ol><li><p>一个类可以定义多个不同的构造器，构造器重载比如：可以给Person类顶一个构造器，用来创建对象的收，只指定人名，不需要指定年龄。</p><ol><li>&#96;&#96;&#96;java<br>class Person{<br>String name;<br>int age;<br>public Person(String PName,int PAge){<br>    naem &#x3D; PName;<br>    aeg &#x3D; PAge;<br>}<br>public Person(String PName){<br>    name &#x3D; PName;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 构造器名和类名要相同</span><br><span class="line"></span><br><span class="line">3. 构造器没有返回值</span><br><span class="line"></span><br><span class="line">4. 构造器是完成对象的初始化，并不是创建对象</span><br><span class="line"></span><br><span class="line">5. 在创建对象时，系统会自动的调用该类的构造方法</span><br><span class="line"></span><br><span class="line">6. 如果没有定义构造方法，系统会自动给类一个默认无参构造方法（也叫默认构造方法），比如Person()&#123;&#125;,可使用**javap指令** 反编译查看</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      class Person&#123;</span><br><span class="line">          Person()&#123;&#125;//隐藏构造器</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一旦定义了自己的构造器，默认的构造器就被覆盖，就不能再使用默认的无参构造器，除非显式的定义一下，即；Person(){}</p><ol><li>&#96;&#96;&#96;java<br>class Person{<br>String name;<br>&#x2F;&#x2F;手动定义的无参构造器<br>Person(){}<br>&#x2F;&#x2F;自己定义的有参构造器<br>public Person(String PNanme){<br>    name &#x3D; PName;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 访问修饰符</span><br><span class="line"></span><br><span class="line">有四种访问修饰符规定了定义的属性和方法能访问的区域</span><br><span class="line"></span><br><span class="line">1. private关键字</span><br><span class="line"></span><br><span class="line">   用private关键字修饰的属性和方法只能在该类的大括号内访问，出了这个类就不能被访问了。当一个子类继承一个父类的属性和方法时，若父类的属性或方法被private修饰，那么子类就不可以继承该属性或方法。</span><br><span class="line"></span><br><span class="line">2. default关键字（包访问权限）</span><br><span class="line"></span><br><span class="line">   default关键字修饰的属性或方法只能在同一个包中的所有类访问，且必须是同级的包，在一个包中的子包也不可以访问。但我们在定义属性和方法时不需要将default关键字写出来，没有关键字修饰的属性或方法就是包访问权限。</span><br><span class="line"></span><br><span class="line">3. protected关键字（继承访问权限）</span><br><span class="line"></span><br><span class="line">   被protected关键字修饰的属性或方法只能在同一个包中的所有类和不同包中的子类访问，出了一个包但不是该类的子类的话就不可以访问。</span><br><span class="line"></span><br><span class="line">4. public关键字</span><br><span class="line"></span><br><span class="line">   被public关键字修饰的属性或方法可以在任意位置被访问，没有使用的权限。</span><br><span class="line"></span><br><span class="line">&gt; 所以这四种访问修饰符使用的范围从小到大依次是</span><br><span class="line">&gt; [private](https://so.csdn.net/so/search?q=private&amp;spm=1001.2101.3001.7020) &lt; default &lt; protected &lt; public</span><br><span class="line"></span><br><span class="line">| 范围           | private    | Default(默认)     | Protected     | Public     |</span><br><span class="line">| :------------: | :--: | :--: | :--: | :--: |</span><br><span class="line">| 同一个类       |  √    |  √    |  √    |   √   |</span><br><span class="line">| 同一个包       |      |   √   |   √   |  √   |</span><br><span class="line">| 不同包的子类   |      |      |   √   |   √   |</span><br><span class="line">| 不同包的非子类 |      |      |      |   √   |</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line"></span><br><span class="line">1. 修饰符可以用来修饰类中的属性，成员方法以及类</span><br><span class="line">2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点</span><br><span class="line">3. 1</span><br><span class="line">4. 成员方法的访问规则和属性完全一样</span><br><span class="line"></span><br><span class="line">## This</span><br><span class="line"></span><br><span class="line">#### 注意事项，使用细节</span><br><span class="line"></span><br><span class="line">1. this关键字可以用来访问本类的属性、方法。构造器</span><br><span class="line">2. this用于区分当前类的属性和局部变量</span><br><span class="line">3. 访问成员方法的语法：this.方法名(参数列表)</span><br><span class="line">4. 访问构造器语法：this(参数列表);注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须位于第一行，而且只能出现一次）</span><br><span class="line">5. this不能在类定义的外部使用，只能在类定义的方法中使用</span><br><span class="line">6. 不能在一个类中的两个构造方法中使用this()互相调用</span><br><span class="line"></span><br><span class="line">this关键字的三种用法：</span><br><span class="line"></span><br><span class="line">- 通过this关键字可以明确的访问一个类的成员变量，解决成员变量与局部变量名称冲突问题。</span><br><span class="line">  实例：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class person&#123;</span><br><span class="line">        </span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">        </span><br><span class="line">        public person(String name,int age)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p> 上面代码中<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">构造方法</a>中定义的参数name，age等它是局部变量，在类中也定义了name，age等成员变量，在构造方法中使用age则是访问局部变量，如果想访问类中的成员变量，使用this.age则是访问成员变量。</p></li></ol><ul><li><p>通过this关键字调用成员方法</p><ul><li><p>&#96;&#96;&#96;java<br>class person{</p><pre><code>public void test()&#123;    System.out.println(“该方法被调用”);&#125;public void test1()&#123;    //调用test()方法    this.test();&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;在test2()方法中通过this.test1()访问test1()方法，注意此处的this关键字可以不写，效果是一样的。</p><p>class person{</p><pre><code>public void test()&#123;    System.out.println(“该方法被调用”);&#125;public void test1()&#123;    //调用test()方法    test();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在构造方法中访问构造方法使用this([参数1]，[参数2].。。)</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class person&#123;</span><br><span class="line">        </span><br><span class="line">        int age;</span><br><span class="line">        </span><br><span class="line">        public person()&#123;</span><br><span class="line">            //无参构造</span><br><span class="line">        &#125;</span><br><span class="line">        public person(int age)&#123;</span><br><span class="line">            this();</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误用法</p><ul><li><p>&#96;&#96;&#96;java<br>public class Student {<br>&#x2F;&#x2F;成员变量<br>String name;<br><br>public Student() {<br>    System.out.println(“无参构造方法…”);<br>    &#x2F;&#x2F;错误,必须位于第一行<br>    this(“张三”);<br>}<br><br>public Student(String name) {<br>    this.name &#x3D; name;<br>}<br>  }</p><p>public class Student {<br>String name;&#x2F;&#x2F;成员变量<br><br>public Student() {<br>    &#x2F;&#x2F;错误，不能相互调用<br>    this(“张三”);<br>}<br><br>public Student(String name) {<br>    &#x2F;&#x2F;错误，不能相互调用<br>    this();<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Super</span><br><span class="line"></span><br><span class="line">###  使用super调用父类中重写的方法、访问父类中被隐藏的字段</span><br><span class="line"></span><br><span class="line">子类重写了父类中的某一个方法，隐藏父类中的字段，假如想在子类中访问到父类中被重写的方法和隐藏父类的字段，可以在子类中通过使用关键字super来调用父类中被重写的方法和访问父类中被隐藏的字段。例如：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package first;</span><br><span class="line">class A&#123;</span><br><span class="line">    public String name=&quot;张飞&quot;;         //添加成员变量</span><br><span class="line">public void say() &#123;                //添加成员方法say</span><br><span class="line">System.out.println(&quot;我是父类A成员方法say&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public String name=&quot;关羽&quot;;         //与父类中同名的字段，隐藏父类</span><br><span class="line">public void say()&#123;                 //重写方法say</span><br><span class="line">super.say();                   //使用super关键字调用父类中的方法</span><br><span class="line">System.out.println(&quot;我是子类B成员方法say&quot;);</span><br><span class="line">        System.out.println(&quot;父类的name名字：&quot;+super.name); //使用super关键字访问父类中的变量</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class myfirst &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  B b=new B();                     //创建子类的一个实例对象</span><br><span class="line">  b.say();                         //调用子类中重写的方法</span><br><span class="line">  System.out.println(&quot;子类的name名字：&quot;+b.name);   //调用子类中的name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>运行结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是父类A成员方法say</span></span><br><span class="line"><span class="comment">//我是子类B成员方法say</span></span><br><span class="line"><span class="comment">//父类的name名字：张飞</span></span><br><span class="line"><span class="comment">//子类的name名字：关羽</span></span><br></pre></td></tr></table></figure><h3 id="使用super调用父类的无参数构造方法-x2F-有参数构造方法"><a href="#使用super调用父类的无参数构造方法-x2F-有参数构造方法" class="headerlink" title="使用super调用父类的无参数构造方法&#x2F;有参数构造方法"></a>使用super调用父类的无参数构造方法&#x2F;有参数构造方法</h3><p>子类不继承其父类的构造方法。</p><ul><li>当使用无参数的super()时，父类的无参数构造方法就会被调用；</li><li>当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;              <span class="comment">//创建父类SuperClass</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;            <span class="comment">//声明一个私有变量n</span></span><br><span class="line">  SuperClass()&#123;             <span class="comment">//父类无参数构造方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是父类SuperClass无参数构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(<span class="type">int</span> n) &#123;       <span class="comment">//父类有参数构造方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是父类SuperClass有参数构造方法&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;     <span class="comment">// SubClass类继承SuperClass类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;                       <span class="comment">//声明一个私有变量n</span></span><br><span class="line">  SubClass()&#123;                          <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是子类无参数构造方法&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(<span class="type">int</span> n)</span>&#123;              <span class="comment">//子类有参数构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="number">300</span>);                        <span class="comment">//调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;这是子类有参数构造方法&quot;</span>+n);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();      <span class="comment">//创建子类SubClass实例对象，调用其无参数构造方法</span></span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(<span class="number">100</span>);   <span class="comment">//创建子类SubClass实例对象，调用其有参数构造方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是父类SuperClass无参数构造方法</span></span><br><span class="line"><span class="comment">//这是子类无参数构造方法</span></span><br><span class="line"><span class="comment">//这是父类SuperClass有参数构造方法</span></span><br><span class="line"><span class="comment">//这是子类有参数构造方法100</span></span><br></pre></td></tr></table></figure><p>注意</p><ul><li><p>如果要初始化父类中的字段，可以在子类的构造方法中通过关键字super调用父类的构造方法；</p></li><li><p>对父类的构造放的调用必须放在子类构造方法的第一行；</p></li><li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器；</p></li><li><p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表；</p></li><li><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</p></li></ul><h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。</p><h3 id="强调一下"><a href="#强调一下" class="headerlink" title="强调一下"></a>强调一下</h3><ul><li>static修饰的成员变量和方法，从属于类</li><li>普通变量和方法从属于对象</li><li>静态方法不能调用非静态成员，编译会报错</li></ul><h3 id="static关键字的用途"><a href="#static关键字的用途" class="headerlink" title="static关键字的用途"></a>static关键字的用途</h3><p>一句话描述就是：<strong>方便在没有创建对象的情况下进行调用(方法&#x2F;变量)。</strong></p><p>显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p><p>static可以用来修饰类的成员方法、类的成员变量，另外也可以编写static代码块来优化程序性能</p><h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><p>static方法也成为静态方法，由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this的，因为不依附于任何对象，既然都没有对象，就谈不上this了，并且由于此特性，在静态方法中不能访问类的非静态成员变量和非静态方法，因为非静态成员变量和非静态方法都必须依赖于具体的对象才能被调用。</p><p>虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量。</p><p>代码示例：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20180807172546687" alt="这里写图片描述"></p><p>从上面代码里看出：</p><p>静态方法test2()中调用非静态成员变量address，编译失败。这是因为，在编译期并没有对象生成，address变量根本就不存在。</p><p>静态方法test2()中调用非静态方法test1()，编译失败。这是因为，编译器无法预知在非静态成员方法test1()中是否访问了非静态成员变量，所以也禁止在静态方法中调用非静态成员方法</p><p>非静态成员方法test1()访问静态成员方法test2()&#x2F;变量name是没有限制的</p><p>所以，如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。最常见的静态方法就是main方法，这就是为什么main方法是静态方法就一目了然了，因为程序在执行main方法的时候没有创建任何对象，只有通过类名来访问。</p><p>特别说明：static方法是属于类的，非实例对象，在JVM加载类时，就已经存在内存中，不会被虚拟机GC回收掉，这样内存负荷会很大，但是非static方法会在运行完毕后被虚拟机GC掉，减轻内存压力</p><h3 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h3><p>static变量也称为静态变量，静态变量和非静态变量的区别：</p><p>静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化</p><p>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</p><p>static成员变量初始化顺序按照定义的顺序来进行初始化</p><h3 id="static块"><a href="#static块" class="headerlink" title="static块"></a>static块</h3><p>构造方法用于对象的初始化。静态初始化块，用于类的初始化操作。</p><p>在静态初始化块中不能直接访问非staic成员。</p><h4 id="static块的作用"><a href="#static块的作用" class="headerlink" title="static块的作用"></a>static块的作用</h4><p>静态初始化块的作用就是：提升程序性能。</p><p>为什么说静态初始化块能提升程序性能，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBornBoomer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> Date.valueOf(<span class="string">&quot;1946&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> Date.valueOf(<span class="string">&quot;1964&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">&quot;1946&quot;</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">&quot;1964&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBornBoomer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行</p><p>静态初始化块可以置于类中的任何地方，类中可以有多个静态初始化块。<br>在类初次被加载时，会按照静态初始化块的顺序来执行每个块，并且只会执行一次。</p><hr><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><h3 id="类变量的定义"><a href="#类变量的定义" class="headerlink" title="类变量的定义"></a>类变量的定义</h3><p>类变量也叫静态变量&#x2F;静态方法,是该类的所有对象共享的变量,任何一个该类的对象访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量.</p><h3 id="类变量的定义语法"><a href="#类变量的定义语法" class="headerlink" title="类变量的定义语法"></a>类变量的定义语法</h3><p>推荐使用 :      访问修饰符 static 数据类型 变量名;<br>当然也可以:    static 访问修饰符 数据类型 变量名</p><h3 id="访问类变量"><a href="#访问类变量" class="headerlink" title="访问类变量"></a>访问类变量</h3><p>推荐使用: 类名.类变量名<br>当然也可以用: 对象名.类变量名<br>需要注意的是</p><p>静态变量的访问修饰符的访问权限和范围与普通类型是一样的<br>类变量是随着类加载而加载(用到类的时候会加载,只加载一次),所以即使没有创建实例对象也可以访问<br>访问变量名的代码解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Visit</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.name);<span class="comment">//输出张三</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();              <span class="comment">//两个输出效果相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.name=&quot;</span>+a.name);<span class="comment">//输出a.name=张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>什么时候需要用类变量<ol><li>需要让某个类的所有对象共享一个变量时,可以考虑使用类变量</li></ol></li><li>类变量和实例变量区别<ol><li>类变量是该类所有对象共享的,而实例变量是每个对象独享的</li></ol></li><li>加上static称为<strong>类变量</strong>或者<strong>静态变量</strong>,否则称为实例变量&#x2F;普通变量&#x2F;非静态变量，</li><li>实例变量不能用类名.变量名访问</li><li>类变量可以通过 <strong>类名.类变量名</strong> 或者  <strong>对象名.类变量名</strong>  来访问，但Java设计者推荐  类名.类变量名 方式访问</li><li>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了就可以使用类变量</li><li>类变量的生命周期随类的加载开始，随类消亡而销毁</li></ol><h3 id="关于静态变量-x2F-类变量在内存中的位置"><a href="#关于静态变量-x2F-类变量在内存中的位置" class="headerlink" title="关于静态变量&#x2F;类变量在内存中的位置"></a>关于静态变量&#x2F;类变量在内存中的位置</h3><p>关于这个问题网上流传版本不同,原因是随着jdk的版本不同,但却有以下共识</p><p>static变量是同一个类所有对象共享,不必知道其具体位置也行<br>static在类加载时生成,只加载一次,没有创建对象实例也可以通过类名.类变量来访问,生命周期随类加载而开始,随类消失而消亡那个,与对象无关</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类方法也叫静态方法</p><p>形式如下</p><p>访问修饰符 static 数据返回类型 方法名(){ }</p><p>static 访问修饰符 数据返回类型 方法名(){  }</p><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p><strong>类名.类方法名</strong>   或者    <strong>对象名.类方法名</strong>  </p><blockquote><p>前提是 满足访问修饰符的访问权限和范围</p></blockquote><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：<ol><li>类方法中无this的参数</li><li>普通方法中隐含着this的参数</li></ol></li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用，比如<strong>对象名.方法名(参数)</strong>,不能通过类名调用</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>** <strong>在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。</strong></p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；<br>非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p> 因为静态方法和静态数据成员会随着类的定义而被分配和装载入<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中，而非静态方法和非静态数据成员只有在类的对象创建时在对象的内存中才有这个方法的代码段。</p><p>引用静态方法时，可以用类名.方法名或者对象名.方法名的形式。<br>对以上描述进行验证的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        System.out.println(S.getStatic());<span class="comment">//使用类名加前缀访问静态方法</span></span><br><span class="line">        S s=<span class="keyword">new</span> <span class="title class_">S</span>();</span><br><span class="line">        System.out.println(s.getStatic());<span class="comment">//使用实例化对象名访问静态方法</span></span><br><span class="line">        System.out.println(s.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">S</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态初始器：由static和&#123;&#125;组成，只在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。</span></span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            a=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态方法只能访问静态数据成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getStatic</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getT</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态方法可以访问静态方法和非静态方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            getT();</span><br><span class="line">            getStatic();</span><br><span class="line">            t=a;<span class="comment">//非静态方法可以访问非静态数据成员和静态数据成员</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>（1）<a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>修饰的静态方法会随着类的定义而被分配和装载入内存中，编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然可能有多个实例，但这些实例共享该内存，特别值得注意的是，任何一个对象对静态数据成员的修改，都会影响其它对象。<br>（2）静态不能引用非静态这一特性，是由于静态的会随着类的定义而被分配和装载入内存中这一关键点决定的；如果静态引用了非静态的，根本无法从内存中找到非静态的代码段，势必会出错，这种做法是Java虚拟机决不允许的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>静态方法，只能访问静态成员</li><li>非静态方法，可以访问所有成员</li><li>遵守访问权限规则</li></ol><hr><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>定义：Java中，final 表示最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。</p><p>用途：final 应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变。</p><p>使用注意事项：</p><ol><li>final 修饰变量，表示变量的值不可改变，此时该变量可被称为常量。</li><li>final 修饰方法，表示方法不能被子类重写；<ol><li>重写概念：子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。</li></ol></li><li>final 用在类的前面表示该类不能有子类，即该类不可以被继承。</li></ol><h3 id="final修饰"><a href="#final修饰" class="headerlink" title="final修饰"></a>final修饰</h3><p>1、final变量<br>final变量，凡是对成员变量或者(在方法中的或者代码块中的变量称为本地变量)声明为 final 的都叫作 final 变量。final 变量经常和 static 关键字一起使用，作为常量。下面是 final 变量的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">NAME = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;李四&quot;</span>); <span class="comment">//invalid compilation error</span></span><br><span class="line"><span class="comment">//final 变量是只读的。</span></span><br></pre></td></tr></table></figure><p>2、final 方法<br>final 声明方法，这个方法不允许在派生类中进一步被覆写（override）。</p><p>Java 中非私有的成员方法默认都是虚方法，而虚方法就可以在派生类中被覆写。</p><p>为保证某个类上的某个虚方法不在派生类中被进一步覆写，就需要使用 final 修饰符来声明，让编译器（例如 javac）与 JVM 共同检查并保证这个限制总是成立。</p><p>下面是 final 方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span>张三<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Reader extends User&#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public final String getName()&#123;</span></span><br><span class="line"><span class="string">        return &quot;</span>李四<span class="string">&quot;; //compilation error: overridden method is final</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>3、final 类<br>final 修饰的类叫作 final 类，final类通常是功能完整的，不能被继承，Java 中有许多类是 final 的，比如 String, Interger 以及其他包装类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol><li>final 关键字，提高了性能，JVM 和 Java 应用都会缓存 final 变量。</li><li>final 变量，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>final 关键字可以用于修饰成员变量、本地变量、方法以及类。</li><li>final 成员变量，必须在声明的时初始化或者在构造器中初始化，否则报编译错误。</li><li>final 变量不能再次赋值；final 方法不能被重写；final 类不能被继承。</li><li>在匿名类中，所有变量都必须是 final 变量。</li><li>接口中，声明的所有变量本身是 final 的。</li><li>final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的。</li><li>声明时未初始化的 final 变量，称为空白 final 变量(blank final variable)，必须在构造器中进行初始化，或者调用 this() 初始化，否则，编译器会报错final变量(变量名)需要进行初始化。</li><li>按照 Java 编码规范，final 变量就是常量，而且通常常量名要大写。</li><li>对于集合对象声明为 final 指的是引用不能被更改。</li></ol><hr><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li>java虚拟机需要调用类的main()方法，所以该方法的访问必须是public</li><li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li><li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，</li><li>java执行的程序 参数1，参数2，参数3<ol><li><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919153604012.png" alt="image-20220919153604012"></li></ol></li></ol><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>public是一种访问权限修饰符，public中文翻译共有，正如它的实际意思一样，在Java里面所有被public修饰的方法，类等都可以在任意其他地方调用。main方法之所以是public，是因为一个Java程序在运行时首先创建一个JVM实例，程序要运行需要调用main方法，JVM从外部调用main方法这就需要访问权限修饰符必须给出外部访问的权限，所以只能用public。</p><p>static的定义是为了JVM在调用main方法时不用实例化对象，只需要在初始时加载main方法所在类，然后直接通过类名.main来调用main方法。</p><p>void表示main方法没有返回值，没有返回值的原因是因为Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序。</p><p>main的名称不能变是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。main方法作为程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程，非守护线程和守护线程，main方法属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以表明自己的线程是守护线程。当程序中所有的非守护线程终止时，JVM退出。也可以用Runtime类或者System.exit()来退出。</p><p>String[] args,是main方法中唯一可以改变的地方！args是arguments的缩写，只是一个变量默认名，习惯性写作它，但是也可以改变的，只要符合命名规则随便你写成什么。在使用集成开发工具的今天，String[] args更像是一种摆设了，很多初学者都不知道它的作用，其实它是程序运行传入的一个参数组。一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainMethod</span>&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;获取数组args[]的数据&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;第&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;个实参：&quot;</span> + args[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入实参（1 2 3）</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919164420682.png" alt="image-20220919164420682"></p><p>输出结果为：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919164850936.png" alt="image-20220919164850936"></p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ol><li>在main()方法中，可以直接调用main方法所在类的静态方法或静态属性</li><li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>封装（encapsulation）就是把抽象出的数据[属性]和对数据的操作[方法]封装再一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法].才能对数据进行操作</p><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。<br>实现Java封装的步骤</p></li><li><p>修改属性的可见性来限制对属性的访问（一般限制为private），例如:</p><ol><li>&#96;&#96;&#96;java<br>public class person{<br>private String name;<br>private int age;<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</span><br><span class="line"></span><br><span class="line">2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class Person&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">      ​</span><br><span class="line">        public int getAge()&#123;</span><br><span class="line">         return age;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public String getName()&#123;</span><br><span class="line">         return name;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public void setAge(int age)&#123;</span><br><span class="line">         this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">      ​</span><br><span class="line">        public void setName(String name)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</li></ol></li></ol><p>一个java封装类的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名: EncapTest.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncapTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String idNum;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getIdNum</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> idNum;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">( <span class="type">int</span> newAge)</span>&#123;</span><br><span class="line">   age = newAge;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span>&#123;</span><br><span class="line">   name = newName;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIdNum</span><span class="params">( String newId)</span>&#123;</span><br><span class="line">   idNum = newId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上实例中public方法是外部类访问该类成员变量的入口。</p><p>通常情况下，这些方法被称为getter和setter方法。</p><p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p><p>通过如下的例子说明EncapTest类的变量怎样被访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* F文件名 : RunEncap.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunEncap</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">   <span class="type">EncapTest</span> <span class="variable">encap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncapTest</span>();</span><br><span class="line">   encap.setName(<span class="string">&quot;James&quot;</span>);</span><br><span class="line">   encap.setAge(<span class="number">20</span>);</span><br><span class="line">   encap.setIdNum(<span class="string">&quot;12343ms&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   System.out.print(<span class="string">&quot;Name : &quot;</span> + encap.getName()+ </span><br><span class="line">               <span class="string">&quot; Age : &quot;</span>+ encap.getAge());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码编译运行结果：</p><blockquote><p>Name : James   Age : 20</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>继承的作用：通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。</p><p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 父类&#123;</span><br><span class="line">    ...       <span class="comment">//成员变量、成员方法</span></span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">    ...       <span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">        Systme.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        s.age = <span class="number">19</span>;</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//学生</span></span><br><span class="line"><span class="comment">//Tom</span></span><br><span class="line"><span class="comment">//19</span></span><br></pre></td></tr></table></figure><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>子类不能选择性继承父类；</li><li>Java不支持多重继承，但一个类可以实现多个接口，从而克服单继承的缺点；</li><li>构造方法不会被子类继承，但可以从子类中调用父类的构造方法</li><li>当子类对象创建好后，与父类创建了查找的关系</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>继承过来的字段和方法，可以像任何其他字段和方法一样被直接使用；</li><li>在子类中可以声明一个与父类中同名的新字段或静态方法，从而“隐藏”父类中的字段或方法；</li><li>可以在子类中声明一个在父类中没有的新字段和方法；</li><li>可以在子类中编写一个父类当中具有相同名的新实例方法，这称为“方法重写”或“方法覆盖”；</li><li>可以在子类中编写一个调用父类构造方法的子类构造方法，既可以隐式地实现，也可以通过使用关键字super来实现。</li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220914114141070.png" alt="image-20220914114141070"></p><h3 id="重写和隐藏父类方法"><a href="#重写和隐藏父类方法" class="headerlink" title="重写和隐藏父类方法"></a>重写和隐藏父类方法</h3><p>子类继承了父类中的所有成员及方法，但在某种情况下，子类中该方法所表示的行为与其父类中该方法所表示的行为不完全相同，例如，在父类语言中定义了说话这个方法，而在子类中说话的方法是不同的：外国人说英文，中国人说中文，这时我们就需要重写或隐藏父类的该方法。</p><h3 id="重写父类中的方法"><a href="#重写父类中的方法" class="headerlink" title="重写父类中的方法"></a>重写父类中的方法</h3><p>当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;                      <span class="comment">//输出英文欢迎</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello,Welcome to Java!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayBye</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;GoodBye,everyone&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;                      <span class="comment">//输出中文欢迎  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;大家好，欢迎学习Java！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">B b=<span class="keyword">new</span> <span class="title class_">B</span>();                                <span class="comment">//创建子类B的一个实例对象，使用默认构造方法</span></span><br><span class="line">b.sayHello();                               <span class="comment">//调用子类中重写的方法</span></span><br><span class="line">b.sayBye();                                 <span class="comment">//调用父类中的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大家好，欢迎学习Java！！！</span></span><br><span class="line"><span class="comment">//GoodBye,everyone</span></span><br></pre></td></tr></table></figure><p>注意：重写的方法具有与其所重写的方法相同的名称、参数数量、类型和返回值。</p><p>隐藏父类中的方法<br>如果一个子类定义了一个静态类方法，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。</p><ul><li><p>当调用被重写的方法时，调用的版本是子类的方法；</p></li><li><p>当调用被隐藏的方法时，调用的版本取决于是从父类中调用还是从子类中调用。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;             <span class="comment">//静态类方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;大家好，这是A的静态类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello2</span><span class="params">()</span> &#123;                   <span class="comment">//实例方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;大家好，这是A中的实例方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;             <span class="comment">//静态类方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;大家好，这是B的静态类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello2</span><span class="params">()</span> &#123;                   <span class="comment">//实例方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;大家好，这是B的实例方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    B b=<span class="keyword">new</span> <span class="title class_">B</span>();                           <span class="comment">//创建B类的实例对象b</span></span><br><span class="line">    A a=b;                                 <span class="comment">//隐式对象类型转换</span></span><br><span class="line">    A.sayHello();                          <span class="comment">//调用A类的静态类方法</span></span><br><span class="line">    a.sayHello();                          <span class="comment">//调用a对象的静态类方法</span></span><br><span class="line">    B.sayHello();                          <span class="comment">//调用B类的静态方法</span></span><br><span class="line">    a.sayHello2();                         <span class="comment">//调用a对象的实例方法</span></span><br><span class="line">    b.sayHello2();                         <span class="comment">//调用b对象的的实例方法</span></span><br><span class="line">    A a2=<span class="keyword">new</span> <span class="title class_">A</span>();                          <span class="comment">//创建A类的实例对象a2</span></span><br><span class="line">    a2.sayHello2();                        <span class="comment">//调用a2对象的实现方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大家好，这是A的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是A的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的静态类方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的实例方法</span></span><br><span class="line"><span class="comment">//大家好，这是B的实例方法</span></span><br><span class="line"><span class="comment">//大家好，这是A中的实例方法</span></span><br></pre></td></tr></table></figure><p>得到调用的隐藏方法是父类中的方法，而得到调用的重写方法是子类中的方法。</p><h3 id="方法重写和隐藏后的修饰符"><a href="#方法重写和隐藏后的修饰符" class="headerlink" title="方法重写和隐藏后的修饰符"></a>方法重写和隐藏后的修饰符</h3><p>在子类中被重写的方法，其访问权限允许大于但不允许小于被其重写的方法，例如：父类中一个受保护的实例方法(protected)在子类中可以是公共的(public)的，但不可以是私有的(private)。如果一个方法在父类中是static方法，那么在子类也必须是static方法；如果一个方法在父类中是实例方法，那么在子类中也必须是实例方法。</p><h3 id="子类访问父类私有成员"><a href="#子类访问父类私有成员" class="headerlink" title="子类访问父类私有成员"></a>子类访问父类私有成员</h3><p>子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。那么如何在子类中访问到父类中的字段呢，我们可以在父类中提供用来访问其私有字段的public或protected方法，子类使用这些方法来访问相应的字段。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;                     <span class="comment">//父类A</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> value=<span class="number">10</span>;    <span class="comment">//声明一个私有变量value并赋值为10</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getvalue</span><span class="params">()</span> &#123;  <span class="comment">//声明一个公有成员方法getvalue，返回value</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;           <span class="comment">//A的子类B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myfirst</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  B b=<span class="keyword">new</span> <span class="title class_">B</span>();           <span class="comment">//创建子类B的一个实例对象</span></span><br><span class="line">  System.out.println(<span class="string">&quot;子类通过父类提供的公共接口访问A中的私有字段value:&quot;</span>+b.getvalue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类通过父类提供的公共接口访问A中的私有字段value:10</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h3><p>多态是面向对象程序设计（OOP）的一个重要特征，指同一个实体同时具有多种形式，即同一个对象，在不同时刻，代表的对象不一样，指的是对象的多种形态。</p><p>可以把不同的子类对象都当作父类来看，进而屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，统一调用标准。</p><p>比如，小猫、小狗、小猪我们可以把他们都归纳成小动物，每种小动物都需要吃东西,所以我们可以统一设置他们都必须吃，但是每种小动物的习性不一样，那这个就可以设置成小动物自己特有的功能,多态对象只能调用父类中定义子类中重写的功能,并不能调用子类的特有功能,这样就实现了代码的统一</p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>通俗点讲，多态就是不同对象对同一物体或事件发出不同的反应或响应。比如stuendt是一个父类，那么在操场上上体育课的学生和在教室里面的学生就是它的子类。这时上课铃声响了，上体育课的学生去操场，在教室里面上课的学生则是回教室，不同的学生有着不同的反应，这就是多态。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>父类类型  引用名 &#x3D; new 子类类型();</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>多态的前提1：是继承</li><li>多态的前提2：要有方法的重写</li><li>父类引用指向子类对象,如：Animal a &#x3D; new Cat();</li><li>多态中，编译看左边，运行看右边</li></ol><h3 id="实现多态的条件"><a href="#实现多态的条件" class="headerlink" title="实现多态的条件"></a>实现多态的条件</h3><p>1.继承：必须要有子类继承父类的继承关系。<br>2.重写：子类需要对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法而不是原本父类的方法。<br>3.向上转型：在多态中需要将父类引用指向子类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220908100824809.png" alt="image-20220908100824809"></p><h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ol><li>多态可以让我们不用关心某个对象到底具体是什么类型,就可以使用该对象的某些方法</li><li>提高了程序的可扩展性和可维护性</li></ol><h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p>前提:多态对象把自己看做是父类类型</p><ol><li>成员变量: 使用的是父类的</li><li>成员方法: 由于存在重写现象,所以使用的是子类的</li><li>属性没有重写之说，属性的值看编译类型</li><li>静态成员: 随着类的加载而加载,谁调用就返回谁的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.oop2;</span><br><span class="line"><span class="comment">/*本类用于测试多态成员的使用情况*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//7.创建纯纯的子类对象</span></span><br><span class="line">        <span class="type">Dog2</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2</span>();</span><br><span class="line">        System.out.println(d.sum);<span class="comment">//20,子类自己的属性</span></span><br><span class="line">        d.eat();<span class="comment">//小狗爱吃肉包子,子类自己的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.创建多态对象</span></span><br><span class="line">        <span class="comment">/*口诀1：父类引用指向子类对象*/</span></span><br><span class="line">        <span class="comment">/*口诀2：编译(保存)看左边，运行(效果)看右边*/</span></span><br><span class="line">        <span class="type">Animal2</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2</span>();</span><br><span class="line">        <span class="comment">/*多态中，成员变量使用的是父类的*/</span></span><br><span class="line">        System.out.println(a.sum);<span class="comment">//10</span></span><br><span class="line">        <span class="comment">/*多态中，方法的声明使用的是父类的，方法体使用的是子类的*/</span></span><br><span class="line">        a.eat();<span class="comment">//小狗爱吃肉包子</span></span><br><span class="line">        <span class="comment">/*多态中，调用的静态方法是父类的，因为多态对象把自己看作是父类类型</span></span><br><span class="line"><span class="comment">        * 直接使用父类中的静态资源*/</span></span><br><span class="line">        a.play();<span class="comment">//没有提示，玩啥都行~</span></span><br><span class="line">        Animal2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal2</span>&#123;</span><br><span class="line">    <span class="comment">//3.创建父类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//4.创建父类的普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃啥都行~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9.1定义父类的静态方法play</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩啥都行~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog2</span> <span class="keyword">extends</span> <span class="title class_">Animal2</span>&#123;</span><br><span class="line">    <span class="comment">//5.定义子类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//6.重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗爱吃肉包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9.2创建子类的静态方法play</span></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">/*这不是一个重写的方法，只是恰巧在两个类中出现了一模一样的两个静态方法</span></span><br><span class="line"><span class="comment">    * 静态方法属于类资源，只有一份，不存在重写的现象</span></span><br><span class="line"><span class="comment">    * 在哪个类里定义，就作为哪个类的资源使用*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗喜欢玩皮球~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h3><p>在JAVA中，继承是一个重要的特征，通过extends关键字，子类可以复用父类的功能，如果父类不能满足当前子类的需求，则子类可以重写父类中的方法来加以扩展。<br>那么在这个过程中就存在着多态的应用。存在着两种转型方式，分别是：向上转型和向下转型。</p><p><strong>向上转型</strong>：可以把不同的子类对象都当作父类来看，进而屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，统一调用标准。<br>比如：父类Parent,子类Child<br>父类的引用指向子类对象：Parent p&#x3D;new Child();<br>说明：向上转型时，子类对象当成父类对象，只能调用父类的功能，如果子类重写了父类中声明过的方法，方法体执行的就是子类重过后的功能。但是此时对象是把自己看做是父类类型的，所以其他资源使用的还是父类型的。<br>比如：花木兰替父从军，大家都把花木兰看做她爸，但是实际从军的是花木兰，而且，花木兰只能做她爸能做的事，在军营里是不可以化妆的。</p><p><strong>向下转型</strong>(较少)：子类的引用的指向子类对象，过程中必须要采取到强制转型。这个是之前向上造型过的子类对象仍然想执行子类的特有功能，所以需要重新恢复成子类对象<br>Parent p &#x3D; new Child();&#x2F;&#x2F;向上转型，此时，p是Parent类型<br>Child c &#x3D; (Child)p;&#x2F;&#x2F;此时，把Parent类型的p转成小类型Child<br>其实，相当于创建了一个子类对象一样，可以用父类的，也可以用自己的<br>说明：向下转型时，是为了方便使用子类的特殊方法，也就是说当子类方法做了功能拓展，就可以直接使用子类功能。<br>比如：花木兰打仗结束，就不需要再看做是她爸了，就可以”对镜贴花黄”了</p><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());<span class="comment">//40</span></span><br><span class="line">        System.out.println(a.sum1());<span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>A a &#x3D; new B();是向上转型，调用方法看运行类型</strong><br><strong>a.sum()和a.sum1()分别输出40和30，这一点毫无疑问</strong></p><h3 id="动态绑定机制-调用对象方法"><a href="#动态绑定机制-调用对象方法" class="headerlink" title="动态绑定机制-调用对象方法"></a>动态绑定机制-调用对象方法</h3><p><strong>如果把上述子类中的sum()注释掉，结果会有什么不同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个时候a.sum()访问子类，发现子类中没有sum方法，再去访问父类，父类中有sum方法，调用的过程中getl()出现了分歧，父类和子类中都有getl()，该调用哪一个？</strong><br><strong>这里就体现出java的动态绑定机制</strong></p><blockquote><p><strong>java的动态绑定机制</strong><br><strong>1.当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</strong><br><strong>2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//    public int sum()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public int sum1()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>根据案例2中对动态绑定机制的描述，很容易分析出<br>a.sum()和a.sum1()分别输出30和20</strong></p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。而抽象类是指在普通类的结构里面增加抽象方法的组成部分。</p><p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而<strong>抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure><p>而拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。<br>定义一个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: </span></span><br><span class="line"><span class="comment">//Cannot instantiate the type A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//at com.wz.abstractdemo.TestDemo.main(TestDemo.java:15)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上可知，A是抽象的，无法直接进行实例化操作。为什么不能直接实例化呢？当一个类实例化之后，就意味着这个对象可以调用类中的属性或者放过了，但在抽象类里存在抽象方法，而抽象方法没有方法体，没有方法体就无法进行调用。既然无法进行方法调用的话，又怎么去产生实例化对象呢。</p><p>抽象类的使用原则如下：</p><ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；</li><li>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；</li><li>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</li><li>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//B类是抽象类的子类，是一个普通类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;<span class="comment">//强制要求覆写</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line"></span><br><span class="line">a.print();<span class="comment">//被子类所覆写的过的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hello World!</span></span><br></pre></td></tr></table></figure><p>现在就可以清楚的发现：</p><ol><li>抽象类继承子类里面有明确的方法覆写要求，而普通类可以有选择性的来决定是否需要覆写；</li><li>抽象类实际上就比普通类多了一些抽象方法而已，其他组成部分和普通类完全一样；</li><li>普通类对象可以直接实例化，但抽象类的对象必须经过向上转型之后才可以得到。</li></ol><p>虽然一个类的子类可以去继承任意的一个普通类，可是从开发的实际要求来讲，普通类尽量不要去继承另外一个普通类，而是去继承抽象类。</p><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong></p><h3 id="抽象类的使用限制"><a href="#抽象类的使用限制" class="headerlink" title="抽象类的使用限制"></a>抽象类的使用限制</h3><ol><li>抽象类中有构造方法，由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</li><li>抽象类不可以用final声明，因为抽象类必须有子类，而final定义的类不能有子类；</li><li>外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</li><li>可以直接调用抽象类中的static声明的方法，任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</li><li>有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><ol><li>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</li></ol></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><ol><li>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</li></ol></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><ol><li>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设 计。</li></ol></li><li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p><ol><li>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</li></ol></li></ol><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>有如下需求；</p><ul><li>有多个类，完成不同的任务job</li><li>要求统计得到的各自完成任务的时间</li></ul><p>抽象行为类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">time</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        job();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;运行时长为：&quot;</span> + (end - start) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>job_1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( <span class="string">&quot;aa =&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>job_2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( <span class="string">&quot;bb =&quot;</span> + num );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        AA aa = new AA();</span></span><br><span class="line"><span class="comment">//        aa.time();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        BB bb = new BB();</span></span><br><span class="line"><span class="comment">//        bb.time();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Template</span> <span class="variable">t_a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        t_a.time();</span><br><span class="line">        <span class="type">Template</span> <span class="variable">t_b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        t_b.time();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aa =3200040000</span></span><br><span class="line"><span class="comment">//运行时长为：1</span></span><br><span class="line"><span class="comment">//bb =200010000</span></span><br><span class="line"><span class="comment">//运行时长为：1</span></span><br></pre></td></tr></table></figure><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合。接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">class 子类 [extends 父类] [implemetns 接口<span class="number">1</span>,接口<span class="number">2</span>,...] &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果一个类只由抽象方法和全局常量组成，那么这种情况下不会将其定义为一个抽象类。只会定义为一个接口，所以接口严格的来讲属于一个特殊的类，而这个类里面只有抽象方法和全局常量，就连构造方法也没有。</p><p>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p><blockquote><p>解释：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</p></blockquote><p>定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。 </p><ul><li>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。</li><li>一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。</li><li>如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）</li><li>一个JAVA库中接口的例子是：Comparator 接口，这个接口代表了“能够进行比较”这种能力，任何类只要实现了这个Comparator接口的话，这个类也具备了“比较”这种能力，那么就可以用来进行排序操作了。</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>由于接口里面存在抽象方法，所以接口对象不能直接使用关键字new进行实例化。接口的使用原则如下：</p><ol><li>接口必须要有子类，但此时一个子类可以使用implements关键字实现多个接口；</li><li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li><li>接口的对象可以利用子类对象的向上转型进行实例化。</li></ol><h3 id="实际应用（标准定义）"><a href="#实际应用（标准定义）" class="headerlink" title="实际应用（标准定义）"></a>实际应用（标准定义）</h3><p>在日常的生活之中，接口这一名词经常听到的，例如：USB接口、打印接口、充电接口等等。</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/20161006002203942" alt="interface"></p><p>如果要进行开发，要先开发出USB接口标准，然后设备厂商才可以设计出USB设备。</p><p>现在假设每一个USB设备只有两个功能：安装驱动程序、工作。<br>定义一个USB的标准：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;   <span class="comment">// 操作标准       </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在电脑上应用此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">plugin</span><span class="params">(USB usb)</span> &#123;</span><br><span class="line">          usb.install() ;</span><br><span class="line">          usb.work() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义USB设备—手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装手机驱动程序。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;手机与电脑进行工作。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义USB设备—打印机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装打印机驱动程序。&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;进行文件打印。&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试主类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>() ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> <span class="title class_">Phone</span>()) ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装手机驱动程序。</span></span><br><span class="line"><span class="comment">//手机与电脑进行工作。</span></span><br><span class="line"><span class="comment">//安装打印机驱动程序。</span></span><br><span class="line"><span class="comment">//进行文件打印。</span></span><br></pre></td></tr></table></figure><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol><li><p>接口不能被实例化</p></li><li><p>接口中所有的方法师public方法，接口中抽象方法，可以不用abstract修饰</p></li><li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p></li><li><p>抽象类实现接口，可以不用实现接口的方法</p></li><li><p>一个类可以实现多个接口</p></li><li><p>接口中的属性，只能是final的，而且是public static final修饰符，比如：</p><ol><li>&#96;&#96;&#96;java<br>int a &#x3D; 1;<br>&#x2F;&#x2F;实际上为<br>public static final int a &#x3D; 1;&#x2F;&#x2F;在接口中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 接口中属性的访问形式，接口名.属性名</span><br><span class="line"></span><br><span class="line">8. 一个接口不能继承其他的类，但是可以继承多个别的接口</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      interface A extends B,C&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>接口的修饰符只能是public和默认，这点和类的修饰符相同</p></li></ol><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>代码块又称为初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p><p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[修饰符]&#123;</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//普通代码块</span></span><br><span class="line">&#123; </span><br><span class="line">  ...普通代码块</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><p>也叫：实例代码块<br>定义在类中的代码块(不加修饰符)<br><strong>构造代码块一般用于初始化实例成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">//构造代码块</span></span><br><span class="line">        name = <span class="string">&quot;花花&quot;</span>;</span><br><span class="line">        sex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造代码块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行</p><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>用 <a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>{ } 包裹起来的代码片段<br>只会执行一次，静态代码块优先于构造代码块执行，<strong>一般用于初始化静态成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">    money = <span class="number">100</span>;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是静态代码块！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/image-20220919172541150.png" alt="image-20220919172541150"></p><p><strong>静态代码块在类加载时只执行一次</strong></p><p>在类加载阶段执行，在编译阶段时，编译器会将多个静态代码块按照定义的先后次序依次合并，最终放在生成的方法中</p><p>总结：</p><ul><li>静态代码块不管生成多少个对象，其只会执行一次</li><li>静态成员变量是类的属性，因此是在JVM加载类时开辟空间并初始化的</li><li>Java代码在经过编译器编译之后，如果要运行必须先要经过类加载子系统加载到JVM中才能运行</li><li>如果一个类中包含多个静态代码块，在编译代码时，编译器会按照定义的先后次序依次合并，最终放在生成的&lt;&gt;方法中，该方法在类加载时调用，并且只调用一次</li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>使用synchronized（）{}包裹起来的代码块，在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中</p><h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol><li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且他随着类的加载而执行，并且只会执行一次，如果时普通代码块，没创建一个对象，就执行一次</p></li><li><p>什么时候被加载</p><ol><li>普通代码块，创建对象实例时（new）创建一次，调用一次</li><li>创建子类对象实例，父类也会被加载（父类先被加载，子类后被加载）</li><li>使用类的静态成员时（静态属性，静态方法）</li></ol></li><li><p>普通的代码块，在创建对象实例时，会被隐式的调用，被创建一次就会调用一次，如果只是使用类的静态成员，普通代码块不会被执行</p></li><li><p>创建一个对象时，在一个类中的调用顺序：</p><ol><li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级语音，如果有多个静态代码块，和多个静态变量初始化，则按定义的顺序调用）</li><li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级语音，如果有多个普通代码块，和多个普通变量初始化，则按定义的顺序调用）</li><li>调用构造方法</li></ol></li><li><p>构造方法（构造器）的最前面隐含了super()和调用普通代码块。静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此时优先于构造器和普通代码块执行的</p></li><li><p>创建一个子列对象时（继承关系），静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法懂得调用顺序如下：</p><ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>子类的构造方法</li></ol></li><li><p>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p></li></ol><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p>可以将一个类的定义放在里另一个类的内部，这就是内部类。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*我是一个外部类（外部是相对内部而言）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*我是一个内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><blockquote><p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》</p></blockquote><p>也就是说内部类拥有类的基本特征。(eg：可以继承父类，实现接口。)在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。（注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，这里不推荐使用。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. Outer类继承了ClassA，实现了IFunctionA</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> <span class="keyword">extends</span> <span class="title class_">ClassA</span> <span class="keyword">implements</span> <span class="title class_">IFunctionA</span>&#123; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Inner类继承了ClassB，实现了IFunctionB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> <span class="keyword">extends</span> <span class="title class_">ClassB</span> <span class="keyword">implements</span> <span class="title class_">IfunctionB</span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li><li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li><li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li></ol><p>具体来说，内部类信息（属性、方法）可以和外部类重名；内部类是具有类的基本特征的独立实体；可以利用访问修饰符隐藏内部类的实施细节，提供了更好的封装；静态内部类使用时可直接使用，不需先创造外部类。</p><h3 id="局部（方法）内部类"><a href="#局部（方法）内部类" class="headerlink" title="局部（方法）内部类"></a>局部（方法）内部类</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterType</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/** 局部内部类Inner*/</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol><li>局部内部类类似方法的局部变量，所以在类外或者类的其他方法中不能访问这个内部类，但这并不代表局部内部类的实例和定义了它的方法中的局部变量具有相同的生命周期。</li><li>只能在方法内部，类（局部内部类）定义之后使用，不存在外部可见性问题，因此没有访问修饰符，但是可以使用final 或 abstract修饰。</li><li>不能在局部内部类中使用可变的局部变量</li><li>可以访问外围类的成员变量。如果是static方法，则只能访问static修饰的成员变量</li><li>作用域：仅仅在定义他的方法或代码块中</li><li>如果外部类和局部内部类的成员重名，默认遵循就近原则，如果访问外部类的成员，使用  外部类名.this.成员 去访问</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote><p><strong>一个接口&#x2F;类的</strong>方法的<strong>某个实现方式</strong>在程序中<strong>只会执行一次</strong>，但为了使用它，我们需要创建它的实现类&#x2F;<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>去实现&#x2F;重写。此时可以使用匿名内部类的方式，可以无需创建新的类，<strong>减少代码冗余</strong></p></blockquote><p>假设当前有一个接口，接口中只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用该接口的show方法，我们需要去创建一个实现类，同时书写show方法的具体实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01Impl</span> <span class="keyword">implements</span> <span class="title class_">Interface01</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a impl class...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实现类Interface01Impl全程只使用一次，那么为了这一次的使用去创建一个类，未免太过麻烦。我们需要一个方式来帮助我们摆脱这个困境。匿名内部类则可以很好的解决这个问题。</p><p>我们使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Interface01</span> <span class="variable">interface01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interface01</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里使用了匿名内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//调用接口方法</span></span><br><span class="line">    interface01.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了匿名内部类</span></span><br></pre></td></tr></table></figure><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 接口/类名(参数<span class="number">1</span>, 参数<span class="number">2.</span>..)&#123;</span><br><span class="line">    实现方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    实现方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在上文代码编译后，我们查看一下class文件的路径</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/BxrQZd.png" alt="BxrQZd.png"></p><p>再反编译一下看看</p><p><img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/BxsW1f.png" alt="BxsW1f.png"></p><p>至此，我们可以得知，匿名内部类在编译期间，会生成一个名称以<code>$编号</code>结尾的class文件，即<strong>它被识别为一个真实的类</strong>，仅在编译前（java文件）为匿名的形态。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>设存在具体类Class01，抽象类AbstractClass01，接口Interface01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啦啦啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass01</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类TestInner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重写具体类的方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;具体类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写抽象类的抽象方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClass01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;抽象类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现接口的抽象方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Interface01</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是一个&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show(<span class="string">&quot;接口&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是一个具体类</span></span><br><span class="line"><span class="comment">//我是一个抽象类</span></span><br><span class="line"><span class="comment">//我是一个接口</span></span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><strong>成员内部类</strong> ：定义在<strong>外部类中方法外</strong>的类</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类名 [extends 外部类的父类] [implements 外部类的父接口们] &#123;</span><br><span class="line">    [修饰符] class 内部类名 [extends 非静态内部类自己的父类] [implements 非静态内部类的父接口们] &#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部类的其他成员列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://so.csdn.net/so/search?q=%E5%A4%96%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">外部类</a>、内部类的父类、父接口没有关系，各是各的</p></blockquote><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul><li>成员内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和符 号 。 例 如 ： O u t e r 符号。例如：Outer符号。例如：OuterInner.class</li><li>成员内部类可以使用修饰符public，protected，缺省，private</li><li>成员内部类还可以使用final或abstract修饰</li><li>成员内部类中不可以声明静态成员</li><li>成员内部类可以直接使用外部类的所有成员，包括私有的。如果成员内部类有与外部类的非静态属性重名时，可以通过“外部类名.this.属性”进行区别，如果与外部类的静态属性重名时，可以通过“外部类名.类变量”进行区别</li><li>外部类要访问内部类的成员，必须要建立内部类的对象</li></ul><h4 id="使用成员内部类"><a href="#使用成员内部类" class="headerlink" title="使用成员内部类"></a>使用成员内部类</h4><ul><li><p>在外部类中使用成员内部类</p><ul><li>在外部类的静态成员中不能使用非静态的成员内部类</li><li>在外部类的非静态成员中，直接创建内部类的对象来访问内部类的属性与方法。此时把它当做一个普通的类即可</li></ul></li><li><p>在外部类的外面使用成员内部类：</p><ul><li><p>要么通过外部类的对象，去创建内部类的对象</p></li><li><p>&#96;&#96;&#96;java<br>外部类名 外部对象名 &#x3D; new 外部类型();<br>内部类名 对象名 &#x3D; 外部对象名.new 外部类型();<br>&#x2F;&#x2F;可合并为：<br>外部类名.内部类名 对象名 &#x3D; new 外部类型().new 内部类型();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 要么通过外部类的对象，去获取内部类的对象</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Outer out = new Outer();</span><br><span class="line">  Outer.Inner in  = out.getInner();</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outerMethod();</span><br><span class="line"><span class="comment">//通过外部类的对象，去创建内部类的对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        oi.innerMethod();</span><br><span class="line"><span class="comment">//通过外部类的对象，去获取内部类的对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">obj</span> <span class="operator">=</span> out.getInner();</span><br><span class="line">        obj.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*Inner in = new Inner();//错误，静态成员中不能使用非静态成员内部类</span></span><br><span class="line"><span class="comment">in.innerMethod();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的方法&quot;</span>);</span><br><span class="line"><span class="comment">/*Inner in = new Inner();//可以</span></span><br><span class="line"><span class="comment">in.innerMethod();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法访问外部类的私有非静态属性：&quot;</span>+Outer.<span class="built_in">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的方法访问外部类的私有静态属性：&quot;</span>+Outer.b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过外部类的某个方法返回内部类的对象</span></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有非静态属性：1</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有静态属性：2</span></span><br><span class="line"><span class="comment">//内部类的方法</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有非静态属性：1</span></span><br><span class="line"><span class="comment">//内部类的方法访问外部类的私有静态属性：2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义在<strong>外部类中方法外</strong>，使用 <code>static</code> 修饰的类</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类名 [extends 外部类的父类] [implements 外部类的父接口们] &#123;</span><br><span class="line">[修饰符] <span class="keyword">static</span> class 内部类名 [extends 静态内部类自己的父类] [implements 静态内部类的父接口们] &#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 外部类的其他成员列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul><li>静态内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和符 号 。 例 如 ： O u t e r 符号。例如：Outer符号。例如：OuterInner.clas</li><li>静态内部类可以使用修饰符public，protected，default，private</li><li>静态内部类还可以使用final或abstract修饰</li><li>静态内部类中可以声明静态成员</li><li>静态内部类可以直接使用外部类的静态成员，包括私有的。但不能使用外部类的非静态成员。</li><li>静态内部类中有与外部类的静态属性重名时，如果要使用外部类的属性，那么用“外部类名.属性”</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ul><li>在外部类中使用静态内部类：就和使用其他普通类一样</li><li>在外部类的外面使用成员内部类：<ul><li>使用静态内部类的静态成员：外部类名.静态内部类名.静态内部类的静态成员</li><li>使用静态内部类的非静态成员：外部类名.静态内部类名 obj &#x3D; new 外部类名.静态内部类名(); obj.静态内部类的非静态成员</li></ul></li></ul><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.StaticInnerClass.innerStaticMethod();</span><br><span class="line">        Outer.<span class="type">StaticInnerClass</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInnerClass();</span><br><span class="line">        os.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        StaticInnerClass.innerStaticMethod();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        StaticInnerClass.innerStaticMethod();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">innerStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的非静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><blockquote><p><a href="http://www.java265.com/JavaCourse/202109/1153.html">一篇文章让你彻底理解Java的单例设计模式 (java265.com)</a></p></blockquote><p>   <strong>单例（<a href="https://so.csdn.net/so/search?q=Singleton&spm=1001.2101.3001.7020">Singleton</a>）模式的定义</strong>：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>   在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p><p>   单例模式有 3 个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ol><h3 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h3><p>   单例模式是<a href="http://c.biancheng.net/design_pattern/">设计模式</a>中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><p>   下面来分析其基本结构和实现方法。</p><h4 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h4><p>   单例模式的主要角色如下。</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><p>   <img src="https://raw.githubusercontent.com/Unfalll/picgo/main/img/c7c2f601aebbe257b1036cb74b93d339.gif" alt="img"></p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="(饿汉式)"></a>(饿汉式)</h4><p>   该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="(懒汉式)"></a>(懒汉式)</h4><p>   该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p><h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/2022/05/15/JavaSE/"/>
      <url>/2022/05/15/JavaSE/</url>
      
        <content type="html"><![CDATA[<h2 id="编译型、解释型"><a href="#编译型、解释型" class="headerlink" title="编译型、解释型"></a>编译型、解释型</h2><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>​            使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>​            在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>现有的C、C++、Objective等都属于编译型语言。</li></ol><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/70-164708429946416-164708454272221.png"></p><h3 id="解释性语言"><a href="#解释性语言" class="headerlink" title="解释性语言"></a>解释性语言</h3><p>​            使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>​            解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>Python等属于解释型语言</li></ol><p><img src="https://img-blog.csdn.net/20180802084124396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxODQ1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><hr><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​        JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。</p><p>​        JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</p><p>  　　JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac&#x2F;java&#x2F;jdb等）和Java基础的类库（即Java API 包括rt.jar）</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​        JRE是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。</p><p>​        JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。</p><p>  　　与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​        jvm就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><p>​        也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机（相当于中间层）间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><p>  　　只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p><p>  　　JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p><h3 id="三者之间关系"><a href="#三者之间关系" class="headerlink" title="三者之间关系"></a>三者之间关系</h3><p> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/jdkjeejvm.png">)</p><h3 id="JAVA应用程序的运行机制"><a href="#JAVA应用程序的运行机制" class="headerlink" title="JAVA应用程序的运行机制"></a>JAVA应用程序的运行机制</h3><p><img src="https://img-blog.csdnimg.cn/20190401111217837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xnbDc4MjUxOTE5Nw==,size_16,color_FFFFFF,t_70"></p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</p><h3 id="八大基本类型（primitiv-type）"><a href="#八大基本类型（primitiv-type）" class="headerlink" title="八大基本类型（primitiv  type）"></a>八大基本类型（primitiv  type）</h3><p>​        基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p><h4 id="Java的基本类型及其封装器类"><a href="#Java的基本类型及其封装器类" class="headerlink" title="Java的基本类型及其封装器类"></a>Java的基本类型及其封装器类</h4><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下：</p><ul><li>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之</li><li>short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。</li><li>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</li><li>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</li><li>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</li><li>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</li><li>boolean：只有true和false两个取值。</li><li>char：16位，存储Unicode码，用单引号赋值。</li></ul><p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。</p><table><thead><tr><th>简单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th><th>void</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td><td>–</td></tr><tr><td>封装器类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Void</td></tr></tbody></table><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p><p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p><p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p><p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p><p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p><p>注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。</p><p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p><p>基本类型的优势：数据存储相对简单，运算效率比较高</p><p>包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="自动类型转换-隐式类型转换"><a href="#自动类型转换-隐式类型转换" class="headerlink" title="自动类型转换(隐式类型转换)"></a>自动类型转换(隐式类型转换)</h4><p>整型、实型(常量)、字符型数据可以混合运算。不同类型的数据先转化为同类型再进行运算</p><p>自动转换按从低级到高级顺序:</p><pre><code>      char       ↓       Byte→short→int→long---›float→double</code></pre><p>自动转换有以下规律：</p><p>小的类型自动转化为大的类型</p><p>整数类型可以自动转化为浮点类型，可能会产生舍入误差</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ol><li>强制类型转换 将 取值范围大的类型 强制转换成 取值范围小的类型</li><li>特点 : 代码需要进行特殊的格式处理, 不能自动完成</li><li>转换格式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</span><br><span class="line">int i = (int) 1.7; // 强制转化后 i--&gt; 1</span><br></pre></td></tr></table></figure><ol start="4"><li>代码展示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntLongDoubleChange</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(getType(((<span class="type">int</span>) <span class="number">100L</span>)));  <span class="comment">// Long ---&gt; int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">100L</span>; <span class="comment">// 100L是长整型</span></span><br><span class="line">        System.out.println(getType((<span class="type">short</span>) i));  <span class="comment">//  int ---&gt; short</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object a)</span> &#123;  <span class="comment">// 获取这些数据的数据类型</span></span><br><span class="line">        <span class="keyword">return</span> a.getClass().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意事项； </p><ol><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>再把高容量转换到低容量的时候，强制转换</li><li>转换的时候可能存在内存溢出，或者精度问题</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型分为：数组，类，接口，字符串。</p><blockquote><p>数组：其实就是一个容器，存储同一种数据类型的集合；如 int[] a &#x3D; {1,2,3,4}</p><p>类：对象是对事物的抽象，而类是对对象的抽象和归纳；如 public class Person{ ……}</p><p>接口：使用interface来定义一个接口，只能定义方法，不能有方法的实现；如public interface personImpl{……}</p><p>字符串：是存放数据区（静态区）以Unicode编码的字符集合，如 String a&#x3D;”你好”</p></blockquote><p>基本类型与引用类型的区别：</p><p>（1）基本数据类型传值，对形参的修改不会影响实参；<br>（2）引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；<br>（3）String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</p><hr><h2 id="什么是标识符？"><a href="#什么是标识符？" class="headerlink" title="什么是标识符？"></a>什么是标识符？</h2><p>  凡是可以由自己命名的地方都称为标识符。<br>  例如，对于常量、变量、函数、语句块、类、项目等都需要一个名字，这些我们都统统称为标识符。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>标识符有字母、数字、_(下划线)、$所组成，其中不能以数字开头，不能用Java中的保留字（关键字）</li><li>标识符采用有意义的简单命名</li><li>“$”不要在代码中出现。（是由于在后面内部类中，编译后会出现$符号）</li></ol><ul><li>类名和接口名：每个单词的首字母，其余为小写。（大驼峰）</li><li>方法名：第二个单词起的首字母为大写，其余全为小写。（小驼峰）</li><li>常量名：基本数据类型的常量名使用全部大写字母，字与字之间用下划线分隔。</li></ul><hr><h2 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java关键字是<a href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91%E8%AF%AD%E8%A8%80">电脑语言</a>里事先定义的，有特别意义的<a href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&spm=1001.2101.3001.7020">标识符</a>，有时又叫<a href="https://baike.baidu.com/item/%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><table><thead><tr><th><a href="https://baike.baidu.com/item/abstract">abstract</a></th><th><a href="https://baike.baidu.com/item/assert"> assert</a></th><th><a href="https://baike.baidu.com/item/boolean"> boolean</a></th><th>break</th><th><a href="https://baike.baidu.com/item/byte"> byte</a></th></tr></thead><tbody><tr><td>case</td><td><a href="https://baike.baidu.com/item/catch">catch</a></td><td><a href="https://baike.baidu.com/item/char">char</a></td><td><a href="https://baike.baidu.com/item/class">class</a></td><td>const</td></tr><tr><td>continue</td><td><a href="https://baike.baidu.com/item/default">default</a></td><td><a href="https://baike.baidu.com/item/do">do</a></td><td><a href="https://baike.baidu.com/item/double">double</a></td><td><a href="https://baike.baidu.com/item/else">else</a></td></tr><tr><td><a href="https://baike.baidu.com/item/enum">enum</a></td><td><a href="https://baike.baidu.com/item/extends">extends</a></td><td><a href="https://baike.baidu.com/item/final">final</a></td><td><a href="https://baike.baidu.com/item/finally">finally</a></td><td>float</td></tr><tr><td><a href="https://baike.baidu.com/item/for">for</a></td><td>goto</td><td><a href="https://baike.baidu.com/item/if">if</a></td><td><a href="https://baike.baidu.com/item/implements">implements</a></td><td><a href="https://baike.baidu.com/item/import">import</a></td></tr><tr><td><a href="https://baike.baidu.com/item/instanceof">instanceof</a></td><td><a href="https://baike.baidu.com/item/int">int</a></td><td><a href="https://baike.baidu.com/item/interface">interface</a></td><td>long</td><td>native</td></tr><tr><td>new</td><td><a href="https://baike.baidu.com/item/package">package</a></td><td><a href="https://baike.baidu.com/item/private">private</a></td><td><a href="https://baike.baidu.com/item/protected">protected</a></td><td><a href="https://baike.baidu.com/item/public">public</a></td></tr><tr><td><a href="https://baike.baidu.com/item/return">return</a></td><td><a href="https://baike.baidu.com/item/strictfp">strictfp</a></td><td><a href="https://baike.baidu.com/item/short">short</a></td><td><a href="https://baike.baidu.com/item/static">static</a></td><td><a href="https://baike.baidu.com/item/super">super</a></td></tr><tr><td><a href="https://baike.baidu.com/item/switch">switch</a></td><td><a href="https://baike.baidu.com/item/synchronized">synchronized</a></td><td><a href="https://baike.baidu.com/item/this">this</a></td><td><a href="https://baike.baidu.com/item/throw">throw</a></td><td><a href="https://baike.baidu.com/item/throws">throws</a></td></tr><tr><td><a href="https://baike.baidu.com/item/transient">transient</a></td><td>try</td><td><a href="https://baike.baidu.com/item/void">void</a></td><td><a href="https://baike.baidu.com/item/volatile">volatile</a></td><td><a href="https://baike.baidu.com/item/while">while</a></td></tr><tr><td>true</td><td>false</td><td>null</td><td></td><td></td></tr></tbody></table><p>　另外，Java还有3个保留字:true、false、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样,它们也不可以作为标识符使用。参考<a href="https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_43">https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_43</a></p><h3 id="定义类、接口、抽象类"><a href="#定义类、接口、抽象类" class="headerlink" title="定义类、接口、抽象类"></a>定义类、接口、抽象类</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>class</td><td>声明一个类</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr></tbody></table><h3 id="用于建立类与类之间关系"><a href="#用于建立类与类之间关系" class="headerlink" title="用于建立类与类之间关系"></a>用于建立类与类之间关系</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>implements</td><td>表明一个类实现了给定的接口类</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型，常见的类型有类和接口</td></tr></tbody></table><h3 id="用于定义访问权限修饰符"><a href="#用于定义访问权限修饰符" class="headerlink" title="用于定义访问权限修饰符"></a>用于定义访问权限修饰符</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>private</td><td>私有权限，修饰的属性和方法仅供本类引用</td></tr><tr><td>protected</td><td>保护权限，保护子类，当前包内和继承的子类中可以引用</td></tr><tr><td>default</td><td>默认模式，不写任何访问修饰权限，本包内可以使用</td></tr><tr><td>public</td><td>公用模式，可跨包使用，凡是环境下的类和方法都可以使用，需导入包</td></tr></tbody></table><h3 id="用于定义建立实例及引用实例、判断实例"><a href="#用于定义建立实例及引用实例、判断实例" class="headerlink" title="用于定义建立实例及引用实例、判断实例"></a>用于定义建立实例及引用实例、判断实例</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>用来创建新的实例对象</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr></tbody></table><h3 id="用于定义类、函数、变量修饰符"><a href="#用于定义类、函数、变量修饰符" class="headerlink" title="用于定义类、函数、变量修饰符"></a>用于定义类、函数、变量修饰符</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>final</td><td>终结器，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td></tr><tr><td>static</td><td>表示具有静态属性</td></tr><tr><td>synchronized</td><td>线程同步，修饰一段代码表示多个线程都能同步执行</td></tr><tr><td>volatile</td><td>意识，表明两个或者多个变量必须同步地发生变化</td></tr><tr><td>native</td><td>本地用来声明一个方法是由计算机相关语言实现的(如C&#x2F;C++语言等)</td></tr></tbody></table><h3 id="用于异常处理"><a href="#用于异常处理" class="headerlink" title="用于异常处理"></a>用于异常处理</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>finally</td><td>用于异常处理情况，用来声明一个基本肯定会被执行到的语句块（有没有异常都执行）</td></tr><tr><td>throw</td><td>通常用在方法体中，并且抛出一个异常对象，程序在执行到throw语句时立即停止，它后面的语句都不执行</td></tr><tr><td>throws</td><td>如果一个方法可以引发异常，本身不对异常进行处理，将异常抛给调用者使程序可以继续执行下去</td></tr></tbody></table><h3 id="用于包的关键字"><a href="#用于包的关键字" class="headerlink" title="用于包的关键字"></a>用于包的关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>import</td><td>导入这个类所存在的包</td></tr><tr><td>package</td><td>定义包的关键字，将有关类放在一个包中</td></tr></tbody></table><h3 id="其他修饰符关键字"><a href="#其他修饰符关键字" class="headerlink" title="其他修饰符关键字"></a>其他修饰符关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>assert</td><td>断言，用来进行程序调试</td></tr></tbody></table><hr><h2 id="变量、常量"><a href="#变量、常量" class="headerlink" title="变量、常量"></a>变量、常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>变量</strong>是可以变化的量<br><strong>java</strong>是一种强类型语言，每个变量都必须声明其类型。<br><strong>java</strong>变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><h4 id="变量可分为：成员变量、局部变量、静态变量"><a href="#变量可分为：成员变量、局部变量、静态变量" class="headerlink" title="变量可分为：成员变量、局部变量、静态变量"></a>变量可分为：成员变量、局部变量、静态变量</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>在某个方法外部，类内部定义的变量，从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型默认的初始值。部分变量的默认初始值如下表所示</p><table><thead><tr><th>数据类型</th><th>初始值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVariable</span>&#123;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//成员变量，会自动初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">TestVariable</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestVariable</span>();</span><br><span class="line">        System.out.println(test.a);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量是方法或语句块内部定义的变量，其<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>是从声明位置开始到方法或语句块执行完毕为止。局部变量在使用前必须先声明并初始化（赋值），否则会出错。<br>局部变量的初始化有两种方式，一种是先定义再初始化，代码中方式一所示，另外一种是定义的同时进行初始化，如方式二所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">age=<span class="number">18</span>;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">int</span> weight=<span class="number">50</span>;</span><br><span class="line"><span class="comment">//错误赋值示例！！！注意这样写是错误的，不要模仿！！！！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">height</span>&#123;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line">height=<span class="number">180</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量使用static定义，从属于类，声明周期伴随类始终，从类加载时产生，类卸载时结束。如果不进行初始化，与成员变量一样，会自行初始化成该类型的默认初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> a;<span class="comment">//静态变量，会自动初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>每个变量都有类型，类型可以是基本类型，也可以是引用类型。<br>变量名必须是合法的标识符。<br>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span>&#123;     </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">       <span class="comment">// int a,b,c;</span></span><br><span class="line">       <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">       String name=<span class="string">&quot;ZDJ&quot;</span>;</span><br><span class="line">       <span class="type">char</span> x=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">       <span class="type">double</span> pi=<span class="number">3.14</span>;     </span><br><span class="line">       <span class="comment">//定义变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h4><p><a href="https://www.bilibili.com/video/BV12J41137hu?p=26">狂神说java</a></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/b743599935054ed5b26cf550604d5cb6.png" alt="在这里插入图片描述"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>常量定义：在程序执行的过程中，其值不可以发生改变的量。常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义。</li><li>常量值定义：常量和常量值是不同的概念，常量值又称为字面常量，它是通过数据直接表示的。</li><li>关系：常量值是常量的具体和直观的表现形式，常量是形式化的表现。通常在程序中既可以直接使用常量值，也可以使用常量。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>字符串常量 用双引号括起来的内容(“HelloWorld”)</li><li>整数常量 所有整数(12,-23)</li><li>小数常量 所有小数(12.34)</li><li>字符常量 用单引号括起来的内容(‘a’,’A’,’0’)</li><li>布尔常量 较为特有，只有true和false</li><li>空常量 null</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>Java 语言使用 final 关键字来定义一个常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> COUNT=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> HEIGHT=<span class="number">10.2F</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>在定义常量时就需要对该常量进行初始化。</li><li>final 关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</li><li>为了与变量区别，常量取名一般都用大写字符。</li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>求和</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>乘积</td></tr><tr><td>&#x2F;</td><td>商</td></tr><tr><td>%</td><td>求余数（求模）</td></tr><tr><td>++</td><td>自加一</td></tr><tr><td>–</td><td>自减一</td></tr></tbody></table><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="++运算符"></a>++运算符</h4><ul><li>++在变量前</li><li>当++出现在变量前，会先自加一，在做赋值运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ++x;</span><br><span class="line">步骤： ② ①</span><br><span class="line">System.out.println(x); <span class="comment">// 101</span></span><br><span class="line">System.out.println(y); <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><ul><li>++在变量后</li><li>当++出现在变量后，会先做赋值运算，再自加1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m++;</span><br><span class="line">步骤： ① ②</span><br><span class="line">System.out.println(n); <span class="comment">// 20</span></span><br><span class="line">System.out.println(m); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><ul><li>特别地，在print中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">System.out.println(c++);  <span class="comment">// 传，这个“传”在这里有一个隐形的赋值运算。90</span></span><br><span class="line"><span class="comment">// 把上面代码拆解开</span></span><br><span class="line"><span class="comment">//int temp = c++;</span></span><br><span class="line"><span class="comment">//System.out.println(temp);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">System.out.println(++d); <span class="comment">//81</span></span><br><span class="line"><span class="comment">// 拆解</span></span><br><span class="line"><span class="comment">//int temp2 = ++d;</span></span><br><span class="line"><span class="comment">//System.out.println(temp2);</span></span><br></pre></td></tr></table></figure><h4 id="–运算符（例子同-运算符）"><a href="#–运算符（例子同-运算符）" class="headerlink" title="–运算符（例子同++运算符）"></a>–运算符（例子同++运算符）</h4><ul><li><p>–在变量前</p><ul><li><strong>当–出现在变量前，会先自减一，在做赋值运算</strong></li></ul></li><li><p>–在变量后</p><ul><li><strong>当–出现在变量后，会先做赋值运算，再自减1</strong></li></ul></li></ul><blockquote><p>注意:<br>对于++运算符来说：<br>  1.可以出现在变量前，也可以出现在变量后。<br>  2.不管出现在变量前还是后，总之++执行结束之后，变量的值一定会自加1。</p></blockquote><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr></tbody></table><blockquote><p><em><strong>注意</strong></em>：所有的关系运算符的运算结果都是布尔类型，不是true就是false，不可能是其他值。</p></blockquote><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>＆</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr><tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr><tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr><tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td></tr><tr><td>+&#x3D;</td><td>加等（原先的基础上加上&#x2F;追加这个数）</td></tr><tr><td>-&#x3D;</td><td>减等（同理）</td></tr><tr><td>*&#x3D;</td><td>乘等（同理）</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等（同理）</td></tr><tr><td>%&#x3D;</td><td>模等（同理）</td></tr></tbody></table><blockquote><p>注：除了第一个是赋值运算符，其他都死拓展赋值运算符！！</p></blockquote><h4 id="很重要的语法机制："><a href="#很重要的语法机制：" class="headerlink" title="很重要的语法机制："></a>很重要的语法机制：</h4><p>使用扩展赋值运算符的时候，永远都不会改变运算结果类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">m += <span class="number">10</span>; 类似于 m = m + <span class="number">10</span>;-------&gt;注意是类似！！！！</span><br><span class="line"></span><br><span class="line">实际不同：</span><br><span class="line">i = i + <span class="number">10</span>; 和 i += <span class="number">10</span>;一样吗？</span><br><span class="line"><span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">i += <span class="number">10</span>;-----&gt;没报错</span><br><span class="line">其实 x += <span class="number">1</span> 等同于：x = (<span class="type">byte</span>)(x + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">i = i + <span class="number">10</span>;----&gt;错误: 不兼容的类型: 从<span class="type">int</span>转换到<span class="type">byte</span>可能会有损失</span><br><span class="line">编译器检测到x + <span class="number">1</span>是<span class="type">int</span>类型，<span class="type">int</span>类型不可以直接赋值给<span class="type">byte</span>类型的变量x！</span><br><span class="line">详见Java类型转换的时候需要遵循的规则第六点</span><br><span class="line"></span><br><span class="line">i += <span class="number">190</span>; <span class="comment">// i = (byte)(i + 190);</span></span><br><span class="line">System.out.println(i); <span class="comment">// 44 （当然会自动损失精度了。）</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>含义</th><th>结果</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与（可以翻译成并且）</td><td>两边都是true，结果才是true</td></tr><tr><td>│</td><td>逻辑或（可以翻译成或者）</td><td>有一边是true，结果就是true</td></tr><tr><td>!</td><td>逻辑非（取反）</td><td>!true &#x3D; false、!false &#x3D; true</td></tr><tr><td>&amp;&amp;</td><td>短路与</td><td>两边都是true，结果才是true</td></tr><tr><td>││</td><td>短路或</td><td>有一边是true，结果就是true</td></tr></tbody></table><h4 id="短路与-amp-amp"><a href="#短路与-amp-amp" class="headerlink" title="短路与 &amp;&amp;"></a>短路与 &amp;&amp;</h4><ul><li>短路与&amp;&amp; 和 逻辑与 &amp;有什么区别？<ul><li>首先这两个运算符的运算结果没有任何区别，完全相同。</li><li>只不过“短路与&amp;&amp;”会发生短路现象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">System.out.println(x &gt; y &amp; x &gt; y++); <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路与&amp;&amp;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路与&amp;&amp;的时候，当左边的表达式为false的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &gt; n &amp;&amp; m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><ul><li><p>什么是短路现象呢？</p><ul><li>右边表达式不执行，这种现象叫做短路现象。</li></ul></li><li><p>什么时候使用&amp;&amp;，什么时候使用&amp; ？</p><ul><li>从效率方面来说，&amp;&amp;比&amp;的效率高一些。</li><li>因为逻辑与&amp;不管第一个表达式结果是什么，第二个表达式一定会执行。</li></ul></li></ul><p>以后的开发中，短路与&amp;&amp;和逻辑与还是需要同时并存的。<br>大部分情况下都建议使用短路与&amp;&amp;只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&amp;。</p><h4 id="短路或"><a href="#短路或" class="headerlink" title="短路或 ||"></a>短路或 ||</h4><h4 id="跟短路与类似"><a href="#跟短路与类似" class="headerlink" title="跟短路与类似"></a>跟短路与类似</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">System.out.println(x &lt; y | x &gt; y++); <span class="comment">//teur</span></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路或||</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路或||的时候，当左边的表达式为true的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &lt; n || m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>使用短路与 &amp;&amp; 的时候，当左边的表达式为false的时候，右边的表达式不执行    </li><li>使用短路或 || 的时候当左边的表达式结果是true的时候，右边的表达式不执行</li><li>注意：逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。</li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><h4 id="语法格式：（三目运算符。）"><a href="#语法格式：（三目运算符。）" class="headerlink" title="语法格式：（三目运算符。）"></a>语法格式：（三目运算符。）</h4><ul><li>布尔表达式 ? 表达式1 : 表达式2</li></ul><h4 id="执行原理是什么？"><a href="#执行原理是什么？" class="headerlink" title="执行原理是什么？"></a>执行原理是什么？</h4><ul><li>布尔表达式的结果为true时，表达式1的执行结果作为整个表达式的结果。</li><li>布尔表达式的结果为false时，表达式2的执行结果作为整个表达式的结果。</li></ul><h4 id="好玩点："><a href="#好玩点：" class="headerlink" title="好玩点："></a>好玩点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br><span class="line">以上两个都报错。</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面可以</span></span><br><span class="line"> <span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> s += <span class="literal">true</span> ? <span class="string">&#x27;男&#x27;</span> : <span class="string">&quot;女&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符(+)"></a>字符串连接运算符(+)</h3><h4 id="运算符在java语言中有两个作用。"><a href="#运算符在java语言中有两个作用。" class="headerlink" title="+运算符在java语言中有两个作用。"></a>+运算符在java语言中有两个作用。</h4><ul><li><p>作用1：求和</p></li><li><p>作用2：字符串拼接</p></li></ul><h4 id="什么时候求和？什么时候进行字符串的拼接呢？"><a href="#什么时候求和？什么时候进行字符串的拼接呢？" class="headerlink" title="什么时候求和？什么时候进行字符串的拼接呢？"></a>什么时候求和？什么时候进行字符串的拼接呢？</h4><ul><li><p>当 + 运算符两边都是数字类型的时候，求和。</p></li><li><p>当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。</p></li></ul><h4 id="一定要记住：字符串拼接完之后的结果还是一个字符串。"><a href="#一定要记住：字符串拼接完之后的结果还是一个字符串。" class="headerlink" title="一定要记住：字符串拼接完之后的结果还是一个字符串。"></a>一定要记住：字符串拼接完之后的结果还是一个字符串。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 这里的 + 两边都是数字，所以加法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span>  + a + b);<span class="comment">//100+200=100200</span></span><br><span class="line">System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span>  + (a + b));<span class="comment">//100+200=300</span></span><br></pre></td></tr></table></figure><blockquote><p>注：遵循“自左向右”的顺序依次执行。（除非额外添加了小括号，小括号的优先级高）</p></blockquote><hr><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><blockquote><ul><li>Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</li><li>顺序结构是最简单的算法结构。</li><li><strong>顺序结构是任何一个算法都离不开的一种基本算法结构。</strong></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501213059243.png" alt="image-20220501213059243"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;到&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;依&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if单选择机构"><a href="#if单选择机构" class="headerlink" title="if单选择机构"></a>if单选择机构</h3><blockquote><ul><li>if语句的执行步骤<ul><li>对条件进行判断</li><li>判断条件为true，则执行代码块</li><li>判断条件为false，则跳过该语句</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501213713847.png" alt="image-20220501213713847"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h3><blockquote><ul><li>if-else的执行语句<ul><li>对条件进行判断</li><li>如果条件为true，则执行代码1</li><li>如果条件为false，则执行代码2</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501214013036.png" alt="image-20220501214013036"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h3><p>在if-else if-else语句中，if以及多个else-if后面的一对（）内的表达式的值必须为boolean类型。程序执行该语句时按照语句中表达式的顺序，首先计算表达式1的值，如果结果为true则执行紧跟着的复合语句，结束当前该语句的执行。如果结果为false则继续执行表达式2的值，以此类推，假设第M个表达式的值为true则执行跟着的复合语句，结束当前语句的执行，否则执行第M+1个表达式的值，如果所有的表达式的值都为false则执行关键字else后面的复合语句，结束当前语句的执行。</p><blockquote><p>执行流程：</p><ul><li>表达式1为true，则执行代码块1，再退出整个结构。</li><li>表达式2为true，则执行代码块2，再退出整个结构。</li><li>表达式3为true，则执行代码块3，再退出整个结构。</li><li>以上均为false，则执行代码块4，再退出整个结构。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>) &#123;</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (<span class="keyword">if</span>表达式<span class="number">2</span>)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (<span class="keyword">if</span>表达式<span class="number">3</span>)&#123;</span><br><span class="line">语句块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">else</span>(条件表达式n)&#123;</span><br><span class="line">语句块n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501214837908.png" alt="image-20220501214837908"></p><h3 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的if语句</h3><p>很多问题是一次简单的选择判断结构所解决不了的，需要进行多次选择判断，嵌套的if语句便是其中的一种解决方法。嵌套的if语句是一种多重选择结构。多重选择结构，顾名思义，就是有多种选择可以经过多次判断的结构。</p><blockquote><p>执行流程：</p><ul><li>当外层条件满足时，再判断内层条件。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">2</span>) &#123;</span><br><span class="line">语句 <span class="number">1</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">语句 <span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">3</span>) &#123;</span><br><span class="line">语句 <span class="number">3</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">语句 <span class="number">4</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501215733141.png" alt="image-20220501215733141"></p><h3 id="Switch选择语句"><a href="#Switch选择语句" class="headerlink" title="Switch选择语句"></a>Switch选择语句</h3><blockquote><p>switch语句和if的区别在于，switch只能进行等值判断，其限制较大</p></blockquote><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220501222540416.png" alt="image-20220501222540416"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">1</span>：</span><br><span class="line">语句块 <span class="number">1</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">2</span>：</span><br><span class="line">语句块 <span class="number">2</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">3</span>：</span><br><span class="line">语句块 <span class="number">3</span>；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line"><span class="keyword">case</span> 常量值n:</span><br><span class="line">语句块 n；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">default</span>：</span><br><span class="line">语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">while</span>( 布尔表达式 )&#123;</span><br><span class="line"><span class="comment">//循环结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>只要布尔表达式为true，循环就会一直执行下去。</p></li><li><p>我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。</p></li><li><p>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</p></li><li><p>循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或造成程序卡死崩溃</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//计算1+2+3+4+...+100=?</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><ul><li><p>对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p></li><li><p>do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (a&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="while和do…while的区别："><a href="#while和do…while的区别：" class="headerlink" title="while和do…while的区别："></a>while和do…while的区别：</h3><ul><li>while先判断后执行。dowhile是先执行后判断！</li><li>do…while总是保证循环体会被至少执行一次！这是他们的主要差别。</li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul><li>虽然所有循环结构都可以使用while或者do…while表示，但Java提供了另一种语句—for循环，使一些循环结构变得更加简单。</li><li>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</li><li>for循环执行的次数是在执行前就确定的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//初始化条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(a&lt;=<span class="number">100</span>)&#123;<span class="comment">//条件判断</span></span><br><span class="line">            System.out.println(a);<span class="comment">//循环体</span></span><br><span class="line">            a+=<span class="number">2</span>;<span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;while循环结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;for循环结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        关于for循环有以下几点说明：</span></span><br><span class="line"><span class="comment">        最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</span></span><br><span class="line"><span class="comment">        然后检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</span></span><br><span class="line"><span class="comment">        执行一次循环后，更新循环控制变量（迭代因子控制循环变量的增减）。</span></span><br><span class="line"><span class="comment">        再次检测布尔表达式。循环执行上面的过程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">for</span> ( ; ;)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(声明语句 : 表达式 )&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句快，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;; <span class="comment">//定义了一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123; </span><br><span class="line">            System.out.println(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历数组的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:numbers)&#123;<span class="comment">//增强for循环</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="breal、continue、return"><a href="#breal、continue、return" class="headerlink" title="breal、continue、return"></a>breal、continue、return</h2><h3 id="break和continue的作用和区别"><a href="#break和continue的作用和区别" class="headerlink" title="break和continue的作用和区别"></a>break和continue的作用和区别</h3><h4 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h4><p>break和continue都是用来控制循环结构的，主要作用是停止循环。</p><h4 id="break和continue的区别"><a href="#break和continue的区别" class="headerlink" title="break和continue的区别"></a>break和continue的区别</h4><p>1、break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。</p><p><strong>注意</strong>：</p><ul><li>只能在循环体内和switch语句体内使用break。</li><li>不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。</li><li>当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。</li></ul><p>2、continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。</p><p><strong>注意</strong>：</p><ul><li>continue语句并没有使整个循环终止。</li><li>continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。</li></ul><h4 id="break、return、continue的区别"><a href="#break、return、continue的区别" class="headerlink" title="break、return、continue的区别"></a>break、return、continue的区别</h4><p>break用于完全结束一个循环，跳出循环体。不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。 break不仅可以结束其所在的循环，还可结束其外层循环。此时需要在break后紧跟一个标签，这个标签用于标识一个外层循环。Java中的标签就是一个紧跟着英文冒号（:）的标识符。且它必须放在循环语句之前才有作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakTest2</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// 外层循环，outer作为标识符</span></span><br><span class="line">　　　　outer:</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line">　　　　　　<span class="comment">// 内层循环</span></span><br><span class="line">　　　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span> ; j++ )&#123;</span><br><span class="line">　　　　　　　　System.out.println(<span class="string">&quot;i的值为:&quot;</span> + i + <span class="string">&quot; j的值为:&quot;</span> + j);</span><br><span class="line">　　　　　　　　<span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　　　<span class="comment">// 跳出outer标签所标识的循环。</span></span><br><span class="line">　　　　　　　　　　　<span class="keyword">break</span> outer;</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>continue的功能和break有点类似，区别是continue只是中止本次循环，接着开始下一次循环。而break则是完全中止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinueTest</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">// 一个简单的for循环</span></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">&quot;i的值是&quot;</span> + i);</span><br><span class="line">　　　　　　　<span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　　<span class="comment">// 忽略本次循环的剩下语句</span></span><br><span class="line">　　　　　　　　　<span class="keyword">continue</span>;</span><br><span class="line">　　　　　　　&#125;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">&quot;continue后的输出语句&quot;</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return关键字并不是专门用于跳出循环的，return的功能是结束一个方法。 一旦在循环体内执行到一个return语句，return语句将会结束该方法，循环自然也随之结束。与continue和break不同的是，return直接结束整个方法，不管这个return处于多少层循环之内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnTest</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// 一个简单的for循环</span></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;i的值是&quot;</span> + i);</span><br><span class="line">　　　　　　<span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;return后的输出语句&quot;</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归，就是在运行的过程中调用自己。"><a href="#递归，就是在运行的过程中调用自己。" class="headerlink" title="递归，就是在运行的过程中调用自己。"></a><strong>递归，就是在运行的过程中调用自己。</strong></h3><p>递归结构包含两个部分：</p><ul><li><strong>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环</strong></li><li><strong>递归体：什么时候需要调用自身方法</strong></li></ul><p>构成递归需具备的条件：<br><strong>1. 子问题须与原始问题为同样的事，且更为简单；</strong><br><strong>2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。</strong></p><h3 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h3><p>我们知道递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方，也就是下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(参数<span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recursion(参数<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>对递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处。</p><p><strong>阶乘</strong></p><p>一个最简单的递归调用-阶乘，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">System.out.println( f(<span class="number">5</span>) );</span><br><span class="line"><span class="comment">//结果：120</span></span><br></pre></td></tr></table></figure><p>第2-3行是终止条件，第5行是调用自己。就用n等于5的时候来画个图看一下递归究竟是怎么调用的</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220513152851533.png" alt="image-20220513152851533"></p><p>这种递归还是很简单的，我们求f(5)的时候，只需要求出f(4)即可，如果求f(4)我们要求出f(3)……，一层一层的调用，当n&#x3D;1的时候，我们直接返回1，然后再一层一层的返回，直到返回f(5)为止。</p><p>递归的目的是把一个大的问题细分为更小的子问题，我们只需要知道递归函数的功能即可，不要把递归一层一层的拆开来想，如果同时调用多次的话这样你很可能会陷入循环而出不来。比如上面的题中要求f(5)，我们只需要计算f(4)即可，即f(5)&#x3D;5*f(4)；至于f(4)是怎么计算的，我们就不要管了。因为我们知道f(n)中的n可以代表任何正整数，我们只需要传入4就可以计算f(4)。</p><p>递归规则</p><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量是独立的，不会相互影响比如n变量</li><li>如果方法中使用的是引用类型的变量（比如数组，对象）就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无线递归，出现（StackOverflowError，死归）</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。</strong></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>其长度是确定的，数组一旦被创建，它的大小就是不可以改变的</li><li>其元素必须是相同类型的，不允许出现混合类型</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型</li><li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量，</li></ul><p>数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，都是可以的</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>数组的两种常见初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>格式：</p><blockquote><p>数组存储的数据类型[ ] 数组名字 &#x3D; new 数组存储的数据类型[数组长度];<br>数组存储的数据类型 数组名字[ ] &#x3D; new 数组存储的数据类型[数组长度];</p></blockquote><ul><li><p>数组定义格式详解：</p></li><li><p>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</p></li><li><p>[] : 表示数组。</p></li><li><p>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</p></li><li><p>new：关键字，创建数组使用的关键字。</p></li><li><p>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</p></li><li><p>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</p></li><li><p>注意：数组有定长特性，长度一旦指定，不可更改。</p></li></ul><p>和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。<br>举例:<br>定义可以存储3个整数的数组容器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];  </span><br><span class="line"><span class="type">int</span>   arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 可以拆分 </span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><ul><li>格式：</li></ul><blockquote><p>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,元素3…};</p></blockquote><ul><li>举例： 定义存储1，2，3，4，5整数的数组容器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">// 可以拆分 </span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="静态初始化省略格式（不能拆分）"><a href="#静态初始化省略格式（不能拆分）" class="headerlink" title="静态初始化省略格式（不能拆分）"></a>静态初始化省略格式（不能拆分）</h4><ul><li>格式：</li></ul><blockquote><p>数据类型[] 数组名 &#x3D; {元素1,元素2,元素3…};</p></blockquote><ul><li>举例：</li></ul><p>定义存储1，2，3，4，5整数的数组容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><ul><li><p>索引：  每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。</p></li><li><p>格式：</p><blockquote><p>数组名[索引]</p></blockquote></li><li><p>数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数组的最大索引值为数组名.length-1。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">  System.out.println(arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>索引访问数组中的元素：</p><blockquote><p>数组名[索引] &#x3D; 数值，为数组中的元素赋值<br>变量 &#x3D; 数组名[索引]，获取出数组中的元素</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5 </span></span><br><span class="line"> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="comment">//为0索引元素赋值为6 </span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">6</span>; </span><br><span class="line">  <span class="comment">//获取数组0索引上的元素 </span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr[<span class="number">0</span>]; </span><br><span class="line">  System.out.println(i); </span><br><span class="line">  <span class="comment">//直接输出数组0索引元素 </span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组初始化</p><p>同一维数组一样，共有4总不同形式的定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> array2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> array3[][] = &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="type">int</span> array4[][] = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;&#125;;</span><br></pre></td></tr></table></figure><p>不定长二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">array[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>获取二维数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">// 获取二维数组的第一维长度（3）</span></span><br><span class="line">System.out.println(length1);</span><br><span class="line"><span class="comment">// 获取二维数组的第一维的第一个数组长度（1）</span></span><br><span class="line">System.out.println(length2);</span><br></pre></td></tr></table></figure><p>遍历打印二位数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = &#123; &#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">         System.out.print( array[i][j] );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>Sparse Array 稀疏数组。</p><h4 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h4><p>先来看一个实际需求，比较好思考</p><p>编写五子棋程序中的 <strong>存盘退出</strong> 和 <strong>续上盘</strong> 功能</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703215903031.8ffc1996.png" alt="image-20200703215903031"></p><p>我们首先能想到的就是使用一个 <strong>二维数组</strong>，如上图所示：</p><ul><li>0：表示没有棋子</li><li>1：表示黑棋</li><li>2：表示白棋</li></ul><h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>可以看到二维数组中很多值都是 0，因此记录了很多没有意义的数据。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>定义：当一个数组中 <strong>大部分元素为 0（或是同一个值）</strong> 时，可以使用 <strong>稀疏数组</strong> 来保存该数组</p><p>处理方法：</p><ol><li>记录数组一共有 <strong>几行几列</strong>，<strong>有多少个不同的值</strong></li><li>把具有 <strong>不同值的元素</strong> 的 <strong>行列及值</strong> 记录在一个 <strong>小规模的数组</strong> 中，从而缩小程序的规模</li></ol><p>这个小规模的数组就称为 <strong>稀疏数组</strong>，举个例子，如下图</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703221437344.19a0a264.png" alt="image-20200703221437344"></p><p>左侧是原始的二维数组 <code>6x7 = 42 个格子</code>，右侧是稀疏数组 <code>9 x 3 = 27 个格子</code></p><ul><li><p><code>[0]</code>：记录了棋盘的大小，6 行 7 列，棋盘上有 8 个不为 0 的值</p></li><li><p>其他行：分别记录每一个非 0 值的所在行、所在列、值</p><p>比如 <code>[1]</code>：在第 0 行第 3 列上有一个 22（这里的行列都是下标）</p></li></ul><p>可以看到原始 42 个数据，压缩成 27 个数据。一定程度上压缩了数据。</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>使用 <strong>稀疏数组</strong> 保留类似前面的 <strong>二维数组</strong>（如棋盘、地图等等的场景），把 <strong>稀疏数组存盘</strong>，并且可以从新 <strong>恢复原来的二维数组</strong></p><p>####稀疏数组与二维数组互转思路</p><p>以前面的棋盘数据来讲解</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20200703223528941.02cbe7fb.png" alt="image-20200703223528941"></p><p>如上图，总结出来稀疏数组为右侧那样。那么他们互转思路如下：</p><p>二维数组转稀疏数组思路：</p><ol><li>遍历原始的二维数组，得到有效个数 sum</li><li>根据 sum 创建 <strong>稀疏数组</strong> <code>sparseArr = int[sum + 1][3]</code></li><li>将二维数据的有效数据存入到稀疏数组中（从第 2 行开始存储）</li><li>最后将棋盘大小和有效个数写入第一行</li></ol><p>稀疏数组转原始二维数组思路：</p><ol><li>读取第一行数据，根据棋盘大小，创建原始的二维数组 <code>chessArr = int [11][11]</code></li><li>从第二行开始，将有效数据还原到原始数组中</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrcode.study.dsalgtutorialdemo.datastructure.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  稀疏数组：</span></span><br><span class="line"><span class="comment"> *      1. 二维数组转稀疏数组</span></span><br><span class="line"><span class="comment"> *      2. 稀疏数组转二维数组</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原始二维数组</span></span><br><span class="line">        <span class="comment">// 0：没有棋子，1：黑棋，2：白棋</span></span><br><span class="line">        <span class="comment">// 棋盘大小 11 x 11</span></span><br><span class="line">        <span class="type">int</span> chessArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 预览棋盘上的棋子位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;预览原始数组&quot;</span>);</span><br><span class="line">        printChessArray(chessArr);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 二维数组转稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = chessToSparse(chessArr);</span><br><span class="line"><span class="comment">// int[][] sparseArr = chessToSparse2(chessArr); // 紧凑版本可以参考笔记配套项目</span></span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组转稀疏数组&quot;</span>);</span><br><span class="line">        printChessArray(sparseArr);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 稀疏数组转二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr2 = sparseToChess(sparseArr);</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组转二维数组&quot;</span>);</span><br><span class="line">        printChessArray(chessArr2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二维数组转稀疏数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] chessToSparse(<span class="type">int</span>[][] chessArr) &#123;</span><br><span class="line">        <span class="comment">// 1. 遍历数组得到有效棋子个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> chess : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chess != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 3. 将二维数据的有效数据存入到稀疏数组中（从第 2 行开始存储）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chessRow</span> <span class="operator">=</span> chessArr.length;  <span class="comment">// 行： 棋盘大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chessCol</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 列： 棋盘大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前是第几个非 0 的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rows = chessArr[i];</span><br><span class="line">            <span class="keyword">if</span> (chessCol == <span class="number">0</span>) &#123;</span><br><span class="line">                chessCol = rows.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; rows.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">chess</span> <span class="operator">=</span> rows[j];</span><br><span class="line">                <span class="keyword">if</span> (chess == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;  <span class="comment">// 第一行是棋盘信息，所以先自增</span></span><br><span class="line">                sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                sparseArr[count][<span class="number">2</span>] = chess;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 补全第一行的棋盘大小和有效数据</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = chessRow;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = chessCol;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="keyword">return</span> sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 稀疏数组转二维数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sparseArr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] sparseToChess(<span class="type">int</span>[][] sparseArr) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 2. 恢复有效数据到二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rows = sparseArr[i];</span><br><span class="line">            chessArr[rows[<span class="number">0</span>]][rows[<span class="number">1</span>]] = rows[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chessArr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印棋盘上的棋子布局</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printChessArray</span><span class="params">(<span class="type">int</span>[][] chessArr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                <span class="comment">// 左对齐，使用两个空格补齐 2 位数</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%-2d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">预览原始数组</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">二维数组转稀疏数组</span><br><span class="line"><span class="number">11</span><span class="number">11</span><span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line">稀疏数组转二维数组</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="八大排序"><a href="#八大排序" class="headerlink" title="八大排序"></a>八大排序</h2><hr><h2 id="栈、堆"><a href="#栈、堆" class="headerlink" title="栈、堆"></a>栈、堆</h2><p>Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a><strong>栈内存</strong></h3><p>栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a><strong>堆内存</strong></h3><p>存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p><p>主函数里的语句   int [] arr&#x3D;new int [3];在内存中是怎么被定义的：</p><p>主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220514173855512.png" alt="image-20220514173855512"></p><h3 id="堆和栈是怎么联系起来的呢"><a href="#堆和栈是怎么联系起来的呢" class="headerlink" title="堆和栈是怎么联系起来的呢?"></a>堆和栈是怎么联系起来的呢?</h3><p> 给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。</p><p>如果当<strong>int [] arr&#x3D;null;</strong></p><p> arr不做任何指向，null的作用就是取消引用数据类型的指向。、</p><p> 当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。<br>  所以堆与栈的区别很明显：</p><ol><li>栈内存存储的是局部变量而堆内存存储的是实体</li><li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li></ol><hr><h2 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h2><p>javadoc是Sun公司提供的一个技术，它从程序<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969">源代码</a>中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。</p><p>javadoc命令是用来生成自己<a href="https://baike.baidu.com/item/API/10154">API</a>文档的，使用方式：使用命令行在目标文件所在目录输入javadoc +文件名.java。</p><table><thead><tr><th>标签</th><th>说明</th><th>JDK 1.1 doclet</th><th>标准doclet</th><th>标签类型</th></tr></thead><tbody><tr><td>@author 作者</td><td>作者标识</td><td>√</td><td>√</td><td>包、 类、接口</td></tr><tr><td>@version 版本号</td><td>版本号</td><td>√</td><td>√</td><td>包、 类、接口</td></tr><tr><td>@param 参数名 描述</td><td>方法的入参名及描述信息，如入参有特别要求，可在此注释。</td><td>√</td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@return 描述</td><td>对函数返回值的注释</td><td>√</td><td>√</td><td>方法</td></tr><tr><td>@deprecated 过期文本</td><td>标识随着程序版本的提升，当前API已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个API。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>@throws异常类名</td><td>构造函数或方法所会抛出的异常。</td><td></td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@exception 异常类名</td><td>同@throws。</td><td>√</td><td>√</td><td>构造函数、 方法</td></tr><tr><td>@see 引用</td><td>查看相关内容，如类、方法、变量等。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>@since 描述文本</td><td>API在什么程序的什么版本后开发支持。</td><td>√</td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>{@link包.类#成员 标签}</td><td>链接到某个特定的成员对应的文档中。</td><td></td><td>√</td><td>包、类、接口、值域、构造函数、 方法</td></tr><tr><td>{@value}</td><td>当对常量进行注释时，如果想将其值包含在文档中，则通过该标签来引用常量的值。</td><td></td><td>√(JDK1.4)</td><td>静态值域</td></tr></tbody></table><p>此外还有@serial、@serialField、@serialData、{@docRoot}、{@inheritDoc}、{@literal}、{@code} {@value arg}几个不常用的标签，由于不常使用，我们不展开叙述，感兴趣的读者可以查看帮助文档。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序</title>
      <link href="/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/big-o.png" alt="img"></a></p><ul><li>直接插入排序</li><li>希尔排序</li><li>简单选择排序</li><li>堆排序</li><li>冒泡排序</li><li>快速排序</li><li>归并排序</li><li>基数排序</li></ul><p>这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms">Github：<strong>SortAlgorithms</strong></a>，其中也包括了排序测试模块[<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java">Test.java]</a>和排序算法对比模块[<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java">Bench.java]</a>，可以试运行。</p><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p>⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪内部排序⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序{内部排序{插入排序{直接插入排序希尔排序选择排序{简单选择排序堆排序交换排序{冒泡排序快速排序归并排序基数排序外部排序</p><h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p><p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p><h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/insert-sort.gif" alt="直接插入排序演示"></a>直接插入排序演示</p><p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p><p>如果<strong>比较操作</strong>的代价比<strong>交换操作</strong>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95">二分查找法</a>来减少<em>比较操作</em>的数目。可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&action=edit&redlink=1">二分查找插入排序</a>。</p><h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line"> * 5. 将新元素插入到该位置后</span><br><span class="line"> * 6. 重复步骤2~5</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i = 1; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        int temp = arr[i];    // 取出下一个元素，在已经排序的元素序列中从后向前扫描</span><br><span class="line">        for( int j = i; j &gt;= 0; j-- ) &#123;</span><br><span class="line">            if( j &gt; 0 &amp;&amp; arr[j-1] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-1];    // 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span><br><span class="line">                System.out.println(&quot;Temping:  &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将新元素插入到该位置后</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交换次数较多的实现</span><br><span class="line">public static void insertionSort(int[] arr)&#123;</span><br><span class="line">    for( int i=0; i&lt;arr.length-1; i++ ) &#123;</span><br><span class="line">        for( int j=i+1; j&gt;0; j-- ) &#123;</span><br><span class="line">            if( arr[j-1] &lt;= arr[j] )</span><br><span class="line">                break;</span><br><span class="line">            int temp = arr[j];      //交换操作</span><br><span class="line">            arr[j] = arr[j-1];</span><br><span class="line">            arr[j-1] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序复杂度如下：</p><ul><li>最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1n−1；移动次数(RMN)为00。则对应的时间复杂度为O(n)O(n)。</li><li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22 ; 移动次数(RMN)为：∑n−1i&#x3D;1i&#x3D;n(n−1)2≈n22∑i&#x3D;1n−1i&#x3D;n(n−1)2≈n22。则对应的时间复杂度为O(n2)O(n2)。</li><li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n22n22，因此，<strong>直接插入排序的平均时间复杂度</strong>为O(n2)O(n2)。</li></ul><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/shell-sort.jpg" alt="img"></a></p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap&#x3D;1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>。</p><h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shellSort(int[] arr)&#123;</span><br><span class="line">    int gap = arr.length / 2;</span><br><span class="line">    for (; gap &gt; 0; gap /= 2) &#123;      //不断缩小gap，直到1为止</span><br><span class="line">        for (int j = 0; (j+gap) &lt; arr.length; j++)&#123;     //使用当前gap进行组内插入排序</span><br><span class="line">            for(int k = 0; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                if(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    int temp = arr[k+gap];      //交换操作</span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(&quot;    Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>①. 第一层for循环表示一共有多少个增量。增量的序列的个数，就是希尔排序的趟数。上面的增量序列为： <code>arr.length/2, arr.length/2/2, arr.length/2/2/2, .... 2, 1</code><br>②. 里层的两个for循环，实际上就是以一个gap拆分为一组的<strong>组内插入排序</strong>。</p><p>下面是维基百科官方实现，大家注意gap步长取值部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序（Wiki官方版）</span><br><span class="line"> *</span><br><span class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</span><br><span class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span><br><span class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void shell_sort(int[] arr) &#123;</span><br><span class="line">    int gap = 1, i, j, len = arr.length;</span><br><span class="line">    int temp;</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;      // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span><br><span class="line">    for (; gap &gt; 0; gap /= 3) &#123;</span><br><span class="line">        for (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是希尔排序复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog2 n)</td><td align="left">O(nlog2 n)</td><td align="left">O(nlog2 n)</td><td align="left">O(1)</td></tr></tbody></table><h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr><blockquote><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></a>选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p></blockquote><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p><h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</span><br><span class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</span><br><span class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</span><br><span class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void selectionSort(int[] arr)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.length-1; i++)&#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for(int j = i+1; j &lt; arr.length; j++)&#123;    //选出之后待排序中值最小的位置</span><br><span class="line">            if(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min != i)&#123;</span><br><span class="line">            int temp = arr[min];      //交换操作</span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是选择排序复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²&#x2F;2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：nn个元素的序列 {k1,k2,⋅⋅⋅,kn}{k1,k2,···,kn} 当且仅当满足下关系时，称之为堆。</p><p>{kiki⩽k2i⩽k2i+1或{kiki⩾k2i⩾k2i+1(i&#x3D;1,2,⋅⋅⋅,⌊n2⌋){ki⩽k2iki⩽k2i+1或{ki⩾k2iki⩾k2i+1(i&#x3D;1,2,···,⌊n2⌋)</p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列K[1..n]K[1..n]建成一个大顶堆, 那么此时第一个元素K1K1最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录K1K1 (即堆顶, 第一个元素)和无序区的最后一个记录 KnKn 交换, 由此得到新的无序区K[1..n−1]K[1..n−1]和有序区K[n]K[n], 且满足K[1..n−1].keys⩽K[n].keyK[1..n−1].keys⩽K[n].key<br>③. 交换K1K1 和 KnKn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p><p>动图效果如下所示：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></a>堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。</p><h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> *</span><br><span class="line"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</span><br><span class="line"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</span><br><span class="line"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void heapSort(int[] arr)&#123;</span><br><span class="line">    for(int i = arr.length; i &gt; 0; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        int temp = arr[0];      //堆顶元素(第一个元素)与Kn交换</span><br><span class="line">        arr[0] = arr[i-1];</span><br><span class="line">        arr[i-1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void max_heapify(int[] arr, int limit)&#123;</span><br><span class="line">    if(arr.length &lt;= 0 || arr.length &lt; limit) return;</span><br><span class="line">    int parentIdx = limit / 2;</span><br><span class="line"></span><br><span class="line">    for(; parentIdx &gt;= 0; parentIdx--)&#123;</span><br><span class="line">        if(parentIdx * 2 &gt;= limit)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = parentIdx * 2;       //左子节点位置</span><br><span class="line">        int right = (left + 1) &gt;= limit ? left : (left + 1);    //右子节点位置，如果没有右节点，默认为左节点位置</span><br><span class="line"></span><br><span class="line">        int maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        if(arr[maxChildId] &gt; arr[parentIdx])&#123;   //交换父节点与左右子节点中的最大值</span><br><span class="line">            int temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Max_Heapify: &quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 &#x3D;&#x3D; Math.floor(x&#x2F;2) .</p></blockquote><p>以上,<br>①. 建立堆的过程, 从length&#x2F;2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(nlog2n)O(nlog2⁡n)</td><td align="left">O(1)</td></tr></tbody></table><p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p><h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort02.gif" alt="冒泡排序的思想"></a>冒泡排序的思想</p><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/bubble-sort.gif" alt="冒泡排序演示"></a>冒泡排序演示</p><h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p><h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span><br><span class="line"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span><br><span class="line"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</span><br><span class="line"> * @param arr  待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">    for (int i = arr.length; i &gt; 0; i--) &#123;      //外层循环移动游标</span><br><span class="line">        for(int j = 0; j &lt; i &amp;&amp; (j+1) &lt; i; j++)&#123;    //内层循环遍历游标及之后(或之前)的元素</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">                System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²&#x2F;2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p><h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></a>使用快速排序法对一列数字进行排序的过程</p><h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/quick-sort09.gif" alt="快速排序演示"></a>快速排序演示</p><h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p><p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></a>快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> * @param low   左边界</span><br><span class="line"> * @param high  右边界</span><br><span class="line"> */</span><br><span class="line">public static void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    if(low &gt;= high) return;</span><br><span class="line">    int left = low;</span><br><span class="line">    int right = high;</span><br><span class="line"></span><br><span class="line">    int temp = arr[left];   //挖坑1：保存基准的值</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-1);</span><br><span class="line">    quickSort(arr, left+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序（非递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。</span><br><span class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span><br><span class="line"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</span><br><span class="line"> * @param arr   待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void quickSortByStack(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    //初始状态的左右指针入栈</span><br><span class="line">    stack.push(0);</span><br><span class="line">    stack.push(arr.length - 1);</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        int high = stack.pop();     //出栈进行划分</span><br><span class="line">        int low = stack.pop();</span><br><span class="line"></span><br><span class="line">        int pivotIdx = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        //保存中间变量</span><br><span class="line">        if(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= 0)&#123;</span><br><span class="line">            stack.push(pivotIdx + 1);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int partition(int[] arr, int low, int high)&#123;</span><br><span class="line">    if(arr.length &lt;= 0) return -1;</span><br><span class="line">    if(low &gt;= high) return -1;</span><br><span class="line">    int l = low;</span><br><span class="line">    int r = high;</span><br><span class="line"></span><br><span class="line">    int pivot = arr[l];    //挖坑1：保存基准的值</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        while(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   //基准值填补到坑3中，准备分治递归快排</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><p>以下是快速排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n²)</td><td align="left">O(1)（原地分区递归版）</td></tr></tbody></table><p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p><p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p><h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr><blockquote><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort_sample.jpg" alt="img"></a></p></blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"><img src="https://gitee.com/Unfall/blogimage/raw/master/img/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="这个图很有概括性，来自维基"></a>这个图很有概括性，来自维基</p><h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>一、递归法</strong>（假设序列共有n个元素）：</p><p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n&#x2F;2)个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 floor(n&#x2F;4)个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/merging-sort.gif" alt="img"></a></p><p><strong>二、迭代法</strong></p><p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p><h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p><strong>如何合并？</strong></p><p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p><p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p><p><strong>如何分解？</strong></p><p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p>这里我写了递归算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 归并排序（递归）</span><br><span class="line"> *</span><br><span class="line"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span><br><span class="line"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span><br><span class="line"> * ③. 重复步骤②，直到所有元素排序完毕。</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static int[] mergingSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return arr;</span><br><span class="line"></span><br><span class="line">    int num = arr.length &gt;&gt; 1;</span><br><span class="line">    int[] leftArr = Arrays.copyOfRange(arr, 0, num);</span><br><span class="line">    int[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(&quot;split two array: &quot; + Arrays.toString(leftArr) + &quot; And &quot; + Arrays.toString(rightArr));</span><br><span class="line">    return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      //不断拆分为最小单元，再排序合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] mergeTwoArray(int[] arr1, int[] arr2)&#123;</span><br><span class="line">    int i = 0, j = 0, k = 0;</span><br><span class="line">    int[] result = new int[arr1.length + arr2.length];  //申请额外的空间存储合并之后的数组</span><br><span class="line">    while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      //选取两个序列中的较小值放入新数组</span><br><span class="line">        if(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; arr1.length)&#123;     //序列1中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; arr2.length)&#123;     //序列2中多余的元素移入新数组</span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Merging: &quot; + Arrays.toString(result));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p><p>以下是归并排序算法复杂度:</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</li><li><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</li></ul><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radix-sort_sample.gif" alt="基数排序LSD动图演示"></a>基数排序LSD动图演示</p><h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数；<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</li><li><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序（LSD 从低位开始）</span><br><span class="line"> *</span><br><span class="line"> * 基数排序适用于：</span><br><span class="line"> *  (1)数据范围较小，建议在小于1000</span><br><span class="line"> *  (2)每个数值都要大于等于0</span><br><span class="line"> *</span><br><span class="line"> * ①. 取得数组中的最大数，并取得位数；</span><br><span class="line"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</span><br><span class="line"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] arr)&#123;</span><br><span class="line">    if(arr.length &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">    //取得数组中的最大数，并取得位数</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(max &lt; arr[i])&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxDigit = 1;</span><br><span class="line">    while(max / 10 &gt; 0)&#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;maxDigit: &quot; + maxDigit);</span><br><span class="line"></span><br><span class="line">    //申请一个桶空间</span><br><span class="line">    int[][] buckets = new int[10][arr.length];</span><br><span class="line">    int base = 10;</span><br><span class="line"></span><br><span class="line">    //从低位到高位，对每一位遍历，将所有元素分配到桶中</span><br><span class="line">    for(int i = 0; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        int[] bktLen = new int[10];        //存储各个桶中存储元素的数量</span><br><span class="line">        </span><br><span class="line">        //分配：将所有元素分配到桶中</span><br><span class="line">        for(int j = 0; j &lt; arr.length; j++)&#123;</span><br><span class="line">            int whichBucket = (arr[j] % base) / (base / 10);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int b = 0; b &lt; buckets.length; b++)&#123;</span><br><span class="line">            for(int p = 0; p &lt; bktLen[b]; p++)&#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));</span><br><span class="line">        base *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th align="left">平均时间复杂度</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">空间复杂度</th></tr></thead><tbody><tr><td align="left">O(d*(n+r))</td><td align="left">O(d*(n+r))</td><td align="left">O(d*(n+r))</td><td align="left">O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p><p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>各种排序性能对比如下，有些排序未详细介绍，暂且放到这里。实例测试结果可以看这里：<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md"><strong>八大排序算法耗时对比</strong></a> 。</p><table><thead><tr><th align="left">排序类型</th><th align="left">平均情况</th><th align="left">最好情况</th><th align="left">最坏情况</th><th align="left">辅助空间</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">选择排序</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">直接插入排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">折半插入排序</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">希尔排序</td><td align="left">O(n^1.3)</td><td align="left">O(nlogn)</td><td align="left">O(n²)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">归并排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n)</td><td align="left">稳定</td></tr><tr><td align="left">快速排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(n²)</td><td align="left">O(nlog₂n)</td><td align="left">不稳定</td></tr><tr><td align="left">堆排序</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(nlog₂n)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">计数排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(k)</td><td align="left">稳定</td></tr><tr><td align="left">桶排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n²)</td><td align="left">O(n+k)</td><td align="left">(不)稳定</td></tr><tr><td align="left">基数排序</td><td align="left">O(d(n+k))</td><td align="left">O(d(n+k))</td><td align="left">O(d(n+kd))</td><td align="left">O(n+kd)</td><td align="left">稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><p>(1). 平方阶O(n²)排序：**<code>各类简单排序：直接插入、直接选择和冒泡排序</code>**；</p><p>(2). 线性对数阶O(nlog₂n)排序：**<code>快速排序、堆排序和归并排序</code>**；</p><p>(3). O(n1+§))排序，§是介于0和1之间的常数：**<code>希尔排序</code>**</p><p>(4). 线性阶O(n)排序：**<code>基数排序，此外还有桶、箱排序</code><strong>。<br>　　<br>到此，很多人会注意到</strong>基数排序**的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p><p><a href="https://itimetraveler.github.io/gallery/sort-algorithms/radixsort-comparison.jpg"><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/radixsort-comparison.jpg" alt="img"></a></p><p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p><h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p><ol><li>计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数</li><li>基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值</li><li>桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li></ol><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O( nlgn)</strong> 。参考<a href="https://www.zhihu.com/question/24516934">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/2016-07-15_%25E5%25B8%25B8%25E7%2594%25A8%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown文档常用写法</title>
      <link href="/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/"/>
      <url>/2022/05/01/Markdown%E6%96%87%E6%A1%A3%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><p>第一种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165256359-1045755089.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165419890-1445220158.png" alt="img"></p><p>前面带#号，后面带文字，分别表示h1-h6,上图可以看出，只到h6，而且h1下面会有一条横线，注意，#号后面有空格</p><p>第二种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165937218-1530465248.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121165947968-314903197.png" alt="img"></p><p>这种方式好像只能表示一级和二级标题，而且&#x3D;和-的数量没有限制，只要大于一个就行</p><p>第三种：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121170247156-1219352477.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121170255531-442290753.png" alt="img"></p><p>这里的标题支持h1-h6，为了减少篇幅，我就偷个懒，只写前面二个，这个比较好理解，相当于标签闭合，注意，标题与#号要有空格</p><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121172350078-1462814017.png" alt="img"></p><p>在线地址请看这里： <a href="http://tool.oschina.net/markdown/">markdown在线编辑</a> （只是想看看背后的转换原理，没有广告之嫌）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>我们都知道，列表分为有序列表和无序列表，下面直接展示2种列表的写法：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121171909093-661987876.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121171919343-1747027523.png" alt="img"></p><p>可以看到，无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121173226140-1875382054.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121173239421-1080651187.png" alt="img"></p><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的，比如说：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175940718-1084956249.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175948687-1987133124.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175958281-1526944139.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180005984-1893005909.png" alt="img"></p><p>第一组本来是3 2 1 倒序，但是现实3 4 5 ，后面一组 序号是乱的， 但是还是显示 3 4 5 ，这点必须注意了</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174024531-1893848795.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174034406-909064775.png" alt="img"></p><p>无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格</p><p>引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174722343-1828411427.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121174734109-810075211.png" alt="img"></p><p>将上面的代码稍微改一下，全部加上引用标签，就变成了一个大的引用，还有引用里面还有引用，那引用嵌套引用还没有别的写法呢？</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175159984-1386789693.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121175207031-1980491226.png" alt="img"></p><p>上图可以看出，想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的&gt;是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧</p><h2 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h2><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180722171-1035491697.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121180731562-316920662.png" alt="img"></p><p>应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121181659734-1035365203.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121181708390-1994007685.png" alt="img"></p><p>上图可知，行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中，举一反三，经常出现的列表链接就应该这样写：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121182158531-1522139664.png" alt="img"> <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121182206671-1837073264.png" alt="img"></p><p>链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来</p><p><img src="https://images2015.cnblogs.com/blog/600165/201701/600165-20170121182852468-1462512454.png" alt="img"></p><p>这是行内式的写法，参数式的怎么写：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121183435890-1350949010.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121183445640-1750855701.png" alt="img"></p><p>这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系，参数定义时，这3种写法都可以：</p><p>还支持这种写法，如果你不想混淆的话：</p><p>其实还有一种隐式链接的写法，但是我觉得那种写法不直观，所以就不写了，经常用的一般就上面2种，如果你想了解隐式链接，可以看我文章最后放出的参考地址</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片也有2种方式：行内式和参数式，</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121185054312-549083784.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121185106031-1426410254.png" alt="img"></p><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190316875-1459932813.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190325703-1235022505.png" alt="img"></p><p>要是多行这个就不行了，多行可以用这个：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190613718-1073029883.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121190635656-1896064058.png" alt="img"></p><p>多行用三个反引号，如果要写注释，可以在反引号后面写</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这个写的有点麻烦，注意看</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121192302156-105192980.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121192312453-411896732.png" alt="img"></p><p>从这3种不同写法看，表格的格式不一定要对的非常起，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的，不过现实出来的结果是，表格外面并没有线框包起来，不知道别人的怎么弄的</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193336406-237336360.png" alt="img">   <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193346781-1402792187.png" alt="img"></p><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193837156-99120890.png" alt="img">   <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121193847093-1553208687.png" alt="img"></p><p>就不一一列举了，基本上跟js转义是一样的</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><img src="https://images2015.cnblogs.com/blog/600165/201701/600165-20170121194131015-499064556.png" alt="img">  <img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/600165-20170121194138656-989711852.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必备网站大全，给你全面惊喜</title>
      <link href="/2022/04/06/%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99%E5%A4%A7%E5%85%A8%EF%BC%8C%E7%BB%99%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%83%8A%E5%96%9C/"/>
      <url>/2022/04/06/%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99%E5%A4%A7%E5%85%A8%EF%BC%8C%E7%BB%99%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%83%8A%E5%96%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="学习类"><a href="#学习类" class="headerlink" title="学习类"></a>学习类</h1><p>CSDN： <a href="https://www.csdn.net/">https://www.csdn.net/</a><br>TED（最优质的演讲）：<a href="https://www.ted.com/">https://www.ted.com/</a><br>谷粉学术： <a href="https://gfsoso.99lb.net/scholar.html">https://gfsoso.99lb.net/scholar.html</a><br>大学资源网：<a href="http://www.dxzy163.com/">http://www.dxzy163.com/</a><br>简答题：<a href="http://www.jiandati.com/">http://www.jiandati.com/</a><br>网易公开课：<a href="https://open.163.com/ted/">https://open.163.com/ted/</a><br>网易云课堂：<a href="https://study.163.com/">https://study.163.com/</a><br>中国大学MOOC：<a href="http://www.icourse163.org/">www.icourse163.org</a><br>网易云课堂：<a href="https://study.163.com/">https://study.163.com</a><br>哔哩哔哩弹幕网： <a href="http://www.bilibili.com/">www.bilibili.com</a><br>我要自学网： <a href="http://www.51zxw.net/">www.51zxw.net</a><br>知乎：<a href="http://www.zhihu.com/">www.zhihu.com</a><br>学堂在线：<a href="http://www.xuetangx.com/">www.xuetangx.com</a><br>爱课程：<a href="http://www.icourses.cn/">www.icourses.cn</a><br>猫咪论文：<a href="https://lunwen.im/">https://lunwen.im/</a><br>iData（论文搜索）：<a href="http://www.cn-ki.net/">www.cn-ki.net</a><br>文泉考试：<a href="https://www.wqkaoshi.com/">https://www.wqkaoshi.com</a></p><h1 id="书籍类"><a href="#书籍类" class="headerlink" title="书籍类"></a>书籍类</h1><p>书栈网（极力推荐）： <a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a><br>码农之家（计算机电子书下载）：<a href="http://www.xz577.com/">www.xz577.com</a><br>鸠摩搜书：<a href="http://www.jiumodiary.com/">www.jiumodiary.com</a><br>云海电子图书馆：<a href="http://www.pdfbook.cn/">www.pdfbook.cn</a><br>周读（书籍搜索）：<a href="http://ireadweek.com/">http://ireadweek.com</a><br>知轩藏书：<a href="http://www.zxcs.me/">http://www.zxcs.me/</a><br>脚本之家电子书下载：<a href="https://www.jb51.net/books/">https://www.jb51.net/books/</a><br>搜书VIP-电子书搜索：<a href="http://www.soshuvip.com/all.html">http://www.soshuvip.com/all.html</a><br>书格（在线古籍图书馆）：<a href="https://new.shuge.org/">https://new.shuge.org/</a><br>caj云阅读：<a href="http://cajviewer.cnki.net/cajcloud/">http://cajviewer.cnki.net/cajcloud/</a><br>必看网（人生必看的书籍）：<a href="https://www.biikan.com/">https://www.biikan.com/</a></p><h1 id="冷知识-x2F-黑科技"><a href="#冷知识-x2F-黑科技" class="headerlink" title="冷知识 &#x2F; 黑科技"></a>冷知识 &#x2F; 黑科技</h1><p>上班摸鱼必备（假装电脑系统升级）： <a href="http://fakeupdate.net/">http://fakeupdate.net/</a><br>PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）： <a href="http://www.species-in-pieces.com/">http://www.species-in-pieces.com/</a><br>图片立体像素画： <a href="https://pissang.github.io/voxelize-image/">https://pissang.github.io/voxelize-image/</a><br>福利单词（一个不太正经的背单词网站）： <a href="http://dict.ftqq.com/">http://dict.ftqq.com</a><br>查无此人（刷新网站，展现一张AI 生成的人脸照片）：<a href="https://thispersondoesnotexist.com/">https://thispersondoesnotexist.com/</a><br>在线制作地图图例：<a href="https://mapchart.net/">https://mapchart.net/</a><br>创意光线绘画：<a href="http://weavesilk.com/">http://weavesilk.com/</a><br>星系观察： <a href="https://stellarium-web.org/">https://stellarium-web.org/</a><br>煎蛋：<a href="http://jandan.net/">http://jandan.net/</a><br>渣男-说话的艺术：<a href="https://lovelive.tools/">https://lovelive.tools/</a><br>全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a><br>iData：<a href="https://www.cn-ki.net/">https://www.cn-ki.net/</a><br>术语在线：<a href="http://www.termonline.cn/">http://www.termonline.cn/</a></p><h1 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h1><p>GitHub：<a href="https://github.com/">https://github.com/</a><br>码云：<a href="https://gitee.com/">https://gitee.com/</a><br>源码之家：<a href="https://www.mycodes.net/">https://www.mycodes.net/</a><br>JSON to Dart： <a href="https://javiercbk.github.io/json_to_dart/">https://javiercbk.github.io/json_to_dart/</a><br>Json在线解析验证： <a href="https://www.json.cn/">https://www.json.cn/</a><br>在线接口测试（Getman）：<a href="https://getman.cn/">https://getman.cn/</a></p><h1 id="搜资源"><a href="#搜资源" class="headerlink" title="搜资源"></a>搜资源</h1><p>DogeDoge搜索引擎：<a href="http://www.dogedoge.com/">www.dogedoge.com</a><br>秘迹搜索：<a href="https://mijisou.com/">https://mijisou.com/</a><br>小白盘：<a href="https://www.xiaobaipan.com/">https://www.xiaobaipan.com/</a><br>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com/">www.yunpanjingling.com</a><br>虫部落（资源搜索）：<a href="http://www.chongbuluo.com/">www.chongbuluo.com</a><br>如风搜（资源搜索）：<a href="http://www.rufengso.net/">http://www.rufengso.net/</a><br>爱扒：<a href="https://www.zyboe.com/">https://www.zyboe.com/</a></p><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><p>奶牛快传（在线传输文件利器）： <a href="http://cowtransfer.com/">http://cowtransfer.com</a><br>文叔叔（大文件传输，不限速）：<a href="https://www.wenshushu.cn/">https://www.wenshushu.cn/</a><br>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/">https://uzer.me/</a><br>香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：<a href="https://www.xiangdang.net/">https://www.xiangdang.net/</a><br>二维码生成：<a href="https://cli.im/">https://cli.im/</a><br>搜狗翻译：<a href="http://fanyi.sogou.com/">http://fanyi.sogou.com</a><br>熵数（图表制作，数据可视化）：<a href="https://dydata.io/appv2/#/pages/index/home">https://dydata.io/appv2/#/pages/index/home</a><br>拷贝兔：<a href="https://cp.anyknew.com/">https://cp.anyknew.com/</a><br>图片无限变放大：<a href="http://bigjpg.com/zh">http://bigjpg.com/zh</a><br>幕布（在线大纲笔记工具）：mubu.com<br>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/">https://zh.justcnw.com/</a><br>调查问卷制作：<a href="https://www.wenjuan.com/">https://www.wenjuan.com/</a><br>果核剥壳（软件下载）：<a href="https://www.ghpym.com/">https://www.ghpym.com/</a><br>软件下载：<a href="https://www.unyoo.com/">https://www.unyoo.com/</a><br>MSDN我告诉你（windows10系统镜像下载）：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p><h1 id="导航页"><a href="#导航页" class="headerlink" title="导航页"></a>导航页</h1><p>世界各国网址大全： <a href="http://www.world68.com/">http://www.world68.com/</a><br>小森林导航：<a href="http://www.xsldh6.com/">http://www.xsldh6.com/</a><br>简捷工具：<a href="http://www.shulijp.com/">http://www.shulijp.com/</a><br>NiceTool.net 好工具网：<a href="http://www.nicetool.net/">http://www.nicetool.net/</a><br>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/">http://tool.uixsj.cn/</a><br>蓝调网站：<a href="http://lcoc.top/">http://lcoc.top/</a><br>偷渡鱼：<a href="https://touduyu.com/">https://touduyu.com/</a><br>牛导航：<a href="http://www.ziliao6.com/">http://www.ziliao6.com/</a><br>小呆导航：<a href="https://www.webjike.com/index.html">https://www.webjike.com/index.html</a><br>简法主页：<a href="http://www.jianfast.com/">http://www.jianfast.com/</a><br>KIM主页：<a href="https://kim.plopco.com/">https://kim.plopco.com/</a><br>聚BT：<a href="https://jubt.net/cn/index.html">https://jubt.net/cn/index.html</a><br>精准云工具合集：<a href="https://jingzhunyun.com/">https://jingzhunyun.com/</a><br>兔2工具合集：<a href="https://www.tool2.cn/">https://www.tool2.cn/</a><br>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com/">www.toolnb.com</a><br>工具导航：<a href="https://hao.logosc.cn/">https://hao.logosc.cn/</a></p><h1 id="看视频"><a href="#看视频" class="headerlink" title="看视频"></a>看视频</h1><p>阿木影视： <a href="https://www.aosk.online/">https://www.aosk.online/</a><br>电影推荐（分类别致）：<a href="http://www.mvcat.com/">http://www.mvcat.com</a><br>APP影院：<a href="https://app.movie/">https://app.movie/</a><br>去看TV：<a href="https://www.qukantv.net/">https://www.qukantv.net/</a><br>动漫视频网：<a href="http://www.zzzfun.com/">http://www.zzzfun.com/</a><br>94神马电影网：<a href="http://www.9rmb.com/">http://www.9rmb.com/</a><br>NO视频官网：<a href="http://www.novipnoad.com/">http://www.novipnoad.com/</a><br>蓝光画质电影：<a href="http://www.languang.co/">http://www.languang.co/</a><br>在线看剧：<a href="http://dy.27234.cn/">http://dy.27234.cn/</a><br>大数据导航：<a href="http://hao.199it.com/">http://hao.199it.com/</a><br>多功能图片网站：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a><br>牛牛TV：<a href="http://www.ziliao6.com/tv/">http://www.ziliao6.com/tv/</a><br>VideoFk解析视频：<a href="http://www.videofk.com/">http://www.videofk.com/</a><br>蓝调网站：<a href="http://lcoc.top/vip2.3/">http://lcoc.top/vip2.3/</a><br>永久资源采集网：<a href="http://www.yongjiuzy1.com/">http://www.yongjiuzy1.com/</a></p><h1 id="学设计"><a href="#学设计" class="headerlink" title="学设计"></a>学设计</h1><p>码力全开（产品&#x2F;设计师&#x2F;独立开发者的资源库）： <a href="https://www.maliquankai.com/designnav/">https://www.maliquankai.com/designnav/</a><br>免费音频素材：<a href="https://icons8.cn/music">https://icons8.cn/music</a><br>新CG儿（视频素材模板，无水印+免费下载）：<a href="https://www.newcger.com/">https://www.newcger.com/</a><br>Iconfont（阿里巴巴矢量图标库）： <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a><br>小图标下载：<a href="https://www.easyicon.net/">https://www.easyicon.net/</a><br>Flight Icon：<a href="https://www.flighticon.co/">https://www.flighticon.co/</a><br>第一字体转换器：<a href="http://www.diyiziti.com/">http://www.diyiziti.com/</a><br>doyoudosh（平面设计）：<a href="http://www.doyoudo.com/">www.doyoudo.com</a><br>企业宣传视频在线制作：<a href="https://duomu.tv/">https://duomu.tv/</a><br>MAKE海报设计官网：<a href="http://maka.im/">http://maka.im/</a><br>一键海报神器：<a href="https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral">https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&amp;utm_medium=referral</a><br>字由（字体设计）：<a href="http://www.hellofont.cn/">http://www.hellofont.cn/</a><br>查字体网站：<a href="https://fonts.safe.360.cn/">https://fonts.safe.360.cn/</a><br>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）： <a href="http://www.aigei.com/">http://www.aigei.com/</a><br>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor">https://bilibili.clipchamp.com/editor</a></p><h1 id="搞文档"><a href="#搞文档" class="headerlink" title="搞文档"></a>搞文档</h1><p>即书（在线制作PPT）：<a href="https://www.keysuper.com/">https://www.keysuper.com/</a><br>PDF处理：<a href="https://smallpdf.com/cn">https://smallpdf.com/cn</a><br>PDF处理：<a href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a><br>PDF处理： <a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a><br>PDF处理：<a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a><br>图片压缩，PDF处理：<a href="https://docsmall.com/">https://docsmall.com/</a><br>腾讯文档（在线协作编辑和管理文档）：<a href="http://docs.qq.com/">http://docs.qq.com</a><br>ProcessOn（在线协作制作结构图）：<a href="http://www.processon.com/">www.processon.com</a><br>iLovePDF（在线转换PDF利器）：<a href="http://www.ilovepdf.com/">www.ilovepdf.com</a><br>PPT在线制作：<a href="https://www.woodo.cn/">https://www.woodo.cn/</a><br>PDF24工具（pdf处理工具）：<a href="https://tools.pdf24.org/en">https://tools.pdf24.org/en</a><br>IMGBOT（在线图片处理）：<a href="http://www.imgbot.ai/">www.imgbot.ai</a><br>福昕云编辑（在线编辑PDF）：<a href="http://edit.foxitcloud.cn/">http://edit.foxitcloud.cn</a><br>TinyPNG（在线压缩图片）：<a href="http://tinypng.com/">http://tinypng.com</a><br>UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套<br>）：<a href="http://uzer.me/">http://uzer.me</a><br>优品PPT（模板下载）： <a href="http://www.ypppt.com/">http://www.ypppt.com/</a><br>第一PPT（模板下载）：<a href="http://www.1ppt.com/xiazai/">http://www.1ppt.com/xiazai/</a><br>三顿PPT导航：sandunppt.com<br>Excel函数表： <a href="https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188">https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188</a></p><h1 id="找图片"><a href="#找图片" class="headerlink" title="找图片"></a>找图片</h1><p>电脑壁纸：<a href="http://lcoc.top/bizhi/">http://lcoc.top/bizhi/</a><br><a href="https://unsplash.com/">https://unsplash.com/</a><br><a href="https://pixabay.com/">https://pixabay.com/</a><br><a href="https://www.pexels.com/">https://www.pexels.com/</a><br><a href="https://visualhunt.com/">https://visualhunt.com/</a><br><a href="https://www.ssyer.com/">https://www.ssyer.com/</a><br>彼岸图网：<a href="http://pic.netbian.com/">http://pic.netbian.com/</a><br>极像素（超高清大图）：<a href="https://www.sigoo.com/">https://www.sigoo.com/</a><br>免费版权图片搜索：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly页脚养鱼</title>
      <link href="/2022/04/04/Hexo-Butterfly%E9%A1%B5%E8%84%9A%E5%85%BB%E9%B1%BC/"/>
      <url>/2022/04/04/Hexo-Butterfly%E9%A1%B5%E8%84%9A%E5%85%BB%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<p>最终效果在本站页脚，向下滑动即可看到。</p><hr><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>参考文章一共介绍了两种方法，第一种是有针对于Butterfly主题的修改。第二种方法是通用方法（其他也主题可参考）</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>打开站点的主题配置文件_config.butterfly.yml，找到inject，在bottom处直接引入以下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li>找到footer.pug文件：\themes\butterfly\layout\includes\footer.pug，写入以下内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#jsi-flying-fish-container.container</span><br><span class="line">   script(src=&#x27;js/fish.js&#x27;)</span><br><span class="line">style.</span><br><span class="line"></span><br><span class="line">       @media only screen and (max-width: 767px)&#123;</span><br><span class="line">       #sidebar_search_box input[type=text]&#123;width:calc(100% - 24px)&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>点的主题配置文件_config.butterfly.yml，找到inject，在bottom处直接引入<a href="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js">https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>​        注意：引入的js文件需要依赖jquery，所以在之前如果没有引用过的就需要在bottom处的最开始引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>这样效果就出现了。但是引入之后页脚会过高，需要修改footer.styl文件：\themes\butterfly\source\css_layout\footer.styl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#footer</span><br><span class="line">  position: relative</span><br><span class="line">  background: $light-blue</span><br><span class="line">  background-attachment: local</span><br><span class="line">  background-position: bottom</span><br><span class="line">  background-size: cover</span><br><span class="line"></span><br><span class="line">  if hexo-config(&#x27;footer_bg&#x27;) != false</span><br><span class="line">    &amp;:before</span><br><span class="line">      position: absolute</span><br><span class="line">      width: 100%</span><br><span class="line">      height: 100%</span><br><span class="line">      background-color: alpha($dark-black, .1) </span><br><span class="line">      content: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#footer-wrap</span><br><span class="line">  position: absolute</span><br><span class="line">  padding: 1.2rem 1rem 1.4rem</span><br><span class="line">  color: var(--light-grey)</span><br><span class="line">  text-align: center</span><br><span class="line">  left: 0</span><br><span class="line">  right: 0</span><br><span class="line">  top: 0</span><br><span class="line">  bottom: 0</span><br><span class="line"></span><br><span class="line">  a</span><br><span class="line">    color: var(--light-grey)</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      text-decoration: underline</span><br><span class="line"></span><br><span class="line">  .footer-separator</span><br><span class="line">    margin: 0 .2rem</span><br><span class="line"></span><br><span class="line">  .icp-icon</span><br><span class="line">    padding: 0 4px</span><br><span class="line">    vertical-align: text-bottom</span><br><span class="line">    max-height: 1.4em</span><br><span class="line">    width auto</span><br></pre></td></tr></table></figure></li><li><p>参考文章的技术流程写到这里就结束了，如果还有页脚文字被遮挡的情况，可以修改页脚的透明度，在\themes\butterfly\source\css路径下创建一个xxx.css文件，在文件中添加如下代码：</p></li></ol><ul><li>页脚半透明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 页脚半透明 */</span><br><span class="line">#footer &#123;</span><br><span class="line">    background: rgba(255, 255, 255, 0);</span><br><span class="line">    color: #000;</span><br><span class="line">    border-top-right-radius: 20px;</span><br><span class="line">    border-top-left-radius: 20px;</span><br><span class="line">    backdrop-filter: saturate(100%) blur(5px)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer::before &#123;</span><br><span class="line">    background: rgba(255,255,255,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer #footer-wrap &#123;</span><br><span class="line">    color: var(--font-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer #footer-wrap a &#123;</span><br><span class="line">    color: var(--font-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页脚全透明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 页脚透明 */</span><br><span class="line">#footer &#123;</span><br><span class="line">    background: transparent !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后将该文件引入到inject的head处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>至此操作结束，去看看你的页脚有没有发生变化吧。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个更为简单的方法，引入带有颜色的页脚养鱼，效果如下：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/fish.png" alt="img"></p><p>只需要在_config.butterfly.yml文件中，找到inject，在bottom处直接引入：<a href="https://uuuuu.cf/js/fishes.js">https://uuuuu.cf/js/fishes.js</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script defer src=&quot;https://uuuuu.cf/js/fishes.js&quot;&gt;&lt;/script&gt; # 页脚养鱼(彩色)</span><br></pre></td></tr></table></figure><p>注意：该操作同样需要在之前引入jquery。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> Butterfly魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Butterfly魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARK方舟Windows ARK Server Manager开服教程</title>
      <link href="/2022/04/04/ARK%E6%96%B9%E8%88%9FWindows-ARK-Server-Manager%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/ARK%E6%96%B9%E8%88%9FWindows-ARK-Server-Manager%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h3><ul><li>内存：4G能满足游戏运行，不过容易卡顿，6G能稳定运行。推荐8G以上。</li><li>网络：2M~4M上行带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力，避免卡顿。</li><li>端口：默认UDP 777，UDP 27015</li></ul><h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><p>[官网下载](<a href="https://redirect.viglink.com/?format=go&amp;jsonp=vglnk_163763550743810&amp;key=71fe2139a887ad501313cd8cce3053c5&amp;libId=kwbhw0zk0102ylrr000DLkz08zkab&amp;loc=https://arkservermanager.freeforums.net/thread/5193/downloads?page=1&scrollTo=29985&amp;ccpaConsent=1---&amp;v=1&amp;out=https://raw.githubusercontent.com/Bletch1971/ServerManagers/master/ASM/latest.exe&amp;ref=https://arkservermanager.freeforums.net/&amp;title=Downloads">https://redirect.viglink.com/?format=go&amp;jsonp=vglnk_163763550743810&amp;key=71fe2139a887ad501313cd8cce3053c5&amp;libId=kwbhw0zk0102ylrr000DLkz08zkab&amp;loc=https%3A%2F%2Farkservermanager.freeforums.net%2Fthread%2F5193%2Fdownloads%3Fpage%3D1%26scrollTo%3D29985&amp;ccpaConsent=1---&amp;v=1&amp;out=https%3A%2F%2Fraw.githubusercontent.com%2FBletch1971%2FServerManagers%2Fmaster%2FASM%2Flatest.exe&amp;ref=https%3A%2F%2Farkservermanager.freeforums.net%2F&amp;title=Downloads</a> | ARK Server Manager&amp;txt&#x3D;Latest.exe)ARK Server Manager</p><p><a href="https://pan.wapriaily.com/index.php/s/L6W3QfDZL7oJH9b">国内下载</a>ARK Server Manager</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>新建一个ARK文件夹，把ARK Server Manager移动到文件夹内运行</li><li>安装完后启动ARK Server Manager，会提示缺少SteamCMD，一路确定就会自动安装SteamCMD</li><li>安装完SteamCMD后ARK Server Manager就打开了</li></ul><h3 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h3><ul><li>在右上角找到设置按钮，将语言设置为中文。</li><li>然后返回主界面新建配置文件</li><li>点击右边安装按钮等待安装</li></ul><h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><ul><li>首先需要在地图和MOD功能里选择地图</li><li>然后就可以更改服务器的名称</li><li>根据自己的服务器配置调整服务器端口以及最大玩家数量</li></ul><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><ul><li>配置好服务器后点击右上角开始按钮启动服务器即可</li><li>启动时间根据服务器配置而定，时间可能较长</li><li>如长时间没有启动成功，重新启动即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七日杀(7 Days to Die)Liunx开服教程</title>
      <link href="/2022/04/04/%E4%B8%83%E6%97%A5%E6%9D%80-7-Days-to-Die-Liunx%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/%E4%B8%83%E6%97%A5%E6%9D%80-7-Days-to-Die-Liunx%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G能满足正常进行游戏，内存越大，支持的人数越多。推荐8G以上。</li><li>网络：2M~4M上行带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 27000，TCP 27021，TCP 27020</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 或 Debian</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> update</span><br><span class="line">$ sudo apt-<span class="built_in">get</span><span class="built_in"> upgrade</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># CentOS</span></span><br><span class="line">$ yum update -y</span><br><span class="line">$ yum<span class="built_in"> upgrade </span>-y</span><br></pre></td></tr></table></figure><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><h3 id="首先添加一个单独的用户"><a href="#首先添加一个单独的用户" class="headerlink" title="首先添加一个单独的用户"></a>首先添加一个单独的用户</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>adduser <span class="number">7</span>dtd</span><br></pre></td></tr></table></figure><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> glibc.i686 libstdc++i686 -y</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ yum <span class="keyword">install</span> glibc.i686 libstdc++i686 -y</span><br></pre></td></tr></table></figure><h3 id="安装终端复用器"><a href="#安装终端复用器" class="headerlink" title="安装终端复用器"></a>安装终端复用器</h3><p>根据个人喜好安装其中一个</p><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> tmux</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt <span class="keyword">install </span><span class="keyword">screen</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#CentOS</span></span><br><span class="line">$ yum <span class="keyword">install </span><span class="keyword">screen</span></span><br></pre></td></tr></table></figure><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - <span class="number">7</span>dtd</span><br><span class="line">cd <span class="regexp">/home/</span>steam</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Tmux</span></span><br><span class="line"><span class="attribute">tmux</span> new -s <span class="number">7</span>dtd</span><br><span class="line"><span class="comment">#Screen</span></span><br><span class="line"><span class="attribute">screen</span> -s <span class="number">7</span>dtd</span><br></pre></td></tr></table></figure><h3 id="下载SteamCMD"><a href="#下载SteamCMD" class="headerlink" title="下载SteamCMD"></a>下载SteamCMD</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>steamcdn-a.akamaihd.net<span class="regexp">/client/i</span>nstaller/steamcmd_linux.tar.gz</span><br><span class="line">tar -xvzf steamcmd_liunx.tar.gz</span><br></pre></td></tr></table></figure><h3 id="下载服务端"><a href="#下载服务端" class="headerlink" title="下载服务端"></a>下载服务端</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./steamcmd.sh</span><br><span class="line">login anonymous</span><br><span class="line">force_install_dir <span class="regexp">/home/</span>steam/<span class="number">7</span>DaysToDieServer</span><br><span class="line">app_update <span class="number">294420</span> validate</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam/<span class="number">7</span>DaysToDieServer</span><br><span class="line">vi serverconfig.xml</span><br></pre></td></tr></table></figure><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/7DaysToDieServer</span></span><br><span class="line"><span class="string">./startserver.sh</span> -configfile=serverconfig.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>饥荒Liunx SteamCMD开服教程</title>
      <link href="/2022/04/04/%E9%A5%A5%E8%8D%92Liunx-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/%E9%A5%A5%E8%8D%92Liunx-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G能满足5个人左右正常游玩，4G够10个人左右，根据人数选服务器即可，大量MOD需要高配置的服务器。</li><li>网络：4M以上的带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 10998,TCP 10999</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">sudo yum-y <span class="keyword">install</span> glibc.i686 libstdc++i686</span><br></pre></td></tr></table></figure><h2 id="安装终端复用器"><a href="#安装终端复用器" class="headerlink" title="安装终端复用器"></a>安装终端复用器</h2><p>根据个人喜好安装其中一个</p><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt-get <span class="keyword">install</span> tmux</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ sudo apt <span class="keyword">install </span><span class="keyword">screen</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#CentOS</span></span><br><span class="line">$ yum <span class="keyword">install </span><span class="keyword">screen</span></span><br></pre></td></tr></table></figure><h2 id="安装SteamCMD"><a href="#安装SteamCMD" class="headerlink" title="安装SteamCMD"></a>安装SteamCMD</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adduser dst</span><br><span class="line">su -dst</span><br><span class="line">cd /home/steam</span><br><span class="line">n-<span class="selector-tag">a</span><span class="selector-class">.akamaihd</span>.net/client/installer/steamcmd_linux<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">tar -xvzf steamcmd_liunx<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">./steamcmd.sh</span><br></pre></td></tr></table></figure><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br><span class="line">force_install_dir <span class="regexp">/home/</span>steam/dstserver</span><br><span class="line">app_update <span class="number">343050</span> validate</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>Liunx服务端的组件有错误，需要更改一下后启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>lib<span class="regexp">/libcurl.so.4  /</span>home<span class="regexp">/steam/</span>dstserver<span class="regexp">/bin/</span>lib32/libcurl-gnutls.so.<span class="number">4</span></span><br><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstserver/</span>bin</span><br><span class="line">echo <span class="string">&quot;./dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root /home/dstsave -conf_dir dst -cluster World1 -shard Master&quot;</span> &amp;gt; master_start.sh</span><br><span class="line">echo <span class="string">&quot;./dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root /home/dstsave -conf_dir dst -cluster World1 -shard Caves&quot;</span> &amp;gt; cave_start.sh</span><br><span class="line">chmod +x master_start.sh cave_start.sh</span><br><span class="line">.master_start.sh</span><br></pre></td></tr></table></figure><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>启动完后关闭进程</p><p>在&#x2F;home&#x2F;steam&#x2F;dstserver&#x2F;dst&#x2F;World1&#x2F;文件会生成默认的配置文件</p><p>接下来我们需要将电脑上的配置文件传到服务端上，有能力的可以直接在服务端更改配置即可</p><p>打开游戏，创建新的世界，配置好名词，描述，密码，地洞等</p><p>创建好世界后退出世界，返回主界面，点击左下角的游戏数据</p><p>找到Cluster_1文件夹（后面数字为创建的世界顺序）</p><p>打开文件夹后将所有文件上传到服务端的home&#x2F;steam&#x2F;dstserver&#x2F;dst&#x2F;World1&#x2F;目录</p><p>上传完后，在游戏主界面点击左下角的账号信息，点击查看我的游戏按钮</p><p>点击右上角Don’t Strave Together Servers</p><p>拉到最后输入Token名称，点击添加新的服务器，就会生成Token</p><p>复制Token，粘贴到服务端World1目录里的cluster_token.txt里，不会编辑的可以在本地电脑创建同名的txt文件上传替换即可</p><h2 id="启动世界"><a href="#启动世界" class="headerlink" title="启动世界"></a>启动世界</h2><p>依次启动主世界和洞穴，以下教程使用Tmux</p><h3 id="主世界"><a href="#主世界" class="headerlink" title="主世界"></a>主世界</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/steam/dstserver</span><br><span class="line">tmux new -s master</span><br><span class="line">./master_start.sh</span><br></pre></td></tr></table></figure><h3 id="洞穴"><a href="#洞穴" class="headerlink" title="洞穴"></a>洞穴</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmux -s cave</span><br><span class="line">./cave_start.sh</span><br></pre></td></tr></table></figure><p>启动完以上进程后就可以再游戏你们看到服务器了</p><h2 id="配置MOD"><a href="#配置MOD" class="headerlink" title="配置MOD"></a>配置MOD</h2><p>将World1文件夹里的modoverrides.lua文件打开</p><p>找到MOD们的workshop数字ID记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstserver/m</span>ods</span><br></pre></td></tr></table></figure><p>找到dedicated_server_mods_setup.lua文件并打开</p><p>在最后一栏注释上面将所有MOD以下面格式添加</p><p>ServerModSetup(“workshop数字ID”)</p><p>添加完后重启服务器MOD就配置完毕了</p><p>不会编辑的朋友可以将文件下载下来，编辑后上传即可</p><h2 id="配置服主管理员"><a href="#配置服主管理员" class="headerlink" title="配置服主管理员"></a>配置服主管理员</h2><p>点击主界面的账号信息</p><p>找到KLEI用户ID记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>steam<span class="regexp">/dstsave/</span>dst<span class="regexp">/World1/</span></span><br><span class="line">vim adminlist.txt</span><br></pre></td></tr></table></figure><p>创建好txt文件后将KLEI用户ID输入后保存</p>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unturned未转变者Windows SteamCMD开服教程</title>
      <link href="/2022/04/04/Unturned%E6%9C%AA%E8%BD%AC%E5%8F%98%E8%80%85Windows-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/04/Unturned%E6%9C%AA%E8%BD%AC%E5%8F%98%E8%80%85Windows-SteamCMD%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器要求"><a href="#服务器要求" class="headerlink" title="服务器要求"></a>服务器要求</h2><ul><li>内存：2G以上即可，越高越好，根据期望用户量增加。</li><li>网络：2M以上的带宽，游戏服务器容易被ddos攻击，最好弄高防御的服务器或者配置网络防御能力。</li><li>端口：默认TCP 27015</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip">点击下载</a>SteamCMD</p><p><a href="https://gsf-fl.softonic.com/3a8/2ff/6c396563e808aef56baa9e1ac9b34960d3/npp.8.1.9.Installer.exe?Expires=1637759025&Signature=f8fb1aaa36e1203e3d7094c455eea099b751b5c2&url=https://notepad-plus.en.softonic.com&Filename=npp.8.1.9.Installer.exe">点击下载</a>Notepad++</p><h2 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h2><p>在桌面创建一个SteamCMD文件夹，将下载的SteamCMD压缩包解压进去</p><p>右键管理员启动SteamCMD等待下载安装</p><p>显示Steam&gt;时代表已经安装完毕</p><h2 id="使用SteamCMD安装"><a href="#使用SteamCMD安装" class="headerlink" title="使用SteamCMD安装"></a>使用SteamCMD安装</h2><p>若仅是个人开服请使用下方的Steam安装方法更加方便以及无需翻墙</p><p>  1.启动SteamCMD，以匿名用户登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br></pre></td></tr></table></figure><p>  2.安装服务端（时间比较久，大约1.7G，并且可能需要梯子，请注意日志）同时本指令可以用于以后的服务端更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_update 1110390</span><br></pre></td></tr></table></figure><p>  3.输入以下指令关闭SteamCMD（不建议直接叉掉）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><p>  4.现在你的服务端文件将存于<code>SteamCMD目录``/steamapps/common/U3DS</code>内</p><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>在SteamCMD\steamapps\common\U3DS\找到服务端启动Unturned.exe</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220408213735639.png" alt="image-20220408213735639"></p><p>显示这个界面即为运行完成，然后输入shutdown关闭服务器</p><p>第一次启动服务端是为了生成世界</p><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>在U3DS目录找到Servers文件夹，打开默认服务器文件夹Default</p><p>打开Server文件夹，会看到一个Commands.dat文件</p><p>使用Notepad++编辑该文件，按个人需求选填以下指令，当然不添加新的指令在原本的指令更改也可以。</p><table><thead><tr><th>配置代码</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>Name</td><td>服务器名称</td><td></td></tr><tr><td>Map</td><td>地图类型</td><td>默认PEI</td></tr><tr><td>Password</td><td>服务器密码</td><td>公开不填</td></tr><tr><td>Welcome</td><td>服务器欢迎语</td><td></td></tr><tr><td>Maxplayer</td><td>服务器人数</td><td>根据服务器配置填</td></tr><tr><td>Mode</td><td>服务器难度</td><td>可填Eazy,Normal,Hard</td></tr><tr><td>Perspective</td><td>服务器视角限制</td><td>可填First,Third,Both,Vehicle</td></tr><tr><td>PVE</td><td>开启PVE模式</td><td>留空为PVP</td></tr><tr><td>Cheats</td><td>服务器作弊模式</td><td>开True关False</td></tr><tr><td>Port</td><td>服务器端口</td><td>默认27015,更改需要开放端口</td></tr></tbody></table><p>或许你可能不知道这些代表着什么，下面介绍几个常用的</p><ul><li><p><strong>Map</strong> ——此类型可以选择地图<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map Russia</span><br></pre></td></tr></table></figure></li></ul><p>这样就是设置Russia地图了，默认不填写情况下是使用PEI地图</p><ul><li><p><strong>Port</strong> ——此类型选择你的服务器端口<br>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 23333</span><br></pre></td></tr></table></figure></li></ul><p>这样则是设置了使用23333端口，默认不填写情况下是使用27015 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请注意，在改版后，运行公共服务器（也就是Internet模式）需要向你的端口号+1来分别负责与服务器列表通信和与游戏流量传输，比如我使用23333端口来开服，此端口会用于游戏列表通信，23334端口来与客户端游戏通信，也就是会占用2个端口</span><br></pre></td></tr></table></figure><ul><li><p><strong>Name</strong> ——你的服务器名称（将会显示在服务器列表）<br>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name 你的服务器名称</span><br></pre></td></tr></table></figure></li><li><p><strong>Password</strong>——服务器密码，若填写上去并且后面写入字符将会要求提供密码才能加入服务器，一般不需要填写，也不用写上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Password 114514</span><br></pre></td></tr></table></figure></li></ul><p>这样就要求提供密码才能加入</p><ul><li><p><strong>Perspective</strong> ——视角限制，可以填入有<code>First</code>, <code>Third</code>, <code>Both</code>, <code>Vehicle</code>，分别对应仅限第一人称、仅限第三人称、任意、只能在驾驶载具时使用第三人称<br>示例;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perspective Both</span><br></pre></td></tr></table></figure></li></ul><p>这样就能够第一第三人称任意切换</p><ul><li><p><strong>Cheats</strong> ——作弊设置，可以填入的有<code>True</code>和<code>False</code>，分别对应开和关，打开后只能管理员作弊，关闭后管理员都不能作弊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cheats True</span><br></pre></td></tr></table></figure></li></ul><p>这样管理员就能作弊了(没有试过，具体功效不明)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name (服务器名字，不能有数字不能有字符名字必须大于五个字）</span><br><span class="line">password （密码）</span><br><span class="line">Map （地图）</span><br><span class="line">Maxplayers 8 （最大玩家数）</span><br><span class="line">Mode Normal （游戏难度）</span><br><span class="line">PVE（玩家间伤害，不填写则是默认为PVP）</span><br><span class="line">Port 25444 （端口）</span><br><span class="line">Cheats on （作弊是否开启）</span><br><span class="line">Perspective both （第一人称和第三人称的限制）</span><br><span class="line">Loadout 255/(id)  (服务器开局物品）</span><br><span class="line">Welcome （服务器欢迎语）</span><br></pre></td></tr></table></figure><p>配置完后保存，启动steamCMD\steamapps\common\U3DS\Unturned.exe文件</p><p>加载完毕我们就可以看到服务器了(记得放行上方配置文件配置的端口)</p><blockquote><p>部分人在连接服务器时会出现“未能初始化steam网络身份验证”（懒狗，没截图）得情况</p><p>这是因为steam在国内被墙，使用加速器加速steam即可</p></blockquote><h2 id="创意工坊"><a href="#创意工坊" class="headerlink" title="创意工坊"></a>创意工坊</h2><p>在SteamCMD\steamapps\common\U3DS\Servers\Default</p><p>咱们能看到WorkshopDownloadConfig.json文件</p><p>使用Notepad++编辑该文件添加你想要添加的创意工坊文件ID即可</p><h2 id="Rocket与OpenMod"><a href="#Rocket与OpenMod" class="headerlink" title="Rocket与OpenMod"></a>Rocket与OpenMod</h2><p>| Rocket是一种旧式的插件适配框架，OpenMod是新出的插件框架，Rocket具有更多的插件，OpenMod具有更好的兼容性，两者可以同时使用</p><h3 id="Rocket安装方法"><a href="#Rocket安装方法" class="headerlink" title="Rocket安装方法"></a>Rocket安装方法</h3><ol><li>打开服务端文件夹（非服务器文件夹），找到<code>Extras</code>目录，将其中的<code>Rocket.Unturned</code>文件复制</li><li>返回上一级，找到<code>Modules</code>文件夹，将其粘贴在文件夹内即可完成安装</li></ol><h3 id="OpenMod安装方法"><a href="#OpenMod安装方法" class="headerlink" title="OpenMod安装方法"></a>OpenMod安装方法</h3><p>OpenMod有两种安装方法，一种是通过Rocket安装，还有一种是手动安装</p><h5 id="通过Rocket安装OpenMod"><a href="#通过Rocket安装OpenMod" class="headerlink" title="通过Rocket安装OpenMod"></a>通过Rocket安装OpenMod</h5><ol><li>在<a href="https://github.com/openmod/OpenMod.Installer.RocketMod/releases/">此处</a>下载OpenMod安装程序插件</li><li>将dll文件移动至<code>/Rocket/Plugins</code>文件夹下并且重启服务端</li><li>重启服务器端后在窗口内输入&#x2F;openmod install并且按照其说明进行安装即可</li><li>安装完毕后您可以在<a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https://openmod.github.io/openmod-docs/userdoc/concepts/plugins.html">此处</a>查看OpenMod的插件安装方法</li></ol><h5 id="通过离线安装OpenMod"><a href="#通过离线安装OpenMod" class="headerlink" title="通过离线安装OpenMod"></a>通过离线安装OpenMod</h5><ol><li>在<a href="https://github.com/openmod/OpenMod/releases/latest">此处</a>下载最新的OpenMod模块，名字通常为<code>OpenMod.Unturned.Module-vX.X.X.zip</code></li><li>将压缩包中的<code>OpenMod.Unturned</code>文件夹复制到Unturned安装目录中的<code>Modules</code>文件夹中</li><li>启动你的服务器，第一次启动需要一段时间，因为 OpenMod 会下载所需的核心组件</li><li>安装完毕后您可以在<a href="https://www.mcbbs.net/plugin.php?id=link_redirect&target=https://openmod.github.io/openmod-docs/userdoc/concepts/plugins.html">此处</a>查看OpenMod的插件安装方法</li></ol><h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><h3 id="Rocket插件安装方法"><a href="#Rocket插件安装方法" class="headerlink" title="Rocket插件安装方法"></a>Rocket插件安装方法</h3><p>只需要将dll文间移至<code>/Rocket/Plugins</code>文件夹并重启服务器端即可，而后的内容请参考插件手册</p><h3 id="OpenMod插件安装方法"><a href="#OpenMod插件安装方法" class="headerlink" title="OpenMod插件安装方法"></a>OpenMod插件安装方法</h3><ul><li>您可以通过<a href="https://www.nuget.org/packages?q=openmod-plugin">NuGet市场</a>或<a href="https://openmod.github.io/openmod-plugins/search">OpenMod插件列表</a>来查找您所需的插件</li><li>您可以在OpenMod插件列表直接点击<strong>COPY INSTALL COMMAND</strong>按钮来获得安装命令，将其复制在服务器窗口中并回车即可安装</li><li>在NuGet市场中找到您心仪的插件时，您只需要输入<code>openmod install &lt;package id&gt;</code>来安装插件或输入<code>openmod install &lt;package id&gt;@&lt;version&gt;</code>来安装特定版本，以及可以输入<code>openmod install &lt;package id&gt; -Pre</code>来安装测试版（记得去除掉&lt;&gt;）</li><li>输入<code>openmod install &lt;package id&gt;</code>来更新插件</li><li>您也可以下载好插件以及所需库后将其放置到<code>/openmod/plugins</code>文件夹来手动安装插件，当然如果只有dll也可以通过<code>openmod install &lt;package id&gt;</code>来安装所需库，如果需要更新请自行替换dll</li><li>手动安装的插件需要自行删除dll文件，在线安装的插件可以通过<code>openmod remove &lt;package id&gt;</code>来卸载插件</li><li>在安装、删除、更新插件后都需要输入<code>openmod reload</code>来重新加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> steam </category>
          
          <category> 开服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> 开服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux上搭建QQ搜图机器人——基于go-cqhttp和cq-picsearcher-bot</title>
      <link href="/2022/03/22/%E5%9C%A8linux%E4%B8%8A%E6%90%AD%E5%BB%BAQQ%E6%90%9C%E5%9B%BE%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ego-cqhttp%E5%92%8Ccq-picsearcher-bot/"/>
      <url>/2022/03/22/%E5%9C%A8linux%E4%B8%8A%E6%90%AD%E5%BB%BAQQ%E6%90%9C%E5%9B%BE%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ego-cqhttp%E5%92%8Ccq-picsearcher-bot/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系统：CentOS</p><p>文中服务器已安装<a href="https://www.bt.cn/download/linux.html">宝塔Linux面板</a>，并以其演示</p><p>FinalShell  SHH终端</p><p>主要用到的程序 <a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> 和 <a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">cq-picsearcher-bot</a></p><p><a href="https://github.com/Mrs4s/go-cqhttp">https://github.com/Mrs4s/go-cqhttp</a></p><p><a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">https://github.com/Tsuk1ko/cq-picsearcher-bot</a></p></blockquote><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget git screen nodejs</span><br></pre></td></tr></table></figure><h2 id="创建目录，并到该目录下"><a href="#创建目录，并到该目录下" class="headerlink" title="创建目录，并到该目录下"></a>创建目录，并到该目录下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir go-cqhttp &amp;&amp; cd go-cqhttp</span><br></pre></td></tr></table></figure><h2 id="下载-go-cqhttp"><a href="#下载-go-cqhttp" class="headerlink" title="下载 go-cqhttp"></a>下载 go-cqhttp</h2><p>先下载该项目程序：</p><p><a href="https://github.com/Mrs4s/go-cqhttp/releases">https://github.com/Mrs4s/go-cqhttp/releases</a></p><p>一般默认选 go-cqhttp_linux_amd64.tar.gz 作为我们 amd64 架构服务器用到的程序（arm 架构系统选用 arm64）</p><ul><li>Windows 下 32 位文件为 go-cqhttp-v*-windows-386.zip</li><li>Windows 下 64 位文件为 go-cqhttp-v*-windows-amd64.zip</li><li>Windows 下 arm 用 (如使用高通 CPU 的笔记本) 文件为 go-cqhttp-v*-windows-arm.zip</li><li>Linux 下 32 位文件为 go-cqhttp-v*-linux-386.tar.gz</li><li>Linux 下 64 位文件为 go-cqhttp-v*-linux-amd64.tar.gz</li><li>Linux 下 arm 用 (如树莓派) 文件为 go-cqhttp-v*-linux-arm.tar.gz</li><li>MD5 文件为 *.md5 , 用于校验文件完整性</li><li>如果没有你所使用的系统版本或者希望自己构建，请移步 进阶指南 - 如何自己构建</li></ul><p>然后在服务器上下载这个压缩包</p><p>解压该压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf [文件名]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/go-cqhttp.png"></p><p>解压完只有这三个文件。</p><p>然后输入以下命令，回车</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./go-cqhttp</span><br></pre></td></tr></table></figure><p>选择第二个 ws，输入数字 2 回车即可（你甚至可以全部选择，输入 1234 回车）然后生成 config.yml 以后可以 <code>ctrl+c</code> 终止进程</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322140753738.png" alt="image-20220322140753738"></p><h2 id="配置-go-cqhttp"><a href="#配置-go-cqhttp" class="headerlink" title="配置 go-cqhttp"></a>配置 go-cqhttp</h2><p>宝塔中刷新目录，然后会发现多出了个 <code>config.yml</code> 文件，打开然后编辑</p><p>主要就是填入 QQ 账号和密码，别的都不用管</p><p>然后 Save 保存文件即可</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322141236497.png" alt="image-20220322141236497"></p><h2 id="加载-go-cqhttp"><a href="#加载-go-cqhttp" class="headerlink" title="加载 go-cqhttp"></a>加载 go-cqhttp</h2><p>然后再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./go-cqhttp</span><br></pre></td></tr></table></figure><p>如图即正常加载了</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322142536140.png" alt="image-20220322142536140"></p><p>当然，估计你因为异地登录会让你输入滑块验证码反馈</p><p>查看宝塔面板go-cqhttp目录，会生成一张二维码图片，打开手机QQ扫码登陆即可</p><p>或另一种解决方案：<a href="https://docs.go-cqhttp.org/faq/slider.html">https://docs.go-cqhttp.org/faq/slider.html</a></p><p>那么这时候按照他的指示，复制网址到浏览器打开，然后先不要拖动滑块，先按 F12 打开开发者工具</p><p>选择 network，抓取 <code>ticket</code> 字段，并黏贴到 ssh 里要求输入的地方，即可通过。</p><h2 id="安装部署-qc-picsearcher-bot"><a href="#安装部署-qc-picsearcher-bot" class="headerlink" title="安装部署 qc-picsearcher-bot"></a>安装部署 qc-picsearcher-bot</h2><p>然后ctrl c 退出登录。</p><p>回到上级目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>到cq-picsearcher-bot下载最新的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Tsuk1ko/cq-picsearcher-bot &amp;&amp; cd cq-picsearcher-bot &amp;&amp; cp config.default.jsonc config.jsonc</span><br></pre></td></tr></table></figure><p>下载完毕之后，再输入指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i </span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>config.jsonc 文件需要配置的地方太多了，而且根据每个人不同的习惯都各不相同，这个还请自行配置，参考官方配置文档：</p><p><a href="https://github.com/Tsuk1ko/cq-picsearcher-bot/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">https://github.com/Tsuk1ko/cq-picsearcher-bot/wiki/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E</a></p><p>其中几个地方都需要配置 api 才能使用，如 saucenao 和 setu 功能 </p><p>因为要用到saucenao的搜图，要注册拿到api key</p><p>注册：<a href="https://saucenao.com/user.php">https://saucenao.com/user.php</a>?</p><p>api key: <a href="https://saucenao.com/user.php?page=search-api">https://saucenao.com/user.php?page=search-api</a></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20210330233614736.png" alt="img"></p><p>复制，粘贴到cq-picsearcher-bot目录中的config.jsonc文件中。（拉到最下面）</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/20210330233943367.png" alt="img"></p><h2 id="启动-qc-picsearcher-bot"><a href="#启动-qc-picsearcher-bot" class="headerlink" title="启动 qc-picsearcher-bot"></a>启动 qc-picsearcher-bot</h2><p>配置完成后先启动 go-cqhttp 再运行本程序 ！</p><p>回到go-cqhttp目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">cd go-cqhttp</span><br><span class="line"></span><br><span class="line">//启动后台登录</span><br><span class="line"></span><br><span class="line">nohup ./go-cqhttp &gt; /dev/null 2&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>回到cq-picsearcher-bot目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .. </span><br><span class="line">cd cq-picsearcher-bot</span><br></pre></td></tr></table></figure><p>然后输入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220322143158880.png" alt="image-20220322143158880"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm stop</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm restart</span><br></pre></td></tr></table></figure><h3 id="查看日志（平时日志也会保存在-logs-文件夹内）"><a href="#查看日志（平时日志也会保存在-logs-文件夹内）" class="headerlink" title="查看日志（平时日志也会保存在 logs 文件夹内）"></a>查看日志（平时日志也会保存在 logs 文件夹内）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run log</span><br></pre></td></tr></table></figure><h2 id="食用"><a href="#食用" class="headerlink" title="食用"></a>食用</h2><ul><li>私聊<ul><li>直接发送图片即可</li></ul></li><li>群组<ul><li>@ 机器人并发送图片</li><li>回复某人（也可以是自己）发送的图片，在消息中 @ 机器人</li></ul></li><li>可以在同一条消息中包含多张图片，会自动批量搜索</li><li>搜索图片时可以在消息内包含以下参数来指定搜索范围或者使用某项功能，参数之间除 –debug 外互斥，优先级从上到下<ul><li>–get-url：获取图片的在线链接（不会搜图）</li><li>–all：全库搜索（默认）</li><li>–pixiv：从 P 站中搜索</li><li>–danbooru：从 Danbooru 中搜索</li><li>–doujin：搜索本子</li><li>–anime：搜索番剧</li><li>–a2d：使用 ascii2d 进行搜索（优势搜索局部图能力较强）</li><li>–debug：调试，会在控制台中输出搜图时网络请求的内容</li></ul></li><li>对于 saucenao<ul><li>如果得到的结果相似度低于 60%（可配置），会自动使用 ascii2d 进行搜索（可配置）</li><li>如果额度耗尽，会自动使用 ascii2d 进行搜索（可配置）</li><li>如果搜索到本子，会自动在 nhentai 中搜索并返回链接（如果有汉化本会优先返回汉化本链接）</li><li>如果搜到番剧，会自动使用 WhatAnime 搜索番剧详细信息<ul><li>AnimeDB 与 WhatAnime 的结果可能会不一致，是正常现象，毕竟这是两个不同的搜索引擎</li><li>同时展示这两个搜索的目的是为了尽力得到你可能想要的识别结果</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> bot </category>
          
          <category> qqx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bot </tag>
            
            <tag> qq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + GitHub搭建个人图床</title>
      <link href="/2022/03/12/PicGo%20+%20GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/03/12/PicGo%20+%20GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="配置GtiHub"><a href="#配置GtiHub" class="headerlink" title="配置GtiHub"></a>配置GtiHub</h2><p>新建仓库</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312230017936.png"></p><p>这里需要注意：仓库得设置为 Public 。因为后面通过客户端访问算是外部访问，因此无法访问 Private ，这样的话图片传上来之后只能存储不能显示。</p><p>仓库建好之后，点击页面右上角，进入 Settings：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211350596.png" alt="image-20220426211350596"></p><p>然后进入 Developer settings：</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/O%40%7DH%5D%7D%7B%7EYV8D6%7E%24%7BLGAF96A.png"></p><p>点击 Personal access tokens，再点 Generate new token 新建 token</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211239697.png" alt="image-20220426211239697"></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211253151.png" alt="image-20220426211253151"></p><p>填写 Notes 信息，选择 token 过期时间，为了安全，GitHub 会强烈建议不要设置成永久。这个大家根据自己实际情况选择，到期之后重新生成即可。</p><p>复选框的话，repo 一定要全选，其他的无所谓，我是都勾选了。</p><p>确定之后，就生成我们需要的 token 了。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211453791.png" alt="image-20220426211453791"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>下载 PicGo：点击<a href="https://link.segmentfault.com/?enc=Ptgik6w7iSuBHgEgu5ndyA==.OxB/dUe4VpLBJtUlwtNy8DWnb+AJo1LHGidh20qqXVQNEQbpfnvA7chetn/FaQuN">下载地址</a>，然后安装。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312230958908.png"></p><ul><li>设定仓库名：上文在 GitHub 创建的仓库。</li><li>设定分支名：main。</li><li>设定 Token：上文生成的 token。</li><li>指定存储路径：为空的话会上传到跟目录，也可以指定路径。</li></ul><p>配置完成后就可以使用了。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231444544.png"></p><p>直接拖拽，或者点击上传都可以。</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231619090.png"></p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220312231643155.png"></p><p>最后，在相册里复制外链，粘贴到我们的 markdown 文档中，就可以看到图片了。</p><h2 id="Typora关联PicGo粘贴图片自动上传"><a href="#Typora关联PicGo粘贴图片自动上传" class="headerlink" title="Typora关联PicGo粘贴图片自动上传"></a>Typora关联PicGo粘贴图片自动上传</h2><p>打开设置———偏好设置</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426211924526.png" alt="image-20220426211924526"></p><p>选择图像——在上传服务设定一栏中上传服务选择PicGo、路径选择PicGo安装路径</p><p><img src="https://raw.githubusercontent.com/Unfalll/notepic/main/img/image-20220426212043248.png" alt="image-20220426212043248"></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joplin与坚果云搭建免费云盘</title>
      <link href="/2022/03/12/Joplin%E4%B8%8E%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E7%9B%98/"/>
      <url>/2022/03/12/Joplin%E4%B8%8E%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><h2 id="Joplin"><a href="#Joplin" class="headerlink" title="Joplin"></a>Joplin</h2><p>一款开源的、支持自定义同步服务器、多平台支持的makedown笔记。<br>joplin官网<a href="https://joplinapp.org/">https://joplinapp.org/</a><br>第一眼看到joplin发现布局很像印象笔记，就决定用来代替印象笔记了。<br>功能上当然没有印象笔记多，但是基本的makedown、标签、全笔记搜索、目录结构、多平台、云同步还是有的。<br>编辑功能少了一点，但是开源可以进行二次开发，也不知道有没有朋友已经在开发了。</p><h2 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h2><p>一款国内的云存储服务，主要支持<a href="https://so.csdn.net/so/search?q=webdav&spm=1001.2101.3001.7020">webdav</a>可以供joplin实现云同步。<br>可以创建免费用户，每个月有1G上传和3G下载的流量，对于笔记来说应该是很够的了，速度对于笔记来讲也是足够的。</p><h2 id="搭建开始"><a href="#搭建开始" class="headerlink" title="搭建开始"></a>搭建开始</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>注册坚果云账户，在根目录创建一个joplin云储存的文件夹。</p><p><img src="https://img-blog.csdnimg.cn/20200624221255552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><h3 id="步骤2-创建webdav应用"><a href="#步骤2-创建webdav应用" class="headerlink" title="步骤2     创建webdav应用"></a>步骤2     创建webdav应用</h3><p>点击右上角的用户头像进入账户信息页面</p><p><img src="https://img-blog.csdnimg.cn/20200624221430930.png"></p><p>选择安全选项，右下方添加应用（我的已经添加了）</p><p><img src="https://img-blog.csdnimg.cn/20200624221558205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>现在我们有了webdav三个内容：服务器地址，账户，密码</p><h3 id="步骤3-下载安装joplin（想要哪个平台下哪个）"><a href="#步骤3-下载安装joplin（想要哪个平台下哪个）" class="headerlink" title="步骤3 下载安装joplin（想要哪个平台下哪个）"></a>步骤3 下载安装joplin（想要哪个平台下哪个）</h3><h3 id="步骤4-joplin接入云同步"><a href="#步骤4-joplin接入云同步" class="headerlink" title="步骤4 joplin接入云同步"></a>步骤4 joplin接入云同步</h3><p>点击 工具 -》 选项 -》 同步，按照如下填写webdav账户信息，这里需要注意网站后面要加上在坚果云创建的文件夹名字&#x2F;joplin</p><p><img src="https://img-blog.csdnimg.cn/20200624221944862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>点击 检查同步配置，成功之后，就可以通过ctrl+s把文件同步上去了</p><p><img src="https://img-blog.csdnimg.cn/20200624222108517.png"></p><p>其他平台类似方法接入同一个webdav即可时间多设备云同步。<br>我们同步完成之后，坚果云joplin文件夹下便存放我们的笔记内容</p><p><img src="https://img-blog.csdnimg.cn/20200624222508898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTA3MjE4,size_16,color_FFFFFF,t_70"></p><p>.md后缀是我们的文本笔记<br>笔记里面的图片、附件等内容则在resources</p>]]></content>
      
      
      <categories>
          
          <category> noto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> noto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青龙面板批量部署依赖库</title>
      <link href="/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>把常见的依赖库都给它装上去，免得以后运行其他羊毛脚本的时候提示各种错误。</p><p>这里分享下<a href="https://unfall.top/tags/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/">青龙面板</a>的部署教程《<a href="https://unfall.top/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/">青龙面板自动领JD京豆</a>》，再此基础上部署依赖库。再此基础上部署依赖库。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看青龙面板 Docker 是否正常运行，记下青龙 Docker 的容器名字，如果是按照缙哥哥的部署教程操作，那么默认的名称就是<code>qinglong</code></p><p><img src="https://img.dujin.org/uploads/2021/12/20211219214338.png"></p><p>输入一键安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it qinglong bash</span><br></pre></td></tr></table></figure><p>如果你的青龙容器不叫<code>qinglong</code>，那自己替换为相应的容器名字。</p><p>安装依赖命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/shufflewzc/QLDependency/main/Shell/QLOneKeyDependency.sh | sh</span><br></pre></td></tr></table></figure><p>然后慢慢等就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> JD </tag>
            
            <tag> 青龙面板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青龙面板自动领JD京豆</title>
      <link href="/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/"/>
      <url>/2022/03/11/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E8%87%AA%E5%8A%A8%E9%A2%86JD%E4%BA%AC%E8%B1%86/</url>
      
        <content type="html"><![CDATA[<p>青龙面板是一个多功能的可视化面板，本教程利用青龙面板来自动执行京东领京豆，做东东农场任务签到浇水免费领水果，京喜牧场养小鸡收集鸡蛋，京东极速版金币，京东赚赚领金币，东东萌宠喂养。同时还能自动领取京东红包、京喜红包、京东极速版红包……</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ol><li>需要一台服务器，最好是国内的，毕竟你是在国内使用京东购物，挂机服务器在海外太过明显。</li><li>全新安装 CentOS操作系统，并放开 22、5600 端口，如果想安装宝塔，则额外放开 888、8888 端口。</li></ol><h1 id="安装青龙面板"><a href="#安装青龙面板" class="headerlink" title="安装青龙面板"></a>安装青龙面板</h1><p>通过 SSH 连接服务器，安装 Docker 环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>启动 Docker（下方第一行），并设置 Docker 开机自动启动 （下方第二行） 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>直接执行下方代码拉取镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull whyour/qinglong:latest</span><br></pre></td></tr></table></figure><p>如果你是群辉之类的 NAS 安装青龙镜像，在 Dockers 官方镜像列表中拉取最新版的青龙镜像，直接使用 Dockers 搜索镜像<code>qinglong</code>即可。</p><p>接着部署青龙面板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">-v $PWD/ql/config:/ql/config \</span><br><span class="line">-v $PWD/ql/log:/ql/log \</span><br><span class="line">-v $PWD/ql/db:/ql/db \</span><br><span class="line">-p 5600:5600 \</span><br><span class="line">--name qinglong \</span><br><span class="line">--hostname qinglong \</span><br><span class="line">--restart always \</span><br><span class="line">whyour/qinglong:latest</span><br></pre></td></tr></table></figure><h1 id="初始化青龙面板"><a href="#初始化青龙面板" class="headerlink" title="初始化青龙面板"></a>初始化青龙面板</h1><p>部署完成后，直接访问<code>IP:5600</code>访问青龙面板的安装界面。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184333.png"></p><p>直接开始安装进入下一步。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184403.png"></p><p>这里可以根据你自己的喜欢设置通知方式，比如每天22:00告诉你今天领取了多少京豆、多少金币、多少红包……当然，你也可以直接跳过该步骤。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184443.png"></p><p>设置管理员账号密码，这是初始化安装青龙面板最重要的步骤，当然，如果你不小心忘了，或者说不明原因没有进入这个配置页面，也没有关系，可以通过 SSH 执行下方命令查看账号及密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it qinglong cat /ql/config/auth.json</span><br></pre></td></tr></table></figure><h1 id="配置青龙面板定时任务"><a href="#配置青龙面板定时任务" class="headerlink" title="配置青龙面板定时任务"></a>配置青龙面板定时任务</h1><p>青龙面板本身不具备京东脚本的功能，只是一个管理和执行相应脚本的可视化平台。为了使其能够完成媷羊毛的功能，接下来使用青龙面板拉去一些库，使其自动更新一些功能。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216184720.png"></p><p>登录面板后选择<code>定时任务</code>→<code>添加任务</code>。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216185453.png"></p><h1 id="京东定时任务库"><a href="#京东定时任务库" class="headerlink" title="京东定时任务库"></a>京东定时任务库</h1><p>下方整理 GitHub 上的一些任务库，通过添加任务，并设置定时规则，使其自动拉取、更新羊毛任务。</p><p><strong>KingRan&#x2F;KR（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/KingRan/KR.git &quot;jd_|jx_|jdCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|function|sign|sendNotify|ql|JDJR&quot;</span><br></pre></td></tr></table></figure><p><strong>Curtinlv 仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/curtinlv/JD-Script.git</span><br></pre></td></tr></table></figure><p><strong>Zy143L&#x2F;wskey（wskey转换库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/Zy143L/wskey.git &quot;wskey&quot;</span><br></pre></td></tr></table></figure><p><strong>smiek2121（开卡库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo ql repo https://github.com/smiek2121/scripts.git &quot;jd_|gua_&quot; &quot;&quot; &quot;ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js|cleancart_activity.js|jdCookie.js|sendNotify.js&quot;</span><br></pre></td></tr></table></figure><p><strong>Yun-City&#x2F;City（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/Yun-City/City.git &quot;jd_|jx_|gua_|jddj_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|function|utils|sendnotify|ZooFaker_Necklace|jd_Cookie|JDJRValidator_|sign_graphics_validate|ql|magic|cleancart_activity&quot;</span><br></pre></td></tr></table></figure><p><strong>6dylan6&#x2F;jdpro（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/6dylan6/jdpro.git &quot;jd_|jx_|jddj_&quot; &quot;backUp&quot; &quot;^jd[^_]|USER|JD|function|sendNotify&quot;</span><br></pre></td></tr></table></figure><p><strong>gys619&#x2F;Absinthe（集合库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/gys619/Absinthe.git &quot;jd_|jx_|jddj_|gua_|getJDCookie|wskey&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|ZooFaker_Necklace|JDJRValidator_|sign_graphics_validate|jddj_cookie|function|ql|magic|JDJR|JD&quot; &quot;main&quot;</span><br></pre></td></tr></table></figure><p><strong>zero205&#x2F;JD_tencent_scf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/zero205/JD_tencent_scf.git &quot;jd_|jx_|jdCookie&quot; &quot;backUp|icon&quot; &quot;^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql&quot; &quot;main&quot;</span><br></pre></td></tr></table></figure><p><strong>龙珠</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/whyour/hundun.git &quot;quanx&quot; &quot;tokens|caiyun|didi|donate|fold|Env&quot;</span><br></pre></td></tr></table></figure><p>为了防止漏掉某些羊毛，<strong>上方所有的库</strong>新建定时任务拉取，里面有重复脚本禁用脚本，重复的内容会被禁用的。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216185930.png"></p><h1 id="定时规则"><a href="#定时规则" class="headerlink" title="定时规则"></a>定时规则</h1><p>这里的定时规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">秒 分 时 天 月 周</span><br></pre></td></tr></table></figure><p>各个单位之间分别以空格分割，假设该任务需要每天12:23:45执行一次。那么则应该这么设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 23 12 * * *</span><br></pre></td></tr></table></figure><p>拉完之后记得运行，不运行的话要等到你设置好的时间才会自动执行。运行后会自动拉去一些执行活动的脚本</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216190140.png"></p><h1 id="获取京东Cookie"><a href="#获取京东Cookie" class="headerlink" title="获取京东Cookie"></a>获取京东Cookie</h1><p>使用 Chrome 内核浏览器（比如 Google 浏览器、Edge 浏览器、360 极速浏览器……），打开开发者模式（快捷键：F12），打开 Network（网络）标签，浏览器当前页面访问京东移动端登录地址<code>m.jd.com</code>，按照提示登录你的京东账号，复制你的京东账号 Cookie，也就是下图所示内容：</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216214832.png"></p><p>然后打开青龙面板，选择<code>环境变量</code>→<code>添加变量</code>，名称为<code>JD_COOKIE</code>，值为刚复制的京东账号<code>Cookie</code>，备注自己填方便识别，别的不需要动。添加后点<code>确定</code>就可以，如果需要添加多个账号，只需要获取多个Cookie添加上去就可以了，名称仍然为<code>JD_COOKIE</code>。</p><p><img src="https://img.dujin.org/uploads/2021/12/20211216190257.png"></p><p>添加好京东账号 Cookie 之后就可以去执行脚本了，如果等不及想尝试，可以自己触发脚本运行，否则就会在相应的时间执行。</p><p>顺带一说，Cookie 值并不需要这么多，只需要里面的<code>pt_key</code>与<code>pt_pin</code>两个就行了，懂的人自行提取，不懂的人全部复制粘贴上去。</p><p><strong>温馨提醒：</strong>不要频繁的去执行，避免黑号。还有就是建议京东账号绑定微信，有个活动抽奖抽到微信红包会自动提现到微信钱包。</p><h1 id="开启京东游戏任务"><a href="#开启京东游戏任务" class="headerlink" title="开启京东游戏任务"></a>开启京东游戏任务</h1><p>建议把所有活动游戏都点击一次，京东工厂这种需要自己选产品的建议自己选，不然会自动选一个，有的干脆不选。这里给大家说下各个游戏入口位置：</p><p>京东APP</p><ul><li><p>摇钱树：京东APP→右下角我的→中间更多工具</p></li><li><p>东东萌宠：京东APP→右下角我的</p></li><li><p>宠汪汪：京东APP→右下角我的</p></li><li><p>东东农场：京东APP→右下角我的</p></li><li><p>京喜工厂：惊喜APP→右下角我的</p></li><li><p>京喜牧场：惊喜APP→右下角我的</p></li><li><p>京喜财富岛：惊喜APP→右下角我的</p></li><li><p>发财大赢家：京东极速版→右下角我的</p></li><li><p>汪汪乐园：京东极速版→右下角我的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> JD </tag>
            
            <tag> 青龙面板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访客地图</title>
      <link href="/2022/03/10/%E8%AE%BF%E5%AE%A2%E5%9C%B0%E5%9B%BE/"/>
      <url>/2022/03/10/%E8%AE%BF%E5%AE%A2%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="访客地图"><a href="#访客地图" class="headerlink" title="访客地图"></a>访客地图</h1><p>前往 clustrmaps 网站注册一个帐号。</p><p>找到 Free Tools下面的 Website Widget, 点击 Get Map Widget。</p><p>输入你的博客网址，点击Next。根据你自己的喜好选择样式Map widget 或 Globe Widget。</p><p>找到如下代码，记住 src (** 的部分):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; id=&quot;clstr_globe&quot; src=&quot;**********************&quot;&gt;</span><br></pre></td></tr></table></figure><p>在 <strong>themes\Butterfly\layout\includes\widget</strong>文件夹新建<strong>card_map.pug</strong>文件，文件内容如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-map</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_map&#x27;)</span><br><span class="line">    script#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;此处填入你自己的代码&quot;)</span><br></pre></td></tr></table></figure><p>编辑 <strong>themes\Butterfly\layout\includes\widget\index.pug</strong> 文件，在你想要显示的位置插入以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!=partial(&#x27;includes/widget/card_map&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>（切记：如果主题版本大于3.6，请务必将**{cache:theme.fragment_cache}** 改为 { **cache:true }**）：</p><p>编辑_config.butterfly.yml 文件，在<strong>card_webinfo</strong> 下面添加一行<strong>card_map: true</strong></p><p>编辑<strong>themes\Butterfly\languages\zh-CN.yml</strong>文件 (请根据你的网站语言选择)，找到<strong>card_announcement:</strong> 公告 , 在下面添加一行<strong>card_map: 访客地图</strong> (后面的文本可自定义),繁体字方法一样，修改<strong>themes\Butterfly\languages\zh-TW.yml</strong>文件就行。</p><p>如果不想显示，直接把 <strong>_config.butterfly.yml</strong>文件的<strong>card_map: true</strong> 改为 <strong>card_map: false</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> Butterfly美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pixie日推</title>
      <link href="/2022/03/08/pixie%E6%97%A5%E6%8E%A8/"/>
      <url>/2022/03/08/pixie%E6%97%A5%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pixie日推"><a href="#pixie日推" class="headerlink" title="pixie日推"></a>pixie日推</h1><blockquote><p>注意： <a href="https://cloud.mokeyjay.com/pixiv">https://cloud.mokeyjay.com/pixiv</a> 使用的是<a href="https://www.mokeyjay.com/">超能小紫</a>提供的服务，也可以自行搭建，搭建方式请看这里-&gt;<a href="https://www.mokeyjay.com/archives/1063">传送门</a></p></blockquote><h2 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h2><ol><li><p>在 <strong>themes\Butterfly\layout\includes\widget</strong>文件夹新建card_pixiv.pug 文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-pixiv</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-image(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_pixiv&#x27;)</span><br><span class="line">    iframe(src=&quot;https://cloud.mokeyjay.com/pixiv&quot; frameborder=&quot;0&quot; style=&quot;width:99%;height:380px;margin:0;&quot;)</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>themes\Butterfly\layout\includes\widget\index.pug</strong> 文件，在你想要显示的位置插入以下代码（注意要对齐还有不要有空格符）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_pixiv</span><br><span class="line">       !=partial(&#x27;includes/widget/card_pixiv&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>butterfly.yml</strong> 文件，在 <strong>card_webinfo</strong> 下面添加一行 <strong>card_pixiv: true</strong></p></li><li><p>编辑 <strong>themes\Butterfly\languages\zh-CN.yml</strong> 文件 (请根据你的网站语言选择)，找到 <strong>card_announcement:</strong> 公告 , 在下面添加一行 <strong>card_pixiv: Pixiv日榜Top50</strong>(后面的文本可自定义)</p></li><li><p>如果不想显示，直接把 <strong>butterfly.yml</strong> 文件的 <strong>card_pixiv: true</strong> 改为 <strong>card_pixiv: false</strong> 即可</p></li></ol><blockquote><p><strong>文章来自转载：</strong></p><p><strong>文章作者:</strong> <a href="mailto:undefined">bt-sonny</a></p><p><strong>文章链接:</strong> <a href="https://chuchendjs.github.io/posts/BY-MOchange/">https://chuchendjs.github.io/posts/BY-MOchange/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Butterfly美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/01/hello-world/"/>
      <url>/2022/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
